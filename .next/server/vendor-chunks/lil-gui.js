"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lil-gui";
exports.ids = ["vendor-chunks/lil-gui"];
exports.modules = {

/***/ "(ssr)/./node_modules/lil-gui/dist/lil-gui.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/lil-gui/dist/lil-gui.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanController: () => (/* binding */ BooleanController),\n/* harmony export */   ColorController: () => (/* binding */ ColorController),\n/* harmony export */   Controller: () => (/* binding */ Controller),\n/* harmony export */   FunctionController: () => (/* binding */ FunctionController),\n/* harmony export */   GUI: () => (/* binding */ GUI),\n/* harmony export */   NumberController: () => (/* binding */ NumberController),\n/* harmony export */   OptionController: () => (/* binding */ OptionController),\n/* harmony export */   StringController: () => (/* binding */ StringController),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * lil-gui\n * https://lil-gui.georgealways.com\n * @version 0.19.2\n * @author George Michael Brower\n * @license MIT\n */ /**\n * Base class for all controllers.\n */ class Controller {\n    constructor(parent, object, property, className, elementType = \"div\"){\n        /**\n\t\t * The GUI that contains this controller.\n\t\t * @type {GUI}\n\t\t */ this.parent = parent;\n        /**\n\t\t * The object this controller will modify.\n\t\t * @type {object}\n\t\t */ this.object = object;\n        /**\n\t\t * The name of the property to control.\n\t\t * @type {string}\n\t\t */ this.property = property;\n        /**\n\t\t * Used to determine if the controller is disabled.\n\t\t * Use `controller.disable( true|false )` to modify this value.\n\t\t * @type {boolean}\n\t\t */ this._disabled = false;\n        /**\n\t\t * Used to determine if the Controller is hidden.\n\t\t * Use `controller.show()` or `controller.hide()` to change this.\n\t\t * @type {boolean}\n\t\t */ this._hidden = false;\n        /**\n\t\t * The value of `object[ property ]` when the controller was created.\n\t\t * @type {any}\n\t\t */ this.initialValue = this.getValue();\n        /**\n\t\t * The outermost container DOM element for this controller.\n\t\t * @type {HTMLElement}\n\t\t */ this.domElement = document.createElement(elementType);\n        this.domElement.classList.add(\"controller\");\n        this.domElement.classList.add(className);\n        /**\n\t\t * The DOM element that contains the controller's name.\n\t\t * @type {HTMLElement}\n\t\t */ this.$name = document.createElement(\"div\");\n        this.$name.classList.add(\"name\");\n        Controller.nextNameID = Controller.nextNameID || 0;\n        this.$name.id = `lil-gui-name-${++Controller.nextNameID}`;\n        /**\n\t\t * The DOM element that contains the controller's \"widget\" (which differs by controller type).\n\t\t * @type {HTMLElement}\n\t\t */ this.$widget = document.createElement(\"div\");\n        this.$widget.classList.add(\"widget\");\n        /**\n\t\t * The DOM element that receives the disabled attribute when using disable().\n\t\t * @type {HTMLElement}\n\t\t */ this.$disable = this.$widget;\n        this.domElement.appendChild(this.$name);\n        this.domElement.appendChild(this.$widget);\n        // Don't fire global key events while typing in a controller\n        this.domElement.addEventListener(\"keydown\", (e)=>e.stopPropagation());\n        this.domElement.addEventListener(\"keyup\", (e)=>e.stopPropagation());\n        this.parent.children.push(this);\n        this.parent.controllers.push(this);\n        this.parent.$children.appendChild(this.domElement);\n        this._listenCallback = this._listenCallback.bind(this);\n        this.name(property);\n    }\n    /**\n\t * Sets the name of the controller and its label in the GUI.\n\t * @param {string} name\n\t * @returns {this}\n\t */ name(name) {\n        /**\n\t\t * The controller's name. Use `controller.name( 'Name' )` to modify this value.\n\t\t * @type {string}\n\t\t */ this._name = name;\n        this.$name.textContent = name;\n        return this;\n    }\n    /**\n\t * Pass a function to be called whenever the value is modified by this controller.\n\t * The function receives the new value as its first parameter. The value of `this` will be the\n\t * controller.\n\t *\n\t * For function controllers, the `onChange` callback will be fired on click, after the function\n\t * executes.\n\t * @param {Function} callback\n\t * @returns {this}\n\t * @example\n\t * const controller = gui.add( object, 'property' );\n\t *\n\t * controller.onChange( function( v ) {\n\t * \tconsole.log( 'The value is now ' + v );\n\t * \tconsole.assert( this === controller );\n\t * } );\n\t */ onChange(callback) {\n        /**\n\t\t * Used to access the function bound to `onChange` events. Don't modify this value directly.\n\t\t * Use the `controller.onChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */ this._onChange = callback;\n        return this;\n    }\n    /**\n\t * Calls the onChange methods of this controller and its parent GUI.\n\t * @protected\n\t */ _callOnChange() {\n        this.parent._callOnChange(this);\n        if (this._onChange !== undefined) {\n            this._onChange.call(this, this.getValue());\n        }\n        this._changed = true;\n    }\n    /**\n\t * Pass a function to be called after this controller has been modified and loses focus.\n\t * @param {Function} callback\n\t * @returns {this}\n\t * @example\n\t * const controller = gui.add( object, 'property' );\n\t *\n\t * controller.onFinishChange( function( v ) {\n\t * \tconsole.log( 'Changes complete: ' + v );\n\t * \tconsole.assert( this === controller );\n\t * } );\n\t */ onFinishChange(callback) {\n        /**\n\t\t * Used to access the function bound to `onFinishChange` events. Don't modify this value\n\t\t * directly. Use the `controller.onFinishChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */ this._onFinishChange = callback;\n        return this;\n    }\n    /**\n\t * Should be called by Controller when its widgets lose focus.\n\t * @protected\n\t */ _callOnFinishChange() {\n        if (this._changed) {\n            this.parent._callOnFinishChange(this);\n            if (this._onFinishChange !== undefined) {\n                this._onFinishChange.call(this, this.getValue());\n            }\n        }\n        this._changed = false;\n    }\n    /**\n\t * Sets the controller back to its initial value.\n\t * @returns {this}\n\t */ reset() {\n        this.setValue(this.initialValue);\n        this._callOnFinishChange();\n        return this;\n    }\n    /**\n\t * Enables this controller.\n\t * @param {boolean} enabled\n\t * @returns {this}\n\t * @example\n\t * controller.enable();\n\t * controller.enable( false ); // disable\n\t * controller.enable( controller._disabled ); // toggle\n\t */ enable(enabled = true) {\n        return this.disable(!enabled);\n    }\n    /**\n\t * Disables this controller.\n\t * @param {boolean} disabled\n\t * @returns {this}\n\t * @example\n\t * controller.disable();\n\t * controller.disable( false ); // enable\n\t * controller.disable( !controller._disabled ); // toggle\n\t */ disable(disabled = true) {\n        if (disabled === this._disabled) return this;\n        this._disabled = disabled;\n        this.domElement.classList.toggle(\"disabled\", disabled);\n        this.$disable.toggleAttribute(\"disabled\", disabled);\n        return this;\n    }\n    /**\n\t * Shows the Controller after it's been hidden.\n\t * @param {boolean} show\n\t * @returns {this}\n\t * @example\n\t * controller.show();\n\t * controller.show( false ); // hide\n\t * controller.show( controller._hidden ); // toggle\n\t */ show(show = true) {\n        this._hidden = !show;\n        this.domElement.style.display = this._hidden ? \"none\" : \"\";\n        return this;\n    }\n    /**\n\t * Hides the Controller.\n\t * @returns {this}\n\t */ hide() {\n        return this.show(false);\n    }\n    /**\n\t * Changes this controller into a dropdown of options.\n\t *\n\t * Calling this method on an option controller will simply update the options. However, if this\n\t * controller was not already an option controller, old references to this controller are\n\t * destroyed, and a new controller is added to the end of the GUI.\n\t * @example\n\t * // safe usage\n\t *\n\t * gui.add( obj, 'prop1' ).options( [ 'a', 'b', 'c' ] );\n\t * gui.add( obj, 'prop2' ).options( { Big: 10, Small: 1 } );\n\t * gui.add( obj, 'prop3' );\n\t *\n\t * // danger\n\t *\n\t * const ctrl1 = gui.add( obj, 'prop1' );\n\t * gui.add( obj, 'prop2' );\n\t *\n\t * // calling options out of order adds a new controller to the end...\n\t * const ctrl2 = ctrl1.options( [ 'a', 'b', 'c' ] );\n\t *\n\t * // ...and ctrl1 now references a controller that doesn't exist\n\t * assert( ctrl2 !== ctrl1 )\n\t * @param {object|Array} options\n\t * @returns {Controller}\n\t */ options(options) {\n        const controller = this.parent.add(this.object, this.property, options);\n        controller.name(this._name);\n        this.destroy();\n        return controller;\n    }\n    /**\n\t * Sets the minimum value. Only works on number controllers.\n\t * @param {number} min\n\t * @returns {this}\n\t */ min(min) {\n        return this;\n    }\n    /**\n\t * Sets the maximum value. Only works on number controllers.\n\t * @param {number} max\n\t * @returns {this}\n\t */ max(max) {\n        return this;\n    }\n    /**\n\t * Values set by this controller will be rounded to multiples of `step`. Only works on number\n\t * controllers.\n\t * @param {number} step\n\t * @returns {this}\n\t */ step(step) {\n        return this;\n    }\n    /**\n\t * Rounds the displayed value to a fixed number of decimals, without affecting the actual value\n\t * like `step()`. Only works on number controllers.\n\t * @example\n\t * gui.add( object, 'property' ).listen().decimals( 4 );\n\t * @param {number} decimals\n\t * @returns {this}\n\t */ decimals(decimals) {\n        return this;\n    }\n    /**\n\t * Calls `updateDisplay()` every animation frame. Pass `false` to stop listening.\n\t * @param {boolean} listen\n\t * @returns {this}\n\t */ listen(listen = true) {\n        /**\n\t\t * Used to determine if the controller is currently listening. Don't modify this value\n\t\t * directly. Use the `controller.listen( true|false )` method instead.\n\t\t * @type {boolean}\n\t\t */ this._listening = listen;\n        if (this._listenCallbackID !== undefined) {\n            cancelAnimationFrame(this._listenCallbackID);\n            this._listenCallbackID = undefined;\n        }\n        if (this._listening) {\n            this._listenCallback();\n        }\n        return this;\n    }\n    _listenCallback() {\n        this._listenCallbackID = requestAnimationFrame(this._listenCallback);\n        // To prevent framerate loss, make sure the value has changed before updating the display.\n        // Note: save() is used here instead of getValue() only because of ColorController. The !== operator\n        // won't work for color objects or arrays, but ColorController.save() always returns a string.\n        const curValue = this.save();\n        if (curValue !== this._listenPrevValue) {\n            this.updateDisplay();\n        }\n        this._listenPrevValue = curValue;\n    }\n    /**\n\t * Returns `object[ property ]`.\n\t * @returns {any}\n\t */ getValue() {\n        return this.object[this.property];\n    }\n    /**\n\t * Sets the value of `object[ property ]`, invokes any `onChange` handlers and updates the display.\n\t * @param {any} value\n\t * @returns {this}\n\t */ setValue(value) {\n        if (this.getValue() !== value) {\n            this.object[this.property] = value;\n            this._callOnChange();\n            this.updateDisplay();\n        }\n        return this;\n    }\n    /**\n\t * Updates the display to keep it in sync with the current value. Useful for updating your\n\t * controllers when their values have been modified outside of the GUI.\n\t * @returns {this}\n\t */ updateDisplay() {\n        return this;\n    }\n    load(value) {\n        this.setValue(value);\n        this._callOnFinishChange();\n        return this;\n    }\n    save() {\n        return this.getValue();\n    }\n    /**\n\t * Destroys this controller and removes it from the parent GUI.\n\t */ destroy() {\n        this.listen(false);\n        this.parent.children.splice(this.parent.children.indexOf(this), 1);\n        this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1);\n        this.parent.$children.removeChild(this.domElement);\n    }\n}\nclass BooleanController extends Controller {\n    constructor(parent, object, property){\n        super(parent, object, property, \"boolean\", \"label\");\n        this.$input = document.createElement(\"input\");\n        this.$input.setAttribute(\"type\", \"checkbox\");\n        this.$input.setAttribute(\"aria-labelledby\", this.$name.id);\n        this.$widget.appendChild(this.$input);\n        this.$input.addEventListener(\"change\", ()=>{\n            this.setValue(this.$input.checked);\n            this._callOnFinishChange();\n        });\n        this.$disable = this.$input;\n        this.updateDisplay();\n    }\n    updateDisplay() {\n        this.$input.checked = this.getValue();\n        return this;\n    }\n}\nfunction normalizeColorString(string) {\n    let match, result;\n    if (match = string.match(/(#|0x)?([a-f0-9]{6})/i)) {\n        result = match[2];\n    } else if (match = string.match(/rgb\\(\\s*(\\d*)\\s*,\\s*(\\d*)\\s*,\\s*(\\d*)\\s*\\)/)) {\n        result = parseInt(match[1]).toString(16).padStart(2, 0) + parseInt(match[2]).toString(16).padStart(2, 0) + parseInt(match[3]).toString(16).padStart(2, 0);\n    } else if (match = string.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) {\n        result = match[1] + match[1] + match[2] + match[2] + match[3] + match[3];\n    }\n    if (result) {\n        return \"#\" + result;\n    }\n    return false;\n}\nconst STRING = {\n    isPrimitive: true,\n    match: (v)=>typeof v === \"string\",\n    fromHexString: normalizeColorString,\n    toHexString: normalizeColorString\n};\nconst INT = {\n    isPrimitive: true,\n    match: (v)=>typeof v === \"number\",\n    fromHexString: (string)=>parseInt(string.substring(1), 16),\n    toHexString: (value)=>\"#\" + value.toString(16).padStart(6, 0)\n};\nconst ARRAY = {\n    isPrimitive: false,\n    // The arrow function is here to appease tree shakers like esbuild or webpack.\n    // See https://esbuild.github.io/api/#tree-shaking\n    match: (v)=>Array.isArray(v),\n    fromHexString (string, target, rgbScale = 1) {\n        const int = INT.fromHexString(string);\n        target[0] = (int >> 16 & 255) / 255 * rgbScale;\n        target[1] = (int >> 8 & 255) / 255 * rgbScale;\n        target[2] = (int & 255) / 255 * rgbScale;\n    },\n    toHexString ([r, g, b], rgbScale = 1) {\n        rgbScale = 255 / rgbScale;\n        const int = r * rgbScale << 16 ^ g * rgbScale << 8 ^ b * rgbScale << 0;\n        return INT.toHexString(int);\n    }\n};\nconst OBJECT = {\n    isPrimitive: false,\n    match: (v)=>Object(v) === v,\n    fromHexString (string, target, rgbScale = 1) {\n        const int = INT.fromHexString(string);\n        target.r = (int >> 16 & 255) / 255 * rgbScale;\n        target.g = (int >> 8 & 255) / 255 * rgbScale;\n        target.b = (int & 255) / 255 * rgbScale;\n    },\n    toHexString ({ r, g, b }, rgbScale = 1) {\n        rgbScale = 255 / rgbScale;\n        const int = r * rgbScale << 16 ^ g * rgbScale << 8 ^ b * rgbScale << 0;\n        return INT.toHexString(int);\n    }\n};\nconst FORMATS = [\n    STRING,\n    INT,\n    ARRAY,\n    OBJECT\n];\nfunction getColorFormat(value) {\n    return FORMATS.find((format)=>format.match(value));\n}\nclass ColorController extends Controller {\n    constructor(parent, object, property, rgbScale){\n        super(parent, object, property, \"color\");\n        this.$input = document.createElement(\"input\");\n        this.$input.setAttribute(\"type\", \"color\");\n        this.$input.setAttribute(\"tabindex\", -1);\n        this.$input.setAttribute(\"aria-labelledby\", this.$name.id);\n        this.$text = document.createElement(\"input\");\n        this.$text.setAttribute(\"type\", \"text\");\n        this.$text.setAttribute(\"spellcheck\", \"false\");\n        this.$text.setAttribute(\"aria-labelledby\", this.$name.id);\n        this.$display = document.createElement(\"div\");\n        this.$display.classList.add(\"display\");\n        this.$display.appendChild(this.$input);\n        this.$widget.appendChild(this.$display);\n        this.$widget.appendChild(this.$text);\n        this._format = getColorFormat(this.initialValue);\n        this._rgbScale = rgbScale;\n        this._initialValueHexString = this.save();\n        this._textFocused = false;\n        this.$input.addEventListener(\"input\", ()=>{\n            this._setValueFromHexString(this.$input.value);\n        });\n        this.$input.addEventListener(\"blur\", ()=>{\n            this._callOnFinishChange();\n        });\n        this.$text.addEventListener(\"input\", ()=>{\n            const tryParse = normalizeColorString(this.$text.value);\n            if (tryParse) {\n                this._setValueFromHexString(tryParse);\n            }\n        });\n        this.$text.addEventListener(\"focus\", ()=>{\n            this._textFocused = true;\n            this.$text.select();\n        });\n        this.$text.addEventListener(\"blur\", ()=>{\n            this._textFocused = false;\n            this.updateDisplay();\n            this._callOnFinishChange();\n        });\n        this.$disable = this.$text;\n        this.updateDisplay();\n    }\n    reset() {\n        this._setValueFromHexString(this._initialValueHexString);\n        return this;\n    }\n    _setValueFromHexString(value) {\n        if (this._format.isPrimitive) {\n            const newValue = this._format.fromHexString(value);\n            this.setValue(newValue);\n        } else {\n            this._format.fromHexString(value, this.getValue(), this._rgbScale);\n            this._callOnChange();\n            this.updateDisplay();\n        }\n    }\n    save() {\n        return this._format.toHexString(this.getValue(), this._rgbScale);\n    }\n    load(value) {\n        this._setValueFromHexString(value);\n        this._callOnFinishChange();\n        return this;\n    }\n    updateDisplay() {\n        this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale);\n        if (!this._textFocused) {\n            this.$text.value = this.$input.value.substring(1);\n        }\n        this.$display.style.backgroundColor = this.$input.value;\n        return this;\n    }\n}\nclass FunctionController extends Controller {\n    constructor(parent, object, property){\n        super(parent, object, property, \"function\");\n        // Buttons are the only case where widget contains name\n        this.$button = document.createElement(\"button\");\n        this.$button.appendChild(this.$name);\n        this.$widget.appendChild(this.$button);\n        this.$button.addEventListener(\"click\", (e)=>{\n            e.preventDefault();\n            this.getValue().call(this.object);\n            this._callOnChange();\n        });\n        // enables :active pseudo class on mobile\n        this.$button.addEventListener(\"touchstart\", ()=>{}, {\n            passive: true\n        });\n        this.$disable = this.$button;\n    }\n}\nclass NumberController extends Controller {\n    constructor(parent, object, property, min, max, step){\n        super(parent, object, property, \"number\");\n        this._initInput();\n        this.min(min);\n        this.max(max);\n        const stepExplicit = step !== undefined;\n        this.step(stepExplicit ? step : this._getImplicitStep(), stepExplicit);\n        this.updateDisplay();\n    }\n    decimals(decimals) {\n        this._decimals = decimals;\n        this.updateDisplay();\n        return this;\n    }\n    min(min) {\n        this._min = min;\n        this._onUpdateMinMax();\n        return this;\n    }\n    max(max) {\n        this._max = max;\n        this._onUpdateMinMax();\n        return this;\n    }\n    step(step, explicit = true) {\n        this._step = step;\n        this._stepExplicit = explicit;\n        return this;\n    }\n    updateDisplay() {\n        const value = this.getValue();\n        if (this._hasSlider) {\n            let percent = (value - this._min) / (this._max - this._min);\n            percent = Math.max(0, Math.min(percent, 1));\n            this.$fill.style.width = percent * 100 + \"%\";\n        }\n        if (!this._inputFocused) {\n            this.$input.value = this._decimals === undefined ? value : value.toFixed(this._decimals);\n        }\n        return this;\n    }\n    _initInput() {\n        this.$input = document.createElement(\"input\");\n        this.$input.setAttribute(\"type\", \"text\");\n        this.$input.setAttribute(\"aria-labelledby\", this.$name.id);\n        // On touch devices only, use input[type=number] to force a numeric keyboard.\n        // Ideally we could use one input type everywhere, but [type=number] has quirks\n        // on desktop, and [inputmode=decimal] has quirks on iOS.\n        // See https://github.com/georgealways/lil-gui/pull/16\n        const isTouch = window.matchMedia(\"(pointer: coarse)\").matches;\n        if (isTouch) {\n            this.$input.setAttribute(\"type\", \"number\");\n            this.$input.setAttribute(\"step\", \"any\");\n        }\n        this.$widget.appendChild(this.$input);\n        this.$disable = this.$input;\n        const onInput = ()=>{\n            let value = parseFloat(this.$input.value);\n            if (isNaN(value)) return;\n            if (this._stepExplicit) {\n                value = this._snap(value);\n            }\n            this.setValue(this._clamp(value));\n        };\n        // Keys & mouse wheel\n        // ---------------------------------------------------------------------\n        const increment = (delta)=>{\n            const value = parseFloat(this.$input.value);\n            if (isNaN(value)) return;\n            this._snapClampSetValue(value + delta);\n            // Force the input to updateDisplay when it's focused\n            this.$input.value = this.getValue();\n        };\n        const onKeyDown = (e)=>{\n            // Using `e.key` instead of `e.code` also catches NumpadEnter\n            if (e.key === \"Enter\") {\n                this.$input.blur();\n            }\n            if (e.code === \"ArrowUp\") {\n                e.preventDefault();\n                increment(this._step * this._arrowKeyMultiplier(e));\n            }\n            if (e.code === \"ArrowDown\") {\n                e.preventDefault();\n                increment(this._step * this._arrowKeyMultiplier(e) * -1);\n            }\n        };\n        const onWheel = (e)=>{\n            if (this._inputFocused) {\n                e.preventDefault();\n                increment(this._step * this._normalizeMouseWheel(e));\n            }\n        };\n        // Vertical drag\n        // ---------------------------------------------------------------------\n        let testingForVerticalDrag = false, initClientX, initClientY, prevClientY, initValue, dragDelta;\n        // Once the mouse is dragged more than DRAG_THRESH px on any axis, we decide\n        // on the user's intent: horizontal means highlight, vertical means drag.\n        const DRAG_THRESH = 5;\n        const onMouseDown = (e)=>{\n            initClientX = e.clientX;\n            initClientY = prevClientY = e.clientY;\n            testingForVerticalDrag = true;\n            initValue = this.getValue();\n            dragDelta = 0;\n            window.addEventListener(\"mousemove\", onMouseMove);\n            window.addEventListener(\"mouseup\", onMouseUp);\n        };\n        const onMouseMove = (e)=>{\n            if (testingForVerticalDrag) {\n                const dx = e.clientX - initClientX;\n                const dy = e.clientY - initClientY;\n                if (Math.abs(dy) > DRAG_THRESH) {\n                    e.preventDefault();\n                    this.$input.blur();\n                    testingForVerticalDrag = false;\n                    this._setDraggingStyle(true, \"vertical\");\n                } else if (Math.abs(dx) > DRAG_THRESH) {\n                    onMouseUp();\n                }\n            }\n            // This isn't an else so that the first move counts towards dragDelta\n            if (!testingForVerticalDrag) {\n                const dy = e.clientY - prevClientY;\n                dragDelta -= dy * this._step * this._arrowKeyMultiplier(e);\n                // Clamp dragDelta so we don't have 'dead space' after dragging past bounds.\n                // We're okay with the fact that bounds can be undefined here.\n                if (initValue + dragDelta > this._max) {\n                    dragDelta = this._max - initValue;\n                } else if (initValue + dragDelta < this._min) {\n                    dragDelta = this._min - initValue;\n                }\n                this._snapClampSetValue(initValue + dragDelta);\n            }\n            prevClientY = e.clientY;\n        };\n        const onMouseUp = ()=>{\n            this._setDraggingStyle(false, \"vertical\");\n            this._callOnFinishChange();\n            window.removeEventListener(\"mousemove\", onMouseMove);\n            window.removeEventListener(\"mouseup\", onMouseUp);\n        };\n        // Focus state & onFinishChange\n        // ---------------------------------------------------------------------\n        const onFocus = ()=>{\n            this._inputFocused = true;\n        };\n        const onBlur = ()=>{\n            this._inputFocused = false;\n            this.updateDisplay();\n            this._callOnFinishChange();\n        };\n        this.$input.addEventListener(\"input\", onInput);\n        this.$input.addEventListener(\"keydown\", onKeyDown);\n        this.$input.addEventListener(\"wheel\", onWheel, {\n            passive: false\n        });\n        this.$input.addEventListener(\"mousedown\", onMouseDown);\n        this.$input.addEventListener(\"focus\", onFocus);\n        this.$input.addEventListener(\"blur\", onBlur);\n    }\n    _initSlider() {\n        this._hasSlider = true;\n        // Build DOM\n        // ---------------------------------------------------------------------\n        this.$slider = document.createElement(\"div\");\n        this.$slider.classList.add(\"slider\");\n        this.$fill = document.createElement(\"div\");\n        this.$fill.classList.add(\"fill\");\n        this.$slider.appendChild(this.$fill);\n        this.$widget.insertBefore(this.$slider, this.$input);\n        this.domElement.classList.add(\"hasSlider\");\n        // Map clientX to value\n        // ---------------------------------------------------------------------\n        const map = (v, a, b, c, d)=>{\n            return (v - a) / (b - a) * (d - c) + c;\n        };\n        const setValueFromX = (clientX)=>{\n            const rect = this.$slider.getBoundingClientRect();\n            let value = map(clientX, rect.left, rect.right, this._min, this._max);\n            this._snapClampSetValue(value);\n        };\n        // Mouse drag\n        // ---------------------------------------------------------------------\n        const mouseDown = (e)=>{\n            this._setDraggingStyle(true);\n            setValueFromX(e.clientX);\n            window.addEventListener(\"mousemove\", mouseMove);\n            window.addEventListener(\"mouseup\", mouseUp);\n        };\n        const mouseMove = (e)=>{\n            setValueFromX(e.clientX);\n        };\n        const mouseUp = ()=>{\n            this._callOnFinishChange();\n            this._setDraggingStyle(false);\n            window.removeEventListener(\"mousemove\", mouseMove);\n            window.removeEventListener(\"mouseup\", mouseUp);\n        };\n        // Touch drag\n        // ---------------------------------------------------------------------\n        let testingForScroll = false, prevClientX, prevClientY;\n        const beginTouchDrag = (e)=>{\n            e.preventDefault();\n            this._setDraggingStyle(true);\n            setValueFromX(e.touches[0].clientX);\n            testingForScroll = false;\n        };\n        const onTouchStart = (e)=>{\n            if (e.touches.length > 1) return;\n            // If we're in a scrollable container, we should wait for the first\n            // touchmove to see if the user is trying to slide or scroll.\n            if (this._hasScrollBar) {\n                prevClientX = e.touches[0].clientX;\n                prevClientY = e.touches[0].clientY;\n                testingForScroll = true;\n            } else {\n                // Otherwise, we can set the value straight away on touchstart.\n                beginTouchDrag(e);\n            }\n            window.addEventListener(\"touchmove\", onTouchMove, {\n                passive: false\n            });\n            window.addEventListener(\"touchend\", onTouchEnd);\n        };\n        const onTouchMove = (e)=>{\n            if (testingForScroll) {\n                const dx = e.touches[0].clientX - prevClientX;\n                const dy = e.touches[0].clientY - prevClientY;\n                if (Math.abs(dx) > Math.abs(dy)) {\n                    // We moved horizontally, set the value and stop checking.\n                    beginTouchDrag(e);\n                } else {\n                    // This was, in fact, an attempt to scroll. Abort.\n                    window.removeEventListener(\"touchmove\", onTouchMove);\n                    window.removeEventListener(\"touchend\", onTouchEnd);\n                }\n            } else {\n                e.preventDefault();\n                setValueFromX(e.touches[0].clientX);\n            }\n        };\n        const onTouchEnd = ()=>{\n            this._callOnFinishChange();\n            this._setDraggingStyle(false);\n            window.removeEventListener(\"touchmove\", onTouchMove);\n            window.removeEventListener(\"touchend\", onTouchEnd);\n        };\n        // Mouse wheel\n        // ---------------------------------------------------------------------\n        // We have to use a debounced function to call onFinishChange because\n        // there's no way to tell when the user is \"done\" mouse-wheeling.\n        const callOnFinishChange = this._callOnFinishChange.bind(this);\n        const WHEEL_DEBOUNCE_TIME = 400;\n        let wheelFinishChangeTimeout;\n        const onWheel = (e)=>{\n            // ignore vertical wheels if there's a scrollbar\n            const isVertical = Math.abs(e.deltaX) < Math.abs(e.deltaY);\n            if (isVertical && this._hasScrollBar) return;\n            e.preventDefault();\n            // set value\n            const delta = this._normalizeMouseWheel(e) * this._step;\n            this._snapClampSetValue(this.getValue() + delta);\n            // force the input to updateDisplay when it's focused\n            this.$input.value = this.getValue();\n            // debounce onFinishChange\n            clearTimeout(wheelFinishChangeTimeout);\n            wheelFinishChangeTimeout = setTimeout(callOnFinishChange, WHEEL_DEBOUNCE_TIME);\n        };\n        this.$slider.addEventListener(\"mousedown\", mouseDown);\n        this.$slider.addEventListener(\"touchstart\", onTouchStart, {\n            passive: false\n        });\n        this.$slider.addEventListener(\"wheel\", onWheel, {\n            passive: false\n        });\n    }\n    _setDraggingStyle(active, axis = \"horizontal\") {\n        if (this.$slider) {\n            this.$slider.classList.toggle(\"active\", active);\n        }\n        document.body.classList.toggle(\"lil-gui-dragging\", active);\n        document.body.classList.toggle(`lil-gui-${axis}`, active);\n    }\n    _getImplicitStep() {\n        if (this._hasMin && this._hasMax) {\n            return (this._max - this._min) / 1000;\n        }\n        return 0.1;\n    }\n    _onUpdateMinMax() {\n        if (!this._hasSlider && this._hasMin && this._hasMax) {\n            // If this is the first time we're hearing about min and max\n            // and we haven't explicitly stated what our step is, let's\n            // update that too.\n            if (!this._stepExplicit) {\n                this.step(this._getImplicitStep(), false);\n            }\n            this._initSlider();\n            this.updateDisplay();\n        }\n    }\n    _normalizeMouseWheel(e) {\n        let { deltaX, deltaY } = e;\n        // Safari and Chrome report weird non-integral values for a notched wheel,\n        // but still expose actual lines scrolled via wheelDelta. Notched wheels\n        // should behave the same way as arrow keys.\n        if (Math.floor(e.deltaY) !== e.deltaY && e.wheelDelta) {\n            deltaX = 0;\n            deltaY = -e.wheelDelta / 120;\n            deltaY *= this._stepExplicit ? 1 : 10;\n        }\n        const wheel = deltaX + -deltaY;\n        return wheel;\n    }\n    _arrowKeyMultiplier(e) {\n        let mult = this._stepExplicit ? 1 : 10;\n        if (e.shiftKey) {\n            mult *= 10;\n        } else if (e.altKey) {\n            mult /= 10;\n        }\n        return mult;\n    }\n    _snap(value) {\n        // This would be the logical way to do things, but floating point errors.\n        // return Math.round( value / this._step ) * this._step;\n        // Using inverse step solves a lot of them, but not all\n        // const inverseStep = 1 / this._step;\n        // return Math.round( value * inverseStep ) / inverseStep;\n        // Not happy about this, but haven't seen it break.\n        const r = Math.round(value / this._step) * this._step;\n        return parseFloat(r.toPrecision(15));\n    }\n    _clamp(value) {\n        // either condition is false if min or max is undefined\n        if (value < this._min) value = this._min;\n        if (value > this._max) value = this._max;\n        return value;\n    }\n    _snapClampSetValue(value) {\n        this.setValue(this._clamp(this._snap(value)));\n    }\n    get _hasScrollBar() {\n        const root = this.parent.root.$children;\n        return root.scrollHeight > root.clientHeight;\n    }\n    get _hasMin() {\n        return this._min !== undefined;\n    }\n    get _hasMax() {\n        return this._max !== undefined;\n    }\n}\nclass OptionController extends Controller {\n    constructor(parent, object, property, options){\n        super(parent, object, property, \"option\");\n        this.$select = document.createElement(\"select\");\n        this.$select.setAttribute(\"aria-labelledby\", this.$name.id);\n        this.$display = document.createElement(\"div\");\n        this.$display.classList.add(\"display\");\n        this.$select.addEventListener(\"change\", ()=>{\n            this.setValue(this._values[this.$select.selectedIndex]);\n            this._callOnFinishChange();\n        });\n        this.$select.addEventListener(\"focus\", ()=>{\n            this.$display.classList.add(\"focus\");\n        });\n        this.$select.addEventListener(\"blur\", ()=>{\n            this.$display.classList.remove(\"focus\");\n        });\n        this.$widget.appendChild(this.$select);\n        this.$widget.appendChild(this.$display);\n        this.$disable = this.$select;\n        this.options(options);\n    }\n    options(options) {\n        this._values = Array.isArray(options) ? options : Object.values(options);\n        this._names = Array.isArray(options) ? options : Object.keys(options);\n        this.$select.replaceChildren();\n        this._names.forEach((name)=>{\n            const $option = document.createElement(\"option\");\n            $option.textContent = name;\n            this.$select.appendChild($option);\n        });\n        this.updateDisplay();\n        return this;\n    }\n    updateDisplay() {\n        const value = this.getValue();\n        const index = this._values.indexOf(value);\n        this.$select.selectedIndex = index;\n        this.$display.textContent = index === -1 ? value : this._names[index];\n        return this;\n    }\n}\nclass StringController extends Controller {\n    constructor(parent, object, property){\n        super(parent, object, property, \"string\");\n        this.$input = document.createElement(\"input\");\n        this.$input.setAttribute(\"type\", \"text\");\n        this.$input.setAttribute(\"spellcheck\", \"false\");\n        this.$input.setAttribute(\"aria-labelledby\", this.$name.id);\n        this.$input.addEventListener(\"input\", ()=>{\n            this.setValue(this.$input.value);\n        });\n        this.$input.addEventListener(\"keydown\", (e)=>{\n            if (e.code === \"Enter\") {\n                this.$input.blur();\n            }\n        });\n        this.$input.addEventListener(\"blur\", ()=>{\n            this._callOnFinishChange();\n        });\n        this.$widget.appendChild(this.$input);\n        this.$disable = this.$input;\n        this.updateDisplay();\n    }\n    updateDisplay() {\n        this.$input.value = this.getValue();\n        return this;\n    }\n}\nconst stylesheet = `.lil-gui {\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  line-height: 1;\n  font-weight: normal;\n  font-style: normal;\n  text-align: left;\n  color: var(--text-color);\n  user-select: none;\n  -webkit-user-select: none;\n  touch-action: manipulation;\n  --background-color: #1f1f1f;\n  --text-color: #ebebeb;\n  --title-background-color: #111111;\n  --title-text-color: #ebebeb;\n  --widget-color: #424242;\n  --hover-color: #4f4f4f;\n  --focus-color: #595959;\n  --number-color: #2cc9ff;\n  --string-color: #a2db3c;\n  --font-size: 11px;\n  --input-font-size: 11px;\n  --font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Arial, sans-serif;\n  --font-family-mono: Menlo, Monaco, Consolas, \"Droid Sans Mono\", monospace;\n  --padding: 4px;\n  --spacing: 4px;\n  --widget-height: 20px;\n  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);\n  --name-width: 45%;\n  --slider-knob-width: 2px;\n  --slider-input-width: 27%;\n  --color-input-width: 27%;\n  --slider-input-min-width: 45px;\n  --color-input-min-width: 45px;\n  --folder-indent: 7px;\n  --widget-padding: 0 0 0 3px;\n  --widget-border-radius: 2px;\n  --checkbox-size: calc(0.75 * var(--widget-height));\n  --scrollbar-width: 5px;\n}\n.lil-gui, .lil-gui * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n.lil-gui.root {\n  width: var(--width, 245px);\n  display: flex;\n  flex-direction: column;\n  background: var(--background-color);\n}\n.lil-gui.root > .title {\n  background: var(--title-background-color);\n  color: var(--title-text-color);\n}\n.lil-gui.root > .children {\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.lil-gui.root > .children::-webkit-scrollbar {\n  width: var(--scrollbar-width);\n  height: var(--scrollbar-width);\n  background: var(--background-color);\n}\n.lil-gui.root > .children::-webkit-scrollbar-thumb {\n  border-radius: var(--scrollbar-width);\n  background: var(--focus-color);\n}\n@media (pointer: coarse) {\n  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {\n    --widget-height: 28px;\n    --padding: 6px;\n    --spacing: 6px;\n    --font-size: 13px;\n    --input-font-size: 16px;\n    --folder-indent: 10px;\n    --scrollbar-width: 7px;\n    --slider-input-min-width: 50px;\n    --color-input-min-width: 65px;\n  }\n}\n.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {\n  --widget-height: 28px;\n  --padding: 6px;\n  --spacing: 6px;\n  --font-size: 13px;\n  --input-font-size: 16px;\n  --folder-indent: 10px;\n  --scrollbar-width: 7px;\n  --slider-input-min-width: 50px;\n  --color-input-min-width: 65px;\n}\n.lil-gui.autoPlace {\n  max-height: 100%;\n  position: fixed;\n  top: 0;\n  right: 15px;\n  z-index: 1001;\n}\n\n.lil-gui .controller {\n  display: flex;\n  align-items: center;\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n}\n.lil-gui .controller.disabled {\n  opacity: 0.5;\n}\n.lil-gui .controller.disabled, .lil-gui .controller.disabled * {\n  pointer-events: none !important;\n}\n.lil-gui .controller > .name {\n  min-width: var(--name-width);\n  flex-shrink: 0;\n  white-space: pre;\n  padding-right: var(--spacing);\n  line-height: var(--widget-height);\n}\n.lil-gui .controller .widget {\n  position: relative;\n  display: flex;\n  align-items: center;\n  width: 100%;\n  min-height: var(--widget-height);\n}\n.lil-gui .controller.string input {\n  color: var(--string-color);\n}\n.lil-gui .controller.boolean {\n  cursor: pointer;\n}\n.lil-gui .controller.color .display {\n  width: 100%;\n  height: var(--widget-height);\n  border-radius: var(--widget-border-radius);\n  position: relative;\n}\n@media (hover: hover) {\n  .lil-gui .controller.color .display:hover:before {\n    content: \" \";\n    display: block;\n    position: absolute;\n    border-radius: var(--widget-border-radius);\n    border: 1px solid #fff9;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n}\n.lil-gui .controller.color input[type=color] {\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n}\n.lil-gui .controller.color input[type=text] {\n  margin-left: var(--spacing);\n  font-family: var(--font-family-mono);\n  min-width: var(--color-input-min-width);\n  width: var(--color-input-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.option select {\n  opacity: 0;\n  position: absolute;\n  width: 100%;\n  max-width: 100%;\n}\n.lil-gui .controller.option .display {\n  position: relative;\n  pointer-events: none;\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  line-height: var(--widget-height);\n  max-width: 100%;\n  overflow: hidden;\n  word-break: break-all;\n  padding-left: 0.55em;\n  padding-right: 1.75em;\n  background: var(--widget-color);\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .display.focus {\n    background: var(--focus-color);\n  }\n}\n.lil-gui .controller.option .display.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.option .display:after {\n  font-family: \"lil-gui\";\n  content: \"↕\";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  padding-right: 0.375em;\n}\n.lil-gui .controller.option .widget,\n.lil-gui .controller.option select {\n  cursor: pointer;\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .widget:hover .display {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number input {\n  color: var(--number-color);\n}\n.lil-gui .controller.number.hasSlider input {\n  margin-left: var(--spacing);\n  width: var(--slider-input-width);\n  min-width: var(--slider-input-min-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.number .slider {\n  width: 100%;\n  height: var(--widget-height);\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  padding-right: var(--slider-knob-width);\n  overflow: hidden;\n  cursor: ew-resize;\n  touch-action: pan-y;\n}\n@media (hover: hover) {\n  .lil-gui .controller.number .slider:hover {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number .slider.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.number .slider.active .fill {\n  opacity: 0.95;\n}\n.lil-gui .controller.number .fill {\n  height: 100%;\n  border-right: var(--slider-knob-width) solid var(--number-color);\n  box-sizing: content-box;\n}\n\n.lil-gui-dragging .lil-gui {\n  --hover-color: var(--widget-color);\n}\n.lil-gui-dragging * {\n  cursor: ew-resize !important;\n}\n\n.lil-gui-dragging.lil-gui-vertical * {\n  cursor: ns-resize !important;\n}\n\n.lil-gui .title {\n  height: var(--title-height);\n  line-height: calc(var(--title-height) - 4px);\n  font-weight: 600;\n  padding: 0 var(--padding);\n  -webkit-tap-highlight-color: transparent;\n  cursor: pointer;\n  outline: none;\n  text-decoration-skip: objects;\n}\n.lil-gui .title:before {\n  font-family: \"lil-gui\";\n  content: \"▾\";\n  padding-right: 2px;\n  display: inline-block;\n}\n.lil-gui .title:active {\n  background: var(--title-background-color);\n  opacity: 0.75;\n}\n@media (hover: hover) {\n  body:not(.lil-gui-dragging) .lil-gui .title:hover {\n    background: var(--title-background-color);\n    opacity: 0.85;\n  }\n  .lil-gui .title:focus {\n    text-decoration: underline var(--focus-color);\n  }\n}\n.lil-gui.root > .title:focus {\n  text-decoration: none !important;\n}\n.lil-gui.closed > .title:before {\n  content: \"▸\";\n}\n.lil-gui.closed > .children {\n  transform: translateY(-7px);\n  opacity: 0;\n}\n.lil-gui.closed:not(.transition) > .children {\n  display: none;\n}\n.lil-gui.transition > .children {\n  transition-duration: 300ms;\n  transition-property: height, opacity, transform;\n  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);\n  overflow: hidden;\n  pointer-events: none;\n}\n.lil-gui .children:empty:before {\n  content: \"Empty\";\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n  display: block;\n  height: var(--widget-height);\n  font-style: italic;\n  line-height: var(--widget-height);\n  opacity: 0.5;\n}\n.lil-gui.root > .children > .lil-gui > .title {\n  border: 0 solid var(--widget-color);\n  border-width: 1px 0;\n  transition: border-color 300ms;\n}\n.lil-gui.root > .children > .lil-gui.closed > .title {\n  border-bottom-color: transparent;\n}\n.lil-gui + .controller {\n  border-top: 1px solid var(--widget-color);\n  margin-top: 0;\n  padding-top: var(--spacing);\n}\n.lil-gui .lil-gui .lil-gui > .title {\n  border: none;\n}\n.lil-gui .lil-gui .lil-gui > .children {\n  border: none;\n  margin-left: var(--folder-indent);\n  border-left: 2px solid var(--widget-color);\n}\n.lil-gui .lil-gui .controller {\n  border: none;\n}\n\n.lil-gui label, .lil-gui input, .lil-gui button {\n  -webkit-tap-highlight-color: transparent;\n}\n.lil-gui input {\n  border: 0;\n  outline: none;\n  font-family: var(--font-family);\n  font-size: var(--input-font-size);\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  background: var(--widget-color);\n  color: var(--text-color);\n  width: 100%;\n}\n@media (hover: hover) {\n  .lil-gui input:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui input:active {\n    background: var(--focus-color);\n  }\n}\n.lil-gui input:disabled {\n  opacity: 1;\n}\n.lil-gui input[type=text],\n.lil-gui input[type=number] {\n  padding: var(--widget-padding);\n  -moz-appearance: textfield;\n}\n.lil-gui input[type=text]:focus,\n.lil-gui input[type=number]:focus {\n  background: var(--focus-color);\n}\n.lil-gui input[type=checkbox] {\n  appearance: none;\n  width: var(--checkbox-size);\n  height: var(--checkbox-size);\n  border-radius: var(--widget-border-radius);\n  text-align: center;\n  cursor: pointer;\n}\n.lil-gui input[type=checkbox]:checked:before {\n  font-family: \"lil-gui\";\n  content: \"✓\";\n  font-size: var(--checkbox-size);\n  line-height: var(--checkbox-size);\n}\n@media (hover: hover) {\n  .lil-gui input[type=checkbox]:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button {\n  outline: none;\n  cursor: pointer;\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  color: var(--text-color);\n  width: 100%;\n  height: var(--widget-height);\n  text-transform: none;\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  border: none;\n}\n@media (hover: hover) {\n  .lil-gui button:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui button:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button:active {\n  background: var(--focus-color);\n}\n\n@font-face {\n  font-family: \"lil-gui\";\n  src: url(\"data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==\") format(\"woff\");\n}`;\nfunction _injectStyles(cssContent) {\n    const injected = document.createElement(\"style\");\n    injected.innerHTML = cssContent;\n    const before = document.querySelector(\"head link[rel=stylesheet], head style\");\n    if (before) {\n        document.head.insertBefore(injected, before);\n    } else {\n        document.head.appendChild(injected);\n    }\n}\nlet stylesInjected = false;\nclass GUI {\n    /**\n\t * Creates a panel that holds controllers.\n\t * @example\n\t * new GUI();\n\t * new GUI( { container: document.getElementById( 'custom' ) } );\n\t *\n\t * @param {object} [options]\n\t * @param {boolean} [options.autoPlace=true]\n\t * Adds the GUI to `document.body` and fixes it to the top right of the page.\n\t *\n\t * @param {HTMLElement} [options.container]\n\t * Adds the GUI to this DOM element. Overrides `autoPlace`.\n\t *\n\t * @param {number} [options.width=245]\n\t * Width of the GUI in pixels, usually set when name labels become too long. Note that you can make\n\t * name labels wider in CSS with `.lil‑gui { ‑‑name‑width: 55% }`.\n\t *\n\t * @param {string} [options.title=Controls]\n\t * Name to display in the title bar.\n\t *\n\t * @param {boolean} [options.closeFolders=false]\n\t * Pass `true` to close all folders in this GUI by default.\n\t *\n\t * @param {boolean} [options.injectStyles=true]\n\t * Injects the default stylesheet into the page if this is the first GUI.\n\t * Pass `false` to use your own stylesheet.\n\t *\n\t * @param {number} [options.touchStyles=true]\n\t * Makes controllers larger on touch devices. Pass `false` to disable touch styles.\n\t *\n\t * @param {GUI} [options.parent]\n\t * Adds this GUI as a child in another GUI. Usually this is done for you by `addFolder()`.\n\t *\n\t */ constructor({ parent, autoPlace = parent === undefined, container, width, title = \"Controls\", closeFolders = false, injectStyles = true, touchStyles = true } = {}){\n        /**\n\t\t * The GUI containing this folder, or `undefined` if this is the root GUI.\n\t\t * @type {GUI}\n\t\t */ this.parent = parent;\n        /**\n\t\t * The top level GUI containing this folder, or `this` if this is the root GUI.\n\t\t * @type {GUI}\n\t\t */ this.root = parent ? parent.root : this;\n        /**\n\t\t * The list of controllers and folders contained by this GUI.\n\t\t * @type {Array<GUI|Controller>}\n\t\t */ this.children = [];\n        /**\n\t\t * The list of controllers contained by this GUI.\n\t\t * @type {Array<Controller>}\n\t\t */ this.controllers = [];\n        /**\n\t\t * The list of folders contained by this GUI.\n\t\t * @type {Array<GUI>}\n\t\t */ this.folders = [];\n        /**\n\t\t * Used to determine if the GUI is closed. Use `gui.open()` or `gui.close()` to change this.\n\t\t * @type {boolean}\n\t\t */ this._closed = false;\n        /**\n\t\t * Used to determine if the GUI is hidden. Use `gui.show()` or `gui.hide()` to change this.\n\t\t * @type {boolean}\n\t\t */ this._hidden = false;\n        /**\n\t\t * The outermost container element.\n\t\t * @type {HTMLElement}\n\t\t */ this.domElement = document.createElement(\"div\");\n        this.domElement.classList.add(\"lil-gui\");\n        /**\n\t\t * The DOM element that contains the title.\n\t\t * @type {HTMLElement}\n\t\t */ this.$title = document.createElement(\"div\");\n        this.$title.classList.add(\"title\");\n        this.$title.setAttribute(\"role\", \"button\");\n        this.$title.setAttribute(\"aria-expanded\", true);\n        this.$title.setAttribute(\"tabindex\", 0);\n        this.$title.addEventListener(\"click\", ()=>this.openAnimated(this._closed));\n        this.$title.addEventListener(\"keydown\", (e)=>{\n            if (e.code === \"Enter\" || e.code === \"Space\") {\n                e.preventDefault();\n                this.$title.click();\n            }\n        });\n        // enables :active pseudo class on mobile\n        this.$title.addEventListener(\"touchstart\", ()=>{}, {\n            passive: true\n        });\n        /**\n\t\t * The DOM element that contains children.\n\t\t * @type {HTMLElement}\n\t\t */ this.$children = document.createElement(\"div\");\n        this.$children.classList.add(\"children\");\n        this.domElement.appendChild(this.$title);\n        this.domElement.appendChild(this.$children);\n        this.title(title);\n        if (this.parent) {\n            this.parent.children.push(this);\n            this.parent.folders.push(this);\n            this.parent.$children.appendChild(this.domElement);\n            // Stop the constructor early, everything onward only applies to root GUI's\n            return;\n        }\n        this.domElement.classList.add(\"root\");\n        if (touchStyles) {\n            this.domElement.classList.add(\"allow-touch-styles\");\n        }\n        // Inject stylesheet if we haven't done that yet\n        if (!stylesInjected && injectStyles) {\n            _injectStyles(stylesheet);\n            stylesInjected = true;\n        }\n        if (container) {\n            container.appendChild(this.domElement);\n        } else if (autoPlace) {\n            this.domElement.classList.add(\"autoPlace\");\n            document.body.appendChild(this.domElement);\n        }\n        if (width) {\n            this.domElement.style.setProperty(\"--width\", width + \"px\");\n        }\n        this._closeFolders = closeFolders;\n    }\n    /**\n\t * Adds a controller to the GUI, inferring controller type using the `typeof` operator.\n\t * @example\n\t * gui.add( object, 'property' );\n\t * gui.add( object, 'number', 0, 100, 1 );\n\t * gui.add( object, 'options', [ 1, 2, 3 ] );\n\t *\n\t * @param {object} object The object the controller will modify.\n\t * @param {string} property Name of the property to control.\n\t * @param {number|object|Array} [$1] Minimum value for number controllers, or the set of\n\t * selectable values for a dropdown.\n\t * @param {number} [max] Maximum value for number controllers.\n\t * @param {number} [step] Step value for number controllers.\n\t * @returns {Controller}\n\t */ add(object, property, $1, max, step) {\n        if (Object($1) === $1) {\n            return new OptionController(this, object, property, $1);\n        }\n        const initialValue = object[property];\n        switch(typeof initialValue){\n            case \"number\":\n                return new NumberController(this, object, property, $1, max, step);\n            case \"boolean\":\n                return new BooleanController(this, object, property);\n            case \"string\":\n                return new StringController(this, object, property);\n            case \"function\":\n                return new FunctionController(this, object, property);\n        }\n        console.error(`gui.add failed\n\tproperty:`, property, `\n\tobject:`, object, `\n\tvalue:`, initialValue);\n    }\n    /**\n\t * Adds a color controller to the GUI.\n\t * @example\n\t * params = {\n\t * \tcssColor: '#ff00ff',\n\t * \trgbColor: { r: 0, g: 0.2, b: 0.4 },\n\t * \tcustomRange: [ 0, 127, 255 ],\n\t * };\n\t *\n\t * gui.addColor( params, 'cssColor' );\n\t * gui.addColor( params, 'rgbColor' );\n\t * gui.addColor( params, 'customRange', 255 );\n\t *\n\t * @param {object} object The object the controller will modify.\n\t * @param {string} property Name of the property to control.\n\t * @param {number} rgbScale Maximum value for a color channel when using an RGB color. You may\n\t * need to set this to 255 if your colors are too bright.\n\t * @returns {Controller}\n\t */ addColor(object, property, rgbScale = 1) {\n        return new ColorController(this, object, property, rgbScale);\n    }\n    /**\n\t * Adds a folder to the GUI, which is just another GUI. This method returns\n\t * the nested GUI so you can add controllers to it.\n\t * @example\n\t * const folder = gui.addFolder( 'Position' );\n\t * folder.add( position, 'x' );\n\t * folder.add( position, 'y' );\n\t * folder.add( position, 'z' );\n\t *\n\t * @param {string} title Name to display in the folder's title bar.\n\t * @returns {GUI}\n\t */ addFolder(title) {\n        const folder = new GUI({\n            parent: this,\n            title\n        });\n        if (this.root._closeFolders) folder.close();\n        return folder;\n    }\n    /**\n\t * Recalls values that were saved with `gui.save()`.\n\t * @param {object} obj\n\t * @param {boolean} recursive Pass false to exclude folders descending from this GUI.\n\t * @returns {this}\n\t */ load(obj, recursive = true) {\n        if (obj.controllers) {\n            this.controllers.forEach((c)=>{\n                if (c instanceof FunctionController) return;\n                if (c._name in obj.controllers) {\n                    c.load(obj.controllers[c._name]);\n                }\n            });\n        }\n        if (recursive && obj.folders) {\n            this.folders.forEach((f)=>{\n                if (f._title in obj.folders) {\n                    f.load(obj.folders[f._title]);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n\t * Returns an object mapping controller names to values. The object can be passed to `gui.load()` to\n\t * recall these values.\n\t * @example\n\t * {\n\t * \tcontrollers: {\n\t * \t\tprop1: 1,\n\t * \t\tprop2: 'value',\n\t * \t\t...\n\t * \t},\n\t * \tfolders: {\n\t * \t\tfolderName1: { controllers, folders },\n\t * \t\tfolderName2: { controllers, folders }\n\t * \t\t...\n\t * \t}\n\t * }\n\t *\n\t * @param {boolean} recursive Pass false to exclude folders descending from this GUI.\n\t * @returns {object}\n\t */ save(recursive = true) {\n        const obj = {\n            controllers: {},\n            folders: {}\n        };\n        this.controllers.forEach((c)=>{\n            if (c instanceof FunctionController) return;\n            if (c._name in obj.controllers) {\n                throw new Error(`Cannot save GUI with duplicate property \"${c._name}\"`);\n            }\n            obj.controllers[c._name] = c.save();\n        });\n        if (recursive) {\n            this.folders.forEach((f)=>{\n                if (f._title in obj.folders) {\n                    throw new Error(`Cannot save GUI with duplicate folder \"${f._title}\"`);\n                }\n                obj.folders[f._title] = f.save();\n            });\n        }\n        return obj;\n    }\n    /**\n\t * Opens a GUI or folder. GUI and folders are open by default.\n\t * @param {boolean} open Pass false to close.\n\t * @returns {this}\n\t * @example\n\t * gui.open(); // open\n\t * gui.open( false ); // close\n\t * gui.open( gui._closed ); // toggle\n\t */ open(open = true) {\n        this._setClosed(!open);\n        this.$title.setAttribute(\"aria-expanded\", !this._closed);\n        this.domElement.classList.toggle(\"closed\", this._closed);\n        return this;\n    }\n    /**\n\t * Closes the GUI.\n\t * @returns {this}\n\t */ close() {\n        return this.open(false);\n    }\n    _setClosed(closed) {\n        if (this._closed === closed) return;\n        this._closed = closed;\n        this._callOnOpenClose(this);\n    }\n    /**\n\t * Shows the GUI after it's been hidden.\n\t * @param {boolean} show\n\t * @returns {this}\n\t * @example\n\t * gui.show();\n\t * gui.show( false ); // hide\n\t * gui.show( gui._hidden ); // toggle\n\t */ show(show = true) {\n        this._hidden = !show;\n        this.domElement.style.display = this._hidden ? \"none\" : \"\";\n        return this;\n    }\n    /**\n\t * Hides the GUI.\n\t * @returns {this}\n\t */ hide() {\n        return this.show(false);\n    }\n    openAnimated(open = true) {\n        // set state immediately\n        this._setClosed(!open);\n        this.$title.setAttribute(\"aria-expanded\", !this._closed);\n        // wait for next frame to measure $children\n        requestAnimationFrame(()=>{\n            // explicitly set initial height for transition\n            const initialHeight = this.$children.clientHeight;\n            this.$children.style.height = initialHeight + \"px\";\n            this.domElement.classList.add(\"transition\");\n            const onTransitionEnd = (e)=>{\n                if (e.target !== this.$children) return;\n                this.$children.style.height = \"\";\n                this.domElement.classList.remove(\"transition\");\n                this.$children.removeEventListener(\"transitionend\", onTransitionEnd);\n            };\n            this.$children.addEventListener(\"transitionend\", onTransitionEnd);\n            // todo: this is wrong if children's scrollHeight makes for a gui taller than maxHeight\n            const targetHeight = !open ? 0 : this.$children.scrollHeight;\n            this.domElement.classList.toggle(\"closed\", !open);\n            requestAnimationFrame(()=>{\n                this.$children.style.height = targetHeight + \"px\";\n            });\n        });\n        return this;\n    }\n    /**\n\t * Change the title of this GUI.\n\t * @param {string} title\n\t * @returns {this}\n\t */ title(title) {\n        /**\n\t\t * Current title of the GUI. Use `gui.title( 'Title' )` to modify this value.\n\t\t * @type {string}\n\t\t */ this._title = title;\n        this.$title.textContent = title;\n        return this;\n    }\n    /**\n\t * Resets all controllers to their initial values.\n\t * @param {boolean} recursive Pass false to exclude folders descending from this GUI.\n\t * @returns {this}\n\t */ reset(recursive = true) {\n        const controllers = recursive ? this.controllersRecursive() : this.controllers;\n        controllers.forEach((c)=>c.reset());\n        return this;\n    }\n    /**\n\t * Pass a function to be called whenever a controller in this GUI changes.\n\t * @param {function({object:object, property:string, value:any, controller:Controller})} callback\n\t * @returns {this}\n\t * @example\n\t * gui.onChange( event => {\n\t * \tevent.object     // object that was modified\n\t * \tevent.property   // string, name of property\n\t * \tevent.value      // new value of controller\n\t * \tevent.controller // controller that was modified\n\t * } );\n\t */ onChange(callback) {\n        /**\n\t\t * Used to access the function bound to `onChange` events. Don't modify this value\n\t\t * directly. Use the `gui.onChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */ this._onChange = callback;\n        return this;\n    }\n    _callOnChange(controller) {\n        if (this.parent) {\n            this.parent._callOnChange(controller);\n        }\n        if (this._onChange !== undefined) {\n            this._onChange.call(this, {\n                object: controller.object,\n                property: controller.property,\n                value: controller.getValue(),\n                controller\n            });\n        }\n    }\n    /**\n\t * Pass a function to be called whenever a controller in this GUI has finished changing.\n\t * @param {function({object:object, property:string, value:any, controller:Controller})} callback\n\t * @returns {this}\n\t * @example\n\t * gui.onFinishChange( event => {\n\t * \tevent.object     // object that was modified\n\t * \tevent.property   // string, name of property\n\t * \tevent.value      // new value of controller\n\t * \tevent.controller // controller that was modified\n\t * } );\n\t */ onFinishChange(callback) {\n        /**\n\t\t * Used to access the function bound to `onFinishChange` events. Don't modify this value\n\t\t * directly. Use the `gui.onFinishChange( callback )` method instead.\n\t\t * @type {Function}\n\t\t */ this._onFinishChange = callback;\n        return this;\n    }\n    _callOnFinishChange(controller) {\n        if (this.parent) {\n            this.parent._callOnFinishChange(controller);\n        }\n        if (this._onFinishChange !== undefined) {\n            this._onFinishChange.call(this, {\n                object: controller.object,\n                property: controller.property,\n                value: controller.getValue(),\n                controller\n            });\n        }\n    }\n    /**\n\t * Pass a function to be called when this GUI or its descendants are opened or closed.\n\t * @param {function(GUI)} callback\n\t * @returns {this}\n\t * @example\n\t * gui.onOpenClose( changedGUI => {\n\t * \tconsole.log( changedGUI._closed );\n\t * } );\n\t */ onOpenClose(callback) {\n        this._onOpenClose = callback;\n        return this;\n    }\n    _callOnOpenClose(changedGUI) {\n        if (this.parent) {\n            this.parent._callOnOpenClose(changedGUI);\n        }\n        if (this._onOpenClose !== undefined) {\n            this._onOpenClose.call(this, changedGUI);\n        }\n    }\n    /**\n\t * Destroys all DOM elements and event listeners associated with this GUI.\n\t */ destroy() {\n        if (this.parent) {\n            this.parent.children.splice(this.parent.children.indexOf(this), 1);\n            this.parent.folders.splice(this.parent.folders.indexOf(this), 1);\n        }\n        if (this.domElement.parentElement) {\n            this.domElement.parentElement.removeChild(this.domElement);\n        }\n        Array.from(this.children).forEach((c)=>c.destroy());\n    }\n    /**\n\t * Returns an array of controllers contained by this GUI and its descendents.\n\t * @returns {Controller[]}\n\t */ controllersRecursive() {\n        let controllers = Array.from(this.controllers);\n        this.folders.forEach((f)=>{\n            controllers = controllers.concat(f.controllersRecursive());\n        });\n        return controllers;\n    }\n    /**\n\t * Returns an array of folders contained by this GUI and its descendents.\n\t * @returns {GUI[]}\n\t */ foldersRecursive() {\n        let folders = Array.from(this.folders);\n        this.folders.forEach((f)=>{\n            folders = folders.concat(f.foldersRecursive());\n        });\n        return folders;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GUI);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlsLWd1aS9kaXN0L2xpbC1ndWkuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUVEOztDQUVDLEdBQ0QsTUFBTUE7SUFFTEMsWUFBYUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxjQUFjLEtBQUssQ0FBRztRQUV2RTs7O0dBR0MsR0FDRCxJQUFJLENBQUNKLE1BQU0sR0FBR0E7UUFFZDs7O0dBR0MsR0FDRCxJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFFZDs7O0dBR0MsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFFaEI7Ozs7R0FJQyxHQUNELElBQUksQ0FBQ0csU0FBUyxHQUFHO1FBRWpCOzs7O0dBSUMsR0FDRCxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUVmOzs7R0FHQyxHQUNELElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUksQ0FBQ0MsUUFBUTtRQUVqQzs7O0dBR0MsR0FDRCxJQUFJLENBQUNDLFVBQVUsR0FBR0MsU0FBU0MsYUFBYSxDQUFFUDtRQUMxQyxJQUFJLENBQUNLLFVBQVUsQ0FBQ0csU0FBUyxDQUFDQyxHQUFHLENBQUU7UUFDL0IsSUFBSSxDQUFDSixVQUFVLENBQUNHLFNBQVMsQ0FBQ0MsR0FBRyxDQUFFVjtRQUUvQjs7O0dBR0MsR0FDRCxJQUFJLENBQUNXLEtBQUssR0FBR0osU0FBU0MsYUFBYSxDQUFFO1FBQ3JDLElBQUksQ0FBQ0csS0FBSyxDQUFDRixTQUFTLENBQUNDLEdBQUcsQ0FBRTtRQUUxQmYsV0FBV2lCLFVBQVUsR0FBR2pCLFdBQVdpQixVQUFVLElBQUk7UUFDakQsSUFBSSxDQUFDRCxLQUFLLENBQUNFLEVBQUUsR0FBRyxDQUFDLGFBQWEsRUFBRSxFQUFFbEIsV0FBV2lCLFVBQVUsQ0FBQyxDQUFDO1FBRXpEOzs7R0FHQyxHQUNELElBQUksQ0FBQ0UsT0FBTyxHQUFHUCxTQUFTQyxhQUFhLENBQUU7UUFD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LWd1aS5lc20uanM/ZGUxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGxpbC1ndWlcbiAqIGh0dHBzOi8vbGlsLWd1aS5nZW9yZ2VhbHdheXMuY29tXG4gKiBAdmVyc2lvbiAwLjE5LjJcbiAqIEBhdXRob3IgR2VvcmdlIE1pY2hhZWwgQnJvd2VyXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBjb250cm9sbGVycy5cbiAqL1xuY2xhc3MgQ29udHJvbGxlciB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgY2xhc3NOYW1lLCBlbGVtZW50VHlwZSA9ICdkaXYnICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIEdVSSB0aGF0IGNvbnRhaW5zIHRoaXMgY29udHJvbGxlci5cblx0XHQgKiBAdHlwZSB7R1VJfVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG9iamVjdCB0aGlzIGNvbnRyb2xsZXIgd2lsbCBtb2RpZnkuXG5cdFx0ICogQHR5cGUge29iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjb250cm9sLlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0dGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG5cdFx0LyoqXG5cdFx0ICogVXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbnRyb2xsZXIgaXMgZGlzYWJsZWQuXG5cdFx0ICogVXNlIGBjb250cm9sbGVyLmRpc2FibGUoIHRydWV8ZmFsc2UgKWAgdG8gbW9kaWZ5IHRoaXMgdmFsdWUuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBDb250cm9sbGVyIGlzIGhpZGRlbi5cblx0XHQgKiBVc2UgYGNvbnRyb2xsZXIuc2hvdygpYCBvciBgY29udHJvbGxlci5oaWRlKClgIHRvIGNoYW5nZSB0aGlzLlxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuX2hpZGRlbiA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHZhbHVlIG9mIGBvYmplY3RbIHByb3BlcnR5IF1gIHdoZW4gdGhlIGNvbnRyb2xsZXIgd2FzIGNyZWF0ZWQuXG5cdFx0ICogQHR5cGUge2FueX1cblx0XHQgKi9cblx0XHR0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvdXRlcm1vc3QgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGlzIGNvbnRyb2xsZXIuXG5cdFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxuXHRcdCAqL1xuXHRcdHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIGVsZW1lbnRUeXBlICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5hZGQoICdjb250cm9sbGVyJyApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QuYWRkKCBjbGFzc05hbWUgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sbGVyJ3MgbmFtZS5cblx0XHQgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG5cdFx0ICovXG5cdFx0dGhpcy4kbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0dGhpcy4kbmFtZS5jbGFzc0xpc3QuYWRkKCAnbmFtZScgKTtcblxuXHRcdENvbnRyb2xsZXIubmV4dE5hbWVJRCA9IENvbnRyb2xsZXIubmV4dE5hbWVJRCB8fCAwO1xuXHRcdHRoaXMuJG5hbWUuaWQgPSBgbGlsLWd1aS1uYW1lLSR7KytDb250cm9sbGVyLm5leHROYW1lSUR9YDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sbGVyJ3MgXCJ3aWRnZXRcIiAod2hpY2ggZGlmZmVycyBieSBjb250cm9sbGVyIHR5cGUpLlxuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLiR3aWRnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuJHdpZGdldC5jbGFzc0xpc3QuYWRkKCAnd2lkZ2V0JyApO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIERPTSBlbGVtZW50IHRoYXQgcmVjZWl2ZXMgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSB3aGVuIHVzaW5nIGRpc2FibGUoKS5cblx0XHQgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG5cdFx0ICovXG5cdFx0dGhpcy4kZGlzYWJsZSA9IHRoaXMuJHdpZGdldDtcblxuXHRcdHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCggdGhpcy4kbmFtZSApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCggdGhpcy4kd2lkZ2V0ICk7XG5cblx0XHQvLyBEb24ndCBmaXJlIGdsb2JhbCBrZXkgZXZlbnRzIHdoaWxlIHR5cGluZyBpbiBhIGNvbnRyb2xsZXJcblx0XHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCkgKTtcblx0XHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpICk7XG5cblx0XHR0aGlzLnBhcmVudC5jaGlsZHJlbi5wdXNoKCB0aGlzICk7XG5cdFx0dGhpcy5wYXJlbnQuY29udHJvbGxlcnMucHVzaCggdGhpcyApO1xuXG5cdFx0dGhpcy5wYXJlbnQuJGNoaWxkcmVuLmFwcGVuZENoaWxkKCB0aGlzLmRvbUVsZW1lbnQgKTtcblxuXHRcdHRoaXMuX2xpc3RlbkNhbGxiYWNrID0gdGhpcy5fbGlzdGVuQ2FsbGJhY2suYmluZCggdGhpcyApO1xuXG5cdFx0dGhpcy5uYW1lKCBwcm9wZXJ0eSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbmFtZSBvZiB0aGUgY29udHJvbGxlciBhbmQgaXRzIGxhYmVsIGluIHRoZSBHVUkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0bmFtZSggbmFtZSApIHtcblx0XHQvKipcblx0XHQgKiBUaGUgY29udHJvbGxlcidzIG5hbWUuIFVzZSBgY29udHJvbGxlci5uYW1lKCAnTmFtZScgKWAgdG8gbW9kaWZ5IHRoaXMgdmFsdWUuXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLl9uYW1lID0gbmFtZTtcblx0XHR0aGlzLiRuYW1lLnRleHRDb250ZW50ID0gbmFtZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXNzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBpcyBtb2RpZmllZCBieSB0aGlzIGNvbnRyb2xsZXIuXG5cdCAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgbmV3IHZhbHVlIGFzIGl0cyBmaXJzdCBwYXJhbWV0ZXIuIFRoZSB2YWx1ZSBvZiBgdGhpc2Agd2lsbCBiZSB0aGVcblx0ICogY29udHJvbGxlci5cblx0ICpcblx0ICogRm9yIGZ1bmN0aW9uIGNvbnRyb2xsZXJzLCB0aGUgYG9uQ2hhbmdlYCBjYWxsYmFjayB3aWxsIGJlIGZpcmVkIG9uIGNsaWNrLCBhZnRlciB0aGUgZnVuY3Rpb25cblx0ICogZXhlY3V0ZXMuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjb25zdCBjb250cm9sbGVyID0gZ3VpLmFkZCggb2JqZWN0LCAncHJvcGVydHknICk7XG5cdCAqXG5cdCAqIGNvbnRyb2xsZXIub25DaGFuZ2UoIGZ1bmN0aW9uKCB2ICkge1xuXHQgKiBcdGNvbnNvbGUubG9nKCAnVGhlIHZhbHVlIGlzIG5vdyAnICsgdiApO1xuXHQgKiBcdGNvbnNvbGUuYXNzZXJ0KCB0aGlzID09PSBjb250cm9sbGVyICk7XG5cdCAqIH0gKTtcblx0ICovXG5cdG9uQ2hhbmdlKCBjYWxsYmFjayApIHtcblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGFjY2VzcyB0aGUgZnVuY3Rpb24gYm91bmQgdG8gYG9uQ2hhbmdlYCBldmVudHMuIERvbid0IG1vZGlmeSB0aGlzIHZhbHVlIGRpcmVjdGx5LlxuXHRcdCAqIFVzZSB0aGUgYGNvbnRyb2xsZXIub25DaGFuZ2UoIGNhbGxiYWNrIClgIG1ldGhvZCBpbnN0ZWFkLlxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKi9cblx0XHR0aGlzLl9vbkNoYW5nZSA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxzIHRoZSBvbkNoYW5nZSBtZXRob2RzIG9mIHRoaXMgY29udHJvbGxlciBhbmQgaXRzIHBhcmVudCBHVUkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jYWxsT25DaGFuZ2UoKSB7XG5cblx0XHR0aGlzLnBhcmVudC5fY2FsbE9uQ2hhbmdlKCB0aGlzICk7XG5cblx0XHRpZiAoIHRoaXMuX29uQ2hhbmdlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZS5jYWxsKCB0aGlzLCB0aGlzLmdldFZhbHVlKCkgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jaGFuZ2VkID0gdHJ1ZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhpcyBjb250cm9sbGVyIGhhcyBiZWVuIG1vZGlmaWVkIGFuZCBsb3NlcyBmb2N1cy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbnN0IGNvbnRyb2xsZXIgPSBndWkuYWRkKCBvYmplY3QsICdwcm9wZXJ0eScgKTtcblx0ICpcblx0ICogY29udHJvbGxlci5vbkZpbmlzaENoYW5nZSggZnVuY3Rpb24oIHYgKSB7XG5cdCAqIFx0Y29uc29sZS5sb2coICdDaGFuZ2VzIGNvbXBsZXRlOiAnICsgdiApO1xuXHQgKiBcdGNvbnNvbGUuYXNzZXJ0KCB0aGlzID09PSBjb250cm9sbGVyICk7XG5cdCAqIH0gKTtcblx0ICovXG5cdG9uRmluaXNoQ2hhbmdlKCBjYWxsYmFjayApIHtcblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGFjY2VzcyB0aGUgZnVuY3Rpb24gYm91bmQgdG8gYG9uRmluaXNoQ2hhbmdlYCBldmVudHMuIERvbid0IG1vZGlmeSB0aGlzIHZhbHVlXG5cdFx0ICogZGlyZWN0bHkuIFVzZSB0aGUgYGNvbnRyb2xsZXIub25GaW5pc2hDaGFuZ2UoIGNhbGxiYWNrIClgIG1ldGhvZCBpbnN0ZWFkLlxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKi9cblx0XHR0aGlzLl9vbkZpbmlzaENoYW5nZSA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3VsZCBiZSBjYWxsZWQgYnkgQ29udHJvbGxlciB3aGVuIGl0cyB3aWRnZXRzIGxvc2UgZm9jdXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jYWxsT25GaW5pc2hDaGFuZ2UoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2NoYW5nZWQgKSB7XG5cblx0XHRcdHRoaXMucGFyZW50Ll9jYWxsT25GaW5pc2hDaGFuZ2UoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCB0aGlzLl9vbkZpbmlzaENoYW5nZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLl9vbkZpbmlzaENoYW5nZS5jYWxsKCB0aGlzLCB0aGlzLmdldFZhbHVlKCkgKTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuX2NoYW5nZWQgPSBmYWxzZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbnRyb2xsZXIgYmFjayB0byBpdHMgaW5pdGlhbCB2YWx1ZS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRyZXNldCgpIHtcblx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLmluaXRpYWxWYWx1ZSApO1xuXHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgdGhpcyBjb250cm9sbGVyLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbnRyb2xsZXIuZW5hYmxlKCk7XG5cdCAqIGNvbnRyb2xsZXIuZW5hYmxlKCBmYWxzZSApOyAvLyBkaXNhYmxlXG5cdCAqIGNvbnRyb2xsZXIuZW5hYmxlKCBjb250cm9sbGVyLl9kaXNhYmxlZCApOyAvLyB0b2dnbGVcblx0ICovXG5cdGVuYWJsZSggZW5hYmxlZCA9IHRydWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGlzYWJsZSggIWVuYWJsZWQgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyB0aGlzIGNvbnRyb2xsZXIuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWRcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGNvbnRyb2xsZXIuZGlzYWJsZSgpO1xuXHQgKiBjb250cm9sbGVyLmRpc2FibGUoIGZhbHNlICk7IC8vIGVuYWJsZVxuXHQgKiBjb250cm9sbGVyLmRpc2FibGUoICFjb250cm9sbGVyLl9kaXNhYmxlZCApOyAvLyB0b2dnbGVcblx0ICovXG5cdGRpc2FibGUoIGRpc2FibGVkID0gdHJ1ZSApIHtcblxuXHRcdGlmICggZGlzYWJsZWQgPT09IHRoaXMuX2Rpc2FibGVkICkgcmV0dXJuIHRoaXM7XG5cblx0XHR0aGlzLl9kaXNhYmxlZCA9IGRpc2FibGVkO1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoICdkaXNhYmxlZCcsIGRpc2FibGVkICk7XG5cdFx0dGhpcy4kZGlzYWJsZS50b2dnbGVBdHRyaWJ1dGUoICdkaXNhYmxlZCcsIGRpc2FibGVkICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNob3dzIHRoZSBDb250cm9sbGVyIGFmdGVyIGl0J3MgYmVlbiBoaWRkZW4uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd1xuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICogQGV4YW1wbGVcblx0ICogY29udHJvbGxlci5zaG93KCk7XG5cdCAqIGNvbnRyb2xsZXIuc2hvdyggZmFsc2UgKTsgLy8gaGlkZVxuXHQgKiBjb250cm9sbGVyLnNob3coIGNvbnRyb2xsZXIuX2hpZGRlbiApOyAvLyB0b2dnbGVcblx0ICovXG5cdHNob3coIHNob3cgPSB0cnVlICkge1xuXG5cdFx0dGhpcy5faGlkZGVuID0gIXNob3c7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHRoaXMuX2hpZGRlbiA/ICdub25lJyA6ICcnO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBIaWRlcyB0aGUgQ29udHJvbGxlci5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRoaWRlKCkge1xuXHRcdHJldHVybiB0aGlzLnNob3coIGZhbHNlICk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hhbmdlcyB0aGlzIGNvbnRyb2xsZXIgaW50byBhIGRyb3Bkb3duIG9mIG9wdGlvbnMuXG5cdCAqXG5cdCAqIENhbGxpbmcgdGhpcyBtZXRob2Qgb24gYW4gb3B0aW9uIGNvbnRyb2xsZXIgd2lsbCBzaW1wbHkgdXBkYXRlIHRoZSBvcHRpb25zLiBIb3dldmVyLCBpZiB0aGlzXG5cdCAqIGNvbnRyb2xsZXIgd2FzIG5vdCBhbHJlYWR5IGFuIG9wdGlvbiBjb250cm9sbGVyLCBvbGQgcmVmZXJlbmNlcyB0byB0aGlzIGNvbnRyb2xsZXIgYXJlXG5cdCAqIGRlc3Ryb3llZCwgYW5kIGEgbmV3IGNvbnRyb2xsZXIgaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgR1VJLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiAvLyBzYWZlIHVzYWdlXG5cdCAqXG5cdCAqIGd1aS5hZGQoIG9iaiwgJ3Byb3AxJyApLm9wdGlvbnMoIFsgJ2EnLCAnYicsICdjJyBdICk7XG5cdCAqIGd1aS5hZGQoIG9iaiwgJ3Byb3AyJyApLm9wdGlvbnMoIHsgQmlnOiAxMCwgU21hbGw6IDEgfSApO1xuXHQgKiBndWkuYWRkKCBvYmosICdwcm9wMycgKTtcblx0ICpcblx0ICogLy8gZGFuZ2VyXG5cdCAqXG5cdCAqIGNvbnN0IGN0cmwxID0gZ3VpLmFkZCggb2JqLCAncHJvcDEnICk7XG5cdCAqIGd1aS5hZGQoIG9iaiwgJ3Byb3AyJyApO1xuXHQgKlxuXHQgKiAvLyBjYWxsaW5nIG9wdGlvbnMgb3V0IG9mIG9yZGVyIGFkZHMgYSBuZXcgY29udHJvbGxlciB0byB0aGUgZW5kLi4uXG5cdCAqIGNvbnN0IGN0cmwyID0gY3RybDEub3B0aW9ucyggWyAnYScsICdiJywgJ2MnIF0gKTtcblx0ICpcblx0ICogLy8gLi4uYW5kIGN0cmwxIG5vdyByZWZlcmVuY2VzIGEgY29udHJvbGxlciB0aGF0IGRvZXNuJ3QgZXhpc3Rcblx0ICogYXNzZXJ0KCBjdHJsMiAhPT0gY3RybDEgKVxuXHQgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gb3B0aW9uc1xuXHQgKiBAcmV0dXJucyB7Q29udHJvbGxlcn1cblx0ICovXG5cdG9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdFx0Y29uc3QgY29udHJvbGxlciA9IHRoaXMucGFyZW50LmFkZCggdGhpcy5vYmplY3QsIHRoaXMucHJvcGVydHksIG9wdGlvbnMgKTtcblx0XHRjb250cm9sbGVyLm5hbWUoIHRoaXMuX25hbWUgKTtcblx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRyZXR1cm4gY29udHJvbGxlcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBtaW5pbXVtIHZhbHVlLiBPbmx5IHdvcmtzIG9uIG51bWJlciBjb250cm9sbGVycy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pblxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdG1pbiggbWluICkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIG1heGltdW0gdmFsdWUuIE9ubHkgd29ya3Mgb24gbnVtYmVyIGNvbnRyb2xsZXJzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4XG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0bWF4KCBtYXggKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogVmFsdWVzIHNldCBieSB0aGlzIGNvbnRyb2xsZXIgd2lsbCBiZSByb3VuZGVkIHRvIG11bHRpcGxlcyBvZiBgc3RlcGAuIE9ubHkgd29ya3Mgb24gbnVtYmVyXG5cdCAqIGNvbnRyb2xsZXJzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RlcFxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdHN0ZXAoIHN0ZXAgKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUm91bmRzIHRoZSBkaXNwbGF5ZWQgdmFsdWUgdG8gYSBmaXhlZCBudW1iZXIgb2YgZGVjaW1hbHMsIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBhY3R1YWwgdmFsdWVcblx0ICogbGlrZSBgc3RlcCgpYC4gT25seSB3b3JrcyBvbiBudW1iZXIgY29udHJvbGxlcnMuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGd1aS5hZGQoIG9iamVjdCwgJ3Byb3BlcnR5JyApLmxpc3RlbigpLmRlY2ltYWxzKCA0ICk7XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsc1xuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdGRlY2ltYWxzKCBkZWNpbWFscyApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxscyBgdXBkYXRlRGlzcGxheSgpYCBldmVyeSBhbmltYXRpb24gZnJhbWUuIFBhc3MgYGZhbHNlYCB0byBzdG9wIGxpc3RlbmluZy5cblx0ICogQHBhcmFtIHtib29sZWFufSBsaXN0ZW5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRsaXN0ZW4oIGxpc3RlbiA9IHRydWUgKSB7XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGUgY29udHJvbGxlciBpcyBjdXJyZW50bHkgbGlzdGVuaW5nLiBEb24ndCBtb2RpZnkgdGhpcyB2YWx1ZVxuXHRcdCAqIGRpcmVjdGx5LiBVc2UgdGhlIGBjb250cm9sbGVyLmxpc3RlbiggdHJ1ZXxmYWxzZSApYCBtZXRob2QgaW5zdGVhZC5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLl9saXN0ZW5pbmcgPSBsaXN0ZW47XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbkNhbGxiYWNrSUQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aGlzLl9saXN0ZW5DYWxsYmFja0lEICk7XG5cdFx0XHR0aGlzLl9saXN0ZW5DYWxsYmFja0lEID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fbGlzdGVuaW5nICkge1xuXHRcdFx0dGhpcy5fbGlzdGVuQ2FsbGJhY2soKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X2xpc3RlbkNhbGxiYWNrKCkge1xuXG5cdFx0dGhpcy5fbGlzdGVuQ2FsbGJhY2tJRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSggdGhpcy5fbGlzdGVuQ2FsbGJhY2sgKTtcblxuXHRcdC8vIFRvIHByZXZlbnQgZnJhbWVyYXRlIGxvc3MsIG1ha2Ugc3VyZSB0aGUgdmFsdWUgaGFzIGNoYW5nZWQgYmVmb3JlIHVwZGF0aW5nIHRoZSBkaXNwbGF5LlxuXHRcdC8vIE5vdGU6IHNhdmUoKSBpcyB1c2VkIGhlcmUgaW5zdGVhZCBvZiBnZXRWYWx1ZSgpIG9ubHkgYmVjYXVzZSBvZiBDb2xvckNvbnRyb2xsZXIuIFRoZSAhPT0gb3BlcmF0b3Jcblx0XHQvLyB3b24ndCB3b3JrIGZvciBjb2xvciBvYmplY3RzIG9yIGFycmF5cywgYnV0IENvbG9yQ29udHJvbGxlci5zYXZlKCkgYWx3YXlzIHJldHVybnMgYSBzdHJpbmcuXG5cblx0XHRjb25zdCBjdXJWYWx1ZSA9IHRoaXMuc2F2ZSgpO1xuXG5cdFx0aWYgKCBjdXJWYWx1ZSAhPT0gdGhpcy5fbGlzdGVuUHJldlZhbHVlICkge1xuXHRcdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGlzdGVuUHJldlZhbHVlID0gY3VyVmFsdWU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGBvYmplY3RbIHByb3BlcnR5IF1gLlxuXHQgKiBAcmV0dXJucyB7YW55fVxuXHQgKi9cblx0Z2V0VmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMub2JqZWN0WyB0aGlzLnByb3BlcnR5IF07XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgb2YgYG9iamVjdFsgcHJvcGVydHkgXWAsIGludm9rZXMgYW55IGBvbkNoYW5nZWAgaGFuZGxlcnMgYW5kIHVwZGF0ZXMgdGhlIGRpc3BsYXkuXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdHNldFZhbHVlKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5nZXRWYWx1ZSgpICE9PSB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5vYmplY3RbIHRoaXMucHJvcGVydHkgXSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fY2FsbE9uQ2hhbmdlKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgZGlzcGxheSB0byBrZWVwIGl0IGluIHN5bmMgd2l0aCB0aGUgY3VycmVudCB2YWx1ZS4gVXNlZnVsIGZvciB1cGRhdGluZyB5b3VyXG5cdCAqIGNvbnRyb2xsZXJzIHdoZW4gdGhlaXIgdmFsdWVzIGhhdmUgYmVlbiBtb2RpZmllZCBvdXRzaWRlIG9mIHRoZSBHVUkuXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0dXBkYXRlRGlzcGxheSgpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGxvYWQoIHZhbHVlICkge1xuXHRcdHRoaXMuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0dGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRzYXZlKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJveXMgdGhpcyBjb250cm9sbGVyIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIHBhcmVudCBHVUkuXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMubGlzdGVuKCBmYWxzZSApO1xuXHRcdHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSggdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZiggdGhpcyApLCAxICk7XG5cdFx0dGhpcy5wYXJlbnQuY29udHJvbGxlcnMuc3BsaWNlKCB0aGlzLnBhcmVudC5jb250cm9sbGVycy5pbmRleE9mKCB0aGlzICksIDEgKTtcblx0XHR0aGlzLnBhcmVudC4kY2hpbGRyZW4ucmVtb3ZlQ2hpbGQoIHRoaXMuZG9tRWxlbWVudCApO1xuXHR9XG5cbn1cblxuY2xhc3MgQm9vbGVhbkNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5ICkge1xuXG5cdFx0c3VwZXIoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgJ2Jvb2xlYW4nLCAnbGFiZWwnICk7XG5cblx0XHR0aGlzLiRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbnB1dCcgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICd0eXBlJywgJ2NoZWNrYm94JyApO1xuXHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMuJG5hbWUuaWQgKTtcblxuXHRcdHRoaXMuJHdpZGdldC5hcHBlbmRDaGlsZCggdGhpcy4kaW5wdXQgKTtcblxuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLiRpbnB1dC5jaGVja2VkICk7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiRkaXNhYmxlID0gdGhpcy4kaW5wdXQ7XG5cblx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuXHR9XG5cblx0dXBkYXRlRGlzcGxheSgpIHtcblx0XHR0aGlzLiRpbnB1dC5jaGVja2VkID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3JTdHJpbmcoIHN0cmluZyApIHtcblxuXHRsZXQgbWF0Y2gsIHJlc3VsdDtcblxuXHRpZiAoIG1hdGNoID0gc3RyaW5nLm1hdGNoKCAvKCN8MHgpPyhbYS1mMC05XXs2fSkvaSApICkge1xuXG5cdFx0cmVzdWx0ID0gbWF0Y2hbIDIgXTtcblxuXHR9IGVsc2UgaWYgKCBtYXRjaCA9IHN0cmluZy5tYXRjaCggL3JnYlxcKFxccyooXFxkKilcXHMqLFxccyooXFxkKilcXHMqLFxccyooXFxkKilcXHMqXFwpLyApICkge1xuXG5cdFx0cmVzdWx0ID0gcGFyc2VJbnQoIG1hdGNoWyAxIF0gKS50b1N0cmluZyggMTYgKS5wYWRTdGFydCggMiwgMCApXG5cdFx0XHQrIHBhcnNlSW50KCBtYXRjaFsgMiBdICkudG9TdHJpbmcoIDE2ICkucGFkU3RhcnQoIDIsIDAgKVxuXHRcdFx0KyBwYXJzZUludCggbWF0Y2hbIDMgXSApLnRvU3RyaW5nKCAxNiApLnBhZFN0YXJ0KCAyLCAwICk7XG5cblx0fSBlbHNlIGlmICggbWF0Y2ggPSBzdHJpbmcubWF0Y2goIC9eIz8oW2EtZjAtOV0pKFthLWYwLTldKShbYS1mMC05XSkkL2kgKSApIHtcblxuXHRcdHJlc3VsdCA9IG1hdGNoWyAxIF0gKyBtYXRjaFsgMSBdICsgbWF0Y2hbIDIgXSArIG1hdGNoWyAyIF0gKyBtYXRjaFsgMyBdICsgbWF0Y2hbIDMgXTtcblxuXHR9XG5cblx0aWYgKCByZXN1bHQgKSB7XG5cdFx0cmV0dXJuICcjJyArIHJlc3VsdDtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcblxufVxuXG5jb25zdCBTVFJJTkcgPSB7XG5cdGlzUHJpbWl0aXZlOiB0cnVlLFxuXHRtYXRjaDogdiA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycsXG5cdGZyb21IZXhTdHJpbmc6IG5vcm1hbGl6ZUNvbG9yU3RyaW5nLFxuXHR0b0hleFN0cmluZzogbm9ybWFsaXplQ29sb3JTdHJpbmdcbn07XG5cbmNvbnN0IElOVCA9IHtcblx0aXNQcmltaXRpdmU6IHRydWUsXG5cdG1hdGNoOiB2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyxcblx0ZnJvbUhleFN0cmluZzogc3RyaW5nID0+IHBhcnNlSW50KCBzdHJpbmcuc3Vic3RyaW5nKCAxICksIDE2ICksXG5cdHRvSGV4U3RyaW5nOiB2YWx1ZSA9PiAnIycgKyB2YWx1ZS50b1N0cmluZyggMTYgKS5wYWRTdGFydCggNiwgMCApXG59O1xuXG5jb25zdCBBUlJBWSA9IHtcblx0aXNQcmltaXRpdmU6IGZhbHNlLFxuXG5cdC8vIFRoZSBhcnJvdyBmdW5jdGlvbiBpcyBoZXJlIHRvIGFwcGVhc2UgdHJlZSBzaGFrZXJzIGxpa2UgZXNidWlsZCBvciB3ZWJwYWNrLlxuXHQvLyBTZWUgaHR0cHM6Ly9lc2J1aWxkLmdpdGh1Yi5pby9hcGkvI3RyZWUtc2hha2luZ1xuXHRtYXRjaDogdiA9PiBBcnJheS5pc0FycmF5KCB2ICksXG5cblx0ZnJvbUhleFN0cmluZyggc3RyaW5nLCB0YXJnZXQsIHJnYlNjYWxlID0gMSApIHtcblxuXHRcdGNvbnN0IGludCA9IElOVC5mcm9tSGV4U3RyaW5nKCBzdHJpbmcgKTtcblxuXHRcdHRhcmdldFsgMCBdID0gKCBpbnQgPj4gMTYgJiAyNTUgKSAvIDI1NSAqIHJnYlNjYWxlO1xuXHRcdHRhcmdldFsgMSBdID0gKCBpbnQgPj4gOCAmIDI1NSApIC8gMjU1ICogcmdiU2NhbGU7XG5cdFx0dGFyZ2V0WyAyIF0gPSAoIGludCAmIDI1NSApIC8gMjU1ICogcmdiU2NhbGU7XG5cblx0fSxcblx0dG9IZXhTdHJpbmcoIFsgciwgZywgYiBdLCByZ2JTY2FsZSA9IDEgKSB7XG5cblx0XHRyZ2JTY2FsZSA9IDI1NSAvIHJnYlNjYWxlO1xuXG5cdFx0Y29uc3QgaW50ID0gKCByICogcmdiU2NhbGUgKSA8PCAxNiBeXG5cdFx0XHQoIGcgKiByZ2JTY2FsZSApIDw8IDggXlxuXHRcdFx0KCBiICogcmdiU2NhbGUgKSA8PCAwO1xuXG5cdFx0cmV0dXJuIElOVC50b0hleFN0cmluZyggaW50ICk7XG5cblx0fVxufTtcblxuY29uc3QgT0JKRUNUID0ge1xuXHRpc1ByaW1pdGl2ZTogZmFsc2UsXG5cdG1hdGNoOiB2ID0+IE9iamVjdCggdiApID09PSB2LFxuXHRmcm9tSGV4U3RyaW5nKCBzdHJpbmcsIHRhcmdldCwgcmdiU2NhbGUgPSAxICkge1xuXG5cdFx0Y29uc3QgaW50ID0gSU5ULmZyb21IZXhTdHJpbmcoIHN0cmluZyApO1xuXG5cdFx0dGFyZ2V0LnIgPSAoIGludCA+PiAxNiAmIDI1NSApIC8gMjU1ICogcmdiU2NhbGU7XG5cdFx0dGFyZ2V0LmcgPSAoIGludCA+PiA4ICYgMjU1ICkgLyAyNTUgKiByZ2JTY2FsZTtcblx0XHR0YXJnZXQuYiA9ICggaW50ICYgMjU1ICkgLyAyNTUgKiByZ2JTY2FsZTtcblxuXHR9LFxuXHR0b0hleFN0cmluZyggeyByLCBnLCBiIH0sIHJnYlNjYWxlID0gMSApIHtcblxuXHRcdHJnYlNjYWxlID0gMjU1IC8gcmdiU2NhbGU7XG5cblx0XHRjb25zdCBpbnQgPSAoIHIgKiByZ2JTY2FsZSApIDw8IDE2IF5cblx0XHRcdCggZyAqIHJnYlNjYWxlICkgPDwgOCBeXG5cdFx0XHQoIGIgKiByZ2JTY2FsZSApIDw8IDA7XG5cblx0XHRyZXR1cm4gSU5ULnRvSGV4U3RyaW5nKCBpbnQgKTtcblxuXHR9XG59O1xuXG5jb25zdCBGT1JNQVRTID0gWyBTVFJJTkcsIElOVCwgQVJSQVksIE9CSkVDVCBdO1xuXG5mdW5jdGlvbiBnZXRDb2xvckZvcm1hdCggdmFsdWUgKSB7XG5cdHJldHVybiBGT1JNQVRTLmZpbmQoIGZvcm1hdCA9PiBmb3JtYXQubWF0Y2goIHZhbHVlICkgKTtcbn1cblxuY2xhc3MgQ29sb3JDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgcmdiU2NhbGUgKSB7XG5cblx0XHRzdXBlciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5LCAnY29sb3InICk7XG5cblx0XHR0aGlzLiRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbnB1dCcgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICd0eXBlJywgJ2NvbG9yJyApO1xuXHRcdHRoaXMuJGlucHV0LnNldEF0dHJpYnV0ZSggJ3RhYmluZGV4JywgLTEgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLiRuYW1lLmlkICk7XG5cblx0XHR0aGlzLiR0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2lucHV0JyApO1xuXHRcdHRoaXMuJHRleHQuc2V0QXR0cmlidXRlKCAndHlwZScsICd0ZXh0JyApO1xuXHRcdHRoaXMuJHRleHQuc2V0QXR0cmlidXRlKCAnc3BlbGxjaGVjaycsICdmYWxzZScgKTtcblx0XHR0aGlzLiR0ZXh0LnNldEF0dHJpYnV0ZSggJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMuJG5hbWUuaWQgKTtcblxuXHRcdHRoaXMuJGRpc3BsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuJGRpc3BsYXkuY2xhc3NMaXN0LmFkZCggJ2Rpc3BsYXknICk7XG5cblx0XHR0aGlzLiRkaXNwbGF5LmFwcGVuZENoaWxkKCB0aGlzLiRpbnB1dCApO1xuXHRcdHRoaXMuJHdpZGdldC5hcHBlbmRDaGlsZCggdGhpcy4kZGlzcGxheSApO1xuXHRcdHRoaXMuJHdpZGdldC5hcHBlbmRDaGlsZCggdGhpcy4kdGV4dCApO1xuXG5cdFx0dGhpcy5fZm9ybWF0ID0gZ2V0Q29sb3JGb3JtYXQoIHRoaXMuaW5pdGlhbFZhbHVlICk7XG5cdFx0dGhpcy5fcmdiU2NhbGUgPSByZ2JTY2FsZTtcblxuXHRcdHRoaXMuX2luaXRpYWxWYWx1ZUhleFN0cmluZyA9IHRoaXMuc2F2ZSgpO1xuXHRcdHRoaXMuX3RleHRGb2N1c2VkID0gZmFsc2U7XG5cblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLl9zZXRWYWx1ZUZyb21IZXhTdHJpbmcoIHRoaXMuJGlucHV0LnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCAoKSA9PiB7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiR0ZXh0LmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dCcsICgpID0+IHtcblx0XHRcdGNvbnN0IHRyeVBhcnNlID0gbm9ybWFsaXplQ29sb3JTdHJpbmcoIHRoaXMuJHRleHQudmFsdWUgKTtcblx0XHRcdGlmICggdHJ5UGFyc2UgKSB7XG5cdFx0XHRcdHRoaXMuX3NldFZhbHVlRnJvbUhleFN0cmluZyggdHJ5UGFyc2UgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLiR0ZXh0LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1cycsICgpID0+IHtcblx0XHRcdHRoaXMuX3RleHRGb2N1c2VkID0gdHJ1ZTtcblx0XHRcdHRoaXMuJHRleHQuc2VsZWN0KCk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy4kdGV4dC5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsICgpID0+IHtcblx0XHRcdHRoaXMuX3RleHRGb2N1c2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuJGRpc2FibGUgPSB0aGlzLiR0ZXh0O1xuXG5cdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cblx0fVxuXG5cdHJlc2V0KCkge1xuXHRcdHRoaXMuX3NldFZhbHVlRnJvbUhleFN0cmluZyggdGhpcy5faW5pdGlhbFZhbHVlSGV4U3RyaW5nICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfc2V0VmFsdWVGcm9tSGV4U3RyaW5nKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5fZm9ybWF0LmlzUHJpbWl0aXZlICkge1xuXG5cdFx0XHRjb25zdCBuZXdWYWx1ZSA9IHRoaXMuX2Zvcm1hdC5mcm9tSGV4U3RyaW5nKCB2YWx1ZSApO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSggbmV3VmFsdWUgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuX2Zvcm1hdC5mcm9tSGV4U3RyaW5nKCB2YWx1ZSwgdGhpcy5nZXRWYWx1ZSgpLCB0aGlzLl9yZ2JTY2FsZSApO1xuXHRcdFx0dGhpcy5fY2FsbE9uQ2hhbmdlKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2F2ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZm9ybWF0LnRvSGV4U3RyaW5nKCB0aGlzLmdldFZhbHVlKCksIHRoaXMuX3JnYlNjYWxlICk7XG5cdH1cblxuXHRsb2FkKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zZXRWYWx1ZUZyb21IZXhTdHJpbmcoIHZhbHVlICk7XG5cdFx0dGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR1cGRhdGVEaXNwbGF5KCkge1xuXHRcdHRoaXMuJGlucHV0LnZhbHVlID0gdGhpcy5fZm9ybWF0LnRvSGV4U3RyaW5nKCB0aGlzLmdldFZhbHVlKCksIHRoaXMuX3JnYlNjYWxlICk7XG5cdFx0aWYgKCAhdGhpcy5fdGV4dEZvY3VzZWQgKSB7XG5cdFx0XHR0aGlzLiR0ZXh0LnZhbHVlID0gdGhpcy4kaW5wdXQudmFsdWUuc3Vic3RyaW5nKCAxICk7XG5cdFx0fVxuXHRcdHRoaXMuJGRpc3BsYXkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy4kaW5wdXQudmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufVxuXG5jbGFzcyBGdW5jdGlvbkNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5ICkge1xuXG5cdFx0c3VwZXIoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgJ2Z1bmN0aW9uJyApO1xuXG5cdFx0Ly8gQnV0dG9ucyBhcmUgdGhlIG9ubHkgY2FzZSB3aGVyZSB3aWRnZXQgY29udGFpbnMgbmFtZVxuXHRcdHRoaXMuJGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdidXR0b24nICk7XG5cdFx0dGhpcy4kYnV0dG9uLmFwcGVuZENoaWxkKCB0aGlzLiRuYW1lICk7XG5cdFx0dGhpcy4kd2lkZ2V0LmFwcGVuZENoaWxkKCB0aGlzLiRidXR0b24gKTtcblxuXHRcdHRoaXMuJGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBlID0+IHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuZ2V0VmFsdWUoKS5jYWxsKCB0aGlzLm9iamVjdCApO1xuXHRcdFx0dGhpcy5fY2FsbE9uQ2hhbmdlKCk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gZW5hYmxlcyA6YWN0aXZlIHBzZXVkbyBjbGFzcyBvbiBtb2JpbGVcblx0XHR0aGlzLiRidXR0b24uYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCAoKSA9PiB7fSwgeyBwYXNzaXZlOiB0cnVlIH0gKTtcblxuXHRcdHRoaXMuJGRpc2FibGUgPSB0aGlzLiRidXR0b247XG5cblx0fVxuXG59XG5cbmNsYXNzIE51bWJlckNvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyZW50LCBvYmplY3QsIHByb3BlcnR5LCBtaW4sIG1heCwgc3RlcCApIHtcblxuXHRcdHN1cGVyKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHksICdudW1iZXInICk7XG5cblx0XHR0aGlzLl9pbml0SW5wdXQoKTtcblxuXHRcdHRoaXMubWluKCBtaW4gKTtcblx0XHR0aGlzLm1heCggbWF4ICk7XG5cblx0XHRjb25zdCBzdGVwRXhwbGljaXQgPSBzdGVwICE9PSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5zdGVwKCBzdGVwRXhwbGljaXQgPyBzdGVwIDogdGhpcy5fZ2V0SW1wbGljaXRTdGVwKCksIHN0ZXBFeHBsaWNpdCApO1xuXG5cdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cblx0fVxuXG5cdGRlY2ltYWxzKCBkZWNpbWFscyApIHtcblx0XHR0aGlzLl9kZWNpbWFscyA9IGRlY2ltYWxzO1xuXHRcdHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0bWluKCBtaW4gKSB7XG5cdFx0dGhpcy5fbWluID0gbWluO1xuXHRcdHRoaXMuX29uVXBkYXRlTWluTWF4KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRtYXgoIG1heCApIHtcblx0XHR0aGlzLl9tYXggPSBtYXg7XG5cdFx0dGhpcy5fb25VcGRhdGVNaW5NYXgoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHN0ZXAoIHN0ZXAsIGV4cGxpY2l0ID0gdHJ1ZSApIHtcblx0XHR0aGlzLl9zdGVwID0gc3RlcDtcblx0XHR0aGlzLl9zdGVwRXhwbGljaXQgPSBleHBsaWNpdDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHVwZGF0ZURpc3BsYXkoKSB7XG5cblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuXHRcdGlmICggdGhpcy5faGFzU2xpZGVyICkge1xuXG5cdFx0XHRsZXQgcGVyY2VudCA9ICggdmFsdWUgLSB0aGlzLl9taW4gKSAvICggdGhpcy5fbWF4IC0gdGhpcy5fbWluICk7XG5cdFx0XHRwZXJjZW50ID0gTWF0aC5tYXgoIDAsIE1hdGgubWluKCBwZXJjZW50LCAxICkgKTtcblxuXHRcdFx0dGhpcy4kZmlsbC5zdHlsZS53aWR0aCA9IHBlcmNlbnQgKiAxMDAgKyAnJSc7XG5cblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLl9pbnB1dEZvY3VzZWQgKSB7XG5cdFx0XHR0aGlzLiRpbnB1dC52YWx1ZSA9IHRoaXMuX2RlY2ltYWxzID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHZhbHVlLnRvRml4ZWQoIHRoaXMuX2RlY2ltYWxzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdF9pbml0SW5wdXQoKSB7XG5cblx0XHR0aGlzLiRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbnB1dCcgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICd0eXBlJywgJ3RleHQnICk7XG5cdFx0dGhpcy4kaW5wdXQuc2V0QXR0cmlidXRlKCAnYXJpYS1sYWJlbGxlZGJ5JywgdGhpcy4kbmFtZS5pZCApO1xuXG5cdFx0Ly8gT24gdG91Y2ggZGV2aWNlcyBvbmx5LCB1c2UgaW5wdXRbdHlwZT1udW1iZXJdIHRvIGZvcmNlIGEgbnVtZXJpYyBrZXlib2FyZC5cblx0XHQvLyBJZGVhbGx5IHdlIGNvdWxkIHVzZSBvbmUgaW5wdXQgdHlwZSBldmVyeXdoZXJlLCBidXQgW3R5cGU9bnVtYmVyXSBoYXMgcXVpcmtzXG5cdFx0Ly8gb24gZGVza3RvcCwgYW5kIFtpbnB1dG1vZGU9ZGVjaW1hbF0gaGFzIHF1aXJrcyBvbiBpT1MuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nZW9yZ2VhbHdheXMvbGlsLWd1aS9wdWxsLzE2XG5cblx0XHRjb25zdCBpc1RvdWNoID0gd2luZG93Lm1hdGNoTWVkaWEoICcocG9pbnRlcjogY29hcnNlKScgKS5tYXRjaGVzO1xuXG5cdFx0aWYgKCBpc1RvdWNoICkge1xuXHRcdFx0dGhpcy4kaW5wdXQuc2V0QXR0cmlidXRlKCAndHlwZScsICdudW1iZXInICk7XG5cdFx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICdzdGVwJywgJ2FueScgKTtcblx0XHR9XG5cblx0XHR0aGlzLiR3aWRnZXQuYXBwZW5kQ2hpbGQoIHRoaXMuJGlucHV0ICk7XG5cblx0XHR0aGlzLiRkaXNhYmxlID0gdGhpcy4kaW5wdXQ7XG5cblx0XHRjb25zdCBvbklucHV0ID0gKCkgPT4ge1xuXG5cdFx0XHRsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KCB0aGlzLiRpbnB1dC52YWx1ZSApO1xuXG5cdFx0XHRpZiAoIGlzTmFOKCB2YWx1ZSApICkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIHRoaXMuX3N0ZXBFeHBsaWNpdCApIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9zbmFwKCB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLl9jbGFtcCggdmFsdWUgKSApO1xuXG5cdFx0fTtcblxuXHRcdC8vIEtleXMgJiBtb3VzZSB3aGVlbFxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0Y29uc3QgaW5jcmVtZW50ID0gZGVsdGEgPT4ge1xuXG5cdFx0XHRjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQoIHRoaXMuJGlucHV0LnZhbHVlICk7XG5cblx0XHRcdGlmICggaXNOYU4oIHZhbHVlICkgKSByZXR1cm47XG5cblx0XHRcdHRoaXMuX3NuYXBDbGFtcFNldFZhbHVlKCB2YWx1ZSArIGRlbHRhICk7XG5cblx0XHRcdC8vIEZvcmNlIHRoZSBpbnB1dCB0byB1cGRhdGVEaXNwbGF5IHdoZW4gaXQncyBmb2N1c2VkXG5cdFx0XHR0aGlzLiRpbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuXHRcdH07XG5cblx0XHRjb25zdCBvbktleURvd24gPSBlID0+IHtcblx0XHRcdC8vIFVzaW5nIGBlLmtleWAgaW5zdGVhZCBvZiBgZS5jb2RlYCBhbHNvIGNhdGNoZXMgTnVtcGFkRW50ZXJcblx0XHRcdGlmICggZS5rZXkgPT09ICdFbnRlcicgKSB7XG5cdFx0XHRcdHRoaXMuJGlucHV0LmJsdXIoKTtcblx0XHRcdH1cblx0XHRcdGlmICggZS5jb2RlID09PSAnQXJyb3dVcCcgKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0aW5jcmVtZW50KCB0aGlzLl9zdGVwICogdGhpcy5fYXJyb3dLZXlNdWx0aXBsaWVyKCBlICkgKTtcblx0XHRcdH1cblx0XHRcdGlmICggZS5jb2RlID09PSAnQXJyb3dEb3duJyApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRpbmNyZW1lbnQoIHRoaXMuX3N0ZXAgKiB0aGlzLl9hcnJvd0tleU11bHRpcGxpZXIoIGUgKSAqIC0xICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGNvbnN0IG9uV2hlZWwgPSBlID0+IHtcblx0XHRcdGlmICggdGhpcy5faW5wdXRGb2N1c2VkICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGluY3JlbWVudCggdGhpcy5fc3RlcCAqIHRoaXMuX25vcm1hbGl6ZU1vdXNlV2hlZWwoIGUgKSApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBWZXJ0aWNhbCBkcmFnXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRsZXQgdGVzdGluZ0ZvclZlcnRpY2FsRHJhZyA9IGZhbHNlLFxuXHRcdFx0aW5pdENsaWVudFgsXG5cdFx0XHRpbml0Q2xpZW50WSxcblx0XHRcdHByZXZDbGllbnRZLFxuXHRcdFx0aW5pdFZhbHVlLFxuXHRcdFx0ZHJhZ0RlbHRhO1xuXG5cdFx0Ly8gT25jZSB0aGUgbW91c2UgaXMgZHJhZ2dlZCBtb3JlIHRoYW4gRFJBR19USFJFU0ggcHggb24gYW55IGF4aXMsIHdlIGRlY2lkZVxuXHRcdC8vIG9uIHRoZSB1c2VyJ3MgaW50ZW50OiBob3Jpem9udGFsIG1lYW5zIGhpZ2hsaWdodCwgdmVydGljYWwgbWVhbnMgZHJhZy5cblx0XHRjb25zdCBEUkFHX1RIUkVTSCA9IDU7XG5cblx0XHRjb25zdCBvbk1vdXNlRG93biA9IGUgPT4ge1xuXG5cdFx0XHRpbml0Q2xpZW50WCA9IGUuY2xpZW50WDtcblx0XHRcdGluaXRDbGllbnRZID0gcHJldkNsaWVudFkgPSBlLmNsaWVudFk7XG5cdFx0XHR0ZXN0aW5nRm9yVmVydGljYWxEcmFnID0gdHJ1ZTtcblxuXHRcdFx0aW5pdFZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdFx0ZHJhZ0RlbHRhID0gMDtcblxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSApO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwICk7XG5cblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25Nb3VzZU1vdmUgPSBlID0+IHtcblxuXHRcdFx0aWYgKCB0ZXN0aW5nRm9yVmVydGljYWxEcmFnICkge1xuXG5cdFx0XHRcdGNvbnN0IGR4ID0gZS5jbGllbnRYIC0gaW5pdENsaWVudFg7XG5cdFx0XHRcdGNvbnN0IGR5ID0gZS5jbGllbnRZIC0gaW5pdENsaWVudFk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggZHkgKSA+IERSQUdfVEhSRVNIICkge1xuXG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHRoaXMuJGlucHV0LmJsdXIoKTtcblx0XHRcdFx0XHR0ZXN0aW5nRm9yVmVydGljYWxEcmFnID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5fc2V0RHJhZ2dpbmdTdHlsZSggdHJ1ZSwgJ3ZlcnRpY2FsJyApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIE1hdGguYWJzKCBkeCApID4gRFJBR19USFJFU0ggKSB7XG5cblx0XHRcdFx0XHRvbk1vdXNlVXAoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhpcyBpc24ndCBhbiBlbHNlIHNvIHRoYXQgdGhlIGZpcnN0IG1vdmUgY291bnRzIHRvd2FyZHMgZHJhZ0RlbHRhXG5cdFx0XHRpZiAoICF0ZXN0aW5nRm9yVmVydGljYWxEcmFnICkge1xuXG5cdFx0XHRcdGNvbnN0IGR5ID0gZS5jbGllbnRZIC0gcHJldkNsaWVudFk7XG5cblx0XHRcdFx0ZHJhZ0RlbHRhIC09IGR5ICogdGhpcy5fc3RlcCAqIHRoaXMuX2Fycm93S2V5TXVsdGlwbGllciggZSApO1xuXG5cdFx0XHRcdC8vIENsYW1wIGRyYWdEZWx0YSBzbyB3ZSBkb24ndCBoYXZlICdkZWFkIHNwYWNlJyBhZnRlciBkcmFnZ2luZyBwYXN0IGJvdW5kcy5cblx0XHRcdFx0Ly8gV2UncmUgb2theSB3aXRoIHRoZSBmYWN0IHRoYXQgYm91bmRzIGNhbiBiZSB1bmRlZmluZWQgaGVyZS5cblx0XHRcdFx0aWYgKCBpbml0VmFsdWUgKyBkcmFnRGVsdGEgPiB0aGlzLl9tYXggKSB7XG5cdFx0XHRcdFx0ZHJhZ0RlbHRhID0gdGhpcy5fbWF4IC0gaW5pdFZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBpbml0VmFsdWUgKyBkcmFnRGVsdGEgPCB0aGlzLl9taW4gKSB7XG5cdFx0XHRcdFx0ZHJhZ0RlbHRhID0gdGhpcy5fbWluIC0gaW5pdFZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fc25hcENsYW1wU2V0VmFsdWUoIGluaXRWYWx1ZSArIGRyYWdEZWx0YSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHByZXZDbGllbnRZID0gZS5jbGllbnRZO1xuXG5cdFx0fTtcblxuXHRcdGNvbnN0IG9uTW91c2VVcCA9ICgpID0+IHtcblx0XHRcdHRoaXMuX3NldERyYWdnaW5nU3R5bGUoIGZhbHNlLCAndmVydGljYWwnICk7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUgKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCApO1xuXHRcdH07XG5cblx0XHQvLyBGb2N1cyBzdGF0ZSAmIG9uRmluaXNoQ2hhbmdlXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRjb25zdCBvbkZvY3VzID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5faW5wdXRGb2N1c2VkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0Y29uc3Qgb25CbHVyID0gKCkgPT4ge1xuXHRcdFx0dGhpcy5faW5wdXRGb2N1c2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdH07XG5cblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBvbklucHV0ICk7XG5cdFx0dGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24gKTtcblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbldoZWVsLCB7IHBhc3NpdmU6IGZhbHNlIH0gKTtcblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24gKTtcblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXMnLCBvbkZvY3VzICk7XG5cdFx0dGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBvbkJsdXIgKTtcblxuXHR9XG5cblx0X2luaXRTbGlkZXIoKSB7XG5cblx0XHR0aGlzLl9oYXNTbGlkZXIgPSB0cnVlO1xuXG5cdFx0Ly8gQnVpbGQgRE9NXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHR0aGlzLiRzbGlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuJHNsaWRlci5jbGFzc0xpc3QuYWRkKCAnc2xpZGVyJyApO1xuXG5cdFx0dGhpcy4kZmlsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0dGhpcy4kZmlsbC5jbGFzc0xpc3QuYWRkKCAnZmlsbCcgKTtcblxuXHRcdHRoaXMuJHNsaWRlci5hcHBlbmRDaGlsZCggdGhpcy4kZmlsbCApO1xuXHRcdHRoaXMuJHdpZGdldC5pbnNlcnRCZWZvcmUoIHRoaXMuJHNsaWRlciwgdGhpcy4kaW5wdXQgKTtcblxuXHRcdHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QuYWRkKCAnaGFzU2xpZGVyJyApO1xuXG5cdFx0Ly8gTWFwIGNsaWVudFggdG8gdmFsdWVcblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdGNvbnN0IG1hcCA9ICggdiwgYSwgYiwgYywgZCApID0+IHtcblx0XHRcdHJldHVybiAoIHYgLSBhICkgLyAoIGIgLSBhICkgKiAoIGQgLSBjICkgKyBjO1xuXHRcdH07XG5cblx0XHRjb25zdCBzZXRWYWx1ZUZyb21YID0gY2xpZW50WCA9PiB7XG5cdFx0XHRjb25zdCByZWN0ID0gdGhpcy4kc2xpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0bGV0IHZhbHVlID0gbWFwKCBjbGllbnRYLCByZWN0LmxlZnQsIHJlY3QucmlnaHQsIHRoaXMuX21pbiwgdGhpcy5fbWF4ICk7XG5cdFx0XHR0aGlzLl9zbmFwQ2xhbXBTZXRWYWx1ZSggdmFsdWUgKTtcblx0XHR9O1xuXG5cdFx0Ly8gTW91c2UgZHJhZ1xuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0Y29uc3QgbW91c2VEb3duID0gZSA9PiB7XG5cdFx0XHR0aGlzLl9zZXREcmFnZ2luZ1N0eWxlKCB0cnVlICk7XG5cdFx0XHRzZXRWYWx1ZUZyb21YKCBlLmNsaWVudFggKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgbW91c2VNb3ZlICk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBtb3VzZVVwICk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IG1vdXNlTW92ZSA9IGUgPT4ge1xuXHRcdFx0c2V0VmFsdWVGcm9tWCggZS5jbGllbnRYICk7XG5cdFx0fTtcblxuXHRcdGNvbnN0IG1vdXNlVXAgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHRcdHRoaXMuX3NldERyYWdnaW5nU3R5bGUoIGZhbHNlICk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG1vdXNlTW92ZSApO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgbW91c2VVcCApO1xuXHRcdH07XG5cblx0XHQvLyBUb3VjaCBkcmFnXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRsZXQgdGVzdGluZ0ZvclNjcm9sbCA9IGZhbHNlLCBwcmV2Q2xpZW50WCwgcHJldkNsaWVudFk7XG5cblx0XHRjb25zdCBiZWdpblRvdWNoRHJhZyA9IGUgPT4ge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5fc2V0RHJhZ2dpbmdTdHlsZSggdHJ1ZSApO1xuXHRcdFx0c2V0VmFsdWVGcm9tWCggZS50b3VjaGVzWyAwIF0uY2xpZW50WCApO1xuXHRcdFx0dGVzdGluZ0ZvclNjcm9sbCA9IGZhbHNlO1xuXHRcdH07XG5cblx0XHRjb25zdCBvblRvdWNoU3RhcnQgPSBlID0+IHtcblxuXHRcdFx0aWYgKCBlLnRvdWNoZXMubGVuZ3RoID4gMSApIHJldHVybjtcblxuXHRcdFx0Ly8gSWYgd2UncmUgaW4gYSBzY3JvbGxhYmxlIGNvbnRhaW5lciwgd2Ugc2hvdWxkIHdhaXQgZm9yIHRoZSBmaXJzdFxuXHRcdFx0Ly8gdG91Y2htb3ZlIHRvIHNlZSBpZiB0aGUgdXNlciBpcyB0cnlpbmcgdG8gc2xpZGUgb3Igc2Nyb2xsLlxuXHRcdFx0aWYgKCB0aGlzLl9oYXNTY3JvbGxCYXIgKSB7XG5cblx0XHRcdFx0cHJldkNsaWVudFggPSBlLnRvdWNoZXNbIDAgXS5jbGllbnRYO1xuXHRcdFx0XHRwcmV2Q2xpZW50WSA9IGUudG91Y2hlc1sgMCBdLmNsaWVudFk7XG5cdFx0XHRcdHRlc3RpbmdGb3JTY3JvbGwgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgd2UgY2FuIHNldCB0aGUgdmFsdWUgc3RyYWlnaHQgYXdheSBvbiB0b3VjaHN0YXJ0LlxuXHRcdFx0XHRiZWdpblRvdWNoRHJhZyggZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSApO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQgKTtcblxuXHRcdH07XG5cblx0XHRjb25zdCBvblRvdWNoTW92ZSA9IGUgPT4ge1xuXG5cdFx0XHRpZiAoIHRlc3RpbmdGb3JTY3JvbGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgZHggPSBlLnRvdWNoZXNbIDAgXS5jbGllbnRYIC0gcHJldkNsaWVudFg7XG5cdFx0XHRcdGNvbnN0IGR5ID0gZS50b3VjaGVzWyAwIF0uY2xpZW50WSAtIHByZXZDbGllbnRZO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIGR4ICkgPiBNYXRoLmFicyggZHkgKSApIHtcblxuXHRcdFx0XHRcdC8vIFdlIG1vdmVkIGhvcml6b250YWxseSwgc2V0IHRoZSB2YWx1ZSBhbmQgc3RvcCBjaGVja2luZy5cblx0XHRcdFx0XHRiZWdpblRvdWNoRHJhZyggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBUaGlzIHdhcywgaW4gZmFjdCwgYW4gYXR0ZW1wdCB0byBzY3JvbGwuIEFib3J0LlxuXHRcdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUgKTtcblx0XHRcdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHNldFZhbHVlRnJvbVgoIGUudG91Y2hlc1sgMCBdLmNsaWVudFggKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGNvbnN0IG9uVG91Y2hFbmQgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl9jYWxsT25GaW5pc2hDaGFuZ2UoKTtcblx0XHRcdHRoaXMuX3NldERyYWdnaW5nU3R5bGUoIGZhbHNlICk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlICk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCApO1xuXHRcdH07XG5cblx0XHQvLyBNb3VzZSB3aGVlbFxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0Ly8gV2UgaGF2ZSB0byB1c2UgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdG8gY2FsbCBvbkZpbmlzaENoYW5nZSBiZWNhdXNlXG5cdFx0Ly8gdGhlcmUncyBubyB3YXkgdG8gdGVsbCB3aGVuIHRoZSB1c2VyIGlzIFwiZG9uZVwiIG1vdXNlLXdoZWVsaW5nLlxuXHRcdGNvbnN0IGNhbGxPbkZpbmlzaENoYW5nZSA9IHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZS5iaW5kKCB0aGlzICk7XG5cdFx0Y29uc3QgV0hFRUxfREVCT1VOQ0VfVElNRSA9IDQwMDtcblx0XHRsZXQgd2hlZWxGaW5pc2hDaGFuZ2VUaW1lb3V0O1xuXG5cdFx0Y29uc3Qgb25XaGVlbCA9IGUgPT4ge1xuXG5cdFx0XHQvLyBpZ25vcmUgdmVydGljYWwgd2hlZWxzIGlmIHRoZXJlJ3MgYSBzY3JvbGxiYXJcblx0XHRcdGNvbnN0IGlzVmVydGljYWwgPSBNYXRoLmFicyggZS5kZWx0YVggKSA8IE1hdGguYWJzKCBlLmRlbHRhWSApO1xuXHRcdFx0aWYgKCBpc1ZlcnRpY2FsICYmIHRoaXMuX2hhc1Njcm9sbEJhciApIHJldHVybjtcblxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHQvLyBzZXQgdmFsdWVcblx0XHRcdGNvbnN0IGRlbHRhID0gdGhpcy5fbm9ybWFsaXplTW91c2VXaGVlbCggZSApICogdGhpcy5fc3RlcDtcblx0XHRcdHRoaXMuX3NuYXBDbGFtcFNldFZhbHVlKCB0aGlzLmdldFZhbHVlKCkgKyBkZWx0YSApO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgaW5wdXQgdG8gdXBkYXRlRGlzcGxheSB3aGVuIGl0J3MgZm9jdXNlZFxuXHRcdFx0dGhpcy4kaW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cblx0XHRcdC8vIGRlYm91bmNlIG9uRmluaXNoQ2hhbmdlXG5cdFx0XHRjbGVhclRpbWVvdXQoIHdoZWVsRmluaXNoQ2hhbmdlVGltZW91dCApO1xuXHRcdFx0d2hlZWxGaW5pc2hDaGFuZ2VUaW1lb3V0ID0gc2V0VGltZW91dCggY2FsbE9uRmluaXNoQ2hhbmdlLCBXSEVFTF9ERUJPVU5DRV9USU1FICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy4kc2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBtb3VzZURvd24gKTtcblx0XHR0aGlzLiRzbGlkZXIuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIHsgcGFzc2l2ZTogZmFsc2UgfSApO1xuXHRcdHRoaXMuJHNsaWRlci5hZGRFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbldoZWVsLCB7IHBhc3NpdmU6IGZhbHNlIH0gKTtcblxuXHR9XG5cblx0X3NldERyYWdnaW5nU3R5bGUoIGFjdGl2ZSwgYXhpcyA9ICdob3Jpem9udGFsJyApIHtcblx0XHRpZiAoIHRoaXMuJHNsaWRlciApIHtcblx0XHRcdHRoaXMuJHNsaWRlci5jbGFzc0xpc3QudG9nZ2xlKCAnYWN0aXZlJywgYWN0aXZlICk7XG5cdFx0fVxuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnRvZ2dsZSggJ2xpbC1ndWktZHJhZ2dpbmcnLCBhY3RpdmUgKTtcblx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC50b2dnbGUoIGBsaWwtZ3VpLSR7YXhpc31gLCBhY3RpdmUgKTtcblx0fVxuXG5cdF9nZXRJbXBsaWNpdFN0ZXAoKSB7XG5cblx0XHRpZiAoIHRoaXMuX2hhc01pbiAmJiB0aGlzLl9oYXNNYXggKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzLl9tYXggLSB0aGlzLl9taW4gKSAvIDEwMDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDAuMTtcblxuXHR9XG5cblx0X29uVXBkYXRlTWluTWF4KCkge1xuXG5cdFx0aWYgKCAhdGhpcy5faGFzU2xpZGVyICYmIHRoaXMuX2hhc01pbiAmJiB0aGlzLl9oYXNNYXggKSB7XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UncmUgaGVhcmluZyBhYm91dCBtaW4gYW5kIG1heFxuXHRcdFx0Ly8gYW5kIHdlIGhhdmVuJ3QgZXhwbGljaXRseSBzdGF0ZWQgd2hhdCBvdXIgc3RlcCBpcywgbGV0J3Ncblx0XHRcdC8vIHVwZGF0ZSB0aGF0IHRvby5cblx0XHRcdGlmICggIXRoaXMuX3N0ZXBFeHBsaWNpdCApIHtcblx0XHRcdFx0dGhpcy5zdGVwKCB0aGlzLl9nZXRJbXBsaWNpdFN0ZXAoKSwgZmFsc2UgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5faW5pdFNsaWRlcigpO1xuXHRcdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9ub3JtYWxpemVNb3VzZVdoZWVsKCBlICkge1xuXG5cdFx0bGV0IHsgZGVsdGFYLCBkZWx0YVkgfSA9IGU7XG5cblx0XHQvLyBTYWZhcmkgYW5kIENocm9tZSByZXBvcnQgd2VpcmQgbm9uLWludGVncmFsIHZhbHVlcyBmb3IgYSBub3RjaGVkIHdoZWVsLFxuXHRcdC8vIGJ1dCBzdGlsbCBleHBvc2UgYWN0dWFsIGxpbmVzIHNjcm9sbGVkIHZpYSB3aGVlbERlbHRhLiBOb3RjaGVkIHdoZWVsc1xuXHRcdC8vIHNob3VsZCBiZWhhdmUgdGhlIHNhbWUgd2F5IGFzIGFycm93IGtleXMuXG5cdFx0aWYgKCBNYXRoLmZsb29yKCBlLmRlbHRhWSApICE9PSBlLmRlbHRhWSAmJiBlLndoZWVsRGVsdGEgKSB7XG5cdFx0XHRkZWx0YVggPSAwO1xuXHRcdFx0ZGVsdGFZID0gLWUud2hlZWxEZWx0YSAvIDEyMDtcblx0XHRcdGRlbHRhWSAqPSB0aGlzLl9zdGVwRXhwbGljaXQgPyAxIDogMTA7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgd2hlZWwgPSBkZWx0YVggKyAtZGVsdGFZO1xuXG5cdFx0cmV0dXJuIHdoZWVsO1xuXG5cdH1cblxuXHRfYXJyb3dLZXlNdWx0aXBsaWVyKCBlICkge1xuXG5cdFx0bGV0IG11bHQgPSB0aGlzLl9zdGVwRXhwbGljaXQgPyAxIDogMTA7XG5cblx0XHRpZiAoIGUuc2hpZnRLZXkgKSB7XG5cdFx0XHRtdWx0ICo9IDEwO1xuXHRcdH0gZWxzZSBpZiAoIGUuYWx0S2V5ICkge1xuXHRcdFx0bXVsdCAvPSAxMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbXVsdDtcblxuXHR9XG5cblx0X3NuYXAoIHZhbHVlICkge1xuXG5cdFx0Ly8gVGhpcyB3b3VsZCBiZSB0aGUgbG9naWNhbCB3YXkgdG8gZG8gdGhpbmdzLCBidXQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLlxuXHRcdC8vIHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAvIHRoaXMuX3N0ZXAgKSAqIHRoaXMuX3N0ZXA7XG5cblx0XHQvLyBVc2luZyBpbnZlcnNlIHN0ZXAgc29sdmVzIGEgbG90IG9mIHRoZW0sIGJ1dCBub3QgYWxsXG5cdFx0Ly8gY29uc3QgaW52ZXJzZVN0ZXAgPSAxIC8gdGhpcy5fc3RlcDtcblx0XHQvLyByZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiBpbnZlcnNlU3RlcCApIC8gaW52ZXJzZVN0ZXA7XG5cblx0XHQvLyBOb3QgaGFwcHkgYWJvdXQgdGhpcywgYnV0IGhhdmVuJ3Qgc2VlbiBpdCBicmVhay5cblx0XHRjb25zdCByID0gTWF0aC5yb3VuZCggdmFsdWUgLyB0aGlzLl9zdGVwICkgKiB0aGlzLl9zdGVwO1xuXHRcdHJldHVybiBwYXJzZUZsb2F0KCByLnRvUHJlY2lzaW9uKCAxNSApICk7XG5cblx0fVxuXG5cdF9jbGFtcCggdmFsdWUgKSB7XG5cdFx0Ly8gZWl0aGVyIGNvbmRpdGlvbiBpcyBmYWxzZSBpZiBtaW4gb3IgbWF4IGlzIHVuZGVmaW5lZFxuXHRcdGlmICggdmFsdWUgPCB0aGlzLl9taW4gKSB2YWx1ZSA9IHRoaXMuX21pbjtcblx0XHRpZiAoIHZhbHVlID4gdGhpcy5fbWF4ICkgdmFsdWUgPSB0aGlzLl9tYXg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0X3NuYXBDbGFtcFNldFZhbHVlKCB2YWx1ZSApIHtcblx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLl9jbGFtcCggdGhpcy5fc25hcCggdmFsdWUgKSApICk7XG5cdH1cblxuXHRnZXQgX2hhc1Njcm9sbEJhcigpIHtcblx0XHRjb25zdCByb290ID0gdGhpcy5wYXJlbnQucm9vdC4kY2hpbGRyZW47XG5cdFx0cmV0dXJuIHJvb3Quc2Nyb2xsSGVpZ2h0ID4gcm9vdC5jbGllbnRIZWlnaHQ7XG5cdH1cblxuXHRnZXQgX2hhc01pbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHRnZXQgX2hhc01heCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF4ICE9PSB1bmRlZmluZWQ7XG5cdH1cblxufVxuXG5jbGFzcyBPcHRpb25Db250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSwgb3B0aW9ucyApIHtcblxuXHRcdHN1cGVyKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHksICdvcHRpb24nICk7XG5cblx0XHR0aGlzLiRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc2VsZWN0JyApO1xuXHRcdHRoaXMuJHNlbGVjdC5zZXRBdHRyaWJ1dGUoICdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLiRuYW1lLmlkICk7XG5cblx0XHR0aGlzLiRkaXNwbGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHR0aGlzLiRkaXNwbGF5LmNsYXNzTGlzdC5hZGQoICdkaXNwbGF5JyApO1xuXG5cdFx0dGhpcy4kc2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLl92YWx1ZXNbIHRoaXMuJHNlbGVjdC5zZWxlY3RlZEluZGV4IF0gKTtcblx0XHRcdHRoaXMuX2NhbGxPbkZpbmlzaENoYW5nZSgpO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuJHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXMnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLiRkaXNwbGF5LmNsYXNzTGlzdC5hZGQoICdmb2N1cycgKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiRzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCAoKSA9PiB7XG5cdFx0XHR0aGlzLiRkaXNwbGF5LmNsYXNzTGlzdC5yZW1vdmUoICdmb2N1cycgKTtcblx0XHR9ICk7XG5cblx0XHR0aGlzLiR3aWRnZXQuYXBwZW5kQ2hpbGQoIHRoaXMuJHNlbGVjdCApO1xuXHRcdHRoaXMuJHdpZGdldC5hcHBlbmRDaGlsZCggdGhpcy4kZGlzcGxheSApO1xuXG5cdFx0dGhpcy4kZGlzYWJsZSA9IHRoaXMuJHNlbGVjdDtcblxuXHRcdHRoaXMub3B0aW9ucyggb3B0aW9ucyApO1xuXG5cdH1cblxuXHRvcHRpb25zKCBvcHRpb25zICkge1xuXG5cdFx0dGhpcy5fdmFsdWVzID0gQXJyYXkuaXNBcnJheSggb3B0aW9ucyApID8gb3B0aW9ucyA6IE9iamVjdC52YWx1ZXMoIG9wdGlvbnMgKTtcblx0XHR0aGlzLl9uYW1lcyA9IEFycmF5LmlzQXJyYXkoIG9wdGlvbnMgKSA/IG9wdGlvbnMgOiBPYmplY3Qua2V5cyggb3B0aW9ucyApO1xuXG5cdFx0dGhpcy4kc2VsZWN0LnJlcGxhY2VDaGlsZHJlbigpO1xuXG5cdFx0dGhpcy5fbmFtZXMuZm9yRWFjaCggbmFtZSA9PiB7XG5cdFx0XHRjb25zdCAkb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ29wdGlvbicgKTtcblx0XHRcdCRvcHRpb24udGV4dENvbnRlbnQgPSBuYW1lO1xuXHRcdFx0dGhpcy4kc2VsZWN0LmFwcGVuZENoaWxkKCAkb3B0aW9uICk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dXBkYXRlRGlzcGxheSgpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRjb25zdCBpbmRleCA9IHRoaXMuX3ZhbHVlcy5pbmRleE9mKCB2YWx1ZSApO1xuXHRcdHRoaXMuJHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG5cdFx0dGhpcy4kZGlzcGxheS50ZXh0Q29udGVudCA9IGluZGV4ID09PSAtMSA/IHZhbHVlIDogdGhpcy5fbmFtZXNbIGluZGV4IF07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufVxuXG5jbGFzcyBTdHJpbmdDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmVudCwgb2JqZWN0LCBwcm9wZXJ0eSApIHtcblxuXHRcdHN1cGVyKCBwYXJlbnQsIG9iamVjdCwgcHJvcGVydHksICdzdHJpbmcnICk7XG5cblx0XHR0aGlzLiRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdpbnB1dCcgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICd0eXBlJywgJ3RleHQnICk7XG5cdFx0dGhpcy4kaW5wdXQuc2V0QXR0cmlidXRlKCAnc3BlbGxjaGVjaycsICdmYWxzZScgKTtcblx0XHR0aGlzLiRpbnB1dC5zZXRBdHRyaWJ1dGUoICdhcmlhLWxhYmVsbGVkYnknLCB0aGlzLiRuYW1lLmlkICk7XG5cblx0XHR0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCAoKSA9PiB7XG5cdFx0XHR0aGlzLnNldFZhbHVlKCB0aGlzLiRpbnB1dC52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgZSA9PiB7XG5cdFx0XHRpZiAoIGUuY29kZSA9PT0gJ0VudGVyJyApIHtcblx0XHRcdFx0dGhpcy4kaW5wdXQuYmx1cigpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHRoaXMuJGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgKCkgPT4ge1xuXHRcdFx0dGhpcy5fY2FsbE9uRmluaXNoQ2hhbmdlKCk7XG5cdFx0fSApO1xuXG5cdFx0dGhpcy4kd2lkZ2V0LmFwcGVuZENoaWxkKCB0aGlzLiRpbnB1dCApO1xuXG5cdFx0dGhpcy4kZGlzYWJsZSA9IHRoaXMuJGlucHV0O1xuXG5cdFx0dGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cblx0fVxuXG5cdHVwZGF0ZURpc3BsYXkoKSB7XG5cdFx0dGhpcy4kaW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufVxuXG5jb25zdCBzdHlsZXNoZWV0ID0gYC5saWwtZ3VpIHtcbiAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtZmFtaWx5KTtcbiAgZm9udC1zaXplOiB2YXIoLS1mb250LXNpemUpO1xuICBsaW5lLWhlaWdodDogMTtcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xuICB0ZXh0LWFsaWduOiBsZWZ0O1xuICBjb2xvcjogdmFyKC0tdGV4dC1jb2xvcik7XG4gIHVzZXItc2VsZWN0OiBub25lO1xuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgLS1iYWNrZ3JvdW5kLWNvbG9yOiAjMWYxZjFmO1xuICAtLXRleHQtY29sb3I6ICNlYmViZWI7XG4gIC0tdGl0bGUtYmFja2dyb3VuZC1jb2xvcjogIzExMTExMTtcbiAgLS10aXRsZS10ZXh0LWNvbG9yOiAjZWJlYmViO1xuICAtLXdpZGdldC1jb2xvcjogIzQyNDI0MjtcbiAgLS1ob3Zlci1jb2xvcjogIzRmNGY0ZjtcbiAgLS1mb2N1cy1jb2xvcjogIzU5NTk1OTtcbiAgLS1udW1iZXItY29sb3I6ICMyY2M5ZmY7XG4gIC0tc3RyaW5nLWNvbG9yOiAjYTJkYjNjO1xuICAtLWZvbnQtc2l6ZTogMTFweDtcbiAgLS1pbnB1dC1mb250LXNpemU6IDExcHg7XG4gIC0tZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sIEFyaWFsLCBzYW5zLXNlcmlmO1xuICAtLWZvbnQtZmFtaWx5LW1vbm86IE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcIkRyb2lkIFNhbnMgTW9ub1wiLCBtb25vc3BhY2U7XG4gIC0tcGFkZGluZzogNHB4O1xuICAtLXNwYWNpbmc6IDRweDtcbiAgLS13aWRnZXQtaGVpZ2h0OiAyMHB4O1xuICAtLXRpdGxlLWhlaWdodDogY2FsYyh2YXIoLS13aWRnZXQtaGVpZ2h0KSArIHZhcigtLXNwYWNpbmcpICogMS4yNSk7XG4gIC0tbmFtZS13aWR0aDogNDUlO1xuICAtLXNsaWRlci1rbm9iLXdpZHRoOiAycHg7XG4gIC0tc2xpZGVyLWlucHV0LXdpZHRoOiAyNyU7XG4gIC0tY29sb3ItaW5wdXQtd2lkdGg6IDI3JTtcbiAgLS1zbGlkZXItaW5wdXQtbWluLXdpZHRoOiA0NXB4O1xuICAtLWNvbG9yLWlucHV0LW1pbi13aWR0aDogNDVweDtcbiAgLS1mb2xkZXItaW5kZW50OiA3cHg7XG4gIC0td2lkZ2V0LXBhZGRpbmc6IDAgMCAwIDNweDtcbiAgLS13aWRnZXQtYm9yZGVyLXJhZGl1czogMnB4O1xuICAtLWNoZWNrYm94LXNpemU6IGNhbGMoMC43NSAqIHZhcigtLXdpZGdldC1oZWlnaHQpKTtcbiAgLS1zY3JvbGxiYXItd2lkdGg6IDVweDtcbn1cbi5saWwtZ3VpLCAubGlsLWd1aSAqIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xufVxuLmxpbC1ndWkucm9vdCB7XG4gIHdpZHRoOiB2YXIoLS13aWR0aCwgMjQ1cHgpO1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrZ3JvdW5kLWNvbG9yKTtcbn1cbi5saWwtZ3VpLnJvb3QgPiAudGl0bGUge1xuICBiYWNrZ3JvdW5kOiB2YXIoLS10aXRsZS1iYWNrZ3JvdW5kLWNvbG9yKTtcbiAgY29sb3I6IHZhcigtLXRpdGxlLXRleHQtY29sb3IpO1xufVxuLmxpbC1ndWkucm9vdCA+IC5jaGlsZHJlbiB7XG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgb3ZlcmZsb3cteTogYXV0bztcbn1cbi5saWwtZ3VpLnJvb3QgPiAuY2hpbGRyZW46Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgd2lkdGg6IHZhcigtLXNjcm9sbGJhci13aWR0aCk7XG4gIGhlaWdodDogdmFyKC0tc2Nyb2xsYmFyLXdpZHRoKTtcbiAgYmFja2dyb3VuZDogdmFyKC0tYmFja2dyb3VuZC1jb2xvcik7XG59XG4ubGlsLWd1aS5yb290ID4gLmNoaWxkcmVuOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXNjcm9sbGJhci13aWR0aCk7XG4gIGJhY2tncm91bmQ6IHZhcigtLWZvY3VzLWNvbG9yKTtcbn1cbkBtZWRpYSAocG9pbnRlcjogY29hcnNlKSB7XG4gIC5saWwtZ3VpLmFsbG93LXRvdWNoLXN0eWxlcywgLmxpbC1ndWkuYWxsb3ctdG91Y2gtc3R5bGVzIC5saWwtZ3VpIHtcbiAgICAtLXdpZGdldC1oZWlnaHQ6IDI4cHg7XG4gICAgLS1wYWRkaW5nOiA2cHg7XG4gICAgLS1zcGFjaW5nOiA2cHg7XG4gICAgLS1mb250LXNpemU6IDEzcHg7XG4gICAgLS1pbnB1dC1mb250LXNpemU6IDE2cHg7XG4gICAgLS1mb2xkZXItaW5kZW50OiAxMHB4O1xuICAgIC0tc2Nyb2xsYmFyLXdpZHRoOiA3cHg7XG4gICAgLS1zbGlkZXItaW5wdXQtbWluLXdpZHRoOiA1MHB4O1xuICAgIC0tY29sb3ItaW5wdXQtbWluLXdpZHRoOiA2NXB4O1xuICB9XG59XG4ubGlsLWd1aS5mb3JjZS10b3VjaC1zdHlsZXMsIC5saWwtZ3VpLmZvcmNlLXRvdWNoLXN0eWxlcyAubGlsLWd1aSB7XG4gIC0td2lkZ2V0LWhlaWdodDogMjhweDtcbiAgLS1wYWRkaW5nOiA2cHg7XG4gIC0tc3BhY2luZzogNnB4O1xuICAtLWZvbnQtc2l6ZTogMTNweDtcbiAgLS1pbnB1dC1mb250LXNpemU6IDE2cHg7XG4gIC0tZm9sZGVyLWluZGVudDogMTBweDtcbiAgLS1zY3JvbGxiYXItd2lkdGg6IDdweDtcbiAgLS1zbGlkZXItaW5wdXQtbWluLXdpZHRoOiA1MHB4O1xuICAtLWNvbG9yLWlucHV0LW1pbi13aWR0aDogNjVweDtcbn1cbi5saWwtZ3VpLmF1dG9QbGFjZSB7XG4gIG1heC1oZWlnaHQ6IDEwMCU7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgdG9wOiAwO1xuICByaWdodDogMTVweDtcbiAgei1pbmRleDogMTAwMTtcbn1cblxuLmxpbC1ndWkgLmNvbnRyb2xsZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBwYWRkaW5nOiAwIHZhcigtLXBhZGRpbmcpO1xuICBtYXJnaW46IHZhcigtLXNwYWNpbmcpIDA7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5kaXNhYmxlZCB7XG4gIG9wYWNpdHk6IDAuNTtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLmRpc2FibGVkLCAubGlsLWd1aSAuY29udHJvbGxlci5kaXNhYmxlZCAqIHtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmUgIWltcG9ydGFudDtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyID4gLm5hbWUge1xuICBtaW4td2lkdGg6IHZhcigtLW5hbWUtd2lkdGgpO1xuICBmbGV4LXNocmluazogMDtcbiAgd2hpdGUtc3BhY2U6IHByZTtcbiAgcGFkZGluZy1yaWdodDogdmFyKC0tc3BhY2luZyk7XG4gIGxpbmUtaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyIC53aWRnZXQge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIHdpZHRoOiAxMDAlO1xuICBtaW4taGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLnN0cmluZyBpbnB1dCB7XG4gIGNvbG9yOiB2YXIoLS1zdHJpbmctY29sb3IpO1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIuYm9vbGVhbiB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLmNvbG9yIC5kaXNwbGF5IHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogdmFyKC0td2lkZ2V0LWhlaWdodCk7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXdpZGdldC1ib3JkZXItcmFkaXVzKTtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgLmxpbC1ndWkgLmNvbnRyb2xsZXIuY29sb3IgLmRpc3BsYXk6aG92ZXI6YmVmb3JlIHtcbiAgICBjb250ZW50OiBcIiBcIjtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0td2lkZ2V0LWJvcmRlci1yYWRpdXMpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICNmZmY5O1xuICAgIHRvcDogMDtcbiAgICByaWdodDogMDtcbiAgICBib3R0b206IDA7XG4gICAgbGVmdDogMDtcbiAgfVxufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIuY29sb3IgaW5wdXRbdHlwZT1jb2xvcl0ge1xuICBvcGFjaXR5OiAwO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5jb2xvciBpbnB1dFt0eXBlPXRleHRdIHtcbiAgbWFyZ2luLWxlZnQ6IHZhcigtLXNwYWNpbmcpO1xuICBmb250LWZhbWlseTogdmFyKC0tZm9udC1mYW1pbHktbW9ubyk7XG4gIG1pbi13aWR0aDogdmFyKC0tY29sb3ItaW5wdXQtbWluLXdpZHRoKTtcbiAgd2lkdGg6IHZhcigtLWNvbG9yLWlucHV0LXdpZHRoKTtcbiAgZmxleC1zaHJpbms6IDA7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5vcHRpb24gc2VsZWN0IHtcbiAgb3BhY2l0eTogMDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aWR0aDogMTAwJTtcbiAgbWF4LXdpZHRoOiAxMDAlO1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIub3B0aW9uIC5kaXNwbGF5IHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgYm9yZGVyLXJhZGl1czogdmFyKC0td2lkZ2V0LWJvcmRlci1yYWRpdXMpO1xuICBoZWlnaHQ6IHZhcigtLXdpZGdldC1oZWlnaHQpO1xuICBsaW5lLWhlaWdodDogdmFyKC0td2lkZ2V0LWhlaWdodCk7XG4gIG1heC13aWR0aDogMTAwJTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgd29yZC1icmVhazogYnJlYWstYWxsO1xuICBwYWRkaW5nLWxlZnQ6IDAuNTVlbTtcbiAgcGFkZGluZy1yaWdodDogMS43NWVtO1xuICBiYWNrZ3JvdW5kOiB2YXIoLS13aWRnZXQtY29sb3IpO1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgLmxpbC1ndWkgLmNvbnRyb2xsZXIub3B0aW9uIC5kaXNwbGF5LmZvY3VzIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mb2N1cy1jb2xvcik7XG4gIH1cbn1cbi5saWwtZ3VpIC5jb250cm9sbGVyLm9wdGlvbiAuZGlzcGxheS5hY3RpdmUge1xuICBiYWNrZ3JvdW5kOiB2YXIoLS1mb2N1cy1jb2xvcik7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5vcHRpb24gLmRpc3BsYXk6YWZ0ZXIge1xuICBmb250LWZhbWlseTogXCJsaWwtZ3VpXCI7XG4gIGNvbnRlbnQ6IFwi4oaVXCI7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xuICBwYWRkaW5nLXJpZ2h0OiAwLjM3NWVtO1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIub3B0aW9uIC53aWRnZXQsXG4ubGlsLWd1aSAuY29udHJvbGxlci5vcHRpb24gc2VsZWN0IHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgLmxpbC1ndWkgLmNvbnRyb2xsZXIub3B0aW9uIC53aWRnZXQ6aG92ZXIgLmRpc3BsYXkge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWhvdmVyLWNvbG9yKTtcbiAgfVxufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIubnVtYmVyIGlucHV0IHtcbiAgY29sb3I6IHZhcigtLW51bWJlci1jb2xvcik7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIuaGFzU2xpZGVyIGlucHV0IHtcbiAgbWFyZ2luLWxlZnQ6IHZhcigtLXNwYWNpbmcpO1xuICB3aWR0aDogdmFyKC0tc2xpZGVyLWlucHV0LXdpZHRoKTtcbiAgbWluLXdpZHRoOiB2YXIoLS1zbGlkZXItaW5wdXQtbWluLXdpZHRoKTtcbiAgZmxleC1zaHJpbms6IDA7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIgLnNsaWRlciB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IHZhcigtLXdpZGdldC1oZWlnaHQpO1xuICBiYWNrZ3JvdW5kOiB2YXIoLS13aWRnZXQtY29sb3IpO1xuICBib3JkZXItcmFkaXVzOiB2YXIoLS13aWRnZXQtYm9yZGVyLXJhZGl1cyk7XG4gIHBhZGRpbmctcmlnaHQ6IHZhcigtLXNsaWRlci1rbm9iLXdpZHRoKTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgY3Vyc29yOiBldy1yZXNpemU7XG4gIHRvdWNoLWFjdGlvbjogcGFuLXk7XG59XG5AbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIgLnNsaWRlcjpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogdmFyKC0taG92ZXItY29sb3IpO1xuICB9XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIgLnNsaWRlci5hY3RpdmUge1xuICBiYWNrZ3JvdW5kOiB2YXIoLS1mb2N1cy1jb2xvcik7XG59XG4ubGlsLWd1aSAuY29udHJvbGxlci5udW1iZXIgLnNsaWRlci5hY3RpdmUgLmZpbGwge1xuICBvcGFjaXR5OiAwLjk1O1xufVxuLmxpbC1ndWkgLmNvbnRyb2xsZXIubnVtYmVyIC5maWxsIHtcbiAgaGVpZ2h0OiAxMDAlO1xuICBib3JkZXItcmlnaHQ6IHZhcigtLXNsaWRlci1rbm9iLXdpZHRoKSBzb2xpZCB2YXIoLS1udW1iZXItY29sb3IpO1xuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbn1cblxuLmxpbC1ndWktZHJhZ2dpbmcgLmxpbC1ndWkge1xuICAtLWhvdmVyLWNvbG9yOiB2YXIoLS13aWRnZXQtY29sb3IpO1xufVxuLmxpbC1ndWktZHJhZ2dpbmcgKiB7XG4gIGN1cnNvcjogZXctcmVzaXplICFpbXBvcnRhbnQ7XG59XG5cbi5saWwtZ3VpLWRyYWdnaW5nLmxpbC1ndWktdmVydGljYWwgKiB7XG4gIGN1cnNvcjogbnMtcmVzaXplICFpbXBvcnRhbnQ7XG59XG5cbi5saWwtZ3VpIC50aXRsZSB7XG4gIGhlaWdodDogdmFyKC0tdGl0bGUtaGVpZ2h0KTtcbiAgbGluZS1oZWlnaHQ6IGNhbGModmFyKC0tdGl0bGUtaGVpZ2h0KSAtIDRweCk7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIHBhZGRpbmc6IDAgdmFyKC0tcGFkZGluZyk7XG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgb3V0bGluZTogbm9uZTtcbiAgdGV4dC1kZWNvcmF0aW9uLXNraXA6IG9iamVjdHM7XG59XG4ubGlsLWd1aSAudGl0bGU6YmVmb3JlIHtcbiAgZm9udC1mYW1pbHk6IFwibGlsLWd1aVwiO1xuICBjb250ZW50OiBcIuKWvlwiO1xuICBwYWRkaW5nLXJpZ2h0OiAycHg7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbn1cbi5saWwtZ3VpIC50aXRsZTphY3RpdmUge1xuICBiYWNrZ3JvdW5kOiB2YXIoLS10aXRsZS1iYWNrZ3JvdW5kLWNvbG9yKTtcbiAgb3BhY2l0eTogMC43NTtcbn1cbkBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gIGJvZHk6bm90KC5saWwtZ3VpLWRyYWdnaW5nKSAubGlsLWd1aSAudGl0bGU6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLXRpdGxlLWJhY2tncm91bmQtY29sb3IpO1xuICAgIG9wYWNpdHk6IDAuODU7XG4gIH1cbiAgLmxpbC1ndWkgLnRpdGxlOmZvY3VzIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSB2YXIoLS1mb2N1cy1jb2xvcik7XG4gIH1cbn1cbi5saWwtZ3VpLnJvb3QgPiAudGl0bGU6Zm9jdXMge1xuICB0ZXh0LWRlY29yYXRpb246IG5vbmUgIWltcG9ydGFudDtcbn1cbi5saWwtZ3VpLmNsb3NlZCA+IC50aXRsZTpiZWZvcmUge1xuICBjb250ZW50OiBcIuKWuFwiO1xufVxuLmxpbC1ndWkuY2xvc2VkID4gLmNoaWxkcmVuIHtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC03cHgpO1xuICBvcGFjaXR5OiAwO1xufVxuLmxpbC1ndWkuY2xvc2VkOm5vdCgudHJhbnNpdGlvbikgPiAuY2hpbGRyZW4ge1xuICBkaXNwbGF5OiBub25lO1xufVxuLmxpbC1ndWkudHJhbnNpdGlvbiA+IC5jaGlsZHJlbiB7XG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDMwMG1zO1xuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBoZWlnaHQsIG9wYWNpdHksIHRyYW5zZm9ybTtcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjIsIDAuNiwgMC4zNSwgMSk7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuLmxpbC1ndWkgLmNoaWxkcmVuOmVtcHR5OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiRW1wdHlcIjtcbiAgcGFkZGluZzogMCB2YXIoLS1wYWRkaW5nKTtcbiAgbWFyZ2luOiB2YXIoLS1zcGFjaW5nKSAwO1xuICBkaXNwbGF5OiBibG9jaztcbiAgaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbiAgZm9udC1zdHlsZTogaXRhbGljO1xuICBsaW5lLWhlaWdodDogdmFyKC0td2lkZ2V0LWhlaWdodCk7XG4gIG9wYWNpdHk6IDAuNTtcbn1cbi5saWwtZ3VpLnJvb3QgPiAuY2hpbGRyZW4gPiAubGlsLWd1aSA+IC50aXRsZSB7XG4gIGJvcmRlcjogMCBzb2xpZCB2YXIoLS13aWRnZXQtY29sb3IpO1xuICBib3JkZXItd2lkdGg6IDFweCAwO1xuICB0cmFuc2l0aW9uOiBib3JkZXItY29sb3IgMzAwbXM7XG59XG4ubGlsLWd1aS5yb290ID4gLmNoaWxkcmVuID4gLmxpbC1ndWkuY2xvc2VkID4gLnRpdGxlIHtcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG4ubGlsLWd1aSArIC5jb250cm9sbGVyIHtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLXdpZGdldC1jb2xvcik7XG4gIG1hcmdpbi10b3A6IDA7XG4gIHBhZGRpbmctdG9wOiB2YXIoLS1zcGFjaW5nKTtcbn1cbi5saWwtZ3VpIC5saWwtZ3VpIC5saWwtZ3VpID4gLnRpdGxlIHtcbiAgYm9yZGVyOiBub25lO1xufVxuLmxpbC1ndWkgLmxpbC1ndWkgLmxpbC1ndWkgPiAuY2hpbGRyZW4ge1xuICBib3JkZXI6IG5vbmU7XG4gIG1hcmdpbi1sZWZ0OiB2YXIoLS1mb2xkZXItaW5kZW50KTtcbiAgYm9yZGVyLWxlZnQ6IDJweCBzb2xpZCB2YXIoLS13aWRnZXQtY29sb3IpO1xufVxuLmxpbC1ndWkgLmxpbC1ndWkgLmNvbnRyb2xsZXIge1xuICBib3JkZXI6IG5vbmU7XG59XG5cbi5saWwtZ3VpIGxhYmVsLCAubGlsLWd1aSBpbnB1dCwgLmxpbC1ndWkgYnV0dG9uIHtcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cbi5saWwtZ3VpIGlucHV0IHtcbiAgYm9yZGVyOiAwO1xuICBvdXRsaW5lOiBub25lO1xuICBmb250LWZhbWlseTogdmFyKC0tZm9udC1mYW1pbHkpO1xuICBmb250LXNpemU6IHZhcigtLWlucHV0LWZvbnQtc2l6ZSk7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXdpZGdldC1ib3JkZXItcmFkaXVzKTtcbiAgaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbiAgYmFja2dyb3VuZDogdmFyKC0td2lkZ2V0LWNvbG9yKTtcbiAgY29sb3I6IHZhcigtLXRleHQtY29sb3IpO1xuICB3aWR0aDogMTAwJTtcbn1cbkBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gIC5saWwtZ3VpIGlucHV0OmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1ob3Zlci1jb2xvcik7XG4gIH1cbiAgLmxpbC1ndWkgaW5wdXQ6YWN0aXZlIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mb2N1cy1jb2xvcik7XG4gIH1cbn1cbi5saWwtZ3VpIGlucHV0OmRpc2FibGVkIHtcbiAgb3BhY2l0eTogMTtcbn1cbi5saWwtZ3VpIGlucHV0W3R5cGU9dGV4dF0sXG4ubGlsLWd1aSBpbnB1dFt0eXBlPW51bWJlcl0ge1xuICBwYWRkaW5nOiB2YXIoLS13aWRnZXQtcGFkZGluZyk7XG4gIC1tb3otYXBwZWFyYW5jZTogdGV4dGZpZWxkO1xufVxuLmxpbC1ndWkgaW5wdXRbdHlwZT10ZXh0XTpmb2N1cyxcbi5saWwtZ3VpIGlucHV0W3R5cGU9bnVtYmVyXTpmb2N1cyB7XG4gIGJhY2tncm91bmQ6IHZhcigtLWZvY3VzLWNvbG9yKTtcbn1cbi5saWwtZ3VpIGlucHV0W3R5cGU9Y2hlY2tib3hdIHtcbiAgYXBwZWFyYW5jZTogbm9uZTtcbiAgd2lkdGg6IHZhcigtLWNoZWNrYm94LXNpemUpO1xuICBoZWlnaHQ6IHZhcigtLWNoZWNrYm94LXNpemUpO1xuICBib3JkZXItcmFkaXVzOiB2YXIoLS13aWRnZXQtYm9yZGVyLXJhZGl1cyk7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuLmxpbC1ndWkgaW5wdXRbdHlwZT1jaGVja2JveF06Y2hlY2tlZDpiZWZvcmUge1xuICBmb250LWZhbWlseTogXCJsaWwtZ3VpXCI7XG4gIGNvbnRlbnQ6IFwi4pyTXCI7XG4gIGZvbnQtc2l6ZTogdmFyKC0tY2hlY2tib3gtc2l6ZSk7XG4gIGxpbmUtaGVpZ2h0OiB2YXIoLS1jaGVja2JveC1zaXplKTtcbn1cbkBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gIC5saWwtZ3VpIGlucHV0W3R5cGU9Y2hlY2tib3hdOmZvY3VzIHtcbiAgICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggdmFyKC0tZm9jdXMtY29sb3IpO1xuICB9XG59XG4ubGlsLWd1aSBidXR0b24ge1xuICBvdXRsaW5lOiBub25lO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LWZhbWlseSk7XG4gIGZvbnQtc2l6ZTogdmFyKC0tZm9udC1zaXplKTtcbiAgY29sb3I6IHZhcigtLXRleHQtY29sb3IpO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiB2YXIoLS13aWRnZXQtaGVpZ2h0KTtcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XG4gIGJhY2tncm91bmQ6IHZhcigtLXdpZGdldC1jb2xvcik7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLXdpZGdldC1ib3JkZXItcmFkaXVzKTtcbiAgYm9yZGVyOiBub25lO1xufVxuQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgLmxpbC1ndWkgYnV0dG9uOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1ob3Zlci1jb2xvcik7XG4gIH1cbiAgLmxpbC1ndWkgYnV0dG9uOmZvY3VzIHtcbiAgICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggdmFyKC0tZm9jdXMtY29sb3IpO1xuICB9XG59XG4ubGlsLWd1aSBidXR0b246YWN0aXZlIHtcbiAgYmFja2dyb3VuZDogdmFyKC0tZm9jdXMtY29sb3IpO1xufVxuXG5AZm9udC1mYWNlIHtcbiAgZm9udC1mYW1pbHk6IFwibGlsLWd1aVwiO1xuICBzcmM6IHVybChcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBVXNBQXNBQUFBQUNKd0FBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCSFUxVkNBQUFCQ0FBQUFINEFBQURBSW13bVlFOVRMeklBQUFHSUFBQUFQd0FBQUdCS3FINVNZMjFoY0FBQUFjZ0FBQUQwQUFBQ3J1a3l5SkJuYkhsbUFBQUN2QUFBQUY4QUFBQ0VJWnBXSDJobFlXUUFBQU1jQUFBQUp3QUFBRFpmY2oyemFHaGxZUUFBQTBRQUFBQVlBQUFBSkFDNUFIaG9iWFI0QUFBRFhBQUFBQkFBQUFCTUFaQUFBR3h2WTJFQUFBTnNBQUFBRkFBQUFDZ0NFZ0l5YldGNGNBQUFBNEFBQUFBZUFBQUFJQUVmQUJKdVlXMWxBQUFEb0FBQUFTSUFBQUlLOVNVVS9YQnZjM1FBQUFURUFBQUFaZ0FBQUpDVGNNYzJlSnhWamJFT2dqQVVSVStoRlJCSzFkR1JMK0FMbkFpVG95TUxFekZwblB6L2VBc2h3U2E5NzUxN2MvTXd3Sm1lQjlrd1BsKzBjZjUrdUdQWlhzcVB1NG52WmFiY1NabGRaNmtmeVdub21GWS9lU2NLcVpOV3VwS0pPNmtYTjNLOXVDVm9MN2lJblByMVg1YmFYczN0anVNcUN0ekV1YWdtL0FBbHpRZ1BBQUI0bkdOZ1lSQmxuTURBeXNEQVlNL2dCaVQ1b0xRQkF3dURKQU1ERXdNck13TldFSkRtbXNKd2dDRmVYWmdoQmNqbFpNZ0ZDek9pS09JRkFCNzFCYjhBZUp5MWtqRnV3a0FRUlorRHdSQXdCdE5RUlVHS1E4T2RLQ0FXVWhBZ0tMaEl1QXNWU3BXejVCYmtqM2RFZ1lpVUlzenFXZHBaZStaNy93QjFvQ1ltSW9ib2l3aUxUMldqS2wvanNjckhmR2cvcEtkTWt5a2xDNVpzMkxFZkhZcGpjUm9Qem1lOU1XV21rM2RXYks5T2JrV2tpa09ldEo1NTRmV3lvRXNtZFNsdCt1UjBwQ0pSMzRiNnQvVFZnMVNZM3NZdmRmOHZ1aUtycHlhRFhESVNpZWdwMTdwNzU3OUdwM3ArK3k3SFBBaVk5cG1UaWJsanJyODVxU2lkdGxnNCtsMjVHTENhUzhlNnJSeE5CbXNuRVJ1bktiYU9PYlJ6N043Mmp1NXZkQWpZcEJYSGdKeWxPQVZzTXNlREFQRVA4TFlvVUhpY1kyQmlBQUVmaGlBR0pnWldCZ1o3Um5GUmRuVkpFTENRbEJTUmxBVEpNb0xWMkRLNGdsU1lzNnVicTV2YktySkxTYkdyZ0Vtb3ZEdURKVmhlM1Z6Y1hGd05MQ09JTEIvQzRJdVExeFRuNUZQaWxCVGo1RlBtQkFCNFd3b3FBSGljWTJCa1lHQUE0c2sxc1IvaitXMitNbkF6cERCZ0F5RU1RVUNTZzRFSnhBRUF3VWdGSGdCNG5HTmdaR0JnU0dGZ2dKTWhESXdNcUVBWUFCeUhBVEo0bkdOZ0FJSVVORXdtQUFCbDNBR1JlSnhqWUFBQ0lRWWxCaU1HSjN3UUFFY1FCRVY0bkdOZ1pHQmdFR1pnWTJCaUFBRVF5UVdFREF6L3dYd0dBQXNQQVRJQUFIaWNYZEJOU3NOQUhBWHdsMzVpQTBVUVhZbk1TaGZTOUdQWkE3VDdMZ0l1MDNTU3Brd3pZVEl0MUJONEFrL2dLVHlBZUN4ZnczOWpaa2p5bXpjdkF3bUFXL3dnd0hVRUdEYjM2K2pRUTNHWEdvdDc5TDI0anhDUDRnSHpGL0VJcjRqRUllN3d4aE9DM2cyVE1ZeTRRNytMdS9TSHVFZC9pdnQ0d0pkNHdQeGJQRUtNWDNHSTUrREpGR2FTbjRxTnprOG1jYktTUjZ4ZFhkaFN6YU9aSkd0ZGFwZDR2VlBiaTZyUCtjTDdUR1hPSHRYS2xsNGJZMVhsN0VHblB0cDdYeTJuMDB6eUtMVkhma0hCYTRJY0oyb0QzY2dnZ1d2dC9WL0ZiRHJVbEVVSmhUbi8wYXpWV2JOVE5yMEVuczhkZTF0Y2VLOXhabWZCMUNQak9tUEg0a2l0bXZPdWJjTnBtVlROM29GSnlqekN2bm1yd2hKVHpxelZqOWppU1g5MTFGamVBQUI0bkczSE1SS0NNQkJBMGYwZ2lpS2k0RFU4azBWMkdXYklaRE9oNFBvV1d2cTZKNVY4SWY5TlZOUWNhRGh5b3VYTWhZNHJQVGNHN2p3WW1YaEtxOFd6K3A3NjJhTmFlWVhvbTJuM20yZExUVmdzckNnRko3T1RtSWtZYndJYkM2dklCN1dtRmZBQUFBPT1cIikgZm9ybWF0KFwid29mZlwiKTtcbn1gO1xuXG5mdW5jdGlvbiBfaW5qZWN0U3R5bGVzKCBjc3NDb250ZW50ICkge1xuXHRjb25zdCBpbmplY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzdHlsZScgKTtcblx0aW5qZWN0ZWQuaW5uZXJIVE1MID0gY3NzQ29udGVudDtcblx0Y29uc3QgYmVmb3JlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggJ2hlYWQgbGlua1tyZWw9c3R5bGVzaGVldF0sIGhlYWQgc3R5bGUnICk7XG5cdGlmICggYmVmb3JlICkge1xuXHRcdGRvY3VtZW50LmhlYWQuaW5zZXJ0QmVmb3JlKCBpbmplY3RlZCwgYmVmb3JlICk7XG5cdH0gZWxzZSB7XG5cdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggaW5qZWN0ZWQgKTtcblx0fVxufVxuXG5sZXQgc3R5bGVzSW5qZWN0ZWQgPSBmYWxzZTtcblxuY2xhc3MgR1VJIHtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHBhbmVsIHRoYXQgaG9sZHMgY29udHJvbGxlcnMuXG5cdCAqIEBleGFtcGxlXG5cdCAqIG5ldyBHVUkoKTtcblx0ICogbmV3IEdVSSggeyBjb250YWluZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCAnY3VzdG9tJyApIH0gKTtcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9QbGFjZT10cnVlXVxuXHQgKiBBZGRzIHRoZSBHVUkgdG8gYGRvY3VtZW50LmJvZHlgIGFuZCBmaXhlcyBpdCB0byB0aGUgdG9wIHJpZ2h0IG9mIHRoZSBwYWdlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbb3B0aW9ucy5jb250YWluZXJdXG5cdCAqIEFkZHMgdGhlIEdVSSB0byB0aGlzIERPTSBlbGVtZW50LiBPdmVycmlkZXMgYGF1dG9QbGFjZWAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aD0yNDVdXG5cdCAqIFdpZHRoIG9mIHRoZSBHVUkgaW4gcGl4ZWxzLCB1c3VhbGx5IHNldCB3aGVuIG5hbWUgbGFiZWxzIGJlY29tZSB0b28gbG9uZy4gTm90ZSB0aGF0IHlvdSBjYW4gbWFrZVxuXHQgKiBuYW1lIGxhYmVscyB3aWRlciBpbiBDU1Mgd2l0aCBgLmxpbOKAkWd1aSB7IOKAkeKAkW5hbWXigJF3aWR0aDogNTUlIH1gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGl0bGU9Q29udHJvbHNdXG5cdCAqIE5hbWUgdG8gZGlzcGxheSBpbiB0aGUgdGl0bGUgYmFyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsb3NlRm9sZGVycz1mYWxzZV1cblx0ICogUGFzcyBgdHJ1ZWAgdG8gY2xvc2UgYWxsIGZvbGRlcnMgaW4gdGhpcyBHVUkgYnkgZGVmYXVsdC5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbmplY3RTdHlsZXM9dHJ1ZV1cblx0ICogSW5qZWN0cyB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0IGludG8gdGhlIHBhZ2UgaWYgdGhpcyBpcyB0aGUgZmlyc3QgR1VJLlxuXHQgKiBQYXNzIGBmYWxzZWAgdG8gdXNlIHlvdXIgb3duIHN0eWxlc2hlZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50b3VjaFN0eWxlcz10cnVlXVxuXHQgKiBNYWtlcyBjb250cm9sbGVycyBsYXJnZXIgb24gdG91Y2ggZGV2aWNlcy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUgdG91Y2ggc3R5bGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0dVSX0gW29wdGlvbnMucGFyZW50XVxuXHQgKiBBZGRzIHRoaXMgR1VJIGFzIGEgY2hpbGQgaW4gYW5vdGhlciBHVUkuIFVzdWFsbHkgdGhpcyBpcyBkb25lIGZvciB5b3UgYnkgYGFkZEZvbGRlcigpYC5cblx0ICpcblx0ICovXG5cdGNvbnN0cnVjdG9yKCB7XG5cdFx0cGFyZW50LFxuXHRcdGF1dG9QbGFjZSA9IHBhcmVudCA9PT0gdW5kZWZpbmVkLFxuXHRcdGNvbnRhaW5lcixcblx0XHR3aWR0aCxcblx0XHR0aXRsZSA9ICdDb250cm9scycsXG5cdFx0Y2xvc2VGb2xkZXJzID0gZmFsc2UsXG5cdFx0aW5qZWN0U3R5bGVzID0gdHJ1ZSxcblx0XHR0b3VjaFN0eWxlcyA9IHRydWVcblx0fSA9IHt9ICkge1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIEdVSSBjb250YWluaW5nIHRoaXMgZm9sZGVyLCBvciBgdW5kZWZpbmVkYCBpZiB0aGlzIGlzIHRoZSByb290IEdVSS5cblx0XHQgKiBAdHlwZSB7R1VJfVxuXHRcdCAqL1xuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRvcCBsZXZlbCBHVUkgY29udGFpbmluZyB0aGlzIGZvbGRlciwgb3IgYHRoaXNgIGlmIHRoaXMgaXMgdGhlIHJvb3QgR1VJLlxuXHRcdCAqIEB0eXBlIHtHVUl9XG5cdFx0ICovXG5cdFx0dGhpcy5yb290ID0gcGFyZW50ID8gcGFyZW50LnJvb3QgOiB0aGlzO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxpc3Qgb2YgY29udHJvbGxlcnMgYW5kIGZvbGRlcnMgY29udGFpbmVkIGJ5IHRoaXMgR1VJLlxuXHRcdCAqIEB0eXBlIHtBcnJheTxHVUl8Q29udHJvbGxlcj59XG5cdFx0ICovXG5cdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxpc3Qgb2YgY29udHJvbGxlcnMgY29udGFpbmVkIGJ5IHRoaXMgR1VJLlxuXHRcdCAqIEB0eXBlIHtBcnJheTxDb250cm9sbGVyPn1cblx0XHQgKi9cblx0XHR0aGlzLmNvbnRyb2xsZXJzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGlzdCBvZiBmb2xkZXJzIGNvbnRhaW5lZCBieSB0aGlzIEdVSS5cblx0XHQgKiBAdHlwZSB7QXJyYXk8R1VJPn1cblx0XHQgKi9cblx0XHR0aGlzLmZvbGRlcnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBHVUkgaXMgY2xvc2VkLiBVc2UgYGd1aS5vcGVuKClgIG9yIGBndWkuY2xvc2UoKWAgdG8gY2hhbmdlIHRoaXMuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGUgR1VJIGlzIGhpZGRlbi4gVXNlIGBndWkuc2hvdygpYCBvciBgZ3VpLmhpZGUoKWAgdG8gY2hhbmdlIHRoaXMuXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5faGlkZGVuID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgb3V0ZXJtb3N0IGNvbnRhaW5lciBlbGVtZW50LlxuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5jbGFzc0xpc3QuYWRkKCAnbGlsLWd1aScgKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aXRsZS5cblx0XHQgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG5cdFx0ICovXG5cdFx0dGhpcy4kdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRcdHRoaXMuJHRpdGxlLmNsYXNzTGlzdC5hZGQoICd0aXRsZScgKTtcblx0XHR0aGlzLiR0aXRsZS5zZXRBdHRyaWJ1dGUoICdyb2xlJywgJ2J1dHRvbicgKTtcblx0XHR0aGlzLiR0aXRsZS5zZXRBdHRyaWJ1dGUoICdhcmlhLWV4cGFuZGVkJywgdHJ1ZSApO1xuXHRcdHRoaXMuJHRpdGxlLnNldEF0dHJpYnV0ZSggJ3RhYmluZGV4JywgMCApO1xuXG5cdFx0dGhpcy4kdGl0bGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgKCkgPT4gdGhpcy5vcGVuQW5pbWF0ZWQoIHRoaXMuX2Nsb3NlZCApICk7XG5cdFx0dGhpcy4kdGl0bGUuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBlID0+IHtcblx0XHRcdGlmICggZS5jb2RlID09PSAnRW50ZXInIHx8IGUuY29kZSA9PT0gJ1NwYWNlJyApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR0aGlzLiR0aXRsZS5jbGljaygpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIGVuYWJsZXMgOmFjdGl2ZSBwc2V1ZG8gY2xhc3Mgb24gbW9iaWxlXG5cdFx0dGhpcy4kdGl0bGUuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCAoKSA9PiB7fSwgeyBwYXNzaXZlOiB0cnVlIH0gKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIGNoaWxkcmVuLlxuXHRcdCAqIEB0eXBlIHtIVE1MRWxlbWVudH1cblx0XHQgKi9cblx0XHR0aGlzLiRjaGlsZHJlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0dGhpcy4kY2hpbGRyZW4uY2xhc3NMaXN0LmFkZCggJ2NoaWxkcmVuJyApO1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKCB0aGlzLiR0aXRsZSApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCggdGhpcy4kY2hpbGRyZW4gKTtcblxuXHRcdHRoaXMudGl0bGUoIHRpdGxlICk7XG5cblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xuXG5cdFx0XHR0aGlzLnBhcmVudC5jaGlsZHJlbi5wdXNoKCB0aGlzICk7XG5cdFx0XHR0aGlzLnBhcmVudC5mb2xkZXJzLnB1c2goIHRoaXMgKTtcblxuXHRcdFx0dGhpcy5wYXJlbnQuJGNoaWxkcmVuLmFwcGVuZENoaWxkKCB0aGlzLmRvbUVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gU3RvcCB0aGUgY29uc3RydWN0b3IgZWFybHksIGV2ZXJ5dGhpbmcgb253YXJkIG9ubHkgYXBwbGllcyB0byByb290IEdVSSdzXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ3Jvb3QnICk7XG5cblx0XHRpZiAoIHRvdWNoU3R5bGVzICkge1xuXHRcdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5hZGQoICdhbGxvdy10b3VjaC1zdHlsZXMnICk7XG5cdFx0fVxuXG5cdFx0Ly8gSW5qZWN0IHN0eWxlc2hlZXQgaWYgd2UgaGF2ZW4ndCBkb25lIHRoYXQgeWV0XG5cdFx0aWYgKCAhc3R5bGVzSW5qZWN0ZWQgJiYgaW5qZWN0U3R5bGVzICkge1xuXHRcdFx0X2luamVjdFN0eWxlcyggc3R5bGVzaGVldCApO1xuXHRcdFx0c3R5bGVzSW5qZWN0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggY29udGFpbmVyICkge1xuXG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIHRoaXMuZG9tRWxlbWVudCApO1xuXG5cdFx0fSBlbHNlIGlmICggYXV0b1BsYWNlICkge1xuXG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZCggJ2F1dG9QbGFjZScgKTtcblx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIHRoaXMuZG9tRWxlbWVudCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB3aWR0aCApIHtcblx0XHRcdHRoaXMuZG9tRWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSggJy0td2lkdGgnLCB3aWR0aCArICdweCcgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jbG9zZUZvbGRlcnMgPSBjbG9zZUZvbGRlcnM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY29udHJvbGxlciB0byB0aGUgR1VJLCBpbmZlcnJpbmcgY29udHJvbGxlciB0eXBlIHVzaW5nIHRoZSBgdHlwZW9mYCBvcGVyYXRvci5cblx0ICogQGV4YW1wbGVcblx0ICogZ3VpLmFkZCggb2JqZWN0LCAncHJvcGVydHknICk7XG5cdCAqIGd1aS5hZGQoIG9iamVjdCwgJ251bWJlcicsIDAsIDEwMCwgMSApO1xuXHQgKiBndWkuYWRkKCBvYmplY3QsICdvcHRpb25zJywgWyAxLCAyLCAzIF0gKTtcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBjb250cm9sbGVyIHdpbGwgbW9kaWZ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY29udHJvbC5cblx0ICogQHBhcmFtIHtudW1iZXJ8b2JqZWN0fEFycmF5fSBbJDFdIE1pbmltdW0gdmFsdWUgZm9yIG51bWJlciBjb250cm9sbGVycywgb3IgdGhlIHNldCBvZlxuXHQgKiBzZWxlY3RhYmxlIHZhbHVlcyBmb3IgYSBkcm9wZG93bi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFttYXhdIE1heGltdW0gdmFsdWUgZm9yIG51bWJlciBjb250cm9sbGVycy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwXSBTdGVwIHZhbHVlIGZvciBudW1iZXIgY29udHJvbGxlcnMuXG5cdCAqIEByZXR1cm5zIHtDb250cm9sbGVyfVxuXHQgKi9cblx0YWRkKCBvYmplY3QsIHByb3BlcnR5LCAkMSwgbWF4LCBzdGVwICkge1xuXG5cdFx0aWYgKCBPYmplY3QoICQxICkgPT09ICQxICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IE9wdGlvbkNvbnRyb2xsZXIoIHRoaXMsIG9iamVjdCwgcHJvcGVydHksICQxICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpbml0aWFsVmFsdWUgPSBvYmplY3RbIHByb3BlcnR5IF07XG5cblx0XHRzd2l0Y2ggKCB0eXBlb2YgaW5pdGlhbFZhbHVlICkge1xuXG5cdFx0XHRjYXNlICdudW1iZXInOlxuXG5cdFx0XHRcdHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlciggdGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgJDEsIG1heCwgc3RlcCApO1xuXG5cdFx0XHRjYXNlICdib29sZWFuJzpcblxuXHRcdFx0XHRyZXR1cm4gbmV3IEJvb2xlYW5Db250cm9sbGVyKCB0aGlzLCBvYmplY3QsIHByb3BlcnR5ICk7XG5cblx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBTdHJpbmdDb250cm9sbGVyKCB0aGlzLCBvYmplY3QsIHByb3BlcnR5ICk7XG5cblx0XHRcdGNhc2UgJ2Z1bmN0aW9uJzpcblxuXHRcdFx0XHRyZXR1cm4gbmV3IEZ1bmN0aW9uQ29udHJvbGxlciggdGhpcywgb2JqZWN0LCBwcm9wZXJ0eSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc29sZS5lcnJvciggYGd1aS5hZGQgZmFpbGVkXG5cdHByb3BlcnR5OmAsIHByb3BlcnR5LCBgXG5cdG9iamVjdDpgLCBvYmplY3QsIGBcblx0dmFsdWU6YCwgaW5pdGlhbFZhbHVlICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgY29sb3IgY29udHJvbGxlciB0byB0aGUgR1VJLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBwYXJhbXMgPSB7XG5cdCAqIFx0Y3NzQ29sb3I6ICcjZmYwMGZmJyxcblx0ICogXHRyZ2JDb2xvcjogeyByOiAwLCBnOiAwLjIsIGI6IDAuNCB9LFxuXHQgKiBcdGN1c3RvbVJhbmdlOiBbIDAsIDEyNywgMjU1IF0sXG5cdCAqIH07XG5cdCAqXG5cdCAqIGd1aS5hZGRDb2xvciggcGFyYW1zLCAnY3NzQ29sb3InICk7XG5cdCAqIGd1aS5hZGRDb2xvciggcGFyYW1zLCAncmdiQ29sb3InICk7XG5cdCAqIGd1aS5hZGRDb2xvciggcGFyYW1zLCAnY3VzdG9tUmFuZ2UnLCAyNTUgKTtcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBjb250cm9sbGVyIHdpbGwgbW9kaWZ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY29udHJvbC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHJnYlNjYWxlIE1heGltdW0gdmFsdWUgZm9yIGEgY29sb3IgY2hhbm5lbCB3aGVuIHVzaW5nIGFuIFJHQiBjb2xvci4gWW91IG1heVxuXHQgKiBuZWVkIHRvIHNldCB0aGlzIHRvIDI1NSBpZiB5b3VyIGNvbG9ycyBhcmUgdG9vIGJyaWdodC5cblx0ICogQHJldHVybnMge0NvbnRyb2xsZXJ9XG5cdCAqL1xuXHRhZGRDb2xvciggb2JqZWN0LCBwcm9wZXJ0eSwgcmdiU2NhbGUgPSAxICkge1xuXHRcdHJldHVybiBuZXcgQ29sb3JDb250cm9sbGVyKCB0aGlzLCBvYmplY3QsIHByb3BlcnR5LCByZ2JTY2FsZSApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBmb2xkZXIgdG8gdGhlIEdVSSwgd2hpY2ggaXMganVzdCBhbm90aGVyIEdVSS4gVGhpcyBtZXRob2QgcmV0dXJuc1xuXHQgKiB0aGUgbmVzdGVkIEdVSSBzbyB5b3UgY2FuIGFkZCBjb250cm9sbGVycyB0byBpdC5cblx0ICogQGV4YW1wbGVcblx0ICogY29uc3QgZm9sZGVyID0gZ3VpLmFkZEZvbGRlciggJ1Bvc2l0aW9uJyApO1xuXHQgKiBmb2xkZXIuYWRkKCBwb3NpdGlvbiwgJ3gnICk7XG5cdCAqIGZvbGRlci5hZGQoIHBvc2l0aW9uLCAneScgKTtcblx0ICogZm9sZGVyLmFkZCggcG9zaXRpb24sICd6JyApO1xuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgTmFtZSB0byBkaXNwbGF5IGluIHRoZSBmb2xkZXIncyB0aXRsZSBiYXIuXG5cdCAqIEByZXR1cm5zIHtHVUl9XG5cdCAqL1xuXHRhZGRGb2xkZXIoIHRpdGxlICkge1xuXHRcdGNvbnN0IGZvbGRlciA9IG5ldyBHVUkoIHsgcGFyZW50OiB0aGlzLCB0aXRsZSB9ICk7XG5cdFx0aWYgKCB0aGlzLnJvb3QuX2Nsb3NlRm9sZGVycyApIGZvbGRlci5jbG9zZSgpO1xuXHRcdHJldHVybiBmb2xkZXI7XG5cdH1cblxuXHQvKipcblx0ICogUmVjYWxscyB2YWx1ZXMgdGhhdCB3ZXJlIHNhdmVkIHdpdGggYGd1aS5zYXZlKClgLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb2JqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFBhc3MgZmFsc2UgdG8gZXhjbHVkZSBmb2xkZXJzIGRlc2NlbmRpbmcgZnJvbSB0aGlzIEdVSS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRsb2FkKCBvYmosIHJlY3Vyc2l2ZSA9IHRydWUgKSB7XG5cblx0XHRpZiAoIG9iai5jb250cm9sbGVycyApIHtcblxuXHRcdFx0dGhpcy5jb250cm9sbGVycy5mb3JFYWNoKCBjID0+IHtcblxuXHRcdFx0XHRpZiAoIGMgaW5zdGFuY2VvZiBGdW5jdGlvbkNvbnRyb2xsZXIgKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKCBjLl9uYW1lIGluIG9iai5jb250cm9sbGVycyApIHtcblx0XHRcdFx0XHRjLmxvYWQoIG9iai5jb250cm9sbGVyc1sgYy5fbmFtZSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByZWN1cnNpdmUgJiYgb2JqLmZvbGRlcnMgKSB7XG5cblx0XHRcdHRoaXMuZm9sZGVycy5mb3JFYWNoKCBmID0+IHtcblxuXHRcdFx0XHRpZiAoIGYuX3RpdGxlIGluIG9iai5mb2xkZXJzICkge1xuXHRcdFx0XHRcdGYubG9hZCggb2JqLmZvbGRlcnNbIGYuX3RpdGxlIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IG1hcHBpbmcgY29udHJvbGxlciBuYW1lcyB0byB2YWx1ZXMuIFRoZSBvYmplY3QgY2FuIGJlIHBhc3NlZCB0byBgZ3VpLmxvYWQoKWAgdG9cblx0ICogcmVjYWxsIHRoZXNlIHZhbHVlcy5cblx0ICogQGV4YW1wbGVcblx0ICoge1xuXHQgKiBcdGNvbnRyb2xsZXJzOiB7XG5cdCAqIFx0XHRwcm9wMTogMSxcblx0ICogXHRcdHByb3AyOiAndmFsdWUnLFxuXHQgKiBcdFx0Li4uXG5cdCAqIFx0fSxcblx0ICogXHRmb2xkZXJzOiB7XG5cdCAqIFx0XHRmb2xkZXJOYW1lMTogeyBjb250cm9sbGVycywgZm9sZGVycyB9LFxuXHQgKiBcdFx0Zm9sZGVyTmFtZTI6IHsgY29udHJvbGxlcnMsIGZvbGRlcnMgfVxuXHQgKiBcdFx0Li4uXG5cdCAqIFx0fVxuXHQgKiB9XG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIFBhc3MgZmFsc2UgdG8gZXhjbHVkZSBmb2xkZXJzIGRlc2NlbmRpbmcgZnJvbSB0aGlzIEdVSS5cblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG5cdHNhdmUoIHJlY3Vyc2l2ZSA9IHRydWUgKSB7XG5cblx0XHRjb25zdCBvYmogPSB7XG5cdFx0XHRjb250cm9sbGVyczoge30sXG5cdFx0XHRmb2xkZXJzOiB7fVxuXHRcdH07XG5cblx0XHR0aGlzLmNvbnRyb2xsZXJzLmZvckVhY2goIGMgPT4ge1xuXG5cdFx0XHRpZiAoIGMgaW5zdGFuY2VvZiBGdW5jdGlvbkNvbnRyb2xsZXIgKSByZXR1cm47XG5cblx0XHRcdGlmICggYy5fbmFtZSBpbiBvYmouY29udHJvbGxlcnMgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggYENhbm5vdCBzYXZlIEdVSSB3aXRoIGR1cGxpY2F0ZSBwcm9wZXJ0eSBcIiR7Yy5fbmFtZX1cImAgKTtcblx0XHRcdH1cblxuXHRcdFx0b2JqLmNvbnRyb2xsZXJzWyBjLl9uYW1lIF0gPSBjLnNhdmUoKTtcblxuXHRcdH0gKTtcblxuXHRcdGlmICggcmVjdXJzaXZlICkge1xuXG5cdFx0XHR0aGlzLmZvbGRlcnMuZm9yRWFjaCggZiA9PiB7XG5cblx0XHRcdFx0aWYgKCBmLl90aXRsZSBpbiBvYmouZm9sZGVycyApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGBDYW5ub3Qgc2F2ZSBHVUkgd2l0aCBkdXBsaWNhdGUgZm9sZGVyIFwiJHtmLl90aXRsZX1cImAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iai5mb2xkZXJzWyBmLl90aXRsZSBdID0gZi5zYXZlKCk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBPcGVucyBhIEdVSSBvciBmb2xkZXIuIEdVSSBhbmQgZm9sZGVycyBhcmUgb3BlbiBieSBkZWZhdWx0LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG9wZW4gUGFzcyBmYWxzZSB0byBjbG9zZS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGd1aS5vcGVuKCk7IC8vIG9wZW5cblx0ICogZ3VpLm9wZW4oIGZhbHNlICk7IC8vIGNsb3NlXG5cdCAqIGd1aS5vcGVuKCBndWkuX2Nsb3NlZCApOyAvLyB0b2dnbGVcblx0ICovXG5cdG9wZW4oIG9wZW4gPSB0cnVlICkge1xuXG5cdFx0dGhpcy5fc2V0Q2xvc2VkKCAhb3BlbiApO1xuXG5cdFx0dGhpcy4kdGl0bGUuc2V0QXR0cmlidXRlKCAnYXJpYS1leHBhbmRlZCcsICF0aGlzLl9jbG9zZWQgKTtcblx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSggJ2Nsb3NlZCcsIHRoaXMuX2Nsb3NlZCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIEdVSS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRjbG9zZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcGVuKCBmYWxzZSApO1xuXHR9XG5cblx0X3NldENsb3NlZCggY2xvc2VkICkge1xuXHRcdGlmICggdGhpcy5fY2xvc2VkID09PSBjbG9zZWQgKSByZXR1cm47XG5cdFx0dGhpcy5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdHRoaXMuX2NhbGxPbk9wZW5DbG9zZSggdGhpcyApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3dzIHRoZSBHVUkgYWZ0ZXIgaXQncyBiZWVuIGhpZGRlbi5cblx0ICogQHBhcmFtIHtib29sZWFufSBzaG93XG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBndWkuc2hvdygpO1xuXHQgKiBndWkuc2hvdyggZmFsc2UgKTsgLy8gaGlkZVxuXHQgKiBndWkuc2hvdyggZ3VpLl9oaWRkZW4gKTsgLy8gdG9nZ2xlXG5cdCAqL1xuXHRzaG93KCBzaG93ID0gdHJ1ZSApIHtcblxuXHRcdHRoaXMuX2hpZGRlbiA9ICFzaG93O1xuXG5cdFx0dGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9oaWRkZW4gPyAnbm9uZScgOiAnJztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogSGlkZXMgdGhlIEdVSS5cblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqL1xuXHRoaWRlKCkge1xuXHRcdHJldHVybiB0aGlzLnNob3coIGZhbHNlICk7XG5cdH1cblxuXHRvcGVuQW5pbWF0ZWQoIG9wZW4gPSB0cnVlICkge1xuXG5cdFx0Ly8gc2V0IHN0YXRlIGltbWVkaWF0ZWx5XG5cdFx0dGhpcy5fc2V0Q2xvc2VkKCAhb3BlbiApO1xuXG5cdFx0dGhpcy4kdGl0bGUuc2V0QXR0cmlidXRlKCAnYXJpYS1leHBhbmRlZCcsICF0aGlzLl9jbG9zZWQgKTtcblxuXHRcdC8vIHdhaXQgZm9yIG5leHQgZnJhbWUgdG8gbWVhc3VyZSAkY2hpbGRyZW5cblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoICgpID0+IHtcblxuXHRcdFx0Ly8gZXhwbGljaXRseSBzZXQgaW5pdGlhbCBoZWlnaHQgZm9yIHRyYW5zaXRpb25cblx0XHRcdGNvbnN0IGluaXRpYWxIZWlnaHQgPSB0aGlzLiRjaGlsZHJlbi5jbGllbnRIZWlnaHQ7XG5cdFx0XHR0aGlzLiRjaGlsZHJlbi5zdHlsZS5oZWlnaHQgPSBpbml0aWFsSGVpZ2h0ICsgJ3B4JztcblxuXHRcdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC5hZGQoICd0cmFuc2l0aW9uJyApO1xuXG5cdFx0XHRjb25zdCBvblRyYW5zaXRpb25FbmQgPSBlID0+IHtcblx0XHRcdFx0aWYgKCBlLnRhcmdldCAhPT0gdGhpcy4kY2hpbGRyZW4gKSByZXR1cm47XG5cdFx0XHRcdHRoaXMuJGNoaWxkcmVuLnN0eWxlLmhlaWdodCA9ICcnO1xuXHRcdFx0XHR0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSggJ3RyYW5zaXRpb24nICk7XG5cdFx0XHRcdHRoaXMuJGNoaWxkcmVuLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd0cmFuc2l0aW9uZW5kJywgb25UcmFuc2l0aW9uRW5kICk7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLiRjaGlsZHJlbi5hZGRFdmVudExpc3RlbmVyKCAndHJhbnNpdGlvbmVuZCcsIG9uVHJhbnNpdGlvbkVuZCApO1xuXG5cdFx0XHQvLyB0b2RvOiB0aGlzIGlzIHdyb25nIGlmIGNoaWxkcmVuJ3Mgc2Nyb2xsSGVpZ2h0IG1ha2VzIGZvciBhIGd1aSB0YWxsZXIgdGhhbiBtYXhIZWlnaHRcblx0XHRcdGNvbnN0IHRhcmdldEhlaWdodCA9ICFvcGVuID8gMCA6IHRoaXMuJGNoaWxkcmVuLnNjcm9sbEhlaWdodDtcblxuXHRcdFx0dGhpcy5kb21FbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoICdjbG9zZWQnLCAhb3BlbiApO1xuXG5cdFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoICgpID0+IHtcblx0XHRcdFx0dGhpcy4kY2hpbGRyZW4uc3R5bGUuaGVpZ2h0ID0gdGFyZ2V0SGVpZ2h0ICsgJ3B4Jztcblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQ2hhbmdlIHRoZSB0aXRsZSBvZiB0aGlzIEdVSS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG5cdCAqIEByZXR1cm5zIHt0aGlzfVxuXHQgKi9cblx0dGl0bGUoIHRpdGxlICkge1xuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgdGl0bGUgb2YgdGhlIEdVSS4gVXNlIGBndWkudGl0bGUoICdUaXRsZScgKWAgdG8gbW9kaWZ5IHRoaXMgdmFsdWUuXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLl90aXRsZSA9IHRpdGxlO1xuXHRcdHRoaXMuJHRpdGxlLnRleHRDb250ZW50ID0gdGl0bGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIGFsbCBjb250cm9sbGVycyB0byB0aGVpciBpbml0aWFsIHZhbHVlcy5cblx0ICogQHBhcmFtIHtib29sZWFufSByZWN1cnNpdmUgUGFzcyBmYWxzZSB0byBleGNsdWRlIGZvbGRlcnMgZGVzY2VuZGluZyBmcm9tIHRoaXMgR1VJLlxuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICovXG5cdHJlc2V0KCByZWN1cnNpdmUgPSB0cnVlICkge1xuXHRcdGNvbnN0IGNvbnRyb2xsZXJzID0gcmVjdXJzaXZlID8gdGhpcy5jb250cm9sbGVyc1JlY3Vyc2l2ZSgpIDogdGhpcy5jb250cm9sbGVycztcblx0XHRjb250cm9sbGVycy5mb3JFYWNoKCBjID0+IGMucmVzZXQoKSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBjb250cm9sbGVyIGluIHRoaXMgR1VJIGNoYW5nZXMuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24oe29iamVjdDpvYmplY3QsIHByb3BlcnR5OnN0cmluZywgdmFsdWU6YW55LCBjb250cm9sbGVyOkNvbnRyb2xsZXJ9KX0gY2FsbGJhY2tcblx0ICogQHJldHVybnMge3RoaXN9XG5cdCAqIEBleGFtcGxlXG5cdCAqIGd1aS5vbkNoYW5nZSggZXZlbnQgPT4ge1xuXHQgKiBcdGV2ZW50Lm9iamVjdCAgICAgLy8gb2JqZWN0IHRoYXQgd2FzIG1vZGlmaWVkXG5cdCAqIFx0ZXZlbnQucHJvcGVydHkgICAvLyBzdHJpbmcsIG5hbWUgb2YgcHJvcGVydHlcblx0ICogXHRldmVudC52YWx1ZSAgICAgIC8vIG5ldyB2YWx1ZSBvZiBjb250cm9sbGVyXG5cdCAqIFx0ZXZlbnQuY29udHJvbGxlciAvLyBjb250cm9sbGVyIHRoYXQgd2FzIG1vZGlmaWVkXG5cdCAqIH0gKTtcblx0ICovXG5cdG9uQ2hhbmdlKCBjYWxsYmFjayApIHtcblx0XHQvKipcblx0XHQgKiBVc2VkIHRvIGFjY2VzcyB0aGUgZnVuY3Rpb24gYm91bmQgdG8gYG9uQ2hhbmdlYCBldmVudHMuIERvbid0IG1vZGlmeSB0aGlzIHZhbHVlXG5cdFx0ICogZGlyZWN0bHkuIFVzZSB0aGUgYGd1aS5vbkNoYW5nZSggY2FsbGJhY2sgKWAgbWV0aG9kIGluc3RlYWQuXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqL1xuXHRcdHRoaXMuX29uQ2hhbmdlID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfY2FsbE9uQ2hhbmdlKCBjb250cm9sbGVyICkge1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCApIHtcblx0XHRcdHRoaXMucGFyZW50Ll9jYWxsT25DaGFuZ2UoIGNvbnRyb2xsZXIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX29uQ2hhbmdlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZS5jYWxsKCB0aGlzLCB7XG5cdFx0XHRcdG9iamVjdDogY29udHJvbGxlci5vYmplY3QsXG5cdFx0XHRcdHByb3BlcnR5OiBjb250cm9sbGVyLnByb3BlcnR5LFxuXHRcdFx0XHR2YWx1ZTogY29udHJvbGxlci5nZXRWYWx1ZSgpLFxuXHRcdFx0XHRjb250cm9sbGVyXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBjb250cm9sbGVyIGluIHRoaXMgR1VJIGhhcyBmaW5pc2hlZCBjaGFuZ2luZy5cblx0ICogQHBhcmFtIHtmdW5jdGlvbih7b2JqZWN0Om9iamVjdCwgcHJvcGVydHk6c3RyaW5nLCB2YWx1ZTphbnksIGNvbnRyb2xsZXI6Q29udHJvbGxlcn0pfSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICogQGV4YW1wbGVcblx0ICogZ3VpLm9uRmluaXNoQ2hhbmdlKCBldmVudCA9PiB7XG5cdCAqIFx0ZXZlbnQub2JqZWN0ICAgICAvLyBvYmplY3QgdGhhdCB3YXMgbW9kaWZpZWRcblx0ICogXHRldmVudC5wcm9wZXJ0eSAgIC8vIHN0cmluZywgbmFtZSBvZiBwcm9wZXJ0eVxuXHQgKiBcdGV2ZW50LnZhbHVlICAgICAgLy8gbmV3IHZhbHVlIG9mIGNvbnRyb2xsZXJcblx0ICogXHRldmVudC5jb250cm9sbGVyIC8vIGNvbnRyb2xsZXIgdGhhdCB3YXMgbW9kaWZpZWRcblx0ICogfSApO1xuXHQgKi9cblx0b25GaW5pc2hDaGFuZ2UoIGNhbGxiYWNrICkge1xuXHRcdC8qKlxuXHRcdCAqIFVzZWQgdG8gYWNjZXNzIHRoZSBmdW5jdGlvbiBib3VuZCB0byBgb25GaW5pc2hDaGFuZ2VgIGV2ZW50cy4gRG9uJ3QgbW9kaWZ5IHRoaXMgdmFsdWVcblx0XHQgKiBkaXJlY3RseS4gVXNlIHRoZSBgZ3VpLm9uRmluaXNoQ2hhbmdlKCBjYWxsYmFjayApYCBtZXRob2QgaW5zdGVhZC5cblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICovXG5cdFx0dGhpcy5fb25GaW5pc2hDaGFuZ2UgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF9jYWxsT25GaW5pc2hDaGFuZ2UoIGNvbnRyb2xsZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xuXHRcdFx0dGhpcy5wYXJlbnQuX2NhbGxPbkZpbmlzaENoYW5nZSggY29udHJvbGxlciApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fb25GaW5pc2hDaGFuZ2UgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX29uRmluaXNoQ2hhbmdlLmNhbGwoIHRoaXMsIHtcblx0XHRcdFx0b2JqZWN0OiBjb250cm9sbGVyLm9iamVjdCxcblx0XHRcdFx0cHJvcGVydHk6IGNvbnRyb2xsZXIucHJvcGVydHksXG5cdFx0XHRcdHZhbHVlOiBjb250cm9sbGVyLmdldFZhbHVlKCksXG5cdFx0XHRcdGNvbnRyb2xsZXJcblx0XHRcdH0gKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUGFzcyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoaXMgR1VJIG9yIGl0cyBkZXNjZW5kYW50cyBhcmUgb3BlbmVkIG9yIGNsb3NlZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbihHVUkpfSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7dGhpc31cblx0ICogQGV4YW1wbGVcblx0ICogZ3VpLm9uT3BlbkNsb3NlKCBjaGFuZ2VkR1VJID0+IHtcblx0ICogXHRjb25zb2xlLmxvZyggY2hhbmdlZEdVSS5fY2xvc2VkICk7XG5cdCAqIH0gKTtcblx0ICovXG5cdG9uT3BlbkNsb3NlKCBjYWxsYmFjayApIHtcblx0XHR0aGlzLl9vbk9wZW5DbG9zZSA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0X2NhbGxPbk9wZW5DbG9zZSggY2hhbmdlZEdVSSApIHtcblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xuXHRcdFx0dGhpcy5wYXJlbnQuX2NhbGxPbk9wZW5DbG9zZSggY2hhbmdlZEdVSSApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fb25PcGVuQ2xvc2UgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuX29uT3BlbkNsb3NlLmNhbGwoIHRoaXMsIGNoYW5nZWRHVUkgKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJveXMgYWxsIERPTSBlbGVtZW50cyBhbmQgZXZlbnQgbGlzdGVuZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEdVSS5cblx0ICovXG5cdGRlc3Ryb3koKSB7XG5cblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xuXHRcdFx0dGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKCB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKCB0aGlzICksIDEgKTtcblx0XHRcdHRoaXMucGFyZW50LmZvbGRlcnMuc3BsaWNlKCB0aGlzLnBhcmVudC5mb2xkZXJzLmluZGV4T2YoIHRoaXMgKSwgMSApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQgKSB7XG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGhpcy5kb21FbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0QXJyYXkuZnJvbSggdGhpcy5jaGlsZHJlbiApLmZvckVhY2goIGMgPT4gYy5kZXN0cm95KCkgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29udHJvbGxlcnMgY29udGFpbmVkIGJ5IHRoaXMgR1VJIGFuZCBpdHMgZGVzY2VuZGVudHMuXG5cdCAqIEByZXR1cm5zIHtDb250cm9sbGVyW119XG5cdCAqL1xuXHRjb250cm9sbGVyc1JlY3Vyc2l2ZSgpIHtcblx0XHRsZXQgY29udHJvbGxlcnMgPSBBcnJheS5mcm9tKCB0aGlzLmNvbnRyb2xsZXJzICk7XG5cdFx0dGhpcy5mb2xkZXJzLmZvckVhY2goIGYgPT4ge1xuXHRcdFx0Y29udHJvbGxlcnMgPSBjb250cm9sbGVycy5jb25jYXQoIGYuY29udHJvbGxlcnNSZWN1cnNpdmUoKSApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gY29udHJvbGxlcnM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBmb2xkZXJzIGNvbnRhaW5lZCBieSB0aGlzIEdVSSBhbmQgaXRzIGRlc2NlbmRlbnRzLlxuXHQgKiBAcmV0dXJucyB7R1VJW119XG5cdCAqL1xuXHRmb2xkZXJzUmVjdXJzaXZlKCkge1xuXHRcdGxldCBmb2xkZXJzID0gQXJyYXkuZnJvbSggdGhpcy5mb2xkZXJzICk7XG5cdFx0dGhpcy5mb2xkZXJzLmZvckVhY2goIGYgPT4ge1xuXHRcdFx0Zm9sZGVycyA9IGZvbGRlcnMuY29uY2F0KCBmLmZvbGRlcnNSZWN1cnNpdmUoKSApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZm9sZGVycztcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEdVSTtcbmV4cG9ydCB7IEJvb2xlYW5Db250cm9sbGVyLCBDb2xvckNvbnRyb2xsZXIsIENvbnRyb2xsZXIsIEZ1bmN0aW9uQ29udHJvbGxlciwgR1VJLCBOdW1iZXJDb250cm9sbGVyLCBPcHRpb25Db250cm9sbGVyLCBTdHJpbmdDb250cm9sbGVyIH07XG4iXSwibmFtZXMiOlsiQ29udHJvbGxlciIsImNvbnN0cnVjdG9yIiwicGFyZW50Iiwib2JqZWN0IiwicHJvcGVydHkiLCJjbGFzc05hbWUiLCJlbGVtZW50VHlwZSIsIl9kaXNhYmxlZCIsIl9oaWRkZW4iLCJpbml0aWFsVmFsdWUiLCJnZXRWYWx1ZSIsImRvbUVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCIkbmFtZSIsIm5leHROYW1lSUQiLCJpZCIsIiR3aWRnZXQiLCIkZGlzYWJsZSIsImFwcGVuZENoaWxkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJzdG9wUHJvcGFnYXRpb24iLCJjaGlsZHJlbiIsInB1c2giLCJjb250cm9sbGVycyIsIiRjaGlsZHJlbiIsIl9saXN0ZW5DYWxsYmFjayIsImJpbmQiLCJuYW1lIiwiX25hbWUiLCJ0ZXh0Q29udGVudCIsIm9uQ2hhbmdlIiwiY2FsbGJhY2siLCJfb25DaGFuZ2UiLCJfY2FsbE9uQ2hhbmdlIiwidW5kZWZpbmVkIiwiY2FsbCIsIl9jaGFuZ2VkIiwib25GaW5pc2hDaGFuZ2UiLCJfb25GaW5pc2hDaGFuZ2UiLCJfY2FsbE9uRmluaXNoQ2hhbmdlIiwicmVzZXQiLCJzZXRWYWx1ZSIsImVuYWJsZSIsImVuYWJsZWQiLCJkaXNhYmxlIiwiZGlzYWJsZWQiLCJ0b2dnbGUiLCJ0b2dnbGVBdHRyaWJ1dGUiLCJzaG93Iiwic3R5bGUiLCJkaXNwbGF5IiwiaGlkZSIsIm9wdGlvbnMiLCJjb250cm9sbGVyIiwiZGVzdHJveSIsIm1pbiIsIm1heCIsInN0ZXAiLCJkZWNpbWFscyIsImxpc3RlbiIsIl9saXN0ZW5pbmciLCJfbGlzdGVuQ2FsbGJhY2tJRCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY3VyVmFsdWUiLCJzYXZlIiwiX2xpc3RlblByZXZWYWx1ZSIsInVwZGF0ZURpc3BsYXkiLCJ2YWx1ZSIsImxvYWQiLCJzcGxpY2UiLCJpbmRleE9mIiwicmVtb3ZlQ2hpbGQiLCJCb29sZWFuQ29udHJvbGxlciIsIiRpbnB1dCIsInNldEF0dHJpYnV0ZSIsImNoZWNrZWQiLCJub3JtYWxpemVDb2xvclN0cmluZyIsInN0cmluZyIsIm1hdGNoIiwicmVzdWx0IiwicGFyc2VJbnQiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiU1RSSU5HIiwiaXNQcmltaXRpdmUiLCJ2IiwiZnJvbUhleFN0cmluZyIsInRvSGV4U3RyaW5nIiwiSU5UIiwic3Vic3RyaW5nIiwiQVJSQVkiLCJBcnJheSIsImlzQXJyYXkiLCJ0YXJnZXQiLCJyZ2JTY2FsZSIsImludCIsInIiLCJnIiwiYiIsIk9CSkVDVCIsIk9iamVjdCIsIkZPUk1BVFMiLCJnZXRDb2xvckZvcm1hdCIsImZpbmQiLCJmb3JtYXQiLCJDb2xvckNvbnRyb2xsZXIiLCIkdGV4dCIsIiRkaXNwbGF5IiwiX2Zvcm1hdCIsIl9yZ2JTY2FsZSIsIl9pbml0aWFsVmFsdWVIZXhTdHJpbmciLCJfdGV4dEZvY3VzZWQiLCJfc2V0VmFsdWVGcm9tSGV4U3RyaW5nIiwidHJ5UGFyc2UiLCJzZWxlY3QiLCJuZXdWYWx1ZSIsImJhY2tncm91bmRDb2xvciIsIkZ1bmN0aW9uQ29udHJvbGxlciIsIiRidXR0b24iLCJwcmV2ZW50RGVmYXVsdCIsInBhc3NpdmUiLCJOdW1iZXJDb250cm9sbGVyIiwiX2luaXRJbnB1dCIsInN0ZXBFeHBsaWNpdCIsIl9nZXRJbXBsaWNpdFN0ZXAiLCJfZGVjaW1hbHMiLCJfbWluIiwiX29uVXBkYXRlTWluTWF4IiwiX21heCIsImV4cGxpY2l0IiwiX3N0ZXAiLCJfc3RlcEV4cGxpY2l0IiwiX2hhc1NsaWRlciIsInBlcmNlbnQiLCJNYXRoIiwiJGZpbGwiLCJ3aWR0aCIsIl9pbnB1dEZvY3VzZWQiLCJ0b0ZpeGVkIiwiaXNUb3VjaCIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwib25JbnB1dCIsInBhcnNlRmxvYXQiLCJpc05hTiIsIl9zbmFwIiwiX2NsYW1wIiwiaW5jcmVtZW50IiwiZGVsdGEiLCJfc25hcENsYW1wU2V0VmFsdWUiLCJvbktleURvd24iLCJrZXkiLCJibHVyIiwiY29kZSIsIl9hcnJvd0tleU11bHRpcGxpZXIiLCJvbldoZWVsIiwiX25vcm1hbGl6ZU1vdXNlV2hlZWwiLCJ0ZXN0aW5nRm9yVmVydGljYWxEcmFnIiwiaW5pdENsaWVudFgiLCJpbml0Q2xpZW50WSIsInByZXZDbGllbnRZIiwiaW5pdFZhbHVlIiwiZHJhZ0RlbHRhIiwiRFJBR19USFJFU0giLCJvbk1vdXNlRG93biIsImNsaWVudFgiLCJjbGllbnRZIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlVXAiLCJkeCIsImR5IiwiYWJzIiwiX3NldERyYWdnaW5nU3R5bGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25Gb2N1cyIsIm9uQmx1ciIsIl9pbml0U2xpZGVyIiwiJHNsaWRlciIsImluc2VydEJlZm9yZSIsIm1hcCIsImEiLCJjIiwiZCIsInNldFZhbHVlRnJvbVgiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibGVmdCIsInJpZ2h0IiwibW91c2VEb3duIiwibW91c2VNb3ZlIiwibW91c2VVcCIsInRlc3RpbmdGb3JTY3JvbGwiLCJwcmV2Q2xpZW50WCIsImJlZ2luVG91Y2hEcmFnIiwidG91Y2hlcyIsIm9uVG91Y2hTdGFydCIsImxlbmd0aCIsIl9oYXNTY3JvbGxCYXIiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJjYWxsT25GaW5pc2hDaGFuZ2UiLCJXSEVFTF9ERUJPVU5DRV9USU1FIiwid2hlZWxGaW5pc2hDaGFuZ2VUaW1lb3V0IiwiaXNWZXJ0aWNhbCIsImRlbHRhWCIsImRlbHRhWSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJhY3RpdmUiLCJheGlzIiwiYm9keSIsIl9oYXNNaW4iLCJfaGFzTWF4IiwiZmxvb3IiLCJ3aGVlbERlbHRhIiwid2hlZWwiLCJtdWx0Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJyb3VuZCIsInRvUHJlY2lzaW9uIiwicm9vdCIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsIk9wdGlvbkNvbnRyb2xsZXIiLCIkc2VsZWN0IiwiX3ZhbHVlcyIsInNlbGVjdGVkSW5kZXgiLCJyZW1vdmUiLCJ2YWx1ZXMiLCJfbmFtZXMiLCJrZXlzIiwicmVwbGFjZUNoaWxkcmVuIiwiZm9yRWFjaCIsIiRvcHRpb24iLCJpbmRleCIsIlN0cmluZ0NvbnRyb2xsZXIiLCJzdHlsZXNoZWV0IiwiX2luamVjdFN0eWxlcyIsImNzc0NvbnRlbnQiLCJpbmplY3RlZCIsImlubmVySFRNTCIsImJlZm9yZSIsInF1ZXJ5U2VsZWN0b3IiLCJoZWFkIiwic3R5bGVzSW5qZWN0ZWQiLCJHVUkiLCJhdXRvUGxhY2UiLCJjb250YWluZXIiLCJ0aXRsZSIsImNsb3NlRm9sZGVycyIsImluamVjdFN0eWxlcyIsInRvdWNoU3R5bGVzIiwiZm9sZGVycyIsIl9jbG9zZWQiLCIkdGl0bGUiLCJvcGVuQW5pbWF0ZWQiLCJjbGljayIsInNldFByb3BlcnR5IiwiX2Nsb3NlRm9sZGVycyIsIiQxIiwiY29uc29sZSIsImVycm9yIiwiYWRkQ29sb3IiLCJhZGRGb2xkZXIiLCJmb2xkZXIiLCJjbG9zZSIsIm9iaiIsInJlY3Vyc2l2ZSIsImYiLCJfdGl0bGUiLCJFcnJvciIsIm9wZW4iLCJfc2V0Q2xvc2VkIiwiY2xvc2VkIiwiX2NhbGxPbk9wZW5DbG9zZSIsImluaXRpYWxIZWlnaHQiLCJoZWlnaHQiLCJvblRyYW5zaXRpb25FbmQiLCJ0YXJnZXRIZWlnaHQiLCJjb250cm9sbGVyc1JlY3Vyc2l2ZSIsIm9uT3BlbkNsb3NlIiwiX29uT3BlbkNsb3NlIiwiY2hhbmdlZEdVSSIsInBhcmVudEVsZW1lbnQiLCJmcm9tIiwiY29uY2F0IiwiZm9sZGVyc1JlY3Vyc2l2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lil-gui/dist/lil-gui.esm.js\n");

/***/ })

};
;
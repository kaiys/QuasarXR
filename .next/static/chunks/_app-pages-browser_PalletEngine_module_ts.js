"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_PalletEngine_module_ts"],{

/***/ "(app-pages-browser)/./PalletEngine/module.ts":
/*!********************************!*\
  !*** ./PalletEngine/module.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Command: function() { return /* binding */ Command; },\n/* harmony export */   PalletEngine: function() { return /* binding */ PalletEngine; },\n/* harmony export */   Renderer: function() { return /* binding */ Renderer; },\n/* harmony export */   Scene: function() { return /* binding */ Scene; },\n/* harmony export */   _module: function() { return /* binding */ _module; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"(app-pages-browser)/./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n/* harmony import */ var three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"(app-pages-browser)/./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n/* harmony import */ var three_examples_jsm_controls_TransformControls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/controls/TransformControls */ \"(app-pages-browser)/./node_modules/three/examples/jsm/controls/TransformControls.js\");\n/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three-mesh-bvh */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js\");\n\n\n\n\n\nlet _useWebGPU = false;\nlet _pointer = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n// replace extension functions\nthree__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry.prototype.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__.computeBoundsTree;\nthree__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry.prototype.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__.disposeBoundsTree;\nthree__WEBPACK_IMPORTED_MODULE_0__.Mesh.prototype.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_1__.acceleratedRaycast;\nvar PowerPreference;\n(function(PowerPreference) {\n    PowerPreference[\"HighPerformance\"] = \"high-performance\";\n    PowerPreference[\"LowPower\"] = \"low-power\";\n    PowerPreference[\"Default\"] = \"default\";\n})(PowerPreference || (PowerPreference = {}));\nfunction findParentByType(object, type) {\n    if (object.parent instanceof type) {\n        return object.parent; // 부모 요소가 해당 타입인 경우 반환\n    } else if (object.parent !== null) {\n        return findParentByType(object.parent, type); // 타입이 아닌 경우 부모 요소로 재귀 호출\n    } else {\n        return null; // 최상위 부모 요소에 도달할 때까지 타입을 찾지 못한 경우\n    }\n}\nclass Command {\n    constructor(){}\n}\nclass InteractionController {\n    drawHelper() {}\n    connectEvent() {}\n    getViewportPos(x, y) {\n        let target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : undefined;\n        _pointer.x = x / window.innerWidth * 2 - 1;\n        _pointer.y = -(y / window.innerHeight) * 2 + 1;\n        if (target) target.copy(_pointer);\n        return _pointer;\n    }\n    constructor(option){\n        this.raycaster = new three__WEBPACK_IMPORTED_MODULE_0__.Raycaster();\n    }\n}\nclass DesktopIRC extends InteractionController {\n    drawHelper() {}\n    connectEvent() {\n        document.addEventListener(\"mousedown\", (event)=>{\n            if (this.controls.axis) return;\n            this.raycaster.setFromCamera(this.getViewportPos(event.clientX, event.clientY), _module.camera);\n            const hits = this.raycaster.intersectObject(_module.sceneGraph, true);\n            this.onIntersection(hits);\n        });\n    }\n    onIntersection(hits) {\n        const hitMeshes = hits.filter((h)=>h.object.isMesh && !findParentByType(h.object, three_examples_jsm_controls_TransformControls__WEBPACK_IMPORTED_MODULE_2__.TransformControls));\n        if (hitMeshes.length > 0) {\n            this.controls.enabled = true;\n            const group = findParentByType(hitMeshes[0].object, three__WEBPACK_IMPORTED_MODULE_0__.Group);\n            if (group) {\n                this.controls.attach(group);\n            } else {\n                this.controls.attach(hitMeshes[0].object);\n            }\n        } else {\n            this.controls.detach();\n            this.controls.enabled = false;\n        }\n    }\n    createControls(camera, canvas) {\n        this.controls = new three_examples_jsm_controls_TransformControls__WEBPACK_IMPORTED_MODULE_2__.TransformControls(camera, canvas);\n        return this.controls;\n    }\n    constructor(){\n        super({});\n    }\n}\nclass VirtualRealityIRC extends InteractionController {\n    constructor(){\n        super({});\n    }\n}\nclass CommandQueue {\n    isEmpty() {\n        return this.array.length > 0;\n    }\n    update() {\n        if (this.isEmpty()) {}\n    }\n    constructor(){\n        this.array = new Array();\n    }\n}\nclass Scene {\n    defaultScene() {}\n    constructor(){\n        this.root = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this.animationObjects = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    }\n}\nclass Renderer {\n    static Get() {\n        if (!Renderer.renderer) {\n            Renderer.Create({});\n        }\n        return Renderer.renderer;\n    }\n    static Create(opt) {\n        Renderer.renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer(opt);\n        return Renderer.renderer;\n    }\n    static AnimationLoop(func) {}\n}\nRenderer.renderer = null;\nRenderer.canvas = null;\nRenderer.option = {\n    alpha: true\n};\nclass PalletElement extends HTMLElement {\n    constructor(){\n        super();\n    }\n}\nclass PalletEngine extends PalletElement {\n    createScene() {\n        const gridHelper = new three__WEBPACK_IMPORTED_MODULE_0__.GridHelper(50, 50, 0x7c7c7c, 0x5f5f5f);\n        this.camera.position.set(0, 0, 5);\n        this.sceneGraph.add(gridHelper);\n        this.sceneGraph.add(this.directionalLight);\n        this.sceneGraph.add(this.ambientLight);\n        //create temporal object\n        const cube = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(1, 1, 1), new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: 0xffdfba\n        }));\n        this.sceneGraph.add(cube);\n        this.updateFunctions.push((delta)=>{\n            cube.rotation.x += 0.01;\n            cube.rotation.y += 0.01;\n        });\n    }\n    createEnvironment() {}\n    loadGLTF(url, onload) {\n        this.gltfLoader.load(url, (gltf)=>{\n            onload(gltf);\n            this.sceneGraph.add(gltf.scene);\n        });\n    }\n    update(dt) {\n        this.updateFunctions.map((func)=>func(dt));\n        this.commandQueue.update();\n        this.controller.update();\n        Renderer.Get().render(this.sceneGraph, this.camera);\n    }\n    addUpdator(func) {\n        this.updateFunctions.push(func);\n    }\n    appendCommand() {}\n    constructor(canvas){\n        super();\n        this.sceneGraph = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this.camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n        this.directionalLight = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(0xffffff, 10);\n        this.ambientLight = new three__WEBPACK_IMPORTED_MODULE_0__.AmbientLight(0xfff8e8);\n        this.gltfLoader = new three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader();\n        this.clock = new three__WEBPACK_IMPORTED_MODULE_0__.Clock();\n        this.controller = new three_examples_jsm_controls_OrbitControls__WEBPACK_IMPORTED_MODULE_4__.OrbitControls(this.camera, canvas);\n        this.controller.enableDamping = true;\n        this.controller.dampingFactor = 0.1;\n        this.updateFunctions = new Array();\n        this.commandQueue = new CommandQueue();\n        this.irc = new DesktopIRC();\n        this.irc.connectEvent();\n        const transformer = this.irc.createControls(this.camera, canvas);\n        this.sceneGraph.add(transformer);\n        transformer.addEventListener(\"dragging-changed\", (event)=>{\n            this.controller.enabled = !event.value;\n        });\n        const renderer = Renderer.Create({\n            antialias: true,\n            canvas: canvas\n        });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x3c3c3c);\n        renderer.setAnimationLoop(()=>{\n            const dt = this.clock.getDelta();\n            this.update(dt);\n        });\n        window.addEventListener(\"resize\", (event)=>{\n            this.camera.aspect = window.innerWidth / window.innerHeight;\n            this.camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n        this.createScene();\n    }\n}\ncustomElements.define(\"pallet-element\", PalletElement);\ncustomElements.define(\"pallet-engine\", PalletEngine);\nlet canvasElements = document.getElementsByTagName(\"canvas\");\nlet _module;\nif (canvasElements.length > 0) {\n    const canvas = canvasElements[0];\n    _module = new PalletEngine(canvas);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL1BhbGxldEVuZ2luZS9tb2R1bGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUErQjtBQUVvQztBQUNPO0FBQ1E7QUFDUTtBQUUxRixJQUFJTyxhQUF1QjtBQUMzQixJQUFJQyxXQUEyQixJQUFJUiwwQ0FBYTtBQUVoRCw4QkFBOEI7QUFDOUJBLGlEQUFvQixDQUFDVyxTQUFTLENBQUNQLGlCQUFpQixHQUFHQSw2REFBaUJBO0FBQ3BFSixpREFBb0IsQ0FBQ1csU0FBUyxDQUFDTixpQkFBaUIsR0FBR0EsNkRBQWlCQTtBQUNwRUwsdUNBQVUsQ0FBQ1csU0FBUyxDQUFDRSxPQUFPLEdBQUdQLDhEQUFrQkE7O1VBRTVDUTs7OztHQUFBQSxvQkFBQUE7QUFFTCxTQUFTQyxpQkFBa0JDLE1BQU0sRUFBR0MsSUFBSTtJQUNwQyxJQUFJRCxPQUFPRSxNQUFNLFlBQVlELE1BQU87UUFDaEMsT0FBT0QsT0FBT0UsTUFBTSxFQUFFLHNCQUFzQjtJQUNoRCxPQUFPLElBQUlGLE9BQU9FLE1BQU0sS0FBSyxNQUFNO1FBQy9CLE9BQU9ILGlCQUFpQkMsT0FBT0UsTUFBTSxFQUFFRCxPQUFRLHlCQUF5QjtJQUM1RSxPQUFPO1FBQ0gsT0FBTyxNQUFNLGtDQUFrQztJQUNuRDtBQUNKO0FBZ0JPLE1BQU1FO0lBR1RDLGFBQWMsQ0FFZDtBQUNKO0FBRUEsTUFBTUM7SUFLRkMsYUFBYSxDQUFDO0lBQ2RDLGVBQWUsQ0FBQztJQUNoQkMsZUFBZ0JDLENBQVUsRUFBRUMsQ0FBVSxFQUF1RDtZQUFyREMsU0FBQUEsaUVBQXlCQztRQUM3RHBCLFNBQVNpQixDQUFDLEdBQUcsSUFBTUksT0FBT0MsVUFBVSxHQUFLLElBQUk7UUFDN0N0QixTQUFTa0IsQ0FBQyxHQUFHLENBQUlBLENBQUFBLElBQUlHLE9BQU9FLFdBQVcsSUFBSyxJQUFJO1FBQ2hELElBQUtKLFFBQVNBLE9BQU9LLElBQUksQ0FBRXhCO1FBQzNCLE9BQU9BO0lBQ1g7SUFWQVks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RixVQUFVLElBQUl1QyxhQUFjdEI7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vUGFsbGV0RW5naW5lL21vZHVsZS50cz82YzAxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcclxuaW1wb3J0ICogYXMgZGF0IGZyb20gJ2RhdC5ndWknO1xyXG5pbXBvcnQgeyBHTFRGTG9hZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlcic7XHJcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9scyc7XHJcbmltcG9ydCB7IFRyYW5zZm9ybUNvbnRyb2xzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL1RyYW5zZm9ybUNvbnRyb2xzJztcclxuaW1wb3J0IHsgY29tcHV0ZUJvdW5kc1RyZWUsIGRpc3Bvc2VCb3VuZHNUcmVlLCBhY2NlbGVyYXRlZFJheWNhc3QgfSBmcm9tICd0aHJlZS1tZXNoLWJ2aCc7XHJcblxyXG5sZXQgX3VzZVdlYkdQVSA6IEJvb2xlYW4gPSBmYWxzZTtcclxubGV0IF9wb2ludGVyIDogVEhSRUUuVmVjdG9yMiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4vLyByZXBsYWNlIGV4dGVuc2lvbiBmdW5jdGlvbnNcclxuVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVCb3VuZHNUcmVlID0gY29tcHV0ZUJvdW5kc1RyZWU7XHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5kaXNwb3NlQm91bmRzVHJlZSA9IGRpc3Bvc2VCb3VuZHNUcmVlO1xyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5yYXljYXN0ID0gYWNjZWxlcmF0ZWRSYXljYXN0O1xyXG5cclxuZW51bSBQb3dlclByZWZlcmVuY2UgeyBIaWdoUGVyZm9ybWFuY2UgPSBcImhpZ2gtcGVyZm9ybWFuY2VcIiwgTG93UG93ZXIgPSBcImxvdy1wb3dlclwiLCBEZWZhdWx0ID0gXCJkZWZhdWx0XCIgfTtcclxuXHJcbmZ1bmN0aW9uIGZpbmRQYXJlbnRCeVR5cGUoIG9iamVjdCAsIHR5cGUgKSB7XHJcbiAgICBpZiAob2JqZWN0LnBhcmVudCBpbnN0YW5jZW9mIHR5cGUgKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdC5wYXJlbnQ7IC8vIOu2gOuqqCDsmpTshozqsIAg7ZW064u5IO2DgOyeheyduCDqsr3smrAg67CY7ZmYXHJcbiAgICB9IGVsc2UgaWYgKG9iamVjdC5wYXJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmluZFBhcmVudEJ5VHlwZShvYmplY3QucGFyZW50LCB0eXBlICk7IC8vIO2DgOyeheydtCDslYTri4wg6rK97JqwIOu2gOuqqCDsmpTshozroZwg7J6s6reAIO2YuOy2nFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDsgLy8g7LWc7IOB7JyEIOu2gOuqqCDsmpTshozsl5Ag64+E64us7ZWgIOuVjOq5jOyngCDtg4DsnoXsnYQg7LC+7KeAIOuqu+2VnCDqsr3smrBcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUmVuZGVyT3B0aW9ucyA9IHtcclxuICAgIGNhbnZhcyA6IEhUTUxDYW52YXNFbGVtZW50LFxyXG4gICAgY29udGV4dCA6IFJlbmRlcmluZ0NvbnRleHQsXHJcbiAgICBhbHBoYSA6IGJvb2xlYW4sXHJcbiAgICBwcmVjaXNpb24gOiBzdHJpbmcsXHJcbiAgICBwcmVtdWx0aXBsaWVkQWxwaGEgOiBib29sZWFuLFxyXG4gICAgYW50aWFsaWFzIDogYm9vbGVhbixcclxuICAgIGxvZ2FyaXRobWljRGVwdGhCdWZmZXIgOiBib29sZWFuLFxyXG4gICAgZGVwdGggOiBib29sZWFuLFxyXG4gICAgc3RlbmNpbCA6IGJvb2xlYW4sXHJcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBib29sZWFuLFxyXG4gICAgcG93ZXJQcmVmZXJlbmNlIDogUG93ZXJQcmVmZXJlbmNlXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBDb21tYW5kIHtcclxuICAgIGNvbW1hbmQgOiBzdHJpbmc7XHJcbiAgICBwYXJhbWV0ZXIgOiBzdHJpbmc7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIEludGVyYWN0aW9uQ29udHJvbGxlciB7XHJcbiAgICByYXljYXN0ZXIgOiBUSFJFRS5SYXljYXN0ZXI7XHJcbiAgICBjb25zdHJ1Y3Rvciggb3B0aW9uIDogT2JqZWN0ICkge1xyXG4gICAgICAgIHRoaXMucmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xyXG4gICAgfSAgICBcclxuICAgIGRyYXdIZWxwZXIoKSB7fVxyXG4gICAgY29ubmVjdEV2ZW50KCkge31cclxuICAgIGdldFZpZXdwb3J0UG9zKCB4IDogbnVtYmVyLCB5IDogbnVtYmVyLCB0YXJnZXQgOiBUSFJFRS5WZWN0b3IyID0gdW5kZWZpbmVkICkgOiBUSFJFRS5WZWN0b3IyIHtcclxuICAgICAgICBfcG9pbnRlci54ID0gKCB4IC8gd2luZG93LmlubmVyV2lkdGggKSAqIDIgLSAxO1xyXG4gICAgICAgIF9wb2ludGVyLnkgPSAtICggeSAvIHdpbmRvdy5pbm5lckhlaWdodCApICogMiArIDE7XHJcbiAgICAgICAgaWYgKCB0YXJnZXQgKSB0YXJnZXQuY29weSggX3BvaW50ZXIgKTtcclxuICAgICAgICByZXR1cm4gX3BvaW50ZXI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIERlc2t0b3BJUkMgZXh0ZW5kcyBJbnRlcmFjdGlvbkNvbnRyb2xsZXIge1xyXG4gICAgY29udHJvbHMgOiBUcmFuc2Zvcm1Db250cm9scztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcih7fSk7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd0hlbHBlcigpIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgY29ubmVjdEV2ZW50KCkge1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBldmVudCA9PiB7XHJcbiAgICAgICAgICAgIGlmICggdGhpcy5jb250cm9scy5heGlzICkgcmV0dXJuXHJcbiAgICAgICAgICAgIHRoaXMucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoIHRoaXMuZ2V0Vmlld3BvcnRQb3MoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKSwgX21vZHVsZS5jYW1lcmEgKTtcclxuICAgICAgICAgICAgY29uc3QgaGl0cyA9IHRoaXMucmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCggX21vZHVsZS5zY2VuZUdyYXBoLCB0cnVlICk7XHJcbiAgICAgICAgICAgIHRoaXMub25JbnRlcnNlY3Rpb24oIGhpdHMgKTtcclxuICAgICAgICB9ICk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIG9uSW50ZXJzZWN0aW9uKCBoaXRzIDogQXJyYXk8YW55PiApIHtcclxuICAgICAgICBjb25zdCBoaXRNZXNoZXMgPSBoaXRzLmZpbHRlciggaCA9PiBoLm9iamVjdC5pc01lc2ggJiYgISAoIGZpbmRQYXJlbnRCeVR5cGUoIGgub2JqZWN0LCBUcmFuc2Zvcm1Db250cm9scyApICkgKTtcclxuXHJcbiAgICAgICAgaWYgKCBoaXRNZXNoZXMubGVuZ3RoID4gMCApIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9scy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBmaW5kUGFyZW50QnlUeXBlKCBoaXRNZXNoZXNbIDAgXS5vYmplY3QsIFRIUkVFLkdyb3VwICk7XHJcbiAgICAgICAgICAgIGlmICggZ3JvdXAgKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzLmF0dGFjaCggZ3JvdXAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHMuYXR0YWNoKCBoaXRNZXNoZXNbMF0ub2JqZWN0ICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5jb250cm9scy5kZXRhY2goKTtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9scy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUNvbnRyb2xzKCBjYW1lcmEsIGNhbnZhcyApIDogVHJhbnNmb3JtQ29udHJvbHMge1xyXG4gICAgICAgIHRoaXMuY29udHJvbHMgPSBuZXcgVHJhbnNmb3JtQ29udHJvbHMoIGNhbWVyYSwgY2FudmFzICk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHM7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIFZpcnR1YWxSZWFsaXR5SVJDIGV4dGVuZHMgSW50ZXJhY3Rpb25Db250cm9sbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCB7fSApO1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBDb21tYW5kUXVldWUgeyBcclxuICAgIGFycmF5IDogQXJyYXk8Q29tbWFuZD47XHJcbiAgICBcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgQXJyYXk8Q29tbWFuZD4oKTtcclxuICAgIH1cclxuXHJcbiAgICBpc0VtcHR5KCkgOiBCb29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNjZW5lIHtcclxuXHJcbiAgICByb290IDogVEhSRUUuU2NlbmU7XHJcbiAgICBhbmltYXRpb25PYmplY3RzIDogVEhSRUUuR3JvdXA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yb290ID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25PYmplY3RzID0gbmV3IFRIUkVFLkdyb3VwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdFNjZW5lKCkge1xyXG5cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIHtcclxuICAgIHN0YXRpYyByZW5kZXJlciA6IFRIUkVFLldlYkdMUmVuZGVyZXIgPSBudWxsO1xyXG4gICAgc3RhdGljIGNhbnZhcyA6IEhUTUxDYW52YXNFbGVtZW50ID0gbnVsbDtcclxuICAgIHN0YXRpYyBvcHRpb24gOiBSZW5kZXJPcHRpb25zID0geyBhbHBoYTogdHJ1ZSB9IGFzIFJlbmRlck9wdGlvbnM7XHJcbiAgICBzdGF0aWMgR2V0KCkge1xyXG4gICAgICAgIGlmICggISBSZW5kZXJlci5yZW5kZXJlciApIHtcclxuICAgICAgICAgICAgUmVuZGVyZXIuQ3JlYXRlKCB7fSBhcyBSZW5kZXJPcHRpb25zICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZW5kZXJlci5yZW5kZXJlcjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgQ3JlYXRlKCBvcHQgOiBSZW5kZXJPcHRpb25zICkgOiBUSFJFRS5XZWJHTFJlbmRlcmVyIHtcclxuICAgICAgICBSZW5kZXJlci5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCBvcHQgKTtcclxuICAgICAgICByZXR1cm4gUmVuZGVyZXIucmVuZGVyZXI7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIEFuaW1hdGlvbkxvb3AoIGZ1bmMgOiBGdW5jdGlvbiApIHtcclxuICAgICAgICBcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgUGFsbGV0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHsgICAgXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUGFsbGV0RW5naW5lIGV4dGVuZHMgUGFsbGV0RWxlbWVudCB7XHJcbiAgICBcclxuICAgIHNjZW5lR3JhcGggOiBUSFJFRS5TY2VuZTtcclxuICAgIGNhbWVyYSA6IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhO1xyXG4gICAgZGlyZWN0aW9uYWxMaWdodCA6IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQ7XHJcbiAgICBhbWJpZW50TGlnaHQgOiBUSFJFRS5BbWJpZW50TGlnaHQ7XHJcbiAgICBnbHRmTG9hZGVyIDogR0xURkxvYWRlcjtcclxuICAgIGNsb2NrIDogVEhSRUUuQ2xvY2s7XHJcbiAgICBjb250cm9sbGVyIDogT3JiaXRDb250cm9scztcclxuICAgIHVwZGF0ZUZ1bmN0aW9ucyA6IEFycmF5PEZ1bmN0aW9uPjtcclxuICAgIGNvbW1hbmRRdWV1ZSA6IENvbW1hbmRRdWV1ZTtcclxuICAgIGlyYyA6IEludGVyYWN0aW9uQ29udHJvbGxlcjtcclxuICAgICAgICAgICAgXHJcbiAgICBjb25zdHJ1Y3RvciggY2FudmFzIDogSFRNTENhbnZhc0VsZW1lbnQgKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnNjZW5lR3JhcGggPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggNzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwMDAgKTtcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbmFsTGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggMHhmZmZmZmYsIDEwICk7XHJcbiAgICAgICAgdGhpcy5hbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCAweGZmZjhlOCApO1xyXG4gICAgICAgIHRoaXMuZ2x0ZkxvYWRlciA9IG5ldyBHTFRGTG9hZGVyKCk7XHJcbiAgICAgICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBPcmJpdENvbnRyb2xzKCB0aGlzLmNhbWVyYSwgY2FudmFzICk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmVuYWJsZURhbXBpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlci5kYW1waW5nRmFjdG9yID0gMC4xO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRnVuY3Rpb25zID0gbmV3IEFycmF5PEZ1bmN0aW9uPigpO1xyXG4gICAgICAgIHRoaXMuY29tbWFuZFF1ZXVlID0gbmV3IENvbW1hbmRRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuaXJjID0gbmV3IERlc2t0b3BJUkMoKTtcclxuICAgICAgICB0aGlzLmlyYy5jb25uZWN0RXZlbnQoKTtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9ICggdGhpcy5pcmMgYXMgRGVza3RvcElSQyApLmNyZWF0ZUNvbnRyb2xzKCB0aGlzLmNhbWVyYSwgY2FudmFzICk7XHJcbiAgICAgICAgdGhpcy5zY2VuZUdyYXBoLmFkZCggdHJhbnNmb3JtZXIgKTtcclxuICAgICAgICB0cmFuc2Zvcm1lci5hZGRFdmVudExpc3RlbmVyKCAnZHJhZ2dpbmctY2hhbmdlZCcsIGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmVuYWJsZWQgPSAhIGV2ZW50LnZhbHVlO1xyXG4gICAgICAgIH0gKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBSZW5kZXJlci5DcmVhdGUoIHsgYW50aWFsaWFzOiB0cnVlLCBjYW52YXM6IGNhbnZhcyB9IGFzIFJlbmRlck9wdGlvbnMgKTtcclxuICAgICAgICByZW5kZXJlci5zZXRTaXplKCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0ICk7XHJcbiAgICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggMHgzYzNjM2MgKTtcclxuICAgICAgICByZW5kZXJlci5zZXRBbmltYXRpb25Mb29wKCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy5jbG9jay5nZXREZWx0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSggZHQgKTtcclxuICAgICAgICB9ICk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSggd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCApO1xyXG4gICAgICAgIH0gKVxyXG5cclxuICAgICAgICB0aGlzLmNyZWF0ZVNjZW5lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlU2NlbmUoKSB7XHJcbiAgICAgICAgY29uc3QgZ3JpZEhlbHBlciA6IFRIUkVFLkdyaWRIZWxwZXIgPSBuZXcgVEhSRUUuR3JpZEhlbHBlciggNTAsIDUwLCAweDdjN2M3YywgMHg1ZjVmNWYgKTtcclxuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQoIDAsIDAsIDUgKTtcclxuICAgICAgICB0aGlzLnNjZW5lR3JhcGguYWRkKCBncmlkSGVscGVyICk7XHJcbiAgICAgICAgdGhpcy5zY2VuZUdyYXBoLmFkZCggdGhpcy5kaXJlY3Rpb25hbExpZ2h0ICk7XHJcbiAgICAgICAgdGhpcy5zY2VuZUdyYXBoLmFkZCggdGhpcy5hbWJpZW50TGlnaHQgKTtcclxuXHJcbiAgICAgICAgLy9jcmVhdGUgdGVtcG9yYWwgb2JqZWN0XHJcblxyXG4gICAgICAgIGNvbnN0IGN1YmUgPSBuZXcgVEhSRUUuTWVzaCggbmV3IFRIUkVFLkJveEdlb21ldHJ5KCAxLCAxLCAxICksIG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCggeyBjb2xvcjogMHhmZmRmYmEgfSApICk7XHJcbiAgICAgICAgdGhpcy5zY2VuZUdyYXBoLmFkZCggY3ViZSApO1xyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZUZ1bmN0aW9ucy5wdXNoKCAoIGRlbHRhICkgPT4geyBcclxuICAgICAgICAgICAgY3ViZS5yb3RhdGlvbi54ICs9IDAuMDE7XHJcbiAgICAgICAgICAgIGN1YmUucm90YXRpb24ueSArPSAwLjAxO1xyXG4gICAgICAgIH0gKVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUVudmlyb25tZW50KCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBsb2FkR0xURiggdXJsIDogc3RyaW5nLCBvbmxvYWQgOiBGdW5jdGlvbiApIHtcclxuICAgICAgICB0aGlzLmdsdGZMb2FkZXIubG9hZCggdXJsICwgZ2x0ZiA9PiB7XHJcbiAgICAgICAgICAgIG9ubG9hZCggZ2x0ZiApO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lR3JhcGguYWRkKCBnbHRmLnNjZW5lICk7XHJcbiAgICAgICAgfSwgLyogb25Qcm9ncmVzcywgb25FcnJvciAqLyApO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSggZHQgOiBOdW1iZXIgKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVGdW5jdGlvbnMubWFwKCBmdW5jID0+IGZ1bmMoIGR0ICkgKTtcclxuICAgICAgICB0aGlzLmNvbW1hbmRRdWV1ZS51cGRhdGUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnVwZGF0ZSgpO1xyXG4gICAgICAgIFJlbmRlcmVyLkdldCgpLnJlbmRlciggdGhpcy5zY2VuZUdyYXBoLCB0aGlzLmNhbWVyYSApO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFVwZGF0b3IoIGZ1bmMgOiBGdW5jdGlvbiApIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUZ1bmN0aW9ucy5wdXNoKCBmdW5jICk7XHJcbiAgICB9XHJcblxyXG4gICAgYXBwZW5kQ29tbWFuZCgpIHtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSggJ3BhbGxldC1lbGVtZW50JywgUGFsbGV0RWxlbWVudCApO1xyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoICdwYWxsZXQtZW5naW5lJywgUGFsbGV0RW5naW5lICk7XHJcblxyXG5cclxubGV0IGNhbnZhc0VsZW1lbnRzIDogSFRNTENvbGxlY3Rpb25PZjxIVE1MQ2FudmFzRWxlbWVudD4gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJyApO1xyXG5leHBvcnQgbGV0IF9tb2R1bGUgOiBQYWxsZXRFbmdpbmU7XHJcblxyXG5pZiAoIGNhbnZhc0VsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNFbGVtZW50c1sgMCBdO1xyXG4gICAgX21vZHVsZSA9IG5ldyBQYWxsZXRFbmdpbmUoIGNhbnZhcyApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJUSFJFRSIsIkdMVEZMb2FkZXIiLCJPcmJpdENvbnRyb2xzIiwiVHJhbnNmb3JtQ29udHJvbHMiLCJjb21wdXRlQm91bmRzVHJlZSIsImRpc3Bvc2VCb3VuZHNUcmVlIiwiYWNjZWxlcmF0ZWRSYXljYXN0IiwiX3VzZVdlYkdQVSIsIl9wb2ludGVyIiwiVmVjdG9yMiIsIkJ1ZmZlckdlb21ldHJ5IiwicHJvdG90eXBlIiwiTWVzaCIsInJheWNhc3QiLCJQb3dlclByZWZlcmVuY2UiLCJmaW5kUGFyZW50QnlUeXBlIiwib2JqZWN0IiwidHlwZSIsInBhcmVudCIsIkNvbW1hbmQiLCJjb25zdHJ1Y3RvciIsIkludGVyYWN0aW9uQ29udHJvbGxlciIsImRyYXdIZWxwZXIiLCJjb25uZWN0RXZlbnQiLCJnZXRWaWV3cG9ydFBvcyIsIngiLCJ5IiwidGFyZ2V0IiwidW5kZWZpbmVkIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiY29weSIsIm9wdGlvbiIsInJheWNhc3RlciIsIlJheWNhc3RlciIsIkRlc2t0b3BJUkMiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImNvbnRyb2xzIiwiYXhpcyIsInNldEZyb21DYW1lcmEiLCJjbGllbnRYIiwiY2xpZW50WSIsIl9tb2R1bGUiLCJjYW1lcmEiLCJoaXRzIiwiaW50ZXJzZWN0T2JqZWN0Iiwic2NlbmVHcmFwaCIsIm9uSW50ZXJzZWN0aW9uIiwiaGl0TWVzaGVzIiwiZmlsdGVyIiwiaCIsImlzTWVzaCIsImxlbmd0aCIsImVuYWJsZWQiLCJncm91cCIsIkdyb3VwIiwiYXR0YWNoIiwiZGV0YWNoIiwiY3JlYXRlQ29udHJvbHMiLCJjYW52YXMiLCJWaXJ0dWFsUmVhbGl0eUlSQyIsIkNvbW1hbmRRdWV1ZSIsImlzRW1wdHkiLCJhcnJheSIsInVwZGF0ZSIsIkFycmF5IiwiU2NlbmUiLCJkZWZhdWx0U2NlbmUiLCJyb290IiwiYW5pbWF0aW9uT2JqZWN0cyIsIlJlbmRlcmVyIiwiR2V0IiwicmVuZGVyZXIiLCJDcmVhdGUiLCJvcHQiLCJXZWJHTFJlbmRlcmVyIiwiQW5pbWF0aW9uTG9vcCIsImZ1bmMiLCJhbHBoYSIsIlBhbGxldEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIlBhbGxldEVuZ2luZSIsImNyZWF0ZVNjZW5lIiwiZ3JpZEhlbHBlciIsIkdyaWRIZWxwZXIiLCJwb3NpdGlvbiIsInNldCIsImFkZCIsImRpcmVjdGlvbmFsTGlnaHQiLCJhbWJpZW50TGlnaHQiLCJjdWJlIiwiQm94R2VvbWV0cnkiLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsImNvbG9yIiwidXBkYXRlRnVuY3Rpb25zIiwicHVzaCIsImRlbHRhIiwicm90YXRpb24iLCJjcmVhdGVFbnZpcm9ubWVudCIsImxvYWRHTFRGIiwidXJsIiwib25sb2FkIiwiZ2x0ZkxvYWRlciIsImxvYWQiLCJnbHRmIiwic2NlbmUiLCJkdCIsIm1hcCIsImNvbW1hbmRRdWV1ZSIsImNvbnRyb2xsZXIiLCJyZW5kZXIiLCJhZGRVcGRhdG9yIiwiYXBwZW5kQ29tbWFuZCIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiRGlyZWN0aW9uYWxMaWdodCIsIkFtYmllbnRMaWdodCIsImNsb2NrIiwiQ2xvY2siLCJlbmFibGVEYW1waW5nIiwiZGFtcGluZ0ZhY3RvciIsImlyYyIsInRyYW5zZm9ybWVyIiwidmFsdWUiLCJhbnRpYWxpYXMiLCJzZXRTaXplIiwic2V0Q2xlYXJDb2xvciIsInNldEFuaW1hdGlvbkxvb3AiLCJnZXREZWx0YSIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSIsImNhbnZhc0VsZW1lbnRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./PalletEngine/module.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/Constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/Constants.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AVERAGE: function() { return /* binding */ AVERAGE; },\n/* harmony export */   BYTES_PER_NODE: function() { return /* binding */ BYTES_PER_NODE; },\n/* harmony export */   CENTER: function() { return /* binding */ CENTER; },\n/* harmony export */   CONTAINED: function() { return /* binding */ CONTAINED; },\n/* harmony export */   FLOAT32_EPSILON: function() { return /* binding */ FLOAT32_EPSILON; },\n/* harmony export */   INTERSECTED: function() { return /* binding */ INTERSECTED; },\n/* harmony export */   IS_LEAFNODE_FLAG: function() { return /* binding */ IS_LEAFNODE_FLAG; },\n/* harmony export */   NOT_INTERSECTED: function() { return /* binding */ NOT_INTERSECTED; },\n/* harmony export */   SAH: function() { return /* binding */ SAH; },\n/* harmony export */   SKIP_GENERATION: function() { return /* binding */ SKIP_GENERATION; },\n/* harmony export */   TRAVERSAL_COST: function() { return /* binding */ TRAVERSAL_COST; },\n/* harmony export */   TRIANGLE_INTERSECT_COST: function() { return /* binding */ TRIANGLE_INTERSECT_COST; }\n/* harmony export */ });\n// Split strategy constants\nconst CENTER = 0;\nconst AVERAGE = 1;\nconst SAH = 2;\n// Traversal constants\nconst NOT_INTERSECTED = 0;\nconst INTERSECTED = 1;\nconst CONTAINED = 2;\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nconst TRIANGLE_INTERSECT_COST = 1.25;\nconst TRAVERSAL_COST = 1;\n// Build constants\nconst BYTES_PER_NODE = 6 * 4 + 4 + 4;\nconst IS_LEAFNODE_FLAG = 0xFFFF;\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nconst FLOAT32_EPSILON = Math.pow(2, -24);\nconst SKIP_GENERATION = Symbol(\"SKIP_GENERATION\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9Db25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkJBQTJCO0FBQ3BCLE1BQU1BLFNBQVMsRUFBRTtBQUNqQixNQUFNQyxVQUFVLEVBQUU7QUFDbEIsTUFBTUMsTUFBTSxFQUFFO0FBRXJCLHNCQUFzQjtBQUNmLE1BQU1DLGtCQUFrQixFQUFFO0FBQzFCLE1BQU1DLGNBQWMsRUFBRTtBQUN0QixNQUFNQyxZQUFZLEVBQUU7QUFFM0IscUJBQXFCO0FBQ3JCLGtGQUFrRjtBQUNsRiwrRUFBK0U7QUFDL0UsVUFBVTtBQUNILE1BQU1DLDBCQUEwQixLQUFLO0FBQ3JDLE1BQU1DLGlCQUFpQixFQUFFO0FBR2hDLGtCQUFrQjtBQUNYLE1BQU1DLGlCQUFpQixJQUFJLElBQUksSUFBSSxFQUFFO0FBQ3JDLE1BQU1DLG1CQUFtQixPQUFPO0FBRXZDLDBEQUEwRDtBQUMxRCx3R0FBd0c7QUFDakcsTUFBTUMsa0JBQWtCQyxLQUFLQyxHQUFHLENBQUUsR0FBRyxDQUFFLElBQUs7QUFFNUMsTUFBTUMsa0JBQWtCQyxPQUFRLG1CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvQ29uc3RhbnRzLmpzPzg2MTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU3BsaXQgc3RyYXRlZ3kgY29uc3RhbnRzXG5leHBvcnQgY29uc3QgQ0VOVEVSID0gMDtcbmV4cG9ydCBjb25zdCBBVkVSQUdFID0gMTtcbmV4cG9ydCBjb25zdCBTQUggPSAyO1xuXG4vLyBUcmF2ZXJzYWwgY29uc3RhbnRzXG5leHBvcnQgY29uc3QgTk9UX0lOVEVSU0VDVEVEID0gMDtcbmV4cG9ydCBjb25zdCBJTlRFUlNFQ1RFRCA9IDE7XG5leHBvcnQgY29uc3QgQ09OVEFJTkVEID0gMjtcblxuLy8gU0FIIGNvc3QgY29uc3RhbnRzXG4vLyBUT0RPOiBob25lIHRoZXNlIGNvc3RzIG1vcmUuIFRoZSByZWxhdGl2ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlbSBzaG91bGQgYmUgdGhlXG4vLyBkaWZmZXJlbmNlIGluIG1lYXN1cmVkIHRpbWUgdG8gcGVyZm9ybSBhIHRyaWFuZ2xlIGludGVyc2VjdGlvbiB2cyB0cmF2ZXJzaW5nXG4vLyBib3VuZHMuXG5leHBvcnQgY29uc3QgVFJJQU5HTEVfSU5URVJTRUNUX0NPU1QgPSAxLjI1O1xuZXhwb3J0IGNvbnN0IFRSQVZFUlNBTF9DT1NUID0gMTtcblxuXG4vLyBCdWlsZCBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBCWVRFU19QRVJfTk9ERSA9IDYgKiA0ICsgNCArIDQ7XG5leHBvcnQgY29uc3QgSVNfTEVBRk5PREVfRkxBRyA9IDB4RkZGRjtcblxuLy8gRVBTSUxPTiBmb3IgY29tcHV0aW5nIGZsb2F0aW5nIHBvaW50IGVycm9yIGR1cmluZyBidWlsZFxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFjaGluZV9lcHNpbG9uI1ZhbHVlc19mb3Jfc3RhbmRhcmRfaGFyZHdhcmVfZmxvYXRpbmdfcG9pbnRfYXJpdGhtZXRpY3NcbmV4cG9ydCBjb25zdCBGTE9BVDMyX0VQU0lMT04gPSBNYXRoLnBvdyggMiwgLSAyNCApO1xuXG5leHBvcnQgY29uc3QgU0tJUF9HRU5FUkFUSU9OID0gU3ltYm9sKCAnU0tJUF9HRU5FUkFUSU9OJyApO1xuIl0sIm5hbWVzIjpbIkNFTlRFUiIsIkFWRVJBR0UiLCJTQUgiLCJOT1RfSU5URVJTRUNURUQiLCJJTlRFUlNFQ1RFRCIsIkNPTlRBSU5FRCIsIlRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUIiwiVFJBVkVSU0FMX0NPU1QiLCJCWVRFU19QRVJfTk9ERSIsIklTX0xFQUZOT0RFX0ZMQUciLCJGTE9BVDMyX0VQU0lMT04iLCJNYXRoIiwicG93IiwiU0tJUF9HRU5FUkFUSU9OIiwiU3ltYm9sIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/Constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/MeshBVH.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/MeshBVH.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_OPTIONS: function() { return /* binding */ DEFAULT_OPTIONS; },\n/* harmony export */   MeshBVH: function() { return /* binding */ MeshBVH; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Constants.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/Constants.js\");\n/* harmony import */ var _build_buildTree_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./build/buildTree.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/buildTree.js\");\n/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/OrientedBox.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/OrientedBox.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../utils/ArrayBoxUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/ExtendedTrianglePool.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js\");\n/* harmony import */ var _cast_shapecast_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./cast/shapecast.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/shapecast.js\");\n/* harmony import */ var _cast_closestPointToPoint_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./cast/closestPointToPoint.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js\");\n/* harmony import */ var _utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/iterationUtils.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js\");\n/* harmony import */ var _cast_refit_generated_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cast/refit.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/refit.generated.js\");\n/* harmony import */ var _cast_raycast_generated_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cast/raycast.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js\");\n/* harmony import */ var _cast_raycastFirst_generated_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cast/raycastFirst.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js\");\n/* harmony import */ var _cast_intersectsGeometry_generated_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cast/intersectsGeometry.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js\");\n/* harmony import */ var _cast_closestPointToGeometry_generated_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cast/closestPointToGeometry.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js\");\n/* harmony import */ var _utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/iterationUtils_indirect.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js\");\n/* harmony import */ var _cast_refit_indirect_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cast/refit_indirect.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js\");\n/* harmony import */ var _cast_raycast_indirect_generated_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cast/raycast_indirect.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js\");\n/* harmony import */ var _cast_raycastFirst_indirect_generated_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cast/raycastFirst_indirect.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js\");\n/* harmony import */ var _cast_intersectsGeometry_indirect_generated_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cast/intersectsGeometry_indirect.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js\");\n/* harmony import */ var _cast_closestPointToGeometry_indirect_generated_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./cast/closestPointToGeometry_indirect.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js\");\n/* harmony import */ var _utils_BufferUtils_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../utils/BufferUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/BufferUtils.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../utils/TriangleUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n/* harmony import */ var _cast_bvhcast_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./cast/bvhcast.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/bvhcast.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_0__.OrientedBox();\nconst tempBox = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_1__.Box3();\nconst DEFAULT_OPTIONS = {\n    strategy: _Constants_js__WEBPACK_IMPORTED_MODULE_2__.CENTER,\n    maxDepth: 40,\n    maxLeafTris: 10,\n    useSharedArrayBuffer: false,\n    setBoundingBox: true,\n    onProgress: null,\n    indirect: false,\n    verbose: true\n};\nclass MeshBVH {\n    static serialize(bvh) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        options = {\n            cloneBuffers: true,\n            ...options\n        };\n        const geometry = bvh.geometry;\n        const rootData = bvh._roots;\n        const indirectBuffer = bvh._indirectBuffer;\n        const indexAttribute = geometry.getIndex();\n        let result;\n        if (options.cloneBuffers) {\n            result = {\n                roots: rootData.map((root)=>root.slice()),\n                index: indexAttribute.array.slice(),\n                indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null\n            };\n        } else {\n            result = {\n                roots: rootData,\n                index: indexAttribute.array,\n                indirectBuffer: indirectBuffer\n            };\n        }\n        return result;\n    }\n    static deserialize(data, geometry) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        options = {\n            setIndex: true,\n            indirect: Boolean(data.indirectBuffer),\n            ...options\n        };\n        const { index, roots, indirectBuffer } = data;\n        const bvh = new MeshBVH(geometry, {\n            ...options,\n            [_Constants_js__WEBPACK_IMPORTED_MODULE_2__.SKIP_GENERATION]: true\n        });\n        bvh._roots = roots;\n        bvh._indirectBuffer = indirectBuffer || null;\n        if (options.setIndex) {\n            const indexAttribute = geometry.getIndex();\n            if (indexAttribute === null) {\n                const newIndex = new three__WEBPACK_IMPORTED_MODULE_1__.BufferAttribute(data.index, 1, false);\n                geometry.setIndex(newIndex);\n            } else if (indexAttribute.array !== index) {\n                indexAttribute.array.set(index);\n                indexAttribute.needsUpdate = true;\n            }\n        }\n        return bvh;\n    }\n    get indirect() {\n        return !!this._indirectBuffer;\n    }\n    refit() {\n        let nodeIndices = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n        const refitFunc = this.indirect ? _cast_refit_indirect_generated_js__WEBPACK_IMPORTED_MODULE_3__.refit_indirect : _cast_refit_generated_js__WEBPACK_IMPORTED_MODULE_4__.refit;\n        return refitFunc(this, nodeIndices);\n    }\n    traverse(callback) {\n        let rootIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        const buffer = this._roots[rootIndex];\n        const uint32Array = new Uint32Array(buffer);\n        const uint16Array = new Uint16Array(buffer);\n        _traverse(0);\n        function _traverse(node32Index) {\n            let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n            const node16Index = node32Index * 2;\n            const isLeaf = uint16Array[node16Index + 15] === _Constants_js__WEBPACK_IMPORTED_MODULE_2__.IS_LEAFNODE_FLAG;\n            if (isLeaf) {\n                const offset = uint32Array[node32Index + 6];\n                const count = uint16Array[node16Index + 14];\n                callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n            } else {\n                // TODO: use node functions here\n                const left = node32Index + _Constants_js__WEBPACK_IMPORTED_MODULE_2__.BYTES_PER_NODE / 4;\n                const right = uint32Array[node32Index + 6];\n                const splitAxis = uint32Array[node32Index + 7];\n                const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n                if (!stopTraversal) {\n                    _traverse(left, depth + 1);\n                    _traverse(right, depth + 1);\n                }\n            }\n        }\n    }\n    /* Core Cast Functions */ raycast(ray) {\n        let materialOrSide = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : three__WEBPACK_IMPORTED_MODULE_1__.FrontSide;\n        const roots = this._roots;\n        const geometry = this.geometry;\n        const intersects = [];\n        const isMaterial = materialOrSide.isMaterial;\n        const isArrayMaterial = Array.isArray(materialOrSide);\n        const groups = geometry.groups;\n        const side = isMaterial ? materialOrSide.side : materialOrSide;\n        const raycastFunc = this.indirect ? _cast_raycast_indirect_generated_js__WEBPACK_IMPORTED_MODULE_5__.raycast_indirect : _cast_raycast_generated_js__WEBPACK_IMPORTED_MODULE_6__.raycast;\n        for(let i = 0, l = roots.length; i < l; i++){\n            const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n            const startCount = intersects.length;\n            raycastFunc(this, i, materialSide, ray, intersects);\n            if (isArrayMaterial) {\n                const materialIndex = groups[i].materialIndex;\n                for(let j = startCount, jl = intersects.length; j < jl; j++){\n                    intersects[j].face.materialIndex = materialIndex;\n                }\n            }\n        }\n        return intersects;\n    }\n    raycastFirst(ray) {\n        let materialOrSide = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : three__WEBPACK_IMPORTED_MODULE_1__.FrontSide;\n        const roots = this._roots;\n        const geometry = this.geometry;\n        const isMaterial = materialOrSide.isMaterial;\n        const isArrayMaterial = Array.isArray(materialOrSide);\n        let closestResult = null;\n        const groups = geometry.groups;\n        const side = isMaterial ? materialOrSide.side : materialOrSide;\n        const raycastFirstFunc = this.indirect ? _cast_raycastFirst_indirect_generated_js__WEBPACK_IMPORTED_MODULE_7__.raycastFirst_indirect : _cast_raycastFirst_generated_js__WEBPACK_IMPORTED_MODULE_8__.raycastFirst;\n        for(let i = 0, l = roots.length; i < l; i++){\n            const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n            const result = raycastFirstFunc(this, i, materialSide, ray);\n            if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n                closestResult = result;\n                if (isArrayMaterial) {\n                    result.face.materialIndex = groups[i].materialIndex;\n                }\n            }\n        }\n        return closestResult;\n    }\n    intersectsGeometry(otherGeometry, geomToMesh) {\n        let result = false;\n        const roots = this._roots;\n        const intersectsGeometryFunc = this.indirect ? _cast_intersectsGeometry_indirect_generated_js__WEBPACK_IMPORTED_MODULE_9__.intersectsGeometry_indirect : _cast_intersectsGeometry_generated_js__WEBPACK_IMPORTED_MODULE_10__.intersectsGeometry;\n        for(let i = 0, l = roots.length; i < l; i++){\n            result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);\n            if (result) {\n                break;\n            }\n        }\n        return result;\n    }\n    shapecast(callbacks) {\n        const triangle = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_11__.ExtendedTrianglePool.getPrimitive();\n        const iterateFunc = this.indirect ? _utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_12__.iterateOverTriangles_indirect : _utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_13__.iterateOverTriangles;\n        let { boundsTraverseOrder, intersectsBounds, intersectsRange, intersectsTriangle } = callbacks;\n        // wrap the intersectsRange function\n        if (intersectsRange && intersectsTriangle) {\n            const originalIntersectsRange = intersectsRange;\n            intersectsRange = (offset, count, contained, depth, nodeIndex)=>{\n                if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n                    return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n                }\n                return true;\n            };\n        } else if (!intersectsRange) {\n            if (intersectsTriangle) {\n                intersectsRange = (offset, count, contained, depth)=>{\n                    return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n                };\n            } else {\n                intersectsRange = (offset, count, contained)=>{\n                    return contained;\n                };\n            }\n        }\n        // run shapecast\n        let result = false;\n        let byteOffset = 0;\n        const roots = this._roots;\n        for(let i = 0, l = roots.length; i < l; i++){\n            const root = roots[i];\n            result = (0,_cast_shapecast_js__WEBPACK_IMPORTED_MODULE_14__.shapecast)(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n            if (result) {\n                break;\n            }\n            byteOffset += root.byteLength;\n        }\n        _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_11__.ExtendedTrianglePool.releasePrimitive(triangle);\n        return result;\n    }\n    bvhcast(otherBvh, matrixToLocal, callbacks) {\n        let { intersectsRanges, intersectsTriangles } = callbacks;\n        const triangle1 = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_11__.ExtendedTrianglePool.getPrimitive();\n        const indexAttr1 = this.geometry.index;\n        const positionAttr1 = this.geometry.attributes.position;\n        const assignTriangle1 = this.indirect ? (i1)=>{\n            const ti = this.resolveTriangleIndex(i1);\n            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_15__.setTriangle)(triangle1, ti * 3, indexAttr1, positionAttr1);\n        } : (i1)=>{\n            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_15__.setTriangle)(triangle1, i1 * 3, indexAttr1, positionAttr1);\n        };\n        const triangle2 = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_11__.ExtendedTrianglePool.getPrimitive();\n        const indexAttr2 = otherBvh.geometry.index;\n        const positionAttr2 = otherBvh.geometry.attributes.position;\n        const assignTriangle2 = otherBvh.indirect ? (i2)=>{\n            const ti2 = otherBvh.resolveTriangleIndex(i2);\n            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_15__.setTriangle)(triangle2, ti2 * 3, indexAttr2, positionAttr2);\n        } : (i2)=>{\n            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_15__.setTriangle)(triangle2, i2 * 3, indexAttr2, positionAttr2);\n        };\n        // generate triangle callback if needed\n        if (intersectsTriangles) {\n            const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2)=>{\n                for(let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++){\n                    assignTriangle2(i2);\n                    triangle2.a.applyMatrix4(matrixToLocal);\n                    triangle2.b.applyMatrix4(matrixToLocal);\n                    triangle2.c.applyMatrix4(matrixToLocal);\n                    triangle2.needsUpdate = true;\n                    for(let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++){\n                        assignTriangle1(i1);\n                        triangle1.needsUpdate = true;\n                        if (intersectsTriangles(triangle1, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            };\n            if (intersectsRanges) {\n                const originalIntersectsRanges = intersectsRanges;\n                intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n                    if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n                        return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n                    }\n                    return true;\n                };\n            } else {\n                intersectsRanges = iterateOverDoubleTriangles;\n            }\n        }\n        return (0,_cast_bvhcast_js__WEBPACK_IMPORTED_MODULE_16__.bvhcast)(this, otherBvh, matrixToLocal, intersectsRanges);\n    }\n    /* Derived Cast Functions */ intersectsBox(box, boxToMesh) {\n        obb.set(box.min, box.max, boxToMesh);\n        obb.needsUpdate = true;\n        return this.shapecast({\n            intersectsBounds: (box)=>obb.intersectsBox(box),\n            intersectsTriangle: (tri)=>obb.intersectsTriangle(tri)\n        });\n    }\n    intersectsSphere(sphere) {\n        return this.shapecast({\n            intersectsBounds: (box)=>sphere.intersectsBox(box),\n            intersectsTriangle: (tri)=>tri.intersectsSphere(sphere)\n        });\n    }\n    closestPointToGeometry(otherGeometry, geometryToBvh) {\n        let target1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, target2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, minThreshold = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, maxThreshold = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : Infinity;\n        const closestPointToGeometryFunc = this.indirect ? _cast_closestPointToGeometry_indirect_generated_js__WEBPACK_IMPORTED_MODULE_17__.closestPointToGeometry_indirect : _cast_closestPointToGeometry_generated_js__WEBPACK_IMPORTED_MODULE_18__.closestPointToGeometry;\n        return closestPointToGeometryFunc(this, otherGeometry, geometryToBvh, target1, target2, minThreshold, maxThreshold);\n    }\n    closestPointToPoint(point) {\n        let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, minThreshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, maxThreshold = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Infinity;\n        return (0,_cast_closestPointToPoint_js__WEBPACK_IMPORTED_MODULE_19__.closestPointToPoint)(this, point, target, minThreshold, maxThreshold);\n    }\n    getBoundingBox(target) {\n        target.makeEmpty();\n        const roots = this._roots;\n        roots.forEach((buffer)=>{\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_20__.arrayToBox)(0, new Float32Array(buffer), tempBox);\n            target.union(tempBox);\n        });\n        return target;\n    }\n    constructor(geometry, options = {}){\n        if (!geometry.isBufferGeometry) {\n            throw new Error(\"MeshBVH: Only BufferGeometries are supported.\");\n        } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n            throw new Error(\"MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.\");\n        }\n        // default options\n        options = Object.assign({\n            ...DEFAULT_OPTIONS,\n            // undocumented options\n            // Whether to skip generating the tree. Used for deserialization.\n            [_Constants_js__WEBPACK_IMPORTED_MODULE_2__.SKIP_GENERATION]: false\n        }, options);\n        if (options.useSharedArrayBuffer && !(0,_utils_BufferUtils_js__WEBPACK_IMPORTED_MODULE_21__.isSharedArrayBufferSupported)()) {\n            throw new Error(\"MeshBVH: SharedArrayBuffer is not available.\");\n        }\n        // retain references to the geometry so we can use them it without having to\n        // take a geometry reference in every function.\n        this.geometry = geometry;\n        this._roots = null;\n        this._indirectBuffer = null;\n        if (!options[_Constants_js__WEBPACK_IMPORTED_MODULE_2__.SKIP_GENERATION]) {\n            (0,_build_buildTree_js__WEBPACK_IMPORTED_MODULE_22__.buildPackedTree)(this, options);\n            if (!geometry.boundingBox && options.setBoundingBox) {\n                geometry.boundingBox = this.getBoundingBox(new three__WEBPACK_IMPORTED_MODULE_1__.Box3());\n            }\n        }\n        const { _indirectBuffer } = this;\n        this.resolveTriangleIndex = options.indirect ? (i)=>_indirectBuffer[i] : (i)=>i;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9NZXNoQlZILmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDa0M7QUFDcEM7QUFDRjtBQUNNO0FBQ2E7QUFDeEI7QUFDb0I7QUFFTztBQUN6QjtBQUNJO0FBQ1U7QUFDWTtBQUNRO0FBRVM7QUFDekI7QUFDSTtBQUNVO0FBQ1k7QUFDUTtBQUMvQjtBQUNYO0FBQ2hCO0FBRTVDLE1BQU00QixNQUFNLGFBQWEsR0FBRyxJQUFJcEIsNkRBQVdBO0FBQzNDLE1BQU1xQixVQUFVLGFBQWEsR0FBRyxJQUFJNUIsdUNBQUlBO0FBQ2pDLE1BQU02QixrQkFBa0I7SUFDOUJDLFVBQVU1QixpREFBTUE7SUFDaEI2QixVQUFVO0lBQ1ZDLGFBQWE7SUFDYkMsc0JBQXNCO0lBQ3RCQyxnQkFBZ0I7SUFDaEJDLFlBQVk7SUFDWkMsVUFBVTtJQUNWQyxTQUFTO0FBQ1YsRUFBRTtBQUVLLE1BQU1DO0lBRVosT0FBT0MsVUFBV0MsR0FBRyxFQUFpQjtZQUFmQyxVQUFBQSxpRUFBVSxDQUFDO1FBRWpDQSxVQUFVO1lBQ1RDLGNBQWM7WUFDZCxHQUFHRCxPQUFPO1FBQ1g7UUFFQSxNQUFNRSxXQUFXSCxJQUFJRyxRQUFRO1FBQzdCLE1BQU1DLFdBQVdKLElBQUlLLE1BQU07UUFDM0IsTUFBTUMsaUJBQWlCTixJQUFJTyxlQUFlO1FBQzFDLE1BQU1DLGlCQUFpQkwsU0FBU00sUUFBUTtRQUN4QyxJQUFJQztRQUNKLElBQUtULFFBQVFDLFlBQVksRUFBRztZQUUzQlEsU0FBUztnQkFDUkMsT0FBT1AsU0FBU1EsR0FBRyxDQUFFQyxDQUFBQSxPQUFRQSxLQUFLQyxLQUFLO2dCQUN2Q0MsT0FBT1AsZUFBZVEsS0FBSyxDQUFDRixLQUFLO2dCQUNqQ1IsZ0JBQWdCQSxpQkFBaUJBLGVBQWVRLEtBQUssS0FBSztZQUMzRDtRQUVELE9BQU87WUFF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QUFlLEVBQUUsR0FBRyxJQUFJO1FBQ2hDLElBQUksQ0FBQzBGLG9CQUFvQixHQUFHaEcsUUFBUUwsUUFBUSxHQUFHNEQsQ0FBQUEsSUFBS2pELGVBQWUsQ0FBRWlELEVBQUcsR0FBR0EsQ0FBQUEsSUFBS0E7SUFFakY7QUE4WEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL01lc2hCVkguanM/NDRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUsIEJveDMsIEZyb250U2lkZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IENFTlRFUiwgQllURVNfUEVSX05PREUsIElTX0xFQUZOT0RFX0ZMQUcsIFNLSVBfR0VORVJBVElPTiB9IGZyb20gJy4vQ29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGJ1aWxkUGFja2VkVHJlZSB9IGZyb20gJy4vYnVpbGQvYnVpbGRUcmVlLmpzJztcbmltcG9ydCB7IE9yaWVudGVkQm94IH0gZnJvbSAnLi4vbWF0aC9PcmllbnRlZEJveC5qcyc7XG5pbXBvcnQgeyBhcnJheVRvQm94IH0gZnJvbSAnLi4vdXRpbHMvQXJyYXlCb3hVdGlsaXRpZXMuanMnO1xuaW1wb3J0IHsgRXh0ZW5kZWRUcmlhbmdsZVBvb2wgfSBmcm9tICcuLi91dGlscy9FeHRlbmRlZFRyaWFuZ2xlUG9vbC5qcyc7XG5pbXBvcnQgeyBzaGFwZWNhc3QgfSBmcm9tICcuL2Nhc3Qvc2hhcGVjYXN0LmpzJztcbmltcG9ydCB7IGNsb3Nlc3RQb2ludFRvUG9pbnQgfSBmcm9tICcuL2Nhc3QvY2xvc2VzdFBvaW50VG9Qb2ludC5qcyc7XG5cbmltcG9ydCB7IGl0ZXJhdGVPdmVyVHJpYW5nbGVzIH0gZnJvbSAnLi91dGlscy9pdGVyYXRpb25VdGlscy5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgcmVmaXQgfSBmcm9tICcuL2Nhc3QvcmVmaXQuZ2VuZXJhdGVkLmpzJztcbmltcG9ydCB7IHJheWNhc3QgfSBmcm9tICcuL2Nhc3QvcmF5Y2FzdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgcmF5Y2FzdEZpcnN0IH0gZnJvbSAnLi9jYXN0L3JheWNhc3RGaXJzdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgaW50ZXJzZWN0c0dlb21ldHJ5IH0gZnJvbSAnLi9jYXN0L2ludGVyc2VjdHNHZW9tZXRyeS5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgY2xvc2VzdFBvaW50VG9HZW9tZXRyeSB9IGZyb20gJy4vY2FzdC9jbG9zZXN0UG9pbnRUb0dlb21ldHJ5LmdlbmVyYXRlZC5qcyc7XG5cbmltcG9ydCB7IGl0ZXJhdGVPdmVyVHJpYW5nbGVzX2luZGlyZWN0IH0gZnJvbSAnLi91dGlscy9pdGVyYXRpb25VdGlsc19pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgcmVmaXRfaW5kaXJlY3QgfSBmcm9tICcuL2Nhc3QvcmVmaXRfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzJztcbmltcG9ydCB7IHJheWNhc3RfaW5kaXJlY3QgfSBmcm9tICcuL2Nhc3QvcmF5Y2FzdF9pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgcmF5Y2FzdEZpcnN0X2luZGlyZWN0IH0gZnJvbSAnLi9jYXN0L3JheWNhc3RGaXJzdF9pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0IH0gZnJvbSAnLi9jYXN0L2ludGVyc2VjdHNHZW9tZXRyeV9pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgY2xvc2VzdFBvaW50VG9HZW9tZXRyeV9pbmRpcmVjdCB9IGZyb20gJy4vY2FzdC9jbG9zZXN0UG9pbnRUb0dlb21ldHJ5X2luZGlyZWN0LmdlbmVyYXRlZC5qcyc7XG5pbXBvcnQgeyBpc1NoYXJlZEFycmF5QnVmZmVyU3VwcG9ydGVkIH0gZnJvbSAnLi4vdXRpbHMvQnVmZmVyVXRpbHMuanMnO1xuaW1wb3J0IHsgc2V0VHJpYW5nbGUgfSBmcm9tICcuLi91dGlscy9UcmlhbmdsZVV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBidmhjYXN0IH0gZnJvbSAnLi9jYXN0L2J2aGNhc3QuanMnO1xuXG5jb25zdCBvYmIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5jb25zdCB0ZW1wQm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBCb3gzKCk7XG5leHBvcnQgY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuXHRzdHJhdGVneTogQ0VOVEVSLFxuXHRtYXhEZXB0aDogNDAsXG5cdG1heExlYWZUcmlzOiAxMCxcblx0dXNlU2hhcmVkQXJyYXlCdWZmZXI6IGZhbHNlLFxuXHRzZXRCb3VuZGluZ0JveDogdHJ1ZSxcblx0b25Qcm9ncmVzczogbnVsbCxcblx0aW5kaXJlY3Q6IGZhbHNlLFxuXHR2ZXJib3NlOiB0cnVlLFxufTtcblxuZXhwb3J0IGNsYXNzIE1lc2hCVkgge1xuXG5cdHN0YXRpYyBzZXJpYWxpemUoIGJ2aCwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0b3B0aW9ucyA9IHtcblx0XHRcdGNsb25lQnVmZmVyczogdHJ1ZSxcblx0XHRcdC4uLm9wdGlvbnMsXG5cdFx0fTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IHJvb3REYXRhID0gYnZoLl9yb290cztcblx0XHRjb25zdCBpbmRpcmVjdEJ1ZmZlciA9IGJ2aC5faW5kaXJlY3RCdWZmZXI7XG5cdFx0Y29uc3QgaW5kZXhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdGxldCByZXN1bHQ7XG5cdFx0aWYgKCBvcHRpb25zLmNsb25lQnVmZmVycyApIHtcblxuXHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRyb290czogcm9vdERhdGEubWFwKCByb290ID0+IHJvb3Quc2xpY2UoKSApLFxuXHRcdFx0XHRpbmRleDogaW5kZXhBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSxcblx0XHRcdFx0aW5kaXJlY3RCdWZmZXI6IGluZGlyZWN0QnVmZmVyID8gaW5kaXJlY3RCdWZmZXIuc2xpY2UoKSA6IG51bGwsXG5cdFx0XHR9O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRyb290czogcm9vdERhdGEsXG5cdFx0XHRcdGluZGV4OiBpbmRleEF0dHJpYnV0ZS5hcnJheSxcblx0XHRcdFx0aW5kaXJlY3RCdWZmZXI6IGluZGlyZWN0QnVmZmVyLFxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdHN0YXRpYyBkZXNlcmlhbGl6ZSggZGF0YSwgZ2VvbWV0cnksIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRzZXRJbmRleDogdHJ1ZSxcblx0XHRcdGluZGlyZWN0OiBCb29sZWFuKCBkYXRhLmluZGlyZWN0QnVmZmVyICksXG5cdFx0XHQuLi5vcHRpb25zLFxuXHRcdH07XG5cblx0XHRjb25zdCB7IGluZGV4LCByb290cywgaW5kaXJlY3RCdWZmZXIgfSA9IGRhdGE7XG5cdFx0Y29uc3QgYnZoID0gbmV3IE1lc2hCVkgoIGdlb21ldHJ5LCB7IC4uLm9wdGlvbnMsIFsgU0tJUF9HRU5FUkFUSU9OIF06IHRydWUgfSApO1xuXHRcdGJ2aC5fcm9vdHMgPSByb290cztcblx0XHRidmguX2luZGlyZWN0QnVmZmVyID0gaW5kaXJlY3RCdWZmZXIgfHwgbnVsbDtcblxuXHRcdGlmICggb3B0aW9ucy5zZXRJbmRleCApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdFx0aWYgKCBpbmRleEF0dHJpYnV0ZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zdCBuZXdJbmRleCA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGRhdGEuaW5kZXgsIDEsIGZhbHNlICk7XG5cdFx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXdJbmRleCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBpbmRleEF0dHJpYnV0ZS5hcnJheSAhPT0gaW5kZXggKSB7XG5cblx0XHRcdFx0aW5kZXhBdHRyaWJ1dGUuYXJyYXkuc2V0KCBpbmRleCApO1xuXHRcdFx0XHRpbmRleEF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBidmg7XG5cblx0fVxuXG5cdGdldCBpbmRpcmVjdCgpIHtcblxuXHRcdHJldHVybiAhICEgdGhpcy5faW5kaXJlY3RCdWZmZXI7XG5cblx0fVxuXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0aWYgKCAhIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ01lc2hCVkg6IE9ubHkgQnVmZmVyR2VvbWV0cmllcyBhcmUgc3VwcG9ydGVkLicgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmluZGV4ICYmIGdlb21ldHJ5LmluZGV4LmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ01lc2hCVkg6IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoZSBpbmRleCBhdHRyaWJ1dGUuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZGVmYXVsdCBvcHRpb25zXG5cdFx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHtcblxuXHRcdFx0Li4uREVGQVVMVF9PUFRJT05TLFxuXG5cdFx0XHQvLyB1bmRvY3VtZW50ZWQgb3B0aW9uc1xuXG5cdFx0XHQvLyBXaGV0aGVyIHRvIHNraXAgZ2VuZXJhdGluZyB0aGUgdHJlZS4gVXNlZCBmb3IgZGVzZXJpYWxpemF0aW9uLlxuXHRcdFx0WyBTS0lQX0dFTkVSQVRJT04gXTogZmFsc2UsXG5cblx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRpZiAoIG9wdGlvbnMudXNlU2hhcmVkQXJyYXlCdWZmZXIgJiYgISBpc1NoYXJlZEFycmF5QnVmZmVyU3VwcG9ydGVkKCkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ01lc2hCVkg6IFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGUuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmV0YWluIHJlZmVyZW5jZXMgdG8gdGhlIGdlb21ldHJ5IHNvIHdlIGNhbiB1c2UgdGhlbSBpdCB3aXRob3V0IGhhdmluZyB0b1xuXHRcdC8vIHRha2UgYSBnZW9tZXRyeSByZWZlcmVuY2UgaW4gZXZlcnkgZnVuY3Rpb24uXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdHRoaXMuX3Jvb3RzID0gbnVsbDtcblx0XHR0aGlzLl9pbmRpcmVjdEJ1ZmZlciA9IG51bGw7XG5cdFx0aWYgKCAhIG9wdGlvbnNbIFNLSVBfR0VORVJBVElPTiBdICkge1xuXG5cdFx0XHRidWlsZFBhY2tlZFRyZWUoIHRoaXMsIG9wdGlvbnMgKTtcblxuXHRcdFx0aWYgKCAhIGdlb21ldHJ5LmJvdW5kaW5nQm94ICYmIG9wdGlvbnMuc2V0Qm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCBuZXcgQm94MygpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IHsgX2luZGlyZWN0QnVmZmVyIH0gPSB0aGlzO1xuXHRcdHRoaXMucmVzb2x2ZVRyaWFuZ2xlSW5kZXggPSBvcHRpb25zLmluZGlyZWN0ID8gaSA9PiBfaW5kaXJlY3RCdWZmZXJbIGkgXSA6IGkgPT4gaTtcblxuXHR9XG5cblx0cmVmaXQoIG5vZGVJbmRpY2VzID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IHJlZml0RnVuYyA9IHRoaXMuaW5kaXJlY3QgPyByZWZpdF9pbmRpcmVjdCA6IHJlZml0O1xuXHRcdHJldHVybiByZWZpdEZ1bmMoIHRoaXMsIG5vZGVJbmRpY2VzICk7XG5cblx0fVxuXG5cdHRyYXZlcnNlKCBjYWxsYmFjaywgcm9vdEluZGV4ID0gMCApIHtcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3Jvb3RzWyByb290SW5kZXggXTtcblx0XHRjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cdFx0Y29uc3QgdWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGJ1ZmZlciApO1xuXHRcdF90cmF2ZXJzZSggMCApO1xuXG5cdFx0ZnVuY3Rpb24gX3RyYXZlcnNlKCBub2RlMzJJbmRleCwgZGVwdGggPSAwICkge1xuXG5cdFx0XHRjb25zdCBub2RlMTZJbmRleCA9IG5vZGUzMkluZGV4ICogMjtcblx0XHRcdGNvbnN0IGlzTGVhZiA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE1IF0gPT09IElTX0xFQUZOT0RFX0ZMQUc7XG5cdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gdWludDE2QXJyYXlbIG5vZGUxNkluZGV4ICsgMTQgXTtcblx0XHRcdFx0Y2FsbGJhY2soIGRlcHRoLCBpc0xlYWYsIG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciwgbm9kZTMySW5kZXggKiA0LCA2ICksIG9mZnNldCwgY291bnQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBUT0RPOiB1c2Ugbm9kZSBmdW5jdGlvbnMgaGVyZVxuXHRcdFx0XHRjb25zdCBsZWZ0ID0gbm9kZTMySW5kZXggKyBCWVRFU19QRVJfTk9ERSAvIDQ7XG5cdFx0XHRcdGNvbnN0IHJpZ2h0ID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNiBdO1xuXHRcdFx0XHRjb25zdCBzcGxpdEF4aXMgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA3IF07XG5cdFx0XHRcdGNvbnN0IHN0b3BUcmF2ZXJzYWwgPSBjYWxsYmFjayggZGVwdGgsIGlzTGVhZiwgbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyLCBub2RlMzJJbmRleCAqIDQsIDYgKSwgc3BsaXRBeGlzICk7XG5cblx0XHRcdFx0aWYgKCAhIHN0b3BUcmF2ZXJzYWwgKSB7XG5cblx0XHRcdFx0XHRfdHJhdmVyc2UoIGxlZnQsIGRlcHRoICsgMSApO1xuXHRcdFx0XHRcdF90cmF2ZXJzZSggcmlnaHQsIGRlcHRoICsgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKiBDb3JlIENhc3QgRnVuY3Rpb25zICovXG5cdHJheWNhc3QoIHJheSwgbWF0ZXJpYWxPclNpZGUgPSBGcm9udFNpZGUgKSB7XG5cblx0XHRjb25zdCByb290cyA9IHRoaXMuX3Jvb3RzO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBpbnRlcnNlY3RzID0gW107XG5cdFx0Y29uc3QgaXNNYXRlcmlhbCA9IG1hdGVyaWFsT3JTaWRlLmlzTWF0ZXJpYWw7XG5cdFx0Y29uc3QgaXNBcnJheU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWxPclNpZGUgKTtcblxuXHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRjb25zdCBzaWRlID0gaXNNYXRlcmlhbCA/IG1hdGVyaWFsT3JTaWRlLnNpZGUgOiBtYXRlcmlhbE9yU2lkZTtcblx0XHRjb25zdCByYXljYXN0RnVuYyA9IHRoaXMuaW5kaXJlY3QgPyByYXljYXN0X2luZGlyZWN0IDogcmF5Y2FzdDtcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBtYXRlcmlhbFNpZGUgPSBpc0FycmF5TWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZVsgZ3JvdXBzWyBpIF0ubWF0ZXJpYWxJbmRleCBdLnNpZGUgOiBzaWRlO1xuXHRcdFx0Y29uc3Qgc3RhcnRDb3VudCA9IGludGVyc2VjdHMubGVuZ3RoO1xuXG5cdFx0XHRyYXljYXN0RnVuYyggdGhpcywgaSwgbWF0ZXJpYWxTaWRlLCByYXksIGludGVyc2VjdHMgKTtcblxuXHRcdFx0aWYgKCBpc0FycmF5TWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxJbmRleCA9IGdyb3Vwc1sgaSBdLm1hdGVyaWFsSW5kZXg7XG5cdFx0XHRcdGZvciAoIGxldCBqID0gc3RhcnRDb3VudCwgamwgPSBpbnRlcnNlY3RzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1sgaiBdLmZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHR9XG5cblx0cmF5Y2FzdEZpcnN0KCByYXksIG1hdGVyaWFsT3JTaWRlID0gRnJvbnRTaWRlICkge1xuXG5cdFx0Y29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgaXNNYXRlcmlhbCA9IG1hdGVyaWFsT3JTaWRlLmlzTWF0ZXJpYWw7XG5cdFx0Y29uc3QgaXNBcnJheU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWxPclNpZGUgKTtcblxuXHRcdGxldCBjbG9zZXN0UmVzdWx0ID0gbnVsbDtcblxuXHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRjb25zdCBzaWRlID0gaXNNYXRlcmlhbCA/IG1hdGVyaWFsT3JTaWRlLnNpZGUgOiBtYXRlcmlhbE9yU2lkZTtcblx0XHRjb25zdCByYXljYXN0Rmlyc3RGdW5jID0gdGhpcy5pbmRpcmVjdCA/IHJheWNhc3RGaXJzdF9pbmRpcmVjdCA6IHJheWNhc3RGaXJzdDtcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBtYXRlcmlhbFNpZGUgPSBpc0FycmF5TWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZVsgZ3JvdXBzWyBpIF0ubWF0ZXJpYWxJbmRleCBdLnNpZGUgOiBzaWRlO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gcmF5Y2FzdEZpcnN0RnVuYyggdGhpcywgaSwgbWF0ZXJpYWxTaWRlLCByYXkgKTtcblx0XHRcdGlmICggcmVzdWx0ICE9IG51bGwgJiYgKCBjbG9zZXN0UmVzdWx0ID09IG51bGwgfHwgcmVzdWx0LmRpc3RhbmNlIDwgY2xvc2VzdFJlc3VsdC5kaXN0YW5jZSApICkge1xuXG5cdFx0XHRcdGNsb3Nlc3RSZXN1bHQgPSByZXN1bHQ7XG5cdFx0XHRcdGlmICggaXNBcnJheU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0cmVzdWx0LmZhY2UubWF0ZXJpYWxJbmRleCA9IGdyb3Vwc1sgaSBdLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvc2VzdFJlc3VsdDtcblxuXHR9XG5cblx0aW50ZXJzZWN0c0dlb21ldHJ5KCBvdGhlckdlb21ldHJ5LCBnZW9tVG9NZXNoICkge1xuXG5cdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0Y29uc3QgaW50ZXJzZWN0c0dlb21ldHJ5RnVuYyA9IHRoaXMuaW5kaXJlY3QgPyBpbnRlcnNlY3RzR2VvbWV0cnlfaW5kaXJlY3QgOiBpbnRlcnNlY3RzR2VvbWV0cnk7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0cmVzdWx0ID0gaW50ZXJzZWN0c0dlb21ldHJ5RnVuYyggdGhpcywgaSwgb3RoZXJHZW9tZXRyeSwgZ2VvbVRvTWVzaCApO1xuXG5cdFx0XHRpZiAoIHJlc3VsdCApIHtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0c2hhcGVjYXN0KCBjYWxsYmFja3MgKSB7XG5cblx0XHRjb25zdCB0cmlhbmdsZSA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdGNvbnN0IGl0ZXJhdGVGdW5jID0gdGhpcy5pbmRpcmVjdCA/IGl0ZXJhdGVPdmVyVHJpYW5nbGVzX2luZGlyZWN0IDogaXRlcmF0ZU92ZXJUcmlhbmdsZXM7XG5cdFx0bGV0IHtcblx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXIsXG5cdFx0XHRpbnRlcnNlY3RzQm91bmRzLFxuXHRcdFx0aW50ZXJzZWN0c1JhbmdlLFxuXHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlLFxuXHRcdH0gPSBjYWxsYmFja3M7XG5cblx0XHQvLyB3cmFwIHRoZSBpbnRlcnNlY3RzUmFuZ2UgZnVuY3Rpb25cblx0XHRpZiAoIGludGVyc2VjdHNSYW5nZSAmJiBpbnRlcnNlY3RzVHJpYW5nbGUgKSB7XG5cblx0XHRcdGNvbnN0IG9yaWdpbmFsSW50ZXJzZWN0c1JhbmdlID0gaW50ZXJzZWN0c1JhbmdlO1xuXHRcdFx0aW50ZXJzZWN0c1JhbmdlID0gKCBvZmZzZXQsIGNvdW50LCBjb250YWluZWQsIGRlcHRoLCBub2RlSW5kZXggKSA9PiB7XG5cblx0XHRcdFx0aWYgKCAhIG9yaWdpbmFsSW50ZXJzZWN0c1JhbmdlKCBvZmZzZXQsIGNvdW50LCBjb250YWluZWQsIGRlcHRoLCBub2RlSW5kZXggKSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBpdGVyYXRlRnVuYyggb2Zmc2V0LCBjb3VudCwgdGhpcywgaW50ZXJzZWN0c1RyaWFuZ2xlLCBjb250YWluZWQsIGRlcHRoLCB0cmlhbmdsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fTtcblxuXHRcdH0gZWxzZSBpZiAoICEgaW50ZXJzZWN0c1JhbmdlICkge1xuXG5cdFx0XHRpZiAoIGludGVyc2VjdHNUcmlhbmdsZSApIHtcblxuXHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2UgPSAoIG9mZnNldCwgY291bnQsIGNvbnRhaW5lZCwgZGVwdGggKSA9PiB7XG5cblx0XHRcdFx0XHRyZXR1cm4gaXRlcmF0ZUZ1bmMoIG9mZnNldCwgY291bnQsIHRoaXMsIGludGVyc2VjdHNUcmlhbmdsZSwgY29udGFpbmVkLCBkZXB0aCwgdHJpYW5nbGUgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZSA9ICggb2Zmc2V0LCBjb3VudCwgY29udGFpbmVkICkgPT4ge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGNvbnRhaW5lZDtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBydW4gc2hhcGVjYXN0XG5cdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXHRcdGxldCBieXRlT2Zmc2V0ID0gMDtcblx0XHRjb25zdCByb290cyA9IHRoaXMuX3Jvb3RzO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHJvb3QgPSByb290c1sgaSBdO1xuXHRcdFx0cmVzdWx0ID0gc2hhcGVjYXN0KCB0aGlzLCBpLCBpbnRlcnNlY3RzQm91bmRzLCBpbnRlcnNlY3RzUmFuZ2UsIGJvdW5kc1RyYXZlcnNlT3JkZXIsIGJ5dGVPZmZzZXQgKTtcblxuXHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0Ynl0ZU9mZnNldCArPSByb290LmJ5dGVMZW5ndGg7XG5cblx0XHR9XG5cblx0XHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZSApO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0YnZoY2FzdCggb3RoZXJCdmgsIG1hdHJpeFRvTG9jYWwsIGNhbGxiYWNrcyApIHtcblxuXHRcdGxldCB7XG5cdFx0XHRpbnRlcnNlY3RzUmFuZ2VzLFxuXHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlcyxcblx0XHR9ID0gY2FsbGJhY2tzO1xuXG5cdFx0Y29uc3QgdHJpYW5nbGUxID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0Y29uc3QgaW5kZXhBdHRyMSA9IHRoaXMuZ2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyMSA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBhc3NpZ25UcmlhbmdsZTEgPSB0aGlzLmluZGlyZWN0ID9cblx0XHRcdGkxID0+IHtcblxuXG5cdFx0XHRcdGNvbnN0IHRpID0gdGhpcy5yZXNvbHZlVHJpYW5nbGVJbmRleCggaTEgKTtcblx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMSwgdGkgKiAzLCBpbmRleEF0dHIxLCBwb3NpdGlvbkF0dHIxICk7XG5cblx0XHRcdH0gOlxuXHRcdFx0aTEgPT4ge1xuXG5cdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTEsIGkxICogMywgaW5kZXhBdHRyMSwgcG9zaXRpb25BdHRyMSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0Y29uc3QgdHJpYW5nbGUyID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0Y29uc3QgaW5kZXhBdHRyMiA9IG90aGVyQnZoLmdlb21ldHJ5LmluZGV4O1xuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cjIgPSBvdGhlckJ2aC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IGFzc2lnblRyaWFuZ2xlMiA9IG90aGVyQnZoLmluZGlyZWN0ID9cblx0XHRcdGkyID0+IHtcblxuXHRcdFx0XHRjb25zdCB0aTIgPSBvdGhlckJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaTIgKTtcblx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgdGkyICogMywgaW5kZXhBdHRyMiwgcG9zaXRpb25BdHRyMiApO1xuXG5cdFx0XHR9IDpcblx0XHRcdGkyID0+IHtcblxuXHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCBpMiAqIDMsIGluZGV4QXR0cjIsIHBvc2l0aW9uQXR0cjIgKTtcblxuXHRcdFx0fTtcblxuXHRcdC8vIGdlbmVyYXRlIHRyaWFuZ2xlIGNhbGxiYWNrIGlmIG5lZWRlZFxuXHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlcyApIHtcblxuXHRcdFx0Y29uc3QgaXRlcmF0ZU92ZXJEb3VibGVUcmlhbmdsZXMgPSAoIG9mZnNldDEsIGNvdW50MSwgb2Zmc2V0MiwgY291bnQyLCBkZXB0aDEsIGluZGV4MSwgZGVwdGgyLCBpbmRleDIgKSA9PiB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkyID0gb2Zmc2V0MiwgbDIgPSBvZmZzZXQyICsgY291bnQyOyBpMiA8IGwyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdGFzc2lnblRyaWFuZ2xlMiggaTIgKTtcblxuXHRcdFx0XHRcdHRyaWFuZ2xlMi5hLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlMi5jLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaTEgPSBvZmZzZXQxLCBsMSA9IG9mZnNldDEgKyBjb3VudDE7IGkxIDwgbDE7IGkxICsrICkge1xuXG5cdFx0XHRcdFx0XHRhc3NpZ25UcmlhbmdsZTEoIGkxICk7XG5cblx0XHRcdFx0XHRcdHRyaWFuZ2xlMS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlcyggdHJpYW5nbGUxLCB0cmlhbmdsZTIsIGkxLCBpMiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIGludGVyc2VjdHNSYW5nZXMgKSB7XG5cblx0XHRcdFx0Y29uc3Qgb3JpZ2luYWxJbnRlcnNlY3RzUmFuZ2VzID0gaW50ZXJzZWN0c1Jhbmdlcztcblx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlcyA9IGZ1bmN0aW9uICggb2Zmc2V0MSwgY291bnQxLCBvZmZzZXQyLCBjb3VudDIsIGRlcHRoMSwgaW5kZXgxLCBkZXB0aDIsIGluZGV4MiApIHtcblxuXHRcdFx0XHRcdGlmICggISBvcmlnaW5hbEludGVyc2VjdHNSYW5nZXMoIG9mZnNldDEsIGNvdW50MSwgb2Zmc2V0MiwgY291bnQyLCBkZXB0aDEsIGluZGV4MSwgZGVwdGgyLCBpbmRleDIgKSApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZXJhdGVPdmVyRG91YmxlVHJpYW5nbGVzKCBvZmZzZXQxLCBjb3VudDEsIG9mZnNldDIsIGNvdW50MiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZXMgPSBpdGVyYXRlT3ZlckRvdWJsZVRyaWFuZ2xlcztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ2aGNhc3QoIHRoaXMsIG90aGVyQnZoLCBtYXRyaXhUb0xvY2FsLCBpbnRlcnNlY3RzUmFuZ2VzICk7XG5cblx0fVxuXG5cblx0LyogRGVyaXZlZCBDYXN0IEZ1bmN0aW9ucyAqL1xuXHRpbnRlcnNlY3RzQm94KCBib3gsIGJveFRvTWVzaCApIHtcblxuXHRcdG9iYi5zZXQoIGJveC5taW4sIGJveC5tYXgsIGJveFRvTWVzaCApO1xuXHRcdG9iYi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcy5zaGFwZWNhc3QoXG5cdFx0XHR7XG5cdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6IGJveCA9PiBvYmIuaW50ZXJzZWN0c0JveCggYm94ICksXG5cdFx0XHRcdGludGVyc2VjdHNUcmlhbmdsZTogdHJpID0+IG9iYi5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaSApXG5cdFx0XHR9XG5cdFx0KTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2hhcGVjYXN0KFxuXHRcdFx0e1xuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiBib3ggPT4gc3BoZXJlLmludGVyc2VjdHNCb3goIGJveCApLFxuXHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IHRyaSA9PiB0cmkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlIClcblx0XHRcdH1cblx0XHQpO1xuXG5cdH1cblxuXHRjbG9zZXN0UG9pbnRUb0dlb21ldHJ5KCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCB0YXJnZXQxID0geyB9LCB0YXJnZXQyID0geyB9LCBtaW5UaHJlc2hvbGQgPSAwLCBtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSApIHtcblxuXHRcdGNvbnN0IGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlGdW5jID0gdGhpcy5pbmRpcmVjdCA/IGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlfaW5kaXJlY3QgOiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5O1xuXHRcdHJldHVybiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5RnVuYyhcblx0XHRcdHRoaXMsXG5cdFx0XHRvdGhlckdlb21ldHJ5LFxuXHRcdFx0Z2VvbWV0cnlUb0J2aCxcblx0XHRcdHRhcmdldDEsXG5cdFx0XHR0YXJnZXQyLFxuXHRcdFx0bWluVGhyZXNob2xkLFxuXHRcdFx0bWF4VGhyZXNob2xkLFxuXHRcdCk7XG5cblx0fVxuXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCB0YXJnZXQgPSB7IH0sIG1pblRocmVzaG9sZCA9IDAsIG1heFRocmVzaG9sZCA9IEluZmluaXR5ICkge1xuXG5cdFx0cmV0dXJuIGNsb3Nlc3RQb2ludFRvUG9pbnQoXG5cdFx0XHR0aGlzLFxuXHRcdFx0cG9pbnQsXG5cdFx0XHR0YXJnZXQsXG5cdFx0XHRtaW5UaHJlc2hvbGQsXG5cdFx0XHRtYXhUaHJlc2hvbGQsXG5cdFx0KTtcblxuXHR9XG5cblx0Z2V0Qm91bmRpbmdCb3goIHRhcmdldCApIHtcblxuXHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblxuXHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0cm9vdHMuZm9yRWFjaCggYnVmZmVyID0+IHtcblxuXHRcdFx0YXJyYXlUb0JveCggMCwgbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICksIHRlbXBCb3ggKTtcblx0XHRcdHRhcmdldC51bmlvbiggdGVtcEJveCApO1xuXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cbn1cbiJdLCJuYW1lcyI6WyJCdWZmZXJBdHRyaWJ1dGUiLCJCb3gzIiwiRnJvbnRTaWRlIiwiQ0VOVEVSIiwiQllURVNfUEVSX05PREUiLCJJU19MRUFGTk9ERV9GTEFHIiwiU0tJUF9HRU5FUkFUSU9OIiwiYnVpbGRQYWNrZWRUcmVlIiwiT3JpZW50ZWRCb3giLCJhcnJheVRvQm94IiwiRXh0ZW5kZWRUcmlhbmdsZVBvb2wiLCJzaGFwZWNhc3QiLCJjbG9zZXN0UG9pbnRUb1BvaW50IiwiaXRlcmF0ZU92ZXJUcmlhbmdsZXMiLCJyZWZpdCIsInJheWNhc3QiLCJyYXljYXN0Rmlyc3QiLCJpbnRlcnNlY3RzR2VvbWV0cnkiLCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5IiwiaXRlcmF0ZU92ZXJUcmlhbmdsZXNfaW5kaXJlY3QiLCJyZWZpdF9pbmRpcmVjdCIsInJheWNhc3RfaW5kaXJlY3QiLCJyYXljYXN0Rmlyc3RfaW5kaXJlY3QiLCJpbnRlcnNlY3RzR2VvbWV0cnlfaW5kaXJlY3QiLCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5X2luZGlyZWN0IiwiaXNTaGFyZWRBcnJheUJ1ZmZlclN1cHBvcnRlZCIsInNldFRyaWFuZ2xlIiwiYnZoY2FzdCIsIm9iYiIsInRlbXBCb3giLCJERUZBVUxUX09QVElPTlMiLCJzdHJhdGVneSIsIm1heERlcHRoIiwibWF4TGVhZlRyaXMiLCJ1c2VTaGFyZWRBcnJheUJ1ZmZlciIsInNldEJvdW5kaW5nQm94Iiwib25Qcm9ncmVzcyIsImluZGlyZWN0IiwidmVyYm9zZSIsIk1lc2hCVkgiLCJzZXJpYWxpemUiLCJidmgiLCJvcHRpb25zIiwiY2xvbmVCdWZmZXJzIiwiZ2VvbWV0cnkiLCJyb290RGF0YSIsIl9yb290cyIsImluZGlyZWN0QnVmZmVyIiwiX2luZGlyZWN0QnVmZmVyIiwiaW5kZXhBdHRyaWJ1dGUiLCJnZXRJbmRleCIsInJlc3VsdCIsInJvb3RzIiwibWFwIiwicm9vdCIsInNsaWNlIiwiaW5kZXgiLCJhcnJheSIsImRlc2VyaWFsaXplIiwiZGF0YSIsInNldEluZGV4IiwiQm9vbGVhbiIsIm5ld0luZGV4Iiwic2V0IiwibmVlZHNVcGRhdGUiLCJub2RlSW5kaWNlcyIsInJlZml0RnVuYyIsInRyYXZlcnNlIiwiY2FsbGJhY2siLCJyb290SW5kZXgiLCJidWZmZXIiLCJ1aW50MzJBcnJheSIsIlVpbnQzMkFycmF5IiwidWludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsIl90cmF2ZXJzZSIsIm5vZGUzMkluZGV4IiwiZGVwdGgiLCJub2RlMTZJbmRleCIsImlzTGVhZiIsIm9mZnNldCIsImNvdW50IiwiRmxvYXQzMkFycmF5IiwibGVmdCIsInJpZ2h0Iiwic3BsaXRBeGlzIiwic3RvcFRyYXZlcnNhbCIsInJheSIsIm1hdGVyaWFsT3JTaWRlIiwiaW50ZXJzZWN0cyIsImlzTWF0ZXJpYWwiLCJpc0FycmF5TWF0ZXJpYWwiLCJBcnJheSIsImlzQXJyYXkiLCJncm91cHMiLCJzaWRlIiwicmF5Y2FzdEZ1bmMiLCJpIiwibCIsImxlbmd0aCIsIm1hdGVyaWFsU2lkZSIsIm1hdGVyaWFsSW5kZXgiLCJzdGFydENvdW50IiwiaiIsImpsIiwiZmFjZSIsImNsb3Nlc3RSZXN1bHQiLCJyYXljYXN0Rmlyc3RGdW5jIiwiZGlzdGFuY2UiLCJvdGhlckdlb21ldHJ5IiwiZ2VvbVRvTWVzaCIsImludGVyc2VjdHNHZW9tZXRyeUZ1bmMiLCJjYWxsYmFja3MiLCJ0cmlhbmdsZSIsImdldFByaW1pdGl2ZSIsIml0ZXJhdGVGdW5jIiwiYm91bmRzVHJhdmVyc2VPcmRlciIsImludGVyc2VjdHNCb3VuZHMiLCJpbnRlcnNlY3RzUmFuZ2UiLCJpbnRlcnNlY3RzVHJpYW5nbGUiLCJvcmlnaW5hbEludGVyc2VjdHNSYW5nZSIsImNvbnRhaW5lZCIsIm5vZGVJbmRleCIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwicmVsZWFzZVByaW1pdGl2ZSIsIm90aGVyQnZoIiwibWF0cml4VG9Mb2NhbCIsImludGVyc2VjdHNSYW5nZXMiLCJpbnRlcnNlY3RzVHJpYW5nbGVzIiwidHJpYW5nbGUxIiwiaW5kZXhBdHRyMSIsInBvc2l0aW9uQXR0cjEiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJhc3NpZ25UcmlhbmdsZTEiLCJpMSIsInRpIiwicmVzb2x2ZVRyaWFuZ2xlSW5kZXgiLCJ0cmlhbmdsZTIiLCJpbmRleEF0dHIyIiwicG9zaXRpb25BdHRyMiIsImFzc2lnblRyaWFuZ2xlMiIsImkyIiwidGkyIiwiaXRlcmF0ZU92ZXJEb3VibGVUcmlhbmdsZXMiLCJvZmZzZXQxIiwiY291bnQxIiwib2Zmc2V0MiIsImNvdW50MiIsImRlcHRoMSIsImluZGV4MSIsImRlcHRoMiIsImluZGV4MiIsImwyIiwiYSIsImFwcGx5TWF0cml4NCIsImIiLCJjIiwibDEiLCJvcmlnaW5hbEludGVyc2VjdHNSYW5nZXMiLCJpbnRlcnNlY3RzQm94IiwiYm94IiwiYm94VG9NZXNoIiwibWluIiwibWF4IiwidHJpIiwiaW50ZXJzZWN0c1NwaGVyZSIsInNwaGVyZSIsImdlb21ldHJ5VG9CdmgiLCJ0YXJnZXQxIiwidGFyZ2V0MiIsIm1pblRocmVzaG9sZCIsIm1heFRocmVzaG9sZCIsIkluZmluaXR5IiwiY2xvc2VzdFBvaW50VG9HZW9tZXRyeUZ1bmMiLCJwb2ludCIsInRhcmdldCIsImdldEJvdW5kaW5nQm94IiwibWFrZUVtcHR5IiwiZm9yRWFjaCIsInVuaW9uIiwiY29uc3RydWN0b3IiLCJpc0J1ZmZlckdlb21ldHJ5IiwiRXJyb3IiLCJpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIiwiT2JqZWN0IiwiYXNzaWduIiwiYm91bmRpbmdCb3giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/MeshBVH.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/MeshBVHNode.js":
/*!*************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/MeshBVHNode.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshBVHNode: function() { return /* binding */ MeshBVHNode; }\n/* harmony export */ });\nclass MeshBVHNode {\n    constructor(){\n        // internal nodes have boundingData, left, right, and splitAxis\n        // leaf nodes have offset and count (referring to primitives in the mesh geometry)\n        this.boundingData = new Float32Array(6);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9NZXNoQlZITm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUE7SUFFWkMsYUFBYztRQUViLCtEQUErRDtRQUMvRCxrRkFBa0Y7UUFFbEYsSUFBSSxDQUFDQyxZQUFZLEdBQUcsSUFBSUMsYUFBYztJQUV2QztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9NZXNoQlZITm9kZS5qcz83M2U2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBNZXNoQlZITm9kZSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHQvLyBpbnRlcm5hbCBub2RlcyBoYXZlIGJvdW5kaW5nRGF0YSwgbGVmdCwgcmlnaHQsIGFuZCBzcGxpdEF4aXNcblx0XHQvLyBsZWFmIG5vZGVzIGhhdmUgb2Zmc2V0IGFuZCBjb3VudCAocmVmZXJyaW5nIHRvIHByaW1pdGl2ZXMgaW4gdGhlIG1lc2ggZ2VvbWV0cnkpXG5cblx0XHR0aGlzLmJvdW5kaW5nRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoIDYgKTtcblxuXHR9XG5cbn1cbiJdLCJuYW1lcyI6WyJNZXNoQlZITm9kZSIsImNvbnN0cnVjdG9yIiwiYm91bmRpbmdEYXRhIiwiRmxvYXQzMkFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/MeshBVHNode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/buildTree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/build/buildTree.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildPackedTree: function() { return /* binding */ buildPackedTree; },\n/* harmony export */   buildTree: function() { return /* binding */ buildTree; },\n/* harmony export */   generateIndirectBuffer: function() { return /* binding */ generateIndirectBuffer; }\n/* harmony export */ });\n/* harmony import */ var _geometryUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometryUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/geometryUtils.js\");\n/* harmony import */ var _computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./computeBoundsUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js\");\n/* harmony import */ var _splitUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./splitUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/splitUtils.js\");\n/* harmony import */ var _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MeshBVHNode.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/MeshBVHNode.js\");\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Constants.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/Constants.js\");\n/* harmony import */ var _sortUtils_generated_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sortUtils.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js\");\n/* harmony import */ var _sortUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sortUtils_indirect.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js\");\n/* harmony import */ var _buildUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./buildUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/buildUtils.js\");\n\n\n\n\n\n\n\n\nfunction generateIndirectBuffer(geometry, useSharedArrayBuffer) {\n    const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    const useUint32 = triCount > 2 ** 16;\n    const byteCount = useUint32 ? 4 : 2;\n    const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n    const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n    for(let i = 0, l = indirectBuffer.length; i < l; i++){\n        indirectBuffer[i] = i;\n    }\n    return indirectBuffer;\n}\nfunction buildTree(bvh, triangleBounds, offset, count, options) {\n    // epxand variables\n    const { maxDepth, verbose, maxLeafTris, strategy, onProgress, indirect } = options;\n    const indirectBuffer = bvh._indirectBuffer;\n    const geometry = bvh.geometry;\n    const indexArray = geometry.index ? geometry.index.array : null;\n    const partionFunc = indirect ? _sortUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_0__.partition_indirect : _sortUtils_generated_js__WEBPACK_IMPORTED_MODULE_1__.partition;\n    // generate intermediate variables\n    const totalTriangles = (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.getTriCount)(geometry);\n    const cacheCentroidBoundingData = new Float32Array(6);\n    let reachedMaxDepth = false;\n    const root = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_3__.MeshBVHNode();\n    (0,_computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_4__.getBounds)(triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData);\n    splitNode(root, offset, count, cacheCentroidBoundingData);\n    return root;\n    function triggerProgress(trianglesProcessed) {\n        if (onProgress) {\n            onProgress(trianglesProcessed / totalTriangles);\n        }\n    }\n    // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n    // recording the offset and count of its triangles and writing them into the reordered geometry index.\n    function splitNode(node, offset, count) {\n        let centroidBoundingData = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, depth = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;\n        if (!reachedMaxDepth && depth >= maxDepth) {\n            reachedMaxDepth = true;\n            if (verbose) {\n                console.warn(\"MeshBVH: Max depth of \".concat(maxDepth, \" reached when generating BVH. Consider increasing maxDepth.\"));\n                console.warn(geometry);\n            }\n        }\n        // early out if we've met our capacity\n        if (count <= maxLeafTris || depth >= maxDepth) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n            return node;\n        }\n        // Find where to split the volume\n        const split = (0,_splitUtils_js__WEBPACK_IMPORTED_MODULE_5__.getOptimalSplit)(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n        if (split.axis === -1) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n            return node;\n        }\n        const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n        // create the two new child nodes\n        if (splitOffset === offset || splitOffset === offset + count) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n        } else {\n            node.splitAxis = split.axis;\n            // create the left child and compute its bounding box\n            const left = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_3__.MeshBVHNode();\n            const lstart = offset;\n            const lcount = splitOffset - offset;\n            node.left = left;\n            (0,_computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_4__.getBounds)(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n            splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n            // repeat for right\n            const right = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_3__.MeshBVHNode();\n            const rstart = splitOffset;\n            const rcount = count - lcount;\n            node.right = right;\n            (0,_computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_4__.getBounds)(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n            splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n        }\n        return node;\n    }\n}\nfunction buildPackedTree(bvh, options) {\n    const geometry = bvh.geometry;\n    if (options.indirect) {\n        bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);\n        if ((0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.hasGroupGaps)(geometry) && !options.verbose) {\n            console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' + \"BVH may incorrectly report intersections on unrendered portions of the geometry.\");\n        }\n    }\n    if (!bvh._indirectBuffer) {\n        (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.ensureIndex)(geometry, options);\n    }\n    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    const triangleBounds = (0,_computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_4__.computeTriangleBounds)(geometry);\n    const geometryRanges = options.indirect ? (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.getFullGeometryRange)(geometry) : (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.getRootIndexRanges)(geometry);\n    bvh._roots = geometryRanges.map((range)=>{\n        const root = buildTree(bvh, triangleBounds, range.offset, range.count, options);\n        const nodeCount = (0,_buildUtils_js__WEBPACK_IMPORTED_MODULE_6__.countNodes)(root);\n        const buffer = new BufferConstructor(_Constants_js__WEBPACK_IMPORTED_MODULE_7__.BYTES_PER_NODE * nodeCount);\n        (0,_buildUtils_js__WEBPACK_IMPORTED_MODULE_6__.populateBuffer)(0, root, buffer);\n        return buffer;\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9idWlsZFRyZWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBdUg7QUFDNUM7QUFDekI7QUFDRjtBQUNDO0FBRUk7QUFDa0I7QUFDVjtBQUV0RCxTQUFTYyx1QkFBd0JDLFFBQVEsRUFBRUMsb0JBQW9CO0lBRXJFLE1BQU1DLFdBQVcsQ0FBRUYsU0FBU0csS0FBSyxHQUFHSCxTQUFTRyxLQUFLLENBQUNDLEtBQUssR0FBR0osU0FBU0ssVUFBVSxDQUFDQyxRQUFRLENBQUNGLEtBQUssSUFBSztJQUNsRyxNQUFNRyxZQUFZTCxXQUFXLEtBQUs7SUFDbEMsTUFBTU0sWUFBWUQsWUFBWSxJQUFJO0lBRWxDLE1BQU1FLFNBQVNSLHVCQUF1QixJQUFJUyxrQkFBbUJSLFdBQVdNLGFBQWMsSUFBSUcsWUFBYVQsV0FBV007SUFDbEgsTUFBTUksaUJBQWlCTCxZQUFZLElBQUlNLFlBQWFKLFVBQVcsSUFBSUssWUFBYUw7SUFDaEYsSUFBTSxJQUFJTSxJQUFJLEdBQUdDLElBQUlKLGVBQWVLLE1BQU0sRUFBRUYsSUFBSUMsR0FBR0QsSUFBTztRQUV6REgsY0FBYyxDQUFFRyxFQUFHLEdBQUdBO0lBRXZCO0lBRUEsT0FBT0g7QUFFUjtBQUVPLFNBQVNNLFVBQVdDLEdBQUcsRUFBRUMsY0FBYyxFQUFFQyxNQUFNLEVBQUVqQixLQUFLLEVBQUVrQixPQUFPO0lBRXJFLG1CQUFtQjtJQUNuQixNQUFNLEVBQ0xDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxXQUFXLEVBQ1hDLFFBQVEsRUFDUkMsVUFBVSxFQUNWQyxRQUFRLEVBQ1IsR0FBR047SUFDSixNQUFNVixpQkFBaUJPLElBQUlVLGVBQWU7SUFDMUMsTUFBTTdCLFdBQVdtQixJQUFJbkIsUUFBUTtJQUM3QixNQUFNOEIsYUFBYTlCLFNBQVNHLEtBQUssR0FBR0gsU0FBU0csS0FBSyxDQUFDNEIsS0FB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SVUsZUFBZSxHQUFHOUIsdUJBQXdCQyxVQUFVc0IsUUFBUXJCLG9CQUFvQjtRQUVwRixJQUFLWiwrREFBWUEsQ0FBRVcsYUFBYyxDQUFFc0IsUUFBUUUsT0FBTyxFQUFHO1lBRXBEcUIsUUFBUUMsSUFBSSxDQUNYLDhIQUNBO1FBR0Y7SUFFRDtJQUVBLElBQUssQ0FBRTNCLElBQUlVLGVBQWUsRUFBRztRQUU1QjVDLDhEQUFXQSxDQUFFZSxVQUFVc0I7SUFFeEI7SUFFQSxNQUFNb0Msb0JBQW9CcEMsUUFBUXJCLG9CQUFvQixHQUFHUyxvQkFBb0JDO0lBRTdFLE1BQU1TLGlCQUFpQjdCLDZFQUFxQkEsQ0FBRVM7SUFDOUMsTUFBTTJELGlCQUFpQnJDLFFBQVFNLFFBQVEsR0FBRzFDLHVFQUFvQkEsQ0FBRWMsWUFBYWIscUVBQWtCQSxDQUFFYTtJQUNqR21CLElBQUl5QyxNQUFNLEdBQUdELGVBQWVFLEdBQUcsQ0FBRUMsQ0FBQUE7UUFFaEMsTUFBTXpCLE9BQU9uQixVQUFXQyxLQUFLQyxnQkFBZ0IwQyxNQUFNekMsTUFBTSxFQUFFeUMsTUFBTTFELEtBQUssRUFBRWtCO1FBQ3hFLE1BQU15QyxZQUFZbEUsMERBQVVBLENBQUV3QztRQUM5QixNQUFNNUIsU0FBUyxJQUFJaUQsa0JBQW1CaEUseURBQWNBLEdBQUdxRTtRQUN2RGpFLDhEQUFjQSxDQUFFLEdBQUd1QyxNQUFNNUI7UUFDekIsT0FBT0E7SUFFUjtBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9idWlsZFRyZWUuanM/YTc4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlbnN1cmVJbmRleCwgZ2V0RnVsbEdlb21ldHJ5UmFuZ2UsIGdldFJvb3RJbmRleFJhbmdlcywgZ2V0VHJpQ291bnQsIGhhc0dyb3VwR2FwcywgfSBmcm9tICcuL2dlb21ldHJ5VXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0Qm91bmRzLCBjb21wdXRlVHJpYW5nbGVCb3VuZHMgfSBmcm9tICcuL2NvbXB1dGVCb3VuZHNVdGlscy5qcyc7XG5pbXBvcnQgeyBnZXRPcHRpbWFsU3BsaXQgfSBmcm9tICcuL3NwbGl0VXRpbHMuanMnO1xuaW1wb3J0IHsgTWVzaEJWSE5vZGUgfSBmcm9tICcuLi9NZXNoQlZITm9kZS5qcyc7XG5pbXBvcnQgeyBCWVRFU19QRVJfTk9ERSB9IGZyb20gJy4uL0NvbnN0YW50cy5qcyc7XG5cbmltcG9ydCB7IHBhcnRpdGlvbiB9IGZyb20gJy4vc29ydFV0aWxzLmdlbmVyYXRlZC5qcyc7XG5pbXBvcnQgeyBwYXJ0aXRpb25faW5kaXJlY3QgfSBmcm9tICcuL3NvcnRVdGlsc19pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgY291bnROb2RlcywgcG9wdWxhdGVCdWZmZXIgfSBmcm9tICcuL2J1aWxkVXRpbHMuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJbmRpcmVjdEJ1ZmZlciggZ2VvbWV0cnksIHVzZVNoYXJlZEFycmF5QnVmZmVyICkge1xuXG5cdGNvbnN0IHRyaUNvdW50ID0gKCBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmNvdW50IDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCApIC8gMztcblx0Y29uc3QgdXNlVWludDMyID0gdHJpQ291bnQgPiAyICoqIDE2O1xuXHRjb25zdCBieXRlQ291bnQgPSB1c2VVaW50MzIgPyA0IDogMjtcblxuXHRjb25zdCBidWZmZXIgPSB1c2VTaGFyZWRBcnJheUJ1ZmZlciA/IG5ldyBTaGFyZWRBcnJheUJ1ZmZlciggdHJpQ291bnQgKiBieXRlQ291bnQgKSA6IG5ldyBBcnJheUJ1ZmZlciggdHJpQ291bnQgKiBieXRlQ291bnQgKTtcblx0Y29uc3QgaW5kaXJlY3RCdWZmZXIgPSB1c2VVaW50MzIgPyBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApIDogbmV3IFVpbnQxNkFycmF5KCBidWZmZXIgKTtcblx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kaXJlY3RCdWZmZXIubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGluZGlyZWN0QnVmZmVyWyBpIF0gPSBpO1xuXG5cdH1cblxuXHRyZXR1cm4gaW5kaXJlY3RCdWZmZXI7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVHJlZSggYnZoLCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgb3B0aW9ucyApIHtcblxuXHQvLyBlcHhhbmQgdmFyaWFibGVzXG5cdGNvbnN0IHtcblx0XHRtYXhEZXB0aCxcblx0XHR2ZXJib3NlLFxuXHRcdG1heExlYWZUcmlzLFxuXHRcdHN0cmF0ZWd5LFxuXHRcdG9uUHJvZ3Jlc3MsXG5cdFx0aW5kaXJlY3QsXG5cdH0gPSBvcHRpb25zO1xuXHRjb25zdCBpbmRpcmVjdEJ1ZmZlciA9IGJ2aC5faW5kaXJlY3RCdWZmZXI7XG5cdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRjb25zdCBpbmRleEFycmF5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IG51bGw7XG5cdGNvbnN0IHBhcnRpb25GdW5jID0gaW5kaXJlY3QgPyBwYXJ0aXRpb25faW5kaXJlY3QgOiBwYXJ0aXRpb247XG5cblx0Ly8gZ2VuZXJhdGUgaW50ZXJtZWRpYXRlIHZhcmlhYmxlc1xuXHRjb25zdCB0b3RhbFRyaWFuZ2xlcyA9IGdldFRyaUNvdW50KCBnZW9tZXRyeSApO1xuXHRjb25zdCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhID0gbmV3IEZsb2F0MzJBcnJheSggNiApO1xuXHRsZXQgcmVhY2hlZE1heERlcHRoID0gZmFsc2U7XG5cblx0Y29uc3Qgcm9vdCA9IG5ldyBNZXNoQlZITm9kZSgpO1xuXHRnZXRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCByb290LmJvdW5kaW5nRGF0YSwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRzcGxpdE5vZGUoIHJvb3QsIG9mZnNldCwgY291bnQsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0cmV0dXJuIHJvb3Q7XG5cblx0ZnVuY3Rpb24gdHJpZ2dlclByb2dyZXNzKCB0cmlhbmdsZXNQcm9jZXNzZWQgKSB7XG5cblx0XHRpZiAoIG9uUHJvZ3Jlc3MgKSB7XG5cblx0XHRcdG9uUHJvZ3Jlc3MoIHRyaWFuZ2xlc1Byb2Nlc3NlZCAvIHRvdGFsVHJpYW5nbGVzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIGVpdGhlciByZWN1cnNpdmVseSBzcGxpdHMgdGhlIGdpdmVuIG5vZGUsIGNyZWF0aW5nIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzIGZvciBpdCwgb3IgbWFrZXMgaXQgYSBsZWFmIG5vZGUsXG5cdC8vIHJlY29yZGluZyB0aGUgb2Zmc2V0IGFuZCBjb3VudCBvZiBpdHMgdHJpYW5nbGVzIGFuZCB3cml0aW5nIHRoZW0gaW50byB0aGUgcmVvcmRlcmVkIGdlb21ldHJ5IGluZGV4LlxuXHRmdW5jdGlvbiBzcGxpdE5vZGUoIG5vZGUsIG9mZnNldCwgY291bnQsIGNlbnRyb2lkQm91bmRpbmdEYXRhID0gbnVsbCwgZGVwdGggPSAwICkge1xuXG5cdFx0aWYgKCAhIHJlYWNoZWRNYXhEZXB0aCAmJiBkZXB0aCA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0cmVhY2hlZE1heERlcHRoID0gdHJ1ZTtcblx0XHRcdGlmICggdmVyYm9zZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIGBNZXNoQlZIOiBNYXggZGVwdGggb2YgJHsgbWF4RGVwdGggfSByZWFjaGVkIHdoZW4gZ2VuZXJhdGluZyBCVkguIENvbnNpZGVyIGluY3JlYXNpbmcgbWF4RGVwdGguYCApO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oIGdlb21ldHJ5ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGVhcmx5IG91dCBpZiB3ZSd2ZSBtZXQgb3VyIGNhcGFjaXR5XG5cdFx0aWYgKCBjb3VudCA8PSBtYXhMZWFmVHJpcyB8fCBkZXB0aCA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0dHJpZ2dlclByb2dyZXNzKCBvZmZzZXQgKyBjb3VudCApO1xuXHRcdFx0bm9kZS5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHRub2RlLmNvdW50ID0gY291bnQ7XG5cdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdH1cblxuXHRcdC8vIEZpbmQgd2hlcmUgdG8gc3BsaXQgdGhlIHZvbHVtZVxuXHRcdGNvbnN0IHNwbGl0ID0gZ2V0T3B0aW1hbFNwbGl0KCBub2RlLmJvdW5kaW5nRGF0YSwgY2VudHJvaWRCb3VuZGluZ0RhdGEsIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBzdHJhdGVneSApO1xuXHRcdGlmICggc3BsaXQuYXhpcyA9PT0gLSAxICkge1xuXG5cdFx0XHR0cmlnZ2VyUHJvZ3Jlc3MoIG9mZnNldCArIGNvdW50ICk7XG5cdFx0XHRub2RlLm9mZnNldCA9IG9mZnNldDtcblx0XHRcdG5vZGUuY291bnQgPSBjb3VudDtcblx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc3BsaXRPZmZzZXQgPSBwYXJ0aW9uRnVuYyggaW5kaXJlY3RCdWZmZXIsIGluZGV4QXJyYXksIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBzcGxpdCApO1xuXG5cdFx0Ly8gY3JlYXRlIHRoZSB0d28gbmV3IGNoaWxkIG5vZGVzXG5cdFx0aWYgKCBzcGxpdE9mZnNldCA9PT0gb2Zmc2V0IHx8IHNwbGl0T2Zmc2V0ID09PSBvZmZzZXQgKyBjb3VudCApIHtcblxuXHRcdFx0dHJpZ2dlclByb2dyZXNzKCBvZmZzZXQgKyBjb3VudCApO1xuXHRcdFx0bm9kZS5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHRub2RlLmNvdW50ID0gY291bnQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRub2RlLnNwbGl0QXhpcyA9IHNwbGl0LmF4aXM7XG5cblx0XHRcdC8vIGNyZWF0ZSB0aGUgbGVmdCBjaGlsZCBhbmQgY29tcHV0ZSBpdHMgYm91bmRpbmcgYm94XG5cdFx0XHRjb25zdCBsZWZ0ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0XHRjb25zdCBsc3RhcnQgPSBvZmZzZXQ7XG5cdFx0XHRjb25zdCBsY291bnQgPSBzcGxpdE9mZnNldCAtIG9mZnNldDtcblx0XHRcdG5vZGUubGVmdCA9IGxlZnQ7XG5cblx0XHRcdGdldEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIGxzdGFydCwgbGNvdW50LCBsZWZ0LmJvdW5kaW5nRGF0YSwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0c3BsaXROb2RlKCBsZWZ0LCBsc3RhcnQsIGxjb3VudCwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSwgZGVwdGggKyAxICk7XG5cblx0XHRcdC8vIHJlcGVhdCBmb3IgcmlnaHRcblx0XHRcdGNvbnN0IHJpZ2h0ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0XHRjb25zdCByc3RhcnQgPSBzcGxpdE9mZnNldDtcblx0XHRcdGNvbnN0IHJjb3VudCA9IGNvdW50IC0gbGNvdW50O1xuXHRcdFx0bm9kZS5yaWdodCA9IHJpZ2h0O1xuXG5cdFx0XHRnZXRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCByc3RhcnQsIHJjb3VudCwgcmlnaHQuYm91bmRpbmdEYXRhLCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhICk7XG5cdFx0XHRzcGxpdE5vZGUoIHJpZ2h0LCByc3RhcnQsIHJjb3VudCwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSwgZGVwdGggKyAxICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbm9kZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUGFja2VkVHJlZSggYnZoLCBvcHRpb25zICkge1xuXG5cdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRpZiAoIG9wdGlvbnMuaW5kaXJlY3QgKSB7XG5cblx0XHRidmguX2luZGlyZWN0QnVmZmVyID0gZ2VuZXJhdGVJbmRpcmVjdEJ1ZmZlciggZ2VvbWV0cnksIG9wdGlvbnMudXNlU2hhcmVkQXJyYXlCdWZmZXIgKTtcblxuXHRcdGlmICggaGFzR3JvdXBHYXBzKCBnZW9tZXRyeSApICYmICEgb3B0aW9ucy52ZXJib3NlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdCdNZXNoQlZIOiBQcm92aWRlZCBnZW9tZXRyeSBjb250YWlucyBncm91cHMgdGhhdCBkbyBub3QgZnVsbHkgc3BhbiB0aGUgdmVydGV4IGNvbnRlbnRzIHdoaWxlIHVzaW5nIHRoZSBcImluZGlyZWN0XCIgb3B0aW9uLiAnICtcblx0XHRcdFx0J0JWSCBtYXkgaW5jb3JyZWN0bHkgcmVwb3J0IGludGVyc2VjdGlvbnMgb24gdW5yZW5kZXJlZCBwb3J0aW9ucyBvZiB0aGUgZ2VvbWV0cnkuJ1xuXHRcdFx0KTtcblxuXHRcdH1cblxuXHR9XG5cblx0aWYgKCAhIGJ2aC5faW5kaXJlY3RCdWZmZXIgKSB7XG5cblx0XHRlbnN1cmVJbmRleCggZ2VvbWV0cnksIG9wdGlvbnMgKTtcblxuXHR9XG5cblx0Y29uc3QgQnVmZmVyQ29uc3RydWN0b3IgPSBvcHRpb25zLnVzZVNoYXJlZEFycmF5QnVmZmVyID8gU2hhcmVkQXJyYXlCdWZmZXIgOiBBcnJheUJ1ZmZlcjtcblxuXHRjb25zdCB0cmlhbmdsZUJvdW5kcyA9IGNvbXB1dGVUcmlhbmdsZUJvdW5kcyggZ2VvbWV0cnkgKTtcblx0Y29uc3QgZ2VvbWV0cnlSYW5nZXMgPSBvcHRpb25zLmluZGlyZWN0ID8gZ2V0RnVsbEdlb21ldHJ5UmFuZ2UoIGdlb21ldHJ5ICkgOiBnZXRSb290SW5kZXhSYW5nZXMoIGdlb21ldHJ5ICk7XG5cdGJ2aC5fcm9vdHMgPSBnZW9tZXRyeVJhbmdlcy5tYXAoIHJhbmdlID0+IHtcblxuXHRcdGNvbnN0IHJvb3QgPSBidWlsZFRyZWUoIGJ2aCwgdHJpYW5nbGVCb3VuZHMsIHJhbmdlLm9mZnNldCwgcmFuZ2UuY291bnQsIG9wdGlvbnMgKTtcblx0XHRjb25zdCBub2RlQ291bnQgPSBjb3VudE5vZGVzKCByb290ICk7XG5cdFx0Y29uc3QgYnVmZmVyID0gbmV3IEJ1ZmZlckNvbnN0cnVjdG9yKCBCWVRFU19QRVJfTk9ERSAqIG5vZGVDb3VudCApO1xuXHRcdHBvcHVsYXRlQnVmZmVyKCAwLCByb290LCBidWZmZXIgKTtcblx0XHRyZXR1cm4gYnVmZmVyO1xuXG5cdH0gKTtcblxufVxuIl0sIm5hbWVzIjpbImVuc3VyZUluZGV4IiwiZ2V0RnVsbEdlb21ldHJ5UmFuZ2UiLCJnZXRSb290SW5kZXhSYW5nZXMiLCJnZXRUcmlDb3VudCIsImhhc0dyb3VwR2FwcyIsImdldEJvdW5kcyIsImNvbXB1dGVUcmlhbmdsZUJvdW5kcyIsImdldE9wdGltYWxTcGxpdCIsIk1lc2hCVkhOb2RlIiwiQllURVNfUEVSX05PREUiLCJwYXJ0aXRpb24iLCJwYXJ0aXRpb25faW5kaXJlY3QiLCJjb3VudE5vZGVzIiwicG9wdWxhdGVCdWZmZXIiLCJnZW5lcmF0ZUluZGlyZWN0QnVmZmVyIiwiZ2VvbWV0cnkiLCJ1c2VTaGFyZWRBcnJheUJ1ZmZlciIsInRyaUNvdW50IiwiaW5kZXgiLCJjb3VudCIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsInVzZVVpbnQzMiIsImJ5dGVDb3VudCIsImJ1ZmZlciIsIlNoYXJlZEFycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJpbmRpcmVjdEJ1ZmZlciIsIlVpbnQzMkFycmF5IiwiVWludDE2QXJyYXkiLCJpIiwibCIsImxlbmd0aCIsImJ1aWxkVHJlZSIsImJ2aCIsInRyaWFuZ2xlQm91bmRzIiwib2Zmc2V0Iiwib3B0aW9ucyIsIm1heERlcHRoIiwidmVyYm9zZSIsIm1heExlYWZUcmlzIiwic3RyYXRlZ3kiLCJvblByb2dyZXNzIiwiaW5kaXJlY3QiLCJfaW5kaXJlY3RCdWZmZXIiLCJpbmRleEFycmF5IiwiYXJyYXkiLCJwYXJ0aW9uRnVuYyIsInRvdGFsVHJpYW5nbGVzIiwiY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSIsIkZsb2F0MzJBcnJheSIsInJlYWNoZWRNYXhEZXB0aCIsInJvb3QiLCJib3VuZGluZ0RhdGEiLCJzcGxpdE5vZGUiLCJ0cmlnZ2VyUHJvZ3Jlc3MiLCJ0cmlhbmdsZXNQcm9jZXNzZWQiLCJub2RlIiwiY2VudHJvaWRCb3VuZGluZ0RhdGEiLCJkZXB0aCIsImNvbnNvbGUiLCJ3YXJuIiwic3BsaXQiLCJheGlzIiwic3BsaXRPZmZzZXQiLCJzcGxpdEF4aXMiLCJsZWZ0IiwibHN0YXJ0IiwibGNvdW50IiwicmlnaHQiLCJyc3RhcnQiLCJyY291bnQiLCJidWlsZFBhY2tlZFRyZWUiLCJCdWZmZXJDb25zdHJ1Y3RvciIsImdlb21ldHJ5UmFuZ2VzIiwiX3Jvb3RzIiwibWFwIiwicmFuZ2UiLCJub2RlQ291bnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/buildTree.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/buildUtils.js":
/*!******************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/build/buildUtils.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   countNodes: function() { return /* binding */ countNodes; },\n/* harmony export */   populateBuffer: function() { return /* binding */ populateBuffer; }\n/* harmony export */ });\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Constants.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/Constants.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow(2, 32);\nfunction countNodes(node) {\n    if (\"count\" in node) {\n        return 1;\n    } else {\n        return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n}\nfunction populateBuffer(byteOffset, node, buffer) {\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    uint8Array = new Uint8Array(buffer);\n    return _populateBuffer(byteOffset, node);\n}\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer(byteOffset, node) {\n    const stride4Offset = byteOffset / 4;\n    const stride2Offset = byteOffset / 2;\n    const isLeaf = \"count\" in node;\n    const boundingData = node.boundingData;\n    for(let i = 0; i < 6; i++){\n        float32Array[stride4Offset + i] = boundingData[i];\n    }\n    if (isLeaf) {\n        if (node.buffer) {\n            const buffer = node.buffer;\n            uint8Array.set(new Uint8Array(buffer), byteOffset);\n            for(let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += _Constants_js__WEBPACK_IMPORTED_MODULE_0__.BYTES_PER_NODE){\n                const offset2 = offset / 2;\n                if (!(0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_1__.IS_LEAF)(offset2, uint16Array)) {\n                    uint32Array[offset / 4 + 6] += stride4Offset;\n                }\n            }\n            return byteOffset + buffer.byteLength;\n        } else {\n            const offset = node.offset;\n            const count = node.count;\n            uint32Array[stride4Offset + 6] = offset;\n            uint16Array[stride2Offset + 14] = count;\n            uint16Array[stride2Offset + 15] = _Constants_js__WEBPACK_IMPORTED_MODULE_0__.IS_LEAFNODE_FLAG;\n            return byteOffset + _Constants_js__WEBPACK_IMPORTED_MODULE_0__.BYTES_PER_NODE;\n        }\n    } else {\n        const left = node.left;\n        const right = node.right;\n        const splitAxis = node.splitAxis;\n        let nextUnusedPointer;\n        nextUnusedPointer = _populateBuffer(byteOffset + _Constants_js__WEBPACK_IMPORTED_MODULE_0__.BYTES_PER_NODE, left);\n        if (nextUnusedPointer / 4 > MAX_POINTER) {\n            throw new Error(\"MeshBVH: Cannot store child pointer greater than 32 bits.\");\n        }\n        uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n        nextUnusedPointer = _populateBuffer(nextUnusedPointer, right);\n        uint32Array[stride4Offset + 7] = splitAxis;\n        return nextUnusedPointer;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9idWlsZFV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBbUU7QUFDYjtBQUV0RCxJQUFJRyxjQUFjQyxhQUFhQyxhQUFhQztBQUM1QyxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHLENBQUUsR0FBRztBQUUxQixTQUFTQyxXQUFZQyxJQUFJO0lBRS9CLElBQUssV0FBV0EsTUFBTztRQUV0QixPQUFPO0lBRVIsT0FBTztRQUVOLE9BQU8sSUFBSUQsV0FBWUMsS0FBS0MsSUFBSSxJQUFLRixXQUFZQyxLQUFLRSxLQUFLO0lBRTVEO0FBRUQ7QUFFTyxTQUFTQyxlQUFnQkMsVUFBVSxFQUFFSixJQUFJLEVBQUVLLE1BQU07SUFFdkRiLGVBQWUsSUFBSWMsYUFBY0Q7SUFDakNaLGNBQWMsSUFBSWMsWUFBYUY7SUFDL0JYLGNBQWMsSUFBSWMsWUFBYUg7SUFDL0JWLGFBQWEsSUFBSWMsV0FBWUo7SUFFN0IsT0FBT0ssZ0JBQWlCTixZQUFZSjtBQUVyQztBQUVBLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLG9EQUFvRDtBQUNwRCxTQUFTVSxnQkFBaUJOLFVBQVUsRUFBRUosSUFBSTtJQUV6QyxNQUFNVyxnQkFBZ0JQLGFBQWE7SUFDbkMsTUFBTVEsZ0JBQWdCUixhQUFhO0lBQ25DLE1BQU1TLFNBQVMsV0FBV2I7SUFDMUIsTUFBTWMsZUFBZWQsS0FBS2MsWUFBWTtJQUN0QyxJQUFNLElBQUlDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFPO1FBRTlCdkIsWUFBWSxDQUFFbUIsZ0JBQWdCSSxFQUFHLEdBQUdELFlBQVksQ0FBRUMsRUFBRztJQUV0RDtJQUVBLElBQUtGLFFBQVM7UUFFYixJQUFLYixLQUFLSyxNQUFNLEVBQUc7WUFFbEIsTUFBTUEsU0FBU0wsS0FBS0ssTUFBTTtZQUMxQlYsV0FBV3FCLEdBQUcsQ0FBRSxJQUFJUCxXQUFZSixTQUFVRDtZQUUxQyxJQUFNLElBQUlhLFNBQVNiLFlBQVljLElBQUlkLGFBQWFDLE9BQU9jLFVBQVUsRUFBRUYsU0FBU0MsR0FBR0QsVUFBVTVCLHlEQUFjQSxDQUFHO2dCQUV6RyxNQUFNK0IsVUFBVUgsU0FBUztnQkFDekIsSUFBSyxDQUFFMUIsa0VBQU9BLENBQUU2QixTQUFTMUIsY0FBZ0I7b0JBRXhDRCxXQUFXLENBQUUsU0FBVyxJQUFNLEVBQUcsSUFBSWtCO2dCQUd0QztZQUVEO1lBRUEsT0FBT1AsYUFBYUMsT0FBT2MsVUFBVTtRQUV0QyxPQUFPO1lBRU4sTUFBTUYsU0FBU2pCLEtBQUtpQixNQUFNO1lBQzFCLE1BQU1JLFFBQVFyQixLQUFLcUIsS0FBSztZQUN4QjVCLFdBQVcsQ0FBRWtCLGdCQUFnQixFQUFHLEdBQUdNO1lBQ25DdkIsV0FBVyxDQUFFa0IsZ0JBQWdCLEdBQUksR0FBR1M7WUFDcEMzQixXQUFXLENBQUVrQixnQkFBZ0IsR0FBSSxHQUFHdEIsMkRBQWdCQTtZQUNwRCxPQUFPYyxhQUFhZix5REFBY0E7UUFFbkM7SUFFRCxPQUFPO1FBRU4sTUFBTVksT0FBT0QsS0FBS0MsSUFBSTtRQUN0QixNQUFNQyxRQUFRRixLQUFLRSxLQUFLO1FBQ3hCLE1BQU1vQixZQUFZdEIsS0FBS3NCLFNBQVM7UUFFaEMsSUFBSUM7UUFDSkEsb0JBQW9CYixnQkFBaUJOLGFBQWFmLHlEQUFjQSxFQUFFWTtRQUVsRSxJQUFLLG9CQUFzQixJQUFNTCxhQUFjO1lBRTlDLE1BQU0sSUFBSTRCLE1BQU87UUFFbEI7UUFFQS9CLFdBQVcsQ0FBRWtCLGdCQUFnQixFQUFHLEdBQUdZLG9CQUFvQjtRQUN2REEsb0JBQW9CYixnQkFBaUJhLG1CQUFtQnJCO1FBRXhEVCxXQUFXLENBQUVrQixnQkFBZ0IsRUFBRyxHQUFHVztRQUNuQyxPQUFPQztJQUVSO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2J1aWxkL2J1aWxkVXRpbHMuanM/NTRlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCWVRFU19QRVJfTk9ERSwgSVNfTEVBRk5PREVfRkxBRyB9IGZyb20gJy4uL0NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBJU19MRUFGIH0gZnJvbSAnLi4vdXRpbHMvbm9kZUJ1ZmZlclV0aWxzLmpzJztcblxubGV0IGZsb2F0MzJBcnJheSwgdWludDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50OEFycmF5O1xuY29uc3QgTUFYX1BPSU5URVIgPSBNYXRoLnBvdyggMiwgMzIgKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50Tm9kZXMoIG5vZGUgKSB7XG5cblx0aWYgKCAnY291bnQnIGluIG5vZGUgKSB7XG5cblx0XHRyZXR1cm4gMTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0cmV0dXJuIDEgKyBjb3VudE5vZGVzKCBub2RlLmxlZnQgKSArIGNvdW50Tm9kZXMoIG5vZGUucmlnaHQgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0LCBub2RlLCBidWZmZXIgKSB7XG5cblx0ZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICk7XG5cdHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblx0dWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGJ1ZmZlciApO1xuXHR1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlciApO1xuXG5cdHJldHVybiBfcG9wdWxhdGVCdWZmZXIoIGJ5dGVPZmZzZXQsIG5vZGUgKTtcblxufVxuXG4vLyBwYWNrIHN0cnVjdHVyZVxuLy8gYm91bmRpbmdEYXRhICBcdFx0XHRcdDogNiBmbG9hdDMyXG4vLyByaWdodCAvIG9mZnNldCBcdFx0XHRcdDogMSB1aW50MzJcbi8vIHNwbGl0QXhpcyAvIGlzTGVhZiArIGNvdW50IFx0OiAxIHVpbnQzMiAvIDIgdWludDE2XG5mdW5jdGlvbiBfcG9wdWxhdGVCdWZmZXIoIGJ5dGVPZmZzZXQsIG5vZGUgKSB7XG5cblx0Y29uc3Qgc3RyaWRlNE9mZnNldCA9IGJ5dGVPZmZzZXQgLyA0O1xuXHRjb25zdCBzdHJpZGUyT2Zmc2V0ID0gYnl0ZU9mZnNldCAvIDI7XG5cdGNvbnN0IGlzTGVhZiA9ICdjb3VudCcgaW4gbm9kZTtcblx0Y29uc3QgYm91bmRpbmdEYXRhID0gbm9kZS5ib3VuZGluZ0RhdGE7XG5cdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRmbG9hdDMyQXJyYXlbIHN0cmlkZTRPZmZzZXQgKyBpIF0gPSBib3VuZGluZ0RhdGFbIGkgXTtcblxuXHR9XG5cblx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRpZiAoIG5vZGUuYnVmZmVyICkge1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSBub2RlLmJ1ZmZlcjtcblx0XHRcdHVpbnQ4QXJyYXkuc2V0KCBuZXcgVWludDhBcnJheSggYnVmZmVyICksIGJ5dGVPZmZzZXQgKTtcblxuXHRcdFx0Zm9yICggbGV0IG9mZnNldCA9IGJ5dGVPZmZzZXQsIGwgPSBieXRlT2Zmc2V0ICsgYnVmZmVyLmJ5dGVMZW5ndGg7IG9mZnNldCA8IGw7IG9mZnNldCArPSBCWVRFU19QRVJfTk9ERSApIHtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQyID0gb2Zmc2V0IC8gMjtcblx0XHRcdFx0aWYgKCAhIElTX0xFQUYoIG9mZnNldDIsIHVpbnQxNkFycmF5ICkgKSB7XG5cblx0XHRcdFx0XHR1aW50MzJBcnJheVsgKCBvZmZzZXQgLyA0ICkgKyA2IF0gKz0gc3RyaWRlNE9mZnNldDtcblxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnl0ZU9mZnNldCArIGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gbm9kZS5vZmZzZXQ7XG5cdFx0XHRjb25zdCBjb3VudCA9IG5vZGUuY291bnQ7XG5cdFx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDYgXSA9IG9mZnNldDtcblx0XHRcdHVpbnQxNkFycmF5WyBzdHJpZGUyT2Zmc2V0ICsgMTQgXSA9IGNvdW50O1xuXHRcdFx0dWludDE2QXJyYXlbIHN0cmlkZTJPZmZzZXQgKyAxNSBdID0gSVNfTEVBRk5PREVfRkxBRztcblx0XHRcdHJldHVybiBieXRlT2Zmc2V0ICsgQllURVNfUEVSX05PREU7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGNvbnN0IGxlZnQgPSBub2RlLmxlZnQ7XG5cdFx0Y29uc3QgcmlnaHQgPSBub2RlLnJpZ2h0O1xuXHRcdGNvbnN0IHNwbGl0QXhpcyA9IG5vZGUuc3BsaXRBeGlzO1xuXG5cdFx0bGV0IG5leHRVbnVzZWRQb2ludGVyO1xuXHRcdG5leHRVbnVzZWRQb2ludGVyID0gX3BvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0ICsgQllURVNfUEVSX05PREUsIGxlZnQgKTtcblxuXHRcdGlmICggKCBuZXh0VW51c2VkUG9pbnRlciAvIDQgKSA+IE1BWF9QT0lOVEVSICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBDYW5ub3Qgc3RvcmUgY2hpbGQgcG9pbnRlciBncmVhdGVyIHRoYW4gMzIgYml0cy4nICk7XG5cblx0XHR9XG5cblx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDYgXSA9IG5leHRVbnVzZWRQb2ludGVyIC8gNDtcblx0XHRuZXh0VW51c2VkUG9pbnRlciA9IF9wb3B1bGF0ZUJ1ZmZlciggbmV4dFVudXNlZFBvaW50ZXIsIHJpZ2h0ICk7XG5cblx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDcgXSA9IHNwbGl0QXhpcztcblx0XHRyZXR1cm4gbmV4dFVudXNlZFBvaW50ZXI7XG5cblx0fVxuXG59XG4iXSwibmFtZXMiOlsiQllURVNfUEVSX05PREUiLCJJU19MRUFGTk9ERV9GTEFHIiwiSVNfTEVBRiIsImZsb2F0MzJBcnJheSIsInVpbnQzMkFycmF5IiwidWludDE2QXJyYXkiLCJ1aW50OEFycmF5IiwiTUFYX1BPSU5URVIiLCJNYXRoIiwicG93IiwiY291bnROb2RlcyIsIm5vZGUiLCJsZWZ0IiwicmlnaHQiLCJwb3B1bGF0ZUJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJidWZmZXIiLCJGbG9hdDMyQXJyYXkiLCJVaW50MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDhBcnJheSIsIl9wb3B1bGF0ZUJ1ZmZlciIsInN0cmlkZTRPZmZzZXQiLCJzdHJpZGUyT2Zmc2V0IiwiaXNMZWFmIiwiYm91bmRpbmdEYXRhIiwiaSIsInNldCIsIm9mZnNldCIsImwiLCJieXRlTGVuZ3RoIiwib2Zmc2V0MiIsImNvdW50Iiwic3BsaXRBeGlzIiwibmV4dFVudXNlZFBvaW50ZXIiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/buildUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeTriangleBounds: function() { return /* binding */ computeTriangleBounds; },\n/* harmony export */   getBounds: function() { return /* binding */ getBounds; }\n/* harmony export */ });\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Constants.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/Constants.js\");\n/* harmony import */ var _geometryUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometryUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/geometryUtils.js\");\n\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds(triangleBounds, offset, count, target, centroidTarget) {\n    let minx = Infinity;\n    let miny = Infinity;\n    let minz = Infinity;\n    let maxx = -Infinity;\n    let maxy = -Infinity;\n    let maxz = -Infinity;\n    let cminx = Infinity;\n    let cminy = Infinity;\n    let cminz = Infinity;\n    let cmaxx = -Infinity;\n    let cmaxy = -Infinity;\n    let cmaxz = -Infinity;\n    for(let i = offset * 6, end = (offset + count) * 6; i < end; i += 6){\n        const cx = triangleBounds[i + 0];\n        const hx = triangleBounds[i + 1];\n        const lx = cx - hx;\n        const rx = cx + hx;\n        if (lx < minx) minx = lx;\n        if (rx > maxx) maxx = rx;\n        if (cx < cminx) cminx = cx;\n        if (cx > cmaxx) cmaxx = cx;\n        const cy = triangleBounds[i + 2];\n        const hy = triangleBounds[i + 3];\n        const ly = cy - hy;\n        const ry = cy + hy;\n        if (ly < miny) miny = ly;\n        if (ry > maxy) maxy = ry;\n        if (cy < cminy) cminy = cy;\n        if (cy > cmaxy) cmaxy = cy;\n        const cz = triangleBounds[i + 4];\n        const hz = triangleBounds[i + 5];\n        const lz = cz - hz;\n        const rz = cz + hz;\n        if (lz < minz) minz = lz;\n        if (rz > maxz) maxz = rz;\n        if (cz < cminz) cminz = cz;\n        if (cz > cmaxz) cmaxz = cz;\n    }\n    target[0] = minx;\n    target[1] = miny;\n    target[2] = minz;\n    target[3] = maxx;\n    target[4] = maxy;\n    target[5] = maxz;\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n}\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds(geo) {\n    let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, count = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    const posAttr = geo.attributes.position;\n    const index = geo.index ? geo.index.array : null;\n    const triCount = (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_0__.getTriCount)(geo);\n    const normalized = posAttr.normalized;\n    let triangleBounds;\n    if (target === null) {\n        triangleBounds = new Float32Array(triCount * 6 * 4);\n        offset = 0;\n        count = triCount;\n    } else {\n        triangleBounds = target;\n        offset = offset || 0;\n        count = count || triCount;\n    }\n    // used for non-normalized positions\n    const posArr = posAttr.array;\n    // support for an interleaved position buffer\n    const bufferOffset = posAttr.offset || 0;\n    let stride = 3;\n    if (posAttr.isInterleavedBufferAttribute) {\n        stride = posAttr.data.stride;\n    }\n    // used for normalized positions\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\"\n    ];\n    for(let tri = offset; tri < offset + count; tri++){\n        const tri3 = tri * 3;\n        const tri6 = tri * 6;\n        let ai = tri3 + 0;\n        let bi = tri3 + 1;\n        let ci = tri3 + 2;\n        if (index) {\n            ai = index[ai];\n            bi = index[bi];\n            ci = index[ci];\n        }\n        // we add the stride and offset here since we access the array directly\n        // below for the sake of performance\n        if (!normalized) {\n            ai = ai * stride + bufferOffset;\n            bi = bi * stride + bufferOffset;\n            ci = ci * stride + bufferOffset;\n        }\n        for(let el = 0; el < 3; el++){\n            let a, b, c;\n            if (normalized) {\n                a = posAttr[getters[el]](ai);\n                b = posAttr[getters[el]](bi);\n                c = posAttr[getters[el]](ci);\n            } else {\n                a = posArr[ai + el];\n                b = posArr[bi + el];\n                c = posArr[ci + el];\n            }\n            let min = a;\n            if (b < min) min = b;\n            if (c < min) min = c;\n            let max = a;\n            if (b > max) max = b;\n            if (c > max) max = c;\n            // Increase the bounds size by float32 epsilon to avoid precision errors when\n            // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n            // worked with.\n            const halfExtents = (max - min) / 2;\n            const el2 = el * 2;\n            triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n            triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * _Constants_js__WEBPACK_IMPORTED_MODULE_1__.FLOAT32_EPSILON;\n        }\n    }\n    return triangleBounds;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9jb21wdXRlQm91bmRzVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrRDtBQUNEO0FBRWpELHlHQUF5RztBQUN6RywwR0FBMEc7QUFDMUcsMkVBQTJFO0FBQ3BFLFNBQVNFLFVBQVdDLGNBQWMsRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsY0FBYztJQUUvRSxJQUFJQyxPQUFPQztJQUNYLElBQUlDLE9BQU9EO0lBQ1gsSUFBSUUsT0FBT0Y7SUFDWCxJQUFJRyxPQUFPLENBQUVIO0lBQ2IsSUFBSUksT0FBTyxDQUFFSjtJQUNiLElBQUlLLE9BQU8sQ0FBRUw7SUFFYixJQUFJTSxRQUFRTjtJQUNaLElBQUlPLFFBQVFQO0lBQ1osSUFBSVEsUUFBUVI7SUFDWixJQUFJUyxRQUFRLENBQUVUO0lBQ2QsSUFBSVUsUUFBUSxDQUFFVjtJQUNkLElBQUlXLFFBQVEsQ0FBRVg7SUFFZCxJQUFNLElBQUlZLElBQUlqQixTQUFTLEdBQUdrQixNQUFNLENBQUVsQixTQUFTQyxLQUFJLElBQU0sR0FBR2dCLElBQUlDLEtBQUtELEtBQUssRUFBSTtRQUV6RSxNQUFNRSxLQUFLcEIsY0FBYyxDQUFFa0IsSUFBSSxFQUFHO1FBQ2xDLE1BQU1HLEtBQUtyQixjQUFjLENBQUVrQixJQUFJLEVBQUc7UUFDbEMsTUFBTUksS0FBS0YsS0FBS0M7UUFDaEIsTUFBTUUsS0FBS0gsS0FBS0M7UUFDaEIsSUFBS0MsS0FBS2pCLE1BQU9BLE9BQU9pQjtRQUN4QixJQUFLQyxLQUFLZCxNQUFPQSxPQUFPYztRQUN4QixJQUFLSCxLQUFLUixPQUFRQSxRQUFRUTtRQUMxQixJQUFLQSxLQUFLTCxPQUFRQSxRQUFRSztRQUUxQixNQUFNSSxLQUFLeEIsY0FBYyxDQUFFa0IsSUFBSSxFQUFHO1FBQ2xDLE1BQU1PLEtBQUt6QixjQUFjLENBQUVrQixJQUFJLEVBQUc7UUFDbEMsTUFBTVEsS0FBS0YsS0FBS0M7UUFDaEIsTUFBTUUsS0FBS0gsS0FBS0M7UUFDaEIsSUFBS0MsS0FBS25CLE1BQU9BLE9BQU9tQjtRQUN4QixJQUFLQyxLQUFLakIsTUFBT0EsT0FBT2lCO1FBQ3hCLElBQUtILEtBQUtYLE9BQVFBLFFBQVFXO1FBQzFCLElBQUtBLEtBQUtSLE9BQVFBLFFBQVFRO1FBRTFCLE1BQU1JLEtBQUs1QixjQUFjLENBQUVrQixJQUFJLEVBQUc7UUFDbEMsTUFBTVcsS0FBSzdCLGNBQWMsQ0FBRWtCLElBQUksRUFBRztRQUNsQyxNQUFNWSxLQUFLRixLQUFLQztRQUNoQixNQUFNRSxLQUFLSCxLQUFLQztRQUNoQixJQUFLQyxLQUFLdEIsTUFBT0EsT0FBT3NCO1FBQ3hCLElBQUtDLEtBQUtwQixNQUFPQSxPQUFPb0I7UUFDeEIsSUFBS0gsS0FBS2QsT0FBUUEsUUFBUWM7UUFDMUIsSUFBS0EsS0FBS1gsT0FBUUEsUUFBUVc7SUFFM0I7SUFFQXpCLE1BQU0sQ0FBRSxFQUFHLEdBQUdFO0lBQ2RGLE1BQU0sQ0FBRSxFQUFHLEdBQUdJO0lBQ2RKLE1BQU0sQ0FBRSxFQUFHLEdBQUdLO0lBRWRMLE1BQU0sQ0FBRSxFQUFHLEdBQUdNO0lBQ2ROLE1BQU0sQ0FBRSxFQUFHLEdBQUdPO0lBQ2RQLE1BQU0sQ0FBRSxFQUFHLEdBQUdRO0lBRWRQLGNBQWMsQ0FBRSxFQUFHLEdBQUdRO0lBQ3RCUixjQUFjLENBQUUsRUFBRyxHQUFHUztJQUN0QlQsY0FBYyxDQUFFLEVBQUcsR0FBR1U7SUFFdEJWLGNBQWMsQ0FBRSxFQUFHLEdBQUdXO0lBQ3RCWCxjQUFjLENBQUUsRUFBRyxHQUFHWTtJQUN0QlosY0FBYyxDQUFFLEVBQUcsR0FBR2E7QUFFdkI7QUFFQSxnR0FBZ0c7QUFDaEcsd0VBQXdFO0FBQ3hFLDJGQUEyRjtBQUMzRiwwRUFBMEU7QUFDbkUsU0FBU2Usc0JBQXVCQyxHQUFHO1FBQUU5QixTQUFBQSxpRUFBUyxNQUFNRixTQUFBQSxpRUFBUyxNQUFNQyxRQUFBQSxpRUFBUTtJQUVqRixNQUFNZ0MsVUFBVUQsSUFBSUUsVUFBVSxDQUFDQyxRQUFRO0lBQ3ZDLE1BQU1DLFFBQVFKLElBQUlJLEtBQUssR0FBR0osSUFBSUksS0FBSyxDQUFDQyxLQUFLLEdBQUc7SUFDNUMsTUFBTUMsV0FBV3pDLDhEQUFXQSxDQUFFbUM7SUFDOUIsTUFBTU8sYUFBYU4sUUFBUU0sVUFBVTtJQUNyQyxJQUFJeEM7SUFDSixJQUFLRyxXQUFXLE1BQU87UUFFdEJILGlCQUFpQixJQUFJeUMsYUFBY0YsV0FBVyxJQUFJO1FBQ2xEdEMsU0FBUztRQUNUQyxRQUFRcUM7SUFFVCxPQUFPO1FBRU52QyxpQkFBaUJHO1FBQ2pCRixTQUFTQSxVQUFVO1FBQ25CQyxRQUFRQSxTQUFTcUM7SUFFbEI7SUFFQSxvQ0FBb0M7SUFDcEMsTUFBTUcsU0FBU1IsUUFBUUksS0FBSztJQUU1Qiw2Q0FBNkM7SUFDN0MsTUFBTUssZUFBZVQsUUFBUWpDLE1BQU0sSUFBSTtJQUN2QyxJQUFJMkMsU0FBUztJQUNiLElBQUtWLFFBQVFXLDRCQUE0QixFQUFHO1FBRTNDRCxTQUFTVixRQUFRWSxJQUFJLENBQUNGLE1BQU07SUFFN0I7SUFFQSxnQ0FBZ0M7SUFDaEMsTUFBTUcsVUFBVTtRQUFFO1FBQVE7UUFBUTtLQUFRO0lBRTFDLElBQU0sSUFBSUMsTUFBTS9DLFFBQVErQyxNQUFNL0MsU0FBU0MsT0FBTzhDLE1BQVM7UUFFdEQsTUFBTUMsT0FBT0QsTUFBTTtRQUNuQixNQUFNRSxPQUFPRixNQUFNO1FBRW5CLElBQUlHLEtBQUtGLE9BQU87UUFDaEIsSUFBSUcsS0FBS0gsT0FBTztRQUNoQixJQUFJSSxLQUFLSixPQUFPO1FBRWhCLElBQUtaLE9BQVE7WUFFWmMsS0FBS2QsS0FBSyxDQUFFYyxHQUFJO1lBQ2hCQyxLQUFLZixLQUFLLENBQUVlLEdBQUk7WUFDaEJDLEtBQUtoQixLQUFLLENBQUVnQixHQUFJO1FBRWpCO1FBRUEsdUVBQXVFO1FBQ3ZFLG9DQUFvQztRQUNwQyxJQUFLLENBQUViLFlBQWE7WUFFbkJXLEtBQUtBLEtBQUtQLFNBQVNEO1lBQ25CUyxLQUFLQSxLQUFLUixTQUFTRDtZQUNuQlUsS0FBS0EsS0FBS1QsU0FBU0Q7UUFFcEI7UUFFQSxJQUFNLElBQUlXLEtBQUssR0FBR0EsS0FBSyxHQUFHQSxLQUFRO1lBRWpDLElBQUlDLEdBQUdDLEdBQUdDO1lBRVYsSUFBS2pCLFlBQWE7Z0JBRWpCZSxJQUFJckIsT0FBTyxDQUFFYSxPQUFPLENBQUVPLEdBQUksQ0FBRSxDQUFFSDtnQkFDOUJLLElBQUl0QixPQUFPLENBQUVhLE9BQU8sQ0FBRU8sR0FBSSxDQUFFLENBQUVGO2dCQUM5QkssSUFBSXZCLE9BQU8sQ0FBRWEsT0FBTyxDQUFFTyxHQUFJLENBQUUsQ0FBRUQ7WUFFL0IsT0FBTztnQkFFTkUsSUFBSWIsTUFBTSxDQUFFUyxLQUFLRyxHQUFJO2dCQUNyQkUsSUFBSWQsTUFBTSxDQUFFVSxLQUFLRSxHQUFJO2dCQUNyQkcsSUFBSWYsTUFBTSxDQUFFVyxLQUFLQyxHQUFJO1lBRXRCO1lBRUEsSUFBSUksTUFBTUg7WUFDVixJQUFLQyxJQUFJRSxLQUFNQSxNQUFNRjtZQUNyQixJQUFLQyxJQUFJQyxLQUFNQSxNQUFNRDtZQUVyQixJQUFJRSxNQUFNSjtZQUNWLElBQUtDLElBQUlHLEtBQU1BLE1BQU1IO1lBQ3JCLElBQUtDLElBQUlFLEtBQU1BLE1BQU1GO1lBRXJCLDZFQUE2RTtZQUM3RSxpRkFBaUY7WUFDakYsZUFBZTtZQUNmLE1BQU1HLGNBQWMsQ0FBRUQsTUFBTUQsR0FBRSxJQUFNO1lBQ3BDLE1BQU1HLE1BQU1QLEtBQUs7WUFDakJ0RCxjQUFjLENBQUVrRCxPQUFPVyxNQUFNLEVBQUcsR0FBR0gsTUFBTUU7WUFDekM1RCxjQUFjLENBQUVrRCxPQUFPVyxNQUFNLEVBQUcsR0FBR0QsY0FBYyxDQUFFRSxLQUFLQyxHQUFHLENBQUVMLE9BQVFFLFdBQVUsSUFBTS9ELDBEQUFlQTtRQUVyRztJQUVEO0lBRUEsT0FBT0c7QUFFUiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvYnVpbGQvY29tcHV0ZUJvdW5kc1V0aWxzLmpzP2QwZTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRkxPQVQzMl9FUFNJTE9OIH0gZnJvbSAnLi4vQ29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGdldFRyaUNvdW50IH0gZnJvbSAnLi9nZW9tZXRyeVV0aWxzLmpzJztcblxuLy8gY29tcHV0ZXMgdGhlIHVuaW9uIG9mIHRoZSBib3VuZHMgb2YgYWxsIG9mIHRoZSBnaXZlbiB0cmlhbmdsZXMgYW5kIHB1dHMgdGhlIHJlc3VsdGluZyBib3ggaW4gXCJ0YXJnZXRcIi5cbi8vIEEgYm91bmRpbmcgYm94IGlzIGNvbXB1dGVkIGZvciB0aGUgY2VudHJvaWRzIG9mIHRoZSB0cmlhbmdsZXMsIGFzIHdlbGwsIGFuZCBwbGFjZWQgaW4gXCJjZW50cm9pZFRhcmdldFwiLlxuLy8gVGhlc2UgYXJlIGNvbXB1dGVkIHRvZ2V0aGVyIHRvIGF2b2lkIHJlZHVuZGFudCBhY2Nlc3NlcyB0byBib3VuZHMgYXJyYXkuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm91bmRzKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgdGFyZ2V0LCBjZW50cm9pZFRhcmdldCApIHtcblxuXHRsZXQgbWlueCA9IEluZmluaXR5O1xuXHRsZXQgbWlueSA9IEluZmluaXR5O1xuXHRsZXQgbWlueiA9IEluZmluaXR5O1xuXHRsZXQgbWF4eCA9IC0gSW5maW5pdHk7XG5cdGxldCBtYXh5ID0gLSBJbmZpbml0eTtcblx0bGV0IG1heHogPSAtIEluZmluaXR5O1xuXG5cdGxldCBjbWlueCA9IEluZmluaXR5O1xuXHRsZXQgY21pbnkgPSBJbmZpbml0eTtcblx0bGV0IGNtaW56ID0gSW5maW5pdHk7XG5cdGxldCBjbWF4eCA9IC0gSW5maW5pdHk7XG5cdGxldCBjbWF4eSA9IC0gSW5maW5pdHk7XG5cdGxldCBjbWF4eiA9IC0gSW5maW5pdHk7XG5cblx0Zm9yICggbGV0IGkgPSBvZmZzZXQgKiA2LCBlbmQgPSAoIG9mZnNldCArIGNvdW50ICkgKiA2OyBpIDwgZW5kOyBpICs9IDYgKSB7XG5cblx0XHRjb25zdCBjeCA9IHRyaWFuZ2xlQm91bmRzWyBpICsgMCBdO1xuXHRcdGNvbnN0IGh4ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAxIF07XG5cdFx0Y29uc3QgbHggPSBjeCAtIGh4O1xuXHRcdGNvbnN0IHJ4ID0gY3ggKyBoeDtcblx0XHRpZiAoIGx4IDwgbWlueCApIG1pbnggPSBseDtcblx0XHRpZiAoIHJ4ID4gbWF4eCApIG1heHggPSByeDtcblx0XHRpZiAoIGN4IDwgY21pbnggKSBjbWlueCA9IGN4O1xuXHRcdGlmICggY3ggPiBjbWF4eCApIGNtYXh4ID0gY3g7XG5cblx0XHRjb25zdCBjeSA9IHRyaWFuZ2xlQm91bmRzWyBpICsgMiBdO1xuXHRcdGNvbnN0IGh5ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAzIF07XG5cdFx0Y29uc3QgbHkgPSBjeSAtIGh5O1xuXHRcdGNvbnN0IHJ5ID0gY3kgKyBoeTtcblx0XHRpZiAoIGx5IDwgbWlueSApIG1pbnkgPSBseTtcblx0XHRpZiAoIHJ5ID4gbWF4eSApIG1heHkgPSByeTtcblx0XHRpZiAoIGN5IDwgY21pbnkgKSBjbWlueSA9IGN5O1xuXHRcdGlmICggY3kgPiBjbWF4eSApIGNtYXh5ID0gY3k7XG5cblx0XHRjb25zdCBjeiA9IHRyaWFuZ2xlQm91bmRzWyBpICsgNCBdO1xuXHRcdGNvbnN0IGh6ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyA1IF07XG5cdFx0Y29uc3QgbHogPSBjeiAtIGh6O1xuXHRcdGNvbnN0IHJ6ID0gY3ogKyBoejtcblx0XHRpZiAoIGx6IDwgbWlueiApIG1pbnogPSBsejtcblx0XHRpZiAoIHJ6ID4gbWF4eiApIG1heHogPSByejtcblx0XHRpZiAoIGN6IDwgY21pbnogKSBjbWlueiA9IGN6O1xuXHRcdGlmICggY3ogPiBjbWF4eiApIGNtYXh6ID0gY3o7XG5cblx0fVxuXG5cdHRhcmdldFsgMCBdID0gbWlueDtcblx0dGFyZ2V0WyAxIF0gPSBtaW55O1xuXHR0YXJnZXRbIDIgXSA9IG1pbno7XG5cblx0dGFyZ2V0WyAzIF0gPSBtYXh4O1xuXHR0YXJnZXRbIDQgXSA9IG1heHk7XG5cdHRhcmdldFsgNSBdID0gbWF4ejtcblxuXHRjZW50cm9pZFRhcmdldFsgMCBdID0gY21pbng7XG5cdGNlbnRyb2lkVGFyZ2V0WyAxIF0gPSBjbWlueTtcblx0Y2VudHJvaWRUYXJnZXRbIDIgXSA9IGNtaW56O1xuXG5cdGNlbnRyb2lkVGFyZ2V0WyAzIF0gPSBjbWF4eDtcblx0Y2VudHJvaWRUYXJnZXRbIDQgXSA9IGNtYXh5O1xuXHRjZW50cm9pZFRhcmdldFsgNSBdID0gY21heHo7XG5cbn1cblxuLy8gcHJlY29tcHV0ZXMgdGhlIGJvdW5kaW5nIGJveCBmb3IgZWFjaCB0cmlhbmdsZTsgcmVxdWlyZWQgZm9yIHF1aWNrbHkgY2FsY3VsYXRpbmcgdHJlZSBzcGxpdHMuXG4vLyByZXN1bHQgaXMgYW4gYXJyYXkgb2Ygc2l6ZSB0cmlzLmxlbmd0aCAqIDYgd2hlcmUgdHJpYW5nbGUgaSBtYXBzIHRvIGFcbi8vIFt4X2NlbnRlciwgeF9kZWx0YSwgeV9jZW50ZXIsIHlfZGVsdGEsIHpfY2VudGVyLCB6X2RlbHRhXSB0dXBsZSBzdGFydGluZyBhdCBpbmRleCBpICogNixcbi8vIHJlcHJlc2VudGluZyB0aGUgY2VudGVyIGFuZCBoYWxmLWV4dGVudCBpbiBlYWNoIGRpbWVuc2lvbiBvZiB0cmlhbmdsZSBpXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVRyaWFuZ2xlQm91bmRzKCBnZW8sIHRhcmdldCA9IG51bGwsIG9mZnNldCA9IG51bGwsIGNvdW50ID0gbnVsbCApIHtcblxuXHRjb25zdCBwb3NBdHRyID0gZ2VvLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdGNvbnN0IGluZGV4ID0gZ2VvLmluZGV4ID8gZ2VvLmluZGV4LmFycmF5IDogbnVsbDtcblx0Y29uc3QgdHJpQ291bnQgPSBnZXRUcmlDb3VudCggZ2VvICk7XG5cdGNvbnN0IG5vcm1hbGl6ZWQgPSBwb3NBdHRyLm5vcm1hbGl6ZWQ7XG5cdGxldCB0cmlhbmdsZUJvdW5kcztcblx0aWYgKCB0YXJnZXQgPT09IG51bGwgKSB7XG5cblx0XHR0cmlhbmdsZUJvdW5kcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRyaUNvdW50ICogNiAqIDQgKTtcblx0XHRvZmZzZXQgPSAwO1xuXHRcdGNvdW50ID0gdHJpQ291bnQ7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRyaWFuZ2xlQm91bmRzID0gdGFyZ2V0O1xuXHRcdG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHRcdGNvdW50ID0gY291bnQgfHwgdHJpQ291bnQ7XG5cblx0fVxuXG5cdC8vIHVzZWQgZm9yIG5vbi1ub3JtYWxpemVkIHBvc2l0aW9uc1xuXHRjb25zdCBwb3NBcnIgPSBwb3NBdHRyLmFycmF5O1xuXG5cdC8vIHN1cHBvcnQgZm9yIGFuIGludGVybGVhdmVkIHBvc2l0aW9uIGJ1ZmZlclxuXHRjb25zdCBidWZmZXJPZmZzZXQgPSBwb3NBdHRyLm9mZnNldCB8fCAwO1xuXHRsZXQgc3RyaWRlID0gMztcblx0aWYgKCBwb3NBdHRyLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRzdHJpZGUgPSBwb3NBdHRyLmRhdGEuc3RyaWRlO1xuXG5cdH1cblxuXHQvLyB1c2VkIGZvciBub3JtYWxpemVkIHBvc2l0aW9uc1xuXHRjb25zdCBnZXR0ZXJzID0gWyAnZ2V0WCcsICdnZXRZJywgJ2dldFonIF07XG5cblx0Zm9yICggbGV0IHRyaSA9IG9mZnNldDsgdHJpIDwgb2Zmc2V0ICsgY291bnQ7IHRyaSArKyApIHtcblxuXHRcdGNvbnN0IHRyaTMgPSB0cmkgKiAzO1xuXHRcdGNvbnN0IHRyaTYgPSB0cmkgKiA2O1xuXG5cdFx0bGV0IGFpID0gdHJpMyArIDA7XG5cdFx0bGV0IGJpID0gdHJpMyArIDE7XG5cdFx0bGV0IGNpID0gdHJpMyArIDI7XG5cblx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRhaSA9IGluZGV4WyBhaSBdO1xuXHRcdFx0YmkgPSBpbmRleFsgYmkgXTtcblx0XHRcdGNpID0gaW5kZXhbIGNpIF07XG5cblx0XHR9XG5cblx0XHQvLyB3ZSBhZGQgdGhlIHN0cmlkZSBhbmQgb2Zmc2V0IGhlcmUgc2luY2Ugd2UgYWNjZXNzIHRoZSBhcnJheSBkaXJlY3RseVxuXHRcdC8vIGJlbG93IGZvciB0aGUgc2FrZSBvZiBwZXJmb3JtYW5jZVxuXHRcdGlmICggISBub3JtYWxpemVkICkge1xuXG5cdFx0XHRhaSA9IGFpICogc3RyaWRlICsgYnVmZmVyT2Zmc2V0O1xuXHRcdFx0YmkgPSBiaSAqIHN0cmlkZSArIGJ1ZmZlck9mZnNldDtcblx0XHRcdGNpID0gY2kgKiBzdHJpZGUgKyBidWZmZXJPZmZzZXQ7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgZWwgPSAwOyBlbCA8IDM7IGVsICsrICkge1xuXG5cdFx0XHRsZXQgYSwgYiwgYztcblxuXHRcdFx0aWYgKCBub3JtYWxpemVkICkge1xuXG5cdFx0XHRcdGEgPSBwb3NBdHRyWyBnZXR0ZXJzWyBlbCBdIF0oIGFpICk7XG5cdFx0XHRcdGIgPSBwb3NBdHRyWyBnZXR0ZXJzWyBlbCBdIF0oIGJpICk7XG5cdFx0XHRcdGMgPSBwb3NBdHRyWyBnZXR0ZXJzWyBlbCBdIF0oIGNpICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YSA9IHBvc0FyclsgYWkgKyBlbCBdO1xuXHRcdFx0XHRiID0gcG9zQXJyWyBiaSArIGVsIF07XG5cdFx0XHRcdGMgPSBwb3NBcnJbIGNpICsgZWwgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbWluID0gYTtcblx0XHRcdGlmICggYiA8IG1pbiApIG1pbiA9IGI7XG5cdFx0XHRpZiAoIGMgPCBtaW4gKSBtaW4gPSBjO1xuXG5cdFx0XHRsZXQgbWF4ID0gYTtcblx0XHRcdGlmICggYiA+IG1heCApIG1heCA9IGI7XG5cdFx0XHRpZiAoIGMgPiBtYXggKSBtYXggPSBjO1xuXG5cdFx0XHQvLyBJbmNyZWFzZSB0aGUgYm91bmRzIHNpemUgYnkgZmxvYXQzMiBlcHNpbG9uIHRvIGF2b2lkIHByZWNpc2lvbiBlcnJvcnMgd2hlblxuXHRcdFx0Ly8gY29udmVydGluZyB0byAzMiBiaXQgZmxvYXQuIFNjYWxlIHRoZSBlcHNpbG9uIGJ5IHRoZSBzaXplIG9mIHRoZSBudW1iZXJzIGJlaW5nXG5cdFx0XHQvLyB3b3JrZWQgd2l0aC5cblx0XHRcdGNvbnN0IGhhbGZFeHRlbnRzID0gKCBtYXggLSBtaW4gKSAvIDI7XG5cdFx0XHRjb25zdCBlbDIgPSBlbCAqIDI7XG5cdFx0XHR0cmlhbmdsZUJvdW5kc1sgdHJpNiArIGVsMiArIDAgXSA9IG1pbiArIGhhbGZFeHRlbnRzO1xuXHRcdFx0dHJpYW5nbGVCb3VuZHNbIHRyaTYgKyBlbDIgKyAxIF0gPSBoYWxmRXh0ZW50cyArICggTWF0aC5hYnMoIG1pbiApICsgaGFsZkV4dGVudHMgKSAqIEZMT0FUMzJfRVBTSUxPTjtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHRyaWFuZ2xlQm91bmRzO1xuXG59XG4iXSwibmFtZXMiOlsiRkxPQVQzMl9FUFNJTE9OIiwiZ2V0VHJpQ291bnQiLCJnZXRCb3VuZHMiLCJ0cmlhbmdsZUJvdW5kcyIsIm9mZnNldCIsImNvdW50IiwidGFyZ2V0IiwiY2VudHJvaWRUYXJnZXQiLCJtaW54IiwiSW5maW5pdHkiLCJtaW55IiwibWlueiIsIm1heHgiLCJtYXh5IiwibWF4eiIsImNtaW54IiwiY21pbnkiLCJjbWlueiIsImNtYXh4IiwiY21heHkiLCJjbWF4eiIsImkiLCJlbmQiLCJjeCIsImh4IiwibHgiLCJyeCIsImN5IiwiaHkiLCJseSIsInJ5IiwiY3oiLCJoeiIsImx6IiwicnoiLCJjb21wdXRlVHJpYW5nbGVCb3VuZHMiLCJnZW8iLCJwb3NBdHRyIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiaW5kZXgiLCJhcnJheSIsInRyaUNvdW50Iiwibm9ybWFsaXplZCIsIkZsb2F0MzJBcnJheSIsInBvc0FyciIsImJ1ZmZlck9mZnNldCIsInN0cmlkZSIsImlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUiLCJkYXRhIiwiZ2V0dGVycyIsInRyaSIsInRyaTMiLCJ0cmk2IiwiYWkiLCJiaSIsImNpIiwiZWwiLCJhIiwiYiIsImMiLCJtaW4iLCJtYXgiLCJoYWxmRXh0ZW50cyIsImVsMiIsIk1hdGgiLCJhYnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/geometryUtils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/build/geometryUtils.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureIndex: function() { return /* binding */ ensureIndex; },\n/* harmony export */   getFullGeometryRange: function() { return /* binding */ getFullGeometryRange; },\n/* harmony export */   getIndexArray: function() { return /* binding */ getIndexArray; },\n/* harmony export */   getRootIndexRanges: function() { return /* binding */ getRootIndexRanges; },\n/* harmony export */   getTriCount: function() { return /* binding */ getTriCount; },\n/* harmony export */   getVertexCount: function() { return /* binding */ getVertexCount; },\n/* harmony export */   hasGroupGaps: function() { return /* binding */ hasGroupGaps; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nfunction getVertexCount(geo) {\n    return geo.index ? geo.index.count : geo.attributes.position.count;\n}\nfunction getTriCount(geo) {\n    return getVertexCount(geo) / 3;\n}\nfunction getIndexArray(vertexCount) {\n    let BufferConstructor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ArrayBuffer;\n    if (vertexCount > 65535) {\n        return new Uint32Array(new BufferConstructor(4 * vertexCount));\n    } else {\n        return new Uint16Array(new BufferConstructor(2 * vertexCount));\n    }\n}\n// ensures that an index is present on the geometry\nfunction ensureIndex(geo, options) {\n    if (!geo.index) {\n        const vertexCount = geo.attributes.position.count;\n        const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n        const index = getIndexArray(vertexCount, BufferConstructor);\n        geo.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(index, 1));\n        for(let i = 0; i < vertexCount; i++){\n            index[i] = i;\n        }\n    }\n}\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getFullGeometryRange(geo) {\n    const triCount = getTriCount(geo);\n    const drawRange = geo.drawRange;\n    const start = drawRange.start / 3;\n    const end = (drawRange.start + drawRange.count) / 3;\n    const offset = Math.max(0, start);\n    const count = Math.min(triCount, end) - offset;\n    return [\n        {\n            offset: Math.floor(offset),\n            count: Math.floor(count)\n        }\n    ];\n}\nfunction getRootIndexRanges(geo) {\n    if (!geo.groups || !geo.groups.length) {\n        return getFullGeometryRange(geo);\n    }\n    const ranges = [];\n    const rangeBoundaries = new Set();\n    const drawRange = geo.drawRange;\n    const drawRangeStart = drawRange.start / 3;\n    const drawRangeEnd = (drawRange.start + drawRange.count) / 3;\n    for (const group of geo.groups){\n        const groupStart = group.start / 3;\n        const groupEnd = (group.start + group.count) / 3;\n        rangeBoundaries.add(Math.max(drawRangeStart, groupStart));\n        rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));\n    }\n    // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n    const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b)=>a - b);\n    for(let i = 0; i < sortedBoundaries.length - 1; i++){\n        const start = sortedBoundaries[i];\n        const end = sortedBoundaries[i + 1];\n        ranges.push({\n            offset: Math.floor(start),\n            count: Math.floor(end - start)\n        });\n    }\n    return ranges;\n}\nfunction hasGroupGaps(geometry) {\n    if (geometry.groups.length === 0) {\n        return false;\n    }\n    const vertexCount = getTriCount(geometry);\n    const groups = getRootIndexRanges(geometry).sort((a, b)=>a.offset - b.offset);\n    const finalGroup = groups[groups.length - 1];\n    finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);\n    let total = 0;\n    groups.forEach((param)=>{\n        let { count } = param;\n        return total += count;\n    });\n    return vertexCount !== total;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9nZW9tZXRyeVV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXdDO0FBRWpDLFNBQVNDLGVBQWdCQyxHQUFHO0lBRWxDLE9BQU9BLElBQUlDLEtBQUssR0FBR0QsSUFBSUMsS0FBSyxDQUFDQyxLQUFLLEdBQUdGLElBQUlHLFVBQVUsQ0FBQ0MsUUFBUSxDQUFDRixLQUFLO0FBRW5FO0FBRU8sU0FBU0csWUFBYUwsR0FBRztJQUUvQixPQUFPRCxlQUFnQkMsT0FBUTtBQUVoQztBQUVPLFNBQVNNLGNBQWVDLFdBQVc7UUFBRUMsb0JBQUFBLGlFQUFvQkM7SUFFL0QsSUFBS0YsY0FBYyxPQUFRO1FBRTFCLE9BQU8sSUFBSUcsWUFBYSxJQUFJRixrQkFBbUIsSUFBSUQ7SUFFcEQsT0FBTztRQUVOLE9BQU8sSUFBSUksWUFBYSxJQUFJSCxrQkFBbUIsSUFBSUQ7SUFFcEQ7QUFFRDtBQUVBLG1EQUFtRDtBQUM1QyxTQUFTSyxZQUFhWixHQUFHLEVBQUVhLE9BQU87SUFFeEMsSUFBSyxDQUFFYixJQUFJQyxLQUFLLEVBQUc7UUFFbEIsTUFBTU0sY0FBY1AsSUFBSUcsVUFBVSxDQUFDQyxRQUFRLENBQUNGLEtBQUs7UUFDakQsTUFBTU0sb0JBQW9CSyxRQUFRQyxvQkFBb0IsR0FBR0Msb0JBQW9CTjtRQUM3RSxNQUFNUixRQUFRSyxjQUFlQyxhQUFhQztRQUMxQ1IsSUFBSWdCLFFBQVEsQ0FBRSxJQUFJbEIsa0RBQWVBLENBQUVHLE9BQU87UUFFMUMsSUFBTSxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJVixhQUFhVSxJQUFPO1lBRXhDaEIsS0FBSyxDQUFFZ0IsRUFBRyxHQUFHQTtRQUVkO0lBRUQ7QUFFRDtBQUVBLHNGQUFzRjtBQUN0RiwyRkFBMkY7QUFDM0YsMEZBQTBGO0FBQzFGLDZGQUE2RjtBQUM3RixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xF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ZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvYnVpbGQvZ2VvbWV0cnlVdGlscy5qcz9mNjk5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJ3RocmVlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZlcnRleENvdW50KCBnZW8gKSB7XG5cblx0cmV0dXJuIGdlby5pbmRleCA/IGdlby5pbmRleC5jb3VudCA6IGdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmlDb3VudCggZ2VvICkge1xuXG5cdHJldHVybiBnZXRWZXJ0ZXhDb3VudCggZ2VvICkgLyAzO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleEFycmF5KCB2ZXJ0ZXhDb3VudCwgQnVmZmVyQ29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlciApIHtcblxuXHRpZiAoIHZlcnRleENvdW50ID4gNjU1MzUgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFVpbnQzMkFycmF5KCBuZXcgQnVmZmVyQ29uc3RydWN0b3IoIDQgKiB2ZXJ0ZXhDb3VudCApICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHJldHVybiBuZXcgVWludDE2QXJyYXkoIG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggMiAqIHZlcnRleENvdW50ICkgKTtcblxuXHR9XG5cbn1cblxuLy8gZW5zdXJlcyB0aGF0IGFuIGluZGV4IGlzIHByZXNlbnQgb24gdGhlIGdlb21ldHJ5XG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlSW5kZXgoIGdlbywgb3B0aW9ucyApIHtcblxuXHRpZiAoICEgZ2VvLmluZGV4ICkge1xuXG5cdFx0Y29uc3QgdmVydGV4Q291bnQgPSBnZW8uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcblx0XHRjb25zdCBCdWZmZXJDb25zdHJ1Y3RvciA9IG9wdGlvbnMudXNlU2hhcmVkQXJyYXlCdWZmZXIgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IEFycmF5QnVmZmVyO1xuXHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhBcnJheSggdmVydGV4Q291bnQsIEJ1ZmZlckNvbnN0cnVjdG9yICk7XG5cdFx0Z2VvLnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRleCwgMSApICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSArKyApIHtcblxuXHRcdFx0aW5kZXhbIGkgXSA9IGk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8vIENvbXB1dGVzIHRoZSBzZXQgb2YgeyBvZmZzZXQsIGNvdW50IH0gcmFuZ2VzIHdoaWNoIG5lZWQgaW5kZXBlbmRlbnQgQlZIIHJvb3RzLiBFYWNoXG4vLyByZWdpb24gaW4gdGhlIGdlb21ldHJ5IGluZGV4IHRoYXQgYmVsb25ncyB0byBhIGRpZmZlcmVudCBzZXQgb2YgbWF0ZXJpYWwgZ3JvdXBzIHJlcXVpcmVzXG4vLyBhIHNlcGFyYXRlIEJWSCByb290LCBzbyB0aGF0IHRyaWFuZ2xlcyBpbmRpY2VzIGJlbG9uZ2luZyB0byBvbmUgZ3JvdXAgbmV2ZXIgZ2V0IHN3YXBwZWRcbi8vIHdpdGggdHJpYW5nbGUgaW5kaWNlcyBiZWxvbmdzIHRvIGFub3RoZXIgZ3JvdXAuIEZvciBleGFtcGxlLCBpZiB0aGUgZ3JvdXBzIHdlcmUgbGlrZSB0aGlzOlxuLy9cbi8vIFstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXVxuLy8gfF9fX19fX19fX19fX19fX19fX3xcbi8vICAgZzAgPSBbMCwgMjBdICB8X19fX19fX19fX19fX19fX19fX19fX3x8X19fX19fX19fX19fX19fX19fX19ffFxuLy8gICAgICAgICAgICAgICAgICAgICAgZzEgPSBbMTYsIDQwXSAgICAgICAgICAgZzIgPSBbNDEsIDYwXVxuLy9cbi8vIHdlIHdvdWxkIG5lZWQgZm91ciBCVkggcm9vdHM6IFswLCAxNV0sIFsxNiwgMjBdLCBbMjEsIDQwXSwgWzQxLCA2MF0uXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVsbEdlb21ldHJ5UmFuZ2UoIGdlbyApIHtcblxuXHRjb25zdCB0cmlDb3VudCA9IGdldFRyaUNvdW50KCBnZW8gKTtcblx0Y29uc3QgZHJhd1JhbmdlID0gZ2VvLmRyYXdSYW5nZTtcblx0Y29uc3Qgc3RhcnQgPSBkcmF3UmFuZ2Uuc3RhcnQgLyAzO1xuXHRjb25zdCBlbmQgPSAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApIC8gMztcblxuXHRjb25zdCBvZmZzZXQgPSBNYXRoLm1heCggMCwgc3RhcnQgKTtcblx0Y29uc3QgY291bnQgPSBNYXRoLm1pbiggdHJpQ291bnQsIGVuZCApIC0gb2Zmc2V0O1xuXHRyZXR1cm4gWyB7XG5cdFx0b2Zmc2V0OiBNYXRoLmZsb29yKCBvZmZzZXQgKSxcblx0XHRjb3VudDogTWF0aC5mbG9vciggY291bnQgKSxcblx0fSBdO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb290SW5kZXhSYW5nZXMoIGdlbyApIHtcblxuXHRpZiAoICEgZ2VvLmdyb3VwcyB8fCAhIGdlby5ncm91cHMubGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIGdldEZ1bGxHZW9tZXRyeVJhbmdlKCBnZW8gKTtcblxuXHR9XG5cblx0Y29uc3QgcmFuZ2VzID0gW107XG5cdGNvbnN0IHJhbmdlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcblxuXHRjb25zdCBkcmF3UmFuZ2UgPSBnZW8uZHJhd1JhbmdlO1xuXHRjb25zdCBkcmF3UmFuZ2VTdGFydCA9IGRyYXdSYW5nZS5zdGFydCAvIDM7XG5cdGNvbnN0IGRyYXdSYW5nZUVuZCA9ICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgLyAzO1xuXHRmb3IgKCBjb25zdCBncm91cCBvZiBnZW8uZ3JvdXBzICkge1xuXG5cdFx0Y29uc3QgZ3JvdXBTdGFydCA9IGdyb3VwLnN0YXJ0IC8gMztcblx0XHRjb25zdCBncm91cEVuZCA9ICggZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCApIC8gMztcblx0XHRyYW5nZUJvdW5kYXJpZXMuYWRkKCBNYXRoLm1heCggZHJhd1JhbmdlU3RhcnQsIGdyb3VwU3RhcnQgKSApO1xuXHRcdHJhbmdlQm91bmRhcmllcy5hZGQoIE1hdGgubWluKCBkcmF3UmFuZ2VFbmQsIGdyb3VwRW5kICkgKTtcblxuXHR9XG5cblxuXHQvLyBub3RlIHRoYXQgaWYgeW91IGRvbid0IHBhc3MgaW4gYSBjb21wYXJhdG9yLCBpdCBzb3J0cyB0aGVtIGxleGljb2dyYXBoaWNhbGx5IGFzIHN0cmluZ3MgOi0oXG5cdGNvbnN0IHNvcnRlZEJvdW5kYXJpZXMgPSBBcnJheS5mcm9tKCByYW5nZUJvdW5kYXJpZXMudmFsdWVzKCkgKS5zb3J0KCAoIGEsIGIgKSA9PiBhIC0gYiApO1xuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzb3J0ZWRCb3VuZGFyaWVzLmxlbmd0aCAtIDE7IGkgKysgKSB7XG5cblx0XHRjb25zdCBzdGFydCA9IHNvcnRlZEJvdW5kYXJpZXNbIGkgXTtcblx0XHRjb25zdCBlbmQgPSBzb3J0ZWRCb3VuZGFyaWVzWyBpICsgMSBdO1xuXG5cdFx0cmFuZ2VzLnB1c2goIHtcblx0XHRcdG9mZnNldDogTWF0aC5mbG9vciggc3RhcnQgKSxcblx0XHRcdGNvdW50OiBNYXRoLmZsb29yKCBlbmQgLSBzdGFydCApLFxuXHRcdH0gKTtcblxuXHR9XG5cblx0cmV0dXJuIHJhbmdlcztcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzR3JvdXBHYXBzKCBnZW9tZXRyeSApIHtcblxuXHRpZiAoIGdlb21ldHJ5Lmdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdGNvbnN0IHZlcnRleENvdW50ID0gZ2V0VHJpQ291bnQoIGdlb21ldHJ5ICk7XG5cdGNvbnN0IGdyb3VwcyA9IGdldFJvb3RJbmRleFJhbmdlcyggZ2VvbWV0cnkgKVxuXHRcdC5zb3J0KCAoIGEsIGIgKSA9PiBhLm9mZnNldCAtIGIub2Zmc2V0ICk7XG5cblx0Y29uc3QgZmluYWxHcm91cCA9IGdyb3Vwc1sgZ3JvdXBzLmxlbmd0aCAtIDEgXTtcblx0ZmluYWxHcm91cC5jb3VudCA9IE1hdGgubWluKCB2ZXJ0ZXhDb3VudCAtIGZpbmFsR3JvdXAub2Zmc2V0LCBmaW5hbEdyb3VwLmNvdW50ICk7XG5cblx0bGV0IHRvdGFsID0gMDtcblx0Z3JvdXBzLmZvckVhY2goICggeyBjb3VudCB9ICkgPT4gdG90YWwgKz0gY291bnQgKTtcblx0cmV0dXJuIHZlcnRleENvdW50ICE9PSB0b3RhbDtcblxufVxuIl0sIm5hbWVzIjpbIkJ1ZmZlckF0dHJpYnV0ZSIsImdldFZlcnRleENvdW50IiwiZ2VvIiwiaW5kZXgiLCJjb3VudCIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsImdldFRyaUNvdW50IiwiZ2V0SW5kZXhBcnJheSIsInZlcnRleENvdW50IiwiQnVmZmVyQ29uc3RydWN0b3IiLCJBcnJheUJ1ZmZlciIsIlVpbnQzMkFycmF5IiwiVWludDE2QXJyYXkiLCJlbnN1cmVJbmRleCIsIm9wdGlvbnMiLCJ1c2VTaGFyZWRBcnJheUJ1ZmZlciIsIlNoYXJlZEFycmF5QnVmZmVyIiwic2V0SW5kZXgiLCJpIiwiZ2V0RnVsbEdlb21ldHJ5UmFuZ2UiLCJ0cmlDb3VudCIsImRyYXdSYW5nZSIsInN0YXJ0IiwiZW5kIiwib2Zmc2V0IiwiTWF0aCIsIm1heCIsIm1pbiIsImZsb29yIiwiZ2V0Um9vdEluZGV4UmFuZ2VzIiwiZ3JvdXBzIiwibGVuZ3RoIiwicmFuZ2VzIiwicmFuZ2VCb3VuZGFyaWVzIiwiU2V0IiwiZHJhd1JhbmdlU3RhcnQiLCJkcmF3UmFuZ2VFbmQiLCJncm91cCIsImdyb3VwU3RhcnQiLCJncm91cEVuZCIsImFkZCIsInNvcnRlZEJvdW5kYXJpZXMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJwdXNoIiwiaGFzR3JvdXBHYXBzIiwiZ2VvbWV0cnkiLCJmaW5hbEdyb3VwIiwidG90YWwiLCJmb3JFYWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/geometryUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js":
/*!***************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   partition: function() { return /* binding */ partition; }\n/* harmony export */ });\n/********************************************************/ /* This file is generated from \"sortUtils.template.js\". */ /********************************************************/ // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition(indirectBuffer, index, triangleBounds, offset, count, split) {\n    let left = offset;\n    let right = offset + count - 1;\n    const pos = split.pos;\n    const axisOffset = split.axis * 2;\n    // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    while(true){\n        while(left <= right && triangleBounds[left * 6 + axisOffset] < pos){\n            left++;\n        }\n        // if a triangle center lies on the partition plane it is considered to be on the right side\n        while(left <= right && triangleBounds[right * 6 + axisOffset] >= pos){\n            right--;\n        }\n        if (left < right) {\n            // we need to swap all of the information associated with the triangles at index\n            // left and right; that's the verts in the geometry index, the bounds,\n            // and perhaps the SAH planes\n            for(let i = 0; i < 3; i++){\n                let t0 = index[left * 3 + i];\n                index[left * 3 + i] = index[right * 3 + i];\n                index[right * 3 + i] = t0;\n            }\n            // swap bounds\n            for(let i = 0; i < 6; i++){\n                let tb = triangleBounds[left * 6 + i];\n                triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n                triangleBounds[right * 6 + i] = tb;\n            }\n            left++;\n            right--;\n        } else {\n            return left;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9zb3J0VXRpbHMuZ2VuZXJhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx3REFBd0QsR0FDeEQsd0RBQXdELEdBQ3hELHdEQUF3RCxHQUN4RCx3R0FBd0c7QUFDeEcsMEdBQTBHO0FBQzFHLHdHQUF3RztBQUN4RyxTQUFTQSxVQUFXQyxjQUFjLEVBQUVDLEtBQUssRUFBRUMsY0FBYyxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsS0FBSztJQUU5RSxJQUFJQyxPQUFPSDtJQUNYLElBQUlJLFFBQVFKLFNBQVNDLFFBQVE7SUFDN0IsTUFBTUksTUFBTUgsTUFBTUcsR0FBRztJQUNyQixNQUFNQyxhQUFhSixNQUFNSyxJQUFJLEdBQUc7SUFFaEMsOEZBQThGO0lBQzlGLE1BQVEsS0FBTztRQUVkLE1BQVFKLFFBQVFDLFNBQVNMLGNBQWMsQ0FBRUksT0FBTyxJQUFJRyxXQUFZLEdBQUdELElBQU07WUFFeEVGO1FBRUQ7UUFFQSw0RkFBNEY7UUFDNUYsTUFBUUEsUUFBUUMsU0FBU0wsY0FBYyxDQUFFSyxRQUFRLElBQUlFLFdBQVksSUFBSUQsSUFBTTtZQUUxRUQ7UUFFRDtRQUVBLElBQUtELE9BQU9DLE9BQVE7WUFFbkIsZ0ZBQWdGO1lBQ2hGLHNFQUFzRTtZQUN0RSw2QkFBNkI7WUFFN0IsSUFBTSxJQUFJSSxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBTztnQkFFOUIsSUFBSUMsS0FBS1gsS0FBSyxDQUFFSyxPQUFPLElBQUlLLEVBQUc7Z0JBQzlCVixLQUFLLENBQUVLLE9BQU8sSUFBSUssRUFBRyxHQUFHVixLQUFLLENBQUVNLFFBQVEsSUFBSUksRUFBRztnQkFDOUNWLEtBQUssQ0FBRU0sUUFBUSxJQUFJSSxFQUFHLEdBQUdDO1lBRTFCO1lBR0EsY0FBYztZQUNkLElBQU0sSUFBSUQsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQU87Z0JBRTlCLElBQUlFLEtBQUtYLGNBQWMsQ0FBRUksT0FBTyxJQUFJSyxFQUFHO2dCQUN2Q1QsY0FBYyxDQUFFSSxPQUFPLElBQUlLLEVBQUcsR0FBR1QsY0FBYyxDQUFFSyxRQUFRLElBQUlJLEVBQUc7Z0JBQ2hFVCxjQUFjLENBQUVLLFFBQVEsSUFBSUksRUFBRyxHQUFHRTtZQUVuQztZQUVBUDtZQUNBQztRQUVELE9BQU87WUFFTixPQUFPRDtRQUVSO0lBRUQ7QUFFRDtBQUVxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvYnVpbGQvc29ydFV0aWxzLmdlbmVyYXRlZC5qcz83ZGI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInNvcnRVdGlscy50ZW1wbGF0ZS5qc1wiLiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLy8gcmVvcmRlcnMgYHRyaXNgIHN1Y2ggdGhhdCBmb3IgYGNvdW50YCBlbGVtZW50cyBhZnRlciBgb2Zmc2V0YCwgZWxlbWVudHMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgc3BsaXRcbi8vIHdpbGwgYmUgb24gdGhlIGxlZnQgYW5kIGVsZW1lbnRzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzcGxpdCB3aWxsIGJlIG9uIHRoZSByaWdodC4gcmV0dXJucyB0aGUgaW5kZXhcbi8vIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9uIHRoZSByaWdodCBzaWRlLCBvciBvZmZzZXQgKyBjb3VudCBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHMgb24gdGhlIHJpZ2h0IHNpZGUuXG5mdW5jdGlvbiBwYXJ0aXRpb24oIGluZGlyZWN0QnVmZmVyLCBpbmRleCwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHNwbGl0ICkge1xuXG5cdGxldCBsZWZ0ID0gb2Zmc2V0O1xuXHRsZXQgcmlnaHQgPSBvZmZzZXQgKyBjb3VudCAtIDE7XG5cdGNvbnN0IHBvcyA9IHNwbGl0LnBvcztcblx0Y29uc3QgYXhpc09mZnNldCA9IHNwbGl0LmF4aXMgKiAyO1xuXG5cdC8vIGhvYXJlIHBhcnRpdGlvbmluZywgc2VlIGUuZy4gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVpY2tzb3J0I0hvYXJlX3BhcnRpdGlvbl9zY2hlbWVcblx0d2hpbGUgKCB0cnVlICkge1xuXG5cdFx0d2hpbGUgKCBsZWZ0IDw9IHJpZ2h0ICYmIHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGF4aXNPZmZzZXQgXSA8IHBvcyApIHtcblxuXHRcdFx0bGVmdCArKztcblxuXHRcdH1cblxuXHRcdC8vIGlmIGEgdHJpYW5nbGUgY2VudGVyIGxpZXMgb24gdGhlIHBhcnRpdGlvbiBwbGFuZSBpdCBpcyBjb25zaWRlcmVkIHRvIGJlIG9uIHRoZSByaWdodCBzaWRlXG5cdFx0d2hpbGUgKCBsZWZ0IDw9IHJpZ2h0ICYmIHRyaWFuZ2xlQm91bmRzWyByaWdodCAqIDYgKyBheGlzT2Zmc2V0IF0gPj0gcG9zICkge1xuXG5cdFx0XHRyaWdodCAtLTtcblxuXHRcdH1cblxuXHRcdGlmICggbGVmdCA8IHJpZ2h0ICkge1xuXG5cdFx0XHQvLyB3ZSBuZWVkIHRvIHN3YXAgYWxsIG9mIHRoZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHRyaWFuZ2xlcyBhdCBpbmRleFxuXHRcdFx0Ly8gbGVmdCBhbmQgcmlnaHQ7IHRoYXQncyB0aGUgdmVydHMgaW4gdGhlIGdlb21ldHJ5IGluZGV4LCB0aGUgYm91bmRzLFxuXHRcdFx0Ly8gYW5kIHBlcmhhcHMgdGhlIFNBSCBwbGFuZXNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgdDAgPSBpbmRleFsgbGVmdCAqIDMgKyBpIF07XG5cdFx0XHRcdGluZGV4WyBsZWZ0ICogMyArIGkgXSA9IGluZGV4WyByaWdodCAqIDMgKyBpIF07XG5cdFx0XHRcdGluZGV4WyByaWdodCAqIDMgKyBpIF0gPSB0MDtcblxuXHRcdFx0fVxuXG5cblx0XHRcdC8vIHN3YXAgYm91bmRzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdGxldCB0YiA9IHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGkgXTtcblx0XHRcdFx0dHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgaSBdID0gdHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGkgXTtcblx0XHRcdFx0dHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGkgXSA9IHRiO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxlZnQgKys7XG5cdFx0XHRyaWdodCAtLTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBsZWZ0O1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyBwYXJ0aXRpb24gfTtcbiJdLCJuYW1lcyI6WyJwYXJ0aXRpb24iLCJpbmRpcmVjdEJ1ZmZlciIsImluZGV4IiwidHJpYW5nbGVCb3VuZHMiLCJvZmZzZXQiLCJjb3VudCIsInNwbGl0IiwibGVmdCIsInJpZ2h0IiwicG9zIiwiYXhpc09mZnNldCIsImF4aXMiLCJpIiwidDAiLCJ0YiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js":
/*!************************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   partition_indirect: function() { return /* binding */ partition_indirect; }\n/* harmony export */ });\n/********************************************************/ /* This file is generated from \"sortUtils.template.js\". */ /********************************************************/ // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {\n    let left = offset;\n    let right = offset + count - 1;\n    const pos = split.pos;\n    const axisOffset = split.axis * 2;\n    // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    while(true){\n        while(left <= right && triangleBounds[left * 6 + axisOffset] < pos){\n            left++;\n        }\n        // if a triangle center lies on the partition plane it is considered to be on the right side\n        while(left <= right && triangleBounds[right * 6 + axisOffset] >= pos){\n            right--;\n        }\n        if (left < right) {\n            // we need to swap all of the information associated with the triangles at index\n            // left and right; that's the verts in the geometry index, the bounds,\n            // and perhaps the SAH planes\n            let t = indirectBuffer[left];\n            indirectBuffer[left] = indirectBuffer[right];\n            indirectBuffer[right] = t;\n            // swap bounds\n            for(let i = 0; i < 6; i++){\n                let tb = triangleBounds[left * 6 + i];\n                triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n                triangleBounds[right * 6 + i] = tb;\n            }\n            left++;\n            right--;\n        } else {\n            return left;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9zb3J0VXRpbHNfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx3REFBd0QsR0FDeEQsd0RBQXdELEdBQ3hELHdEQUF3RCxHQUN4RCx3R0FBd0c7QUFDeEcsMEdBQTBHO0FBQzFHLHdHQUF3RztBQUN4RyxTQUFTQSxtQkFBb0JDLGNBQWMsRUFBRUMsS0FBSyxFQUFFQyxjQUFjLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLO0lBRXZGLElBQUlDLE9BQU9IO0lBQ1gsSUFBSUksUUFBUUosU0FBU0MsUUFBUTtJQUM3QixNQUFNSSxNQUFNSCxNQUFNRyxHQUFHO0lBQ3JCLE1BQU1DLGFBQWFKLE1BQU1LLElBQUksR0FBRztJQUVoQyw4RkFBOEY7SUFDOUYsTUFBUSxLQUFPO1FBRWQsTUFBUUosUUFBUUMsU0FBU0wsY0FBYyxDQUFFSSxPQUFPLElBQUlHLFdBQVksR0FBR0QsSUFBTTtZQUV4RUY7UUFFRDtRQUVBLDRGQUE0RjtRQUM1RixNQUFRQSxRQUFRQyxTQUFTTCxjQUFjLENBQUVLLFFBQVEsSUFBSUUsV0FBWSxJQUFJRCxJQUFNO1lBRTFFRDtRQUVEO1FBRUEsSUFBS0QsT0FBT0MsT0FBUTtZQUVuQixnRkFBZ0Y7WUFDaEYsc0VBQXNFO1lBQ3RFLDZCQUE2QjtZQUM3QixJQUFJSSxJQUFJWCxjQUFjLENBQUVNLEtBQU07WUFDOUJOLGNBQWMsQ0FBRU0sS0FBTSxHQUFHTixjQUFjLENBQUVPLE1BQU87WUFDaERQLGNBQWMsQ0FBRU8sTUFBTyxHQUFHSTtZQUcxQixjQUFjO1lBQ2QsSUFBTSxJQUFJQyxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBTztnQkFFOUIsSUFBSUMsS0FBS1gsY0FBYyxDQUFFSSxPQUFPLElBQUlNLEVBQUc7Z0JBQ3ZDVixjQUFjLENBQUVJLE9BQU8sSUFBSU0sRUFBRyxHQUFHVixjQUFjLENBQUVLLFFBQVEsSUFBSUssRUFBRztnQkFDaEVWLGNBQWMsQ0FBRUssUUFBUSxJQUFJSyxFQUFHLEdBQUdDO1lBRW5DO1lBRUFQO1lBQ0FDO1FBRUQsT0FBTztZQUVOLE9BQU9EO1FBRVI7SUFFRDtBQUVEO0FBRThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9zb3J0VXRpbHNfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzPzk3YjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwic29ydFV0aWxzLnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLyByZW9yZGVycyBgdHJpc2Agc3VjaCB0aGF0IGZvciBgY291bnRgIGVsZW1lbnRzIGFmdGVyIGBvZmZzZXRgLCBlbGVtZW50cyBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBzcGxpdFxuLy8gd2lsbCBiZSBvbiB0aGUgbGVmdCBhbmQgZWxlbWVudHMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNwbGl0IHdpbGwgYmUgb24gdGhlIHJpZ2h0LiByZXR1cm5zIHRoZSBpbmRleFxuLy8gb2YgdGhlIGZpcnN0IGVsZW1lbnQgb24gdGhlIHJpZ2h0IHNpZGUsIG9yIG9mZnNldCArIGNvdW50IGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBvbiB0aGUgcmlnaHQgc2lkZS5cbmZ1bmN0aW9uIHBhcnRpdGlvbl9pbmRpcmVjdCggaW5kaXJlY3RCdWZmZXIsIGluZGV4LCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgc3BsaXQgKSB7XG5cblx0bGV0IGxlZnQgPSBvZmZzZXQ7XG5cdGxldCByaWdodCA9IG9mZnNldCArIGNvdW50IC0gMTtcblx0Y29uc3QgcG9zID0gc3BsaXQucG9zO1xuXHRjb25zdCBheGlzT2Zmc2V0ID0gc3BsaXQuYXhpcyAqIDI7XG5cblx0Ly8gaG9hcmUgcGFydGl0aW9uaW5nLCBzZWUgZS5nLiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWlja3NvcnQjSG9hcmVfcGFydGl0aW9uX3NjaGVtZVxuXHR3aGlsZSAoIHRydWUgKSB7XG5cblx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgYXhpc09mZnNldCBdIDwgcG9zICkge1xuXG5cdFx0XHRsZWZ0ICsrO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaWYgYSB0cmlhbmdsZSBjZW50ZXIgbGllcyBvbiB0aGUgcGFydGl0aW9uIHBsYW5lIGl0IGlzIGNvbnNpZGVyZWQgdG8gYmUgb24gdGhlIHJpZ2h0IHNpZGVcblx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGF4aXNPZmZzZXQgXSA+PSBwb3MgKSB7XG5cblx0XHRcdHJpZ2h0IC0tO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBsZWZ0IDwgcmlnaHQgKSB7XG5cblx0XHRcdC8vIHdlIG5lZWQgdG8gc3dhcCBhbGwgb2YgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHJpYW5nbGVzIGF0IGluZGV4XG5cdFx0XHQvLyBsZWZ0IGFuZCByaWdodDsgdGhhdCdzIHRoZSB2ZXJ0cyBpbiB0aGUgZ2VvbWV0cnkgaW5kZXgsIHRoZSBib3VuZHMsXG5cdFx0XHQvLyBhbmQgcGVyaGFwcyB0aGUgU0FIIHBsYW5lc1xuXHRcdFx0bGV0IHQgPSBpbmRpcmVjdEJ1ZmZlclsgbGVmdCBdO1xuXHRcdFx0aW5kaXJlY3RCdWZmZXJbIGxlZnQgXSA9IGluZGlyZWN0QnVmZmVyWyByaWdodCBdO1xuXHRcdFx0aW5kaXJlY3RCdWZmZXJbIHJpZ2h0IF0gPSB0O1xuXG5cblx0XHRcdC8vIHN3YXAgYm91bmRzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdGxldCB0YiA9IHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGkgXTtcblx0XHRcdFx0dHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgaSBdID0gdHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGkgXTtcblx0XHRcdFx0dHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGkgXSA9IHRiO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxlZnQgKys7XG5cdFx0XHRyaWdodCAtLTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBsZWZ0O1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyBwYXJ0aXRpb25faW5kaXJlY3QgfTtcbiJdLCJuYW1lcyI6WyJwYXJ0aXRpb25faW5kaXJlY3QiLCJpbmRpcmVjdEJ1ZmZlciIsImluZGV4IiwidHJpYW5nbGVCb3VuZHMiLCJvZmZzZXQiLCJjb3VudCIsInNwbGl0IiwibGVmdCIsInJpZ2h0IiwicG9zIiwiYXhpc09mZnNldCIsImF4aXMiLCJ0IiwiaSIsInRiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/splitUtils.js":
/*!******************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/build/splitUtils.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOptimalSplit: function() { return /* binding */ getOptimalSplit; }\n/* harmony export */ });\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Constants.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/Constants.js\");\n\n\nconst BIN_COUNT = 32;\nconst binsSort = (a, b)=>a.candidate - b.candidate;\nconst sahBins = new Array(BIN_COUNT).fill().map(()=>{\n    return {\n        count: 0,\n        bounds: new Float32Array(6),\n        rightCacheBounds: new Float32Array(6),\n        leftCacheBounds: new Float32Array(6),\n        candidate: 0\n    };\n});\nconst leftBounds = new Float32Array(6);\nfunction getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n    let axis = -1;\n    let pos = 0;\n    // Center\n    if (strategy === _Constants_js__WEBPACK_IMPORTED_MODULE_0__.CENTER) {\n        axis = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.getLongestEdgeIndex)(centroidBoundingData);\n        if (axis !== -1) {\n            pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n        }\n    } else if (strategy === _Constants_js__WEBPACK_IMPORTED_MODULE_0__.AVERAGE) {\n        axis = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.getLongestEdgeIndex)(nodeBoundingData);\n        if (axis !== -1) {\n            pos = getAverage(triangleBounds, offset, count, axis);\n        }\n    } else if (strategy === _Constants_js__WEBPACK_IMPORTED_MODULE_0__.SAH) {\n        const rootSurfaceArea = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.computeSurfaceArea)(nodeBoundingData);\n        let bestCost = _Constants_js__WEBPACK_IMPORTED_MODULE_0__.TRIANGLE_INTERSECT_COST * count;\n        // iterate over all axes\n        const cStart = offset * 6;\n        const cEnd = (offset + count) * 6;\n        for(let a = 0; a < 3; a++){\n            const axisLeft = centroidBoundingData[a];\n            const axisRight = centroidBoundingData[a + 3];\n            const axisLength = axisRight - axisLeft;\n            const binWidth = axisLength / BIN_COUNT;\n            // If we have fewer triangles than we're planning to split then just check all\n            // the triangle positions because it will be faster.\n            if (count < BIN_COUNT / 4) {\n                // initialize the bin candidates\n                const truncatedBins = [\n                    ...sahBins\n                ];\n                truncatedBins.length = count;\n                // set the candidates\n                let b = 0;\n                for(let c = cStart; c < cEnd; c += 6, b++){\n                    const bin = truncatedBins[b];\n                    bin.candidate = triangleBounds[c + 2 * a];\n                    bin.count = 0;\n                    const { bounds, leftCacheBounds, rightCacheBounds } = bin;\n                    for(let d = 0; d < 3; d++){\n                        rightCacheBounds[d] = Infinity;\n                        rightCacheBounds[d + 3] = -Infinity;\n                        leftCacheBounds[d] = Infinity;\n                        leftCacheBounds[d + 3] = -Infinity;\n                        bounds[d] = Infinity;\n                        bounds[d + 3] = -Infinity;\n                    }\n                    (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.expandByTriangleBounds)(c, triangleBounds, bounds);\n                }\n                truncatedBins.sort(binsSort);\n                // remove redundant splits\n                let splitCount = count;\n                for(let bi = 0; bi < splitCount; bi++){\n                    const bin = truncatedBins[bi];\n                    while(bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate){\n                        truncatedBins.splice(bi + 1, 1);\n                        splitCount--;\n                    }\n                }\n                // find the appropriate bin for each triangle and expand the bounds.\n                for(let c = cStart; c < cEnd; c += 6){\n                    const center = triangleBounds[c + 2 * a];\n                    for(let bi = 0; bi < splitCount; bi++){\n                        const bin = truncatedBins[bi];\n                        if (center >= bin.candidate) {\n                            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.expandByTriangleBounds)(c, triangleBounds, bin.rightCacheBounds);\n                        } else {\n                            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.expandByTriangleBounds)(c, triangleBounds, bin.leftCacheBounds);\n                            bin.count++;\n                        }\n                    }\n                }\n                // expand all the bounds\n                for(let bi = 0; bi < splitCount; bi++){\n                    const bin = truncatedBins[bi];\n                    const leftCount = bin.count;\n                    const rightCount = count - bin.count;\n                    // check the cost of this split\n                    const leftBounds = bin.leftCacheBounds;\n                    const rightBounds = bin.rightCacheBounds;\n                    let leftProb = 0;\n                    if (leftCount !== 0) {\n                        leftProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.computeSurfaceArea)(leftBounds) / rootSurfaceArea;\n                    }\n                    let rightProb = 0;\n                    if (rightCount !== 0) {\n                        rightProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.computeSurfaceArea)(rightBounds) / rootSurfaceArea;\n                    }\n                    const cost = _Constants_js__WEBPACK_IMPORTED_MODULE_0__.TRAVERSAL_COST + _Constants_js__WEBPACK_IMPORTED_MODULE_0__.TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n                    if (cost < bestCost) {\n                        axis = a;\n                        bestCost = cost;\n                        pos = bin.candidate;\n                    }\n                }\n            } else {\n                // reset the bins\n                for(let i = 0; i < BIN_COUNT; i++){\n                    const bin = sahBins[i];\n                    bin.count = 0;\n                    bin.candidate = axisLeft + binWidth + i * binWidth;\n                    const bounds = bin.bounds;\n                    for(let d = 0; d < 3; d++){\n                        bounds[d] = Infinity;\n                        bounds[d + 3] = -Infinity;\n                    }\n                }\n                // iterate over all center positions\n                for(let c = cStart; c < cEnd; c += 6){\n                    const triCenter = triangleBounds[c + 2 * a];\n                    const relativeCenter = triCenter - axisLeft;\n                    // in the partition function if the centroid lies on the split plane then it is\n                    // considered to be on the right side of the split\n                    let binIndex = ~~(relativeCenter / binWidth);\n                    if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\n                    const bin = sahBins[binIndex];\n                    bin.count++;\n                    (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.expandByTriangleBounds)(c, triangleBounds, bin.bounds);\n                }\n                // cache the unioned bounds from right to left so we don't have to regenerate them each time\n                const lastBin = sahBins[BIN_COUNT - 1];\n                (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.copyBounds)(lastBin.bounds, lastBin.rightCacheBounds);\n                for(let i = BIN_COUNT - 2; i >= 0; i--){\n                    const bin = sahBins[i];\n                    const nextBin = sahBins[i + 1];\n                    (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.unionBounds)(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);\n                }\n                let leftCount = 0;\n                for(let i = 0; i < BIN_COUNT - 1; i++){\n                    const bin = sahBins[i];\n                    const binCount = bin.count;\n                    const bounds = bin.bounds;\n                    const nextBin = sahBins[i + 1];\n                    const rightBounds = nextBin.rightCacheBounds;\n                    // don't do anything with the bounds if the new bounds have no triangles\n                    if (binCount !== 0) {\n                        if (leftCount === 0) {\n                            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.copyBounds)(bounds, leftBounds);\n                        } else {\n                            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.unionBounds)(bounds, leftBounds, leftBounds);\n                        }\n                    }\n                    leftCount += binCount;\n                    // check the cost of this split\n                    let leftProb = 0;\n                    let rightProb = 0;\n                    if (leftCount !== 0) {\n                        leftProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.computeSurfaceArea)(leftBounds) / rootSurfaceArea;\n                    }\n                    const rightCount = count - leftCount;\n                    if (rightCount !== 0) {\n                        rightProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.computeSurfaceArea)(rightBounds) / rootSurfaceArea;\n                    }\n                    const cost = _Constants_js__WEBPACK_IMPORTED_MODULE_0__.TRAVERSAL_COST + _Constants_js__WEBPACK_IMPORTED_MODULE_0__.TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n                    if (cost < bestCost) {\n                        axis = a;\n                        bestCost = cost;\n                        pos = bin.candidate;\n                    }\n                }\n            }\n        }\n    } else {\n        console.warn(\"MeshBVH: Invalid build strategy value \".concat(strategy, \" used.\"));\n    }\n    return {\n        axis,\n        pos\n    };\n}\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage(triangleBounds, offset, count, axis) {\n    let avg = 0;\n    for(let i = offset, end = offset + count; i < end; i++){\n        avg += triangleBounds[i * 6 + axis * 2];\n    }\n    return avg / count;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9zcGxpdFV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0STtBQUM1QztBQUVoRyxNQUFNVSxZQUFZO0FBQ2xCLE1BQU1DLFdBQVcsQ0FBRUMsR0FBR0MsSUFBT0QsRUFBRUUsU0FBUyxHQUFHRCxFQUFFQyxTQUFTO0FBQ3RELE1BQU1DLFVBQVUsSUFBSUMsTUFBT04sV0FBWU8sSUFBSSxHQUFHQyxHQUFHLENBQUU7SUFFbEQsT0FBTztRQUVOQyxPQUFPO1FBQ1BDLFFBQVEsSUFBSUMsYUFBYztRQUMxQkMsa0JBQWtCLElBQUlELGFBQWM7UUFDcENFLGlCQUFpQixJQUFJRixhQUFjO1FBQ25DUCxXQUFXO0lBRVo7QUFFRDtBQUNBLE1BQU1VLGFBQWEsSUFBSUgsYUFBYztBQUU5QixTQUFTSSxnQkFBaUJDLGdCQUFnQixFQUFFQyxvQkFBb0IsRUFBRUMsY0FBYyxFQUFFQyxNQUFNLEVBQUVWLEtBQUssRUFBRVcsUUFBUTtJQUUvRyxJQUFJQyxPQUFPLENBQUU7SUFDYixJQUFJQyxNQUFNO0lBRVYsU0FBUztJQUNULElBQUtGLGFBQWF6QixpREFBTUEsRUFBRztRQUUxQjBCLE9BQU8vQixnRkFBbUJBLENBQUUyQjtRQUM1QixJQUFLSSxTQUFTLENBQUUsR0FBSTtZQUVuQkMsTUFBTSxDQUFFTCxvQkFBb0IsQ0FBRUksS0FBTSxHQUFHSixvQkFBb0IsQ0FBRUksT0FBTyxFQUFHLElBQUs7UUFFN0U7SUFFRCxPQUFPLElBQUtELGFBQWF4QixrREFBT0EsRUFBRztRQUVsQ3lCLE9BQU8vQixnRkFBbUJBLENBQUUwQjtRQUM1QixJQUFLSyxTQUFTLENBQUUsR0FBSTtZQUVuQkMsTUFBTUMsV0FBWUwsZ0JBQWdCQyxRQUFRVixPQUFPWTtRQUVsRDtJQUVELE9BQU8sSUFBS0QsYUFBYXZCLDhDQUFHQSxFQUFHO1FBRTlCLE1BQU0yQixrQkFBa0JqQywr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LW1lc2gtYnZoL3NyYy9jb3JlL2J1aWxkL3NwbGl0VXRpbHMuanM/MWQxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRMb25nZXN0RWRnZUluZGV4LCBjb21wdXRlU3VyZmFjZUFyZWEsIGNvcHlCb3VuZHMsIHVuaW9uQm91bmRzLCBleHBhbmRCeVRyaWFuZ2xlQm91bmRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvQXJyYXlCb3hVdGlsaXRpZXMuanMnO1xuaW1wb3J0IHsgQ0VOVEVSLCBBVkVSQUdFLCBTQUgsIFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NULCBUUkFWRVJTQUxfQ09TVCB9IGZyb20gJy4uL0NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IEJJTl9DT1VOVCA9IDMyO1xuY29uc3QgYmluc1NvcnQgPSAoIGEsIGIgKSA9PiBhLmNhbmRpZGF0ZSAtIGIuY2FuZGlkYXRlO1xuY29uc3Qgc2FoQmlucyA9IG5ldyBBcnJheSggQklOX0NPVU5UICkuZmlsbCgpLm1hcCggKCkgPT4ge1xuXG5cdHJldHVybiB7XG5cblx0XHRjb3VudDogMCxcblx0XHRib3VuZHM6IG5ldyBGbG9hdDMyQXJyYXkoIDYgKSxcblx0XHRyaWdodENhY2hlQm91bmRzOiBuZXcgRmxvYXQzMkFycmF5KCA2ICksXG5cdFx0bGVmdENhY2hlQm91bmRzOiBuZXcgRmxvYXQzMkFycmF5KCA2ICksXG5cdFx0Y2FuZGlkYXRlOiAwLFxuXG5cdH07XG5cbn0gKTtcbmNvbnN0IGxlZnRCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcHRpbWFsU3BsaXQoIG5vZGVCb3VuZGluZ0RhdGEsIGNlbnRyb2lkQm91bmRpbmdEYXRhLCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgc3RyYXRlZ3kgKSB7XG5cblx0bGV0IGF4aXMgPSAtIDE7XG5cdGxldCBwb3MgPSAwO1xuXG5cdC8vIENlbnRlclxuXHRpZiAoIHN0cmF0ZWd5ID09PSBDRU5URVIgKSB7XG5cblx0XHRheGlzID0gZ2V0TG9uZ2VzdEVkZ2VJbmRleCggY2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRpZiAoIGF4aXMgIT09IC0gMSApIHtcblxuXHRcdFx0cG9zID0gKCBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYXhpcyBdICsgY2VudHJvaWRCb3VuZGluZ0RhdGFbIGF4aXMgKyAzIF0gKSAvIDI7XG5cblx0XHR9XG5cblx0fSBlbHNlIGlmICggc3RyYXRlZ3kgPT09IEFWRVJBR0UgKSB7XG5cblx0XHRheGlzID0gZ2V0TG9uZ2VzdEVkZ2VJbmRleCggbm9kZUJvdW5kaW5nRGF0YSApO1xuXHRcdGlmICggYXhpcyAhPT0gLSAxICkge1xuXG5cdFx0XHRwb3MgPSBnZXRBdmVyYWdlKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgYXhpcyApO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSBpZiAoIHN0cmF0ZWd5ID09PSBTQUggKSB7XG5cblx0XHRjb25zdCByb290U3VyZmFjZUFyZWEgPSBjb21wdXRlU3VyZmFjZUFyZWEoIG5vZGVCb3VuZGluZ0RhdGEgKTtcblx0XHRsZXQgYmVzdENvc3QgPSBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCAqIGNvdW50O1xuXG5cdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBheGVzXG5cdFx0Y29uc3QgY1N0YXJ0ID0gb2Zmc2V0ICogNjtcblx0XHRjb25zdCBjRW5kID0gKCBvZmZzZXQgKyBjb3VudCApICogNjtcblx0XHRmb3IgKCBsZXQgYSA9IDA7IGEgPCAzOyBhICsrICkge1xuXG5cdFx0XHRjb25zdCBheGlzTGVmdCA9IGNlbnRyb2lkQm91bmRpbmdEYXRhWyBhIF07XG5cdFx0XHRjb25zdCBheGlzUmlnaHQgPSBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYSArIDMgXTtcblx0XHRcdGNvbnN0IGF4aXNMZW5ndGggPSBheGlzUmlnaHQgLSBheGlzTGVmdDtcblx0XHRcdGNvbnN0IGJpbldpZHRoID0gYXhpc0xlbmd0aCAvIEJJTl9DT1VOVDtcblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBmZXdlciB0cmlhbmdsZXMgdGhhbiB3ZSdyZSBwbGFubmluZyB0byBzcGxpdCB0aGVuIGp1c3QgY2hlY2sgYWxsXG5cdFx0XHQvLyB0aGUgdHJpYW5nbGUgcG9zaXRpb25zIGJlY2F1c2UgaXQgd2lsbCBiZSBmYXN0ZXIuXG5cdFx0XHRpZiAoIGNvdW50IDwgQklOX0NPVU5UIC8gNCApIHtcblxuXHRcdFx0XHQvLyBpbml0aWFsaXplIHRoZSBiaW4gY2FuZGlkYXRlc1xuXHRcdFx0XHRjb25zdCB0cnVuY2F0ZWRCaW5zID0gWyAuLi5zYWhCaW5zIF07XG5cdFx0XHRcdHRydW5jYXRlZEJpbnMubGVuZ3RoID0gY291bnQ7XG5cblx0XHRcdFx0Ly8gc2V0IHRoZSBjYW5kaWRhdGVzXG5cdFx0XHRcdGxldCBiID0gMDtcblx0XHRcdFx0Zm9yICggbGV0IGMgPSBjU3RhcnQ7IGMgPCBjRW5kOyBjICs9IDYsIGIgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBiaW4gPSB0cnVuY2F0ZWRCaW5zWyBiIF07XG5cdFx0XHRcdFx0YmluLmNhbmRpZGF0ZSA9IHRyaWFuZ2xlQm91bmRzWyBjICsgMiAqIGEgXTtcblx0XHRcdFx0XHRiaW4uY291bnQgPSAwO1xuXG5cdFx0XHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRcdFx0Ym91bmRzLFxuXHRcdFx0XHRcdFx0bGVmdENhY2hlQm91bmRzLFxuXHRcdFx0XHRcdFx0cmlnaHRDYWNoZUJvdW5kcyxcblx0XHRcdFx0XHR9ID0gYmluO1xuXHRcdFx0XHRcdGZvciAoIGxldCBkID0gMDsgZCA8IDM7IGQgKysgKSB7XG5cblx0XHRcdFx0XHRcdHJpZ2h0Q2FjaGVCb3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0cmlnaHRDYWNoZUJvdW5kc1sgZCArIDMgXSA9IC0gSW5maW5pdHk7XG5cblx0XHRcdFx0XHRcdGxlZnRDYWNoZUJvdW5kc1sgZCBdID0gSW5maW5pdHk7XG5cdFx0XHRcdFx0XHRsZWZ0Q2FjaGVCb3VuZHNbIGQgKyAzIF0gPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0XHRib3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0Ym91bmRzWyBkICsgMyBdID0gLSBJbmZpbml0eTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMoIGMsIHRyaWFuZ2xlQm91bmRzLCBib3VuZHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ1bmNhdGVkQmlucy5zb3J0KCBiaW5zU29ydCApO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSByZWR1bmRhbnQgc3BsaXRzXG5cdFx0XHRcdGxldCBzcGxpdENvdW50ID0gY291bnQ7XG5cdFx0XHRcdGZvciAoIGxldCBiaSA9IDA7IGJpIDwgc3BsaXRDb3VudDsgYmkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBiaW4gPSB0cnVuY2F0ZWRCaW5zWyBiaSBdO1xuXHRcdFx0XHRcdHdoaWxlICggYmkgKyAxIDwgc3BsaXRDb3VudCAmJiB0cnVuY2F0ZWRCaW5zWyBiaSArIDEgXS5jYW5kaWRhdGUgPT09IGJpbi5jYW5kaWRhdGUgKSB7XG5cblx0XHRcdFx0XHRcdHRydW5jYXRlZEJpbnMuc3BsaWNlKCBiaSArIDEsIDEgKTtcblx0XHRcdFx0XHRcdHNwbGl0Q291bnQgLS07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGZpbmQgdGhlIGFwcHJvcHJpYXRlIGJpbiBmb3IgZWFjaCB0cmlhbmdsZSBhbmQgZXhwYW5kIHRoZSBib3VuZHMuXG5cdFx0XHRcdGZvciAoIGxldCBjID0gY1N0YXJ0OyBjIDwgY0VuZDsgYyArPSA2ICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgY2VudGVyID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdGZvciAoIGxldCBiaSA9IDA7IGJpIDwgc3BsaXRDb3VudDsgYmkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbiA9IHRydW5jYXRlZEJpbnNbIGJpIF07XG5cdFx0XHRcdFx0XHRpZiAoIGNlbnRlciA+PSBiaW4uY2FuZGlkYXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdGV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMoIGMsIHRyaWFuZ2xlQm91bmRzLCBiaW4ucmlnaHRDYWNoZUJvdW5kcyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMoIGMsIHRyaWFuZ2xlQm91bmRzLCBiaW4ubGVmdENhY2hlQm91bmRzICk7XG5cdFx0XHRcdFx0XHRcdGJpbi5jb3VudCArKztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBleHBhbmQgYWxsIHRoZSBib3VuZHNcblx0XHRcdFx0Zm9yICggbGV0IGJpID0gMDsgYmkgPCBzcGxpdENvdW50OyBiaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGJpbiA9IHRydW5jYXRlZEJpbnNbIGJpIF07XG5cdFx0XHRcdFx0Y29uc3QgbGVmdENvdW50ID0gYmluLmNvdW50O1xuXHRcdFx0XHRcdGNvbnN0IHJpZ2h0Q291bnQgPSBjb3VudCAtIGJpbi5jb3VudDtcblxuXHRcdFx0XHRcdC8vIGNoZWNrIHRoZSBjb3N0IG9mIHRoaXMgc3BsaXRcblx0XHRcdFx0XHRjb25zdCBsZWZ0Qm91bmRzID0gYmluLmxlZnRDYWNoZUJvdW5kcztcblx0XHRcdFx0XHRjb25zdCByaWdodEJvdW5kcyA9IGJpbi5yaWdodENhY2hlQm91bmRzO1xuXG5cdFx0XHRcdFx0bGV0IGxlZnRQcm9iID0gMDtcblx0XHRcdFx0XHRpZiAoIGxlZnRDb3VudCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0bGVmdFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIGxlZnRCb3VuZHMgKSAvIHJvb3RTdXJmYWNlQXJlYTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCByaWdodFByb2IgPSAwO1xuXHRcdFx0XHRcdGlmICggcmlnaHRDb3VudCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0cmlnaHRQcm9iID0gY29tcHV0ZVN1cmZhY2VBcmVhKCByaWdodEJvdW5kcyApIC8gcm9vdFN1cmZhY2VBcmVhO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgY29zdCA9IFRSQVZFUlNBTF9DT1NUICsgVFJJQU5HTEVfSU5URVJTRUNUX0NPU1QgKiAoXG5cdFx0XHRcdFx0XHRsZWZ0UHJvYiAqIGxlZnRDb3VudCArIHJpZ2h0UHJvYiAqIHJpZ2h0Q291bnRcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKCBjb3N0IDwgYmVzdENvc3QgKSB7XG5cblx0XHRcdFx0XHRcdGF4aXMgPSBhO1xuXHRcdFx0XHRcdFx0YmVzdENvc3QgPSBjb3N0O1xuXHRcdFx0XHRcdFx0cG9zID0gYmluLmNhbmRpZGF0ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gcmVzZXQgdGhlIGJpbnNcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgQklOX0NPVU5UOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdGJpbi5jb3VudCA9IDA7XG5cdFx0XHRcdFx0YmluLmNhbmRpZGF0ZSA9IGF4aXNMZWZ0ICsgYmluV2lkdGggKyBpICogYmluV2lkdGg7XG5cblx0XHRcdFx0XHRjb25zdCBib3VuZHMgPSBiaW4uYm91bmRzO1xuXHRcdFx0XHRcdGZvciAoIGxldCBkID0gMDsgZCA8IDM7IGQgKysgKSB7XG5cblx0XHRcdFx0XHRcdGJvdW5kc1sgZCBdID0gSW5maW5pdHk7XG5cdFx0XHRcdFx0XHRib3VuZHNbIGQgKyAzIF0gPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGNlbnRlciBwb3NpdGlvbnNcblx0XHRcdFx0Zm9yICggbGV0IGMgPSBjU3RhcnQ7IGMgPCBjRW5kOyBjICs9IDYgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB0cmlDZW50ZXIgPSB0cmlhbmdsZUJvdW5kc1sgYyArIDIgKiBhIF07XG5cdFx0XHRcdFx0Y29uc3QgcmVsYXRpdmVDZW50ZXIgPSB0cmlDZW50ZXIgLSBheGlzTGVmdDtcblxuXHRcdFx0XHRcdC8vIGluIHRoZSBwYXJ0aXRpb24gZnVuY3Rpb24gaWYgdGhlIGNlbnRyb2lkIGxpZXMgb24gdGhlIHNwbGl0IHBsYW5lIHRoZW4gaXQgaXNcblx0XHRcdFx0XHQvLyBjb25zaWRlcmVkIHRvIGJlIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzcGxpdFxuXHRcdFx0XHRcdGxldCBiaW5JbmRleCA9IH4gfiAoIHJlbGF0aXZlQ2VudGVyIC8gYmluV2lkdGggKTtcblx0XHRcdFx0XHRpZiAoIGJpbkluZGV4ID49IEJJTl9DT1VOVCApIGJpbkluZGV4ID0gQklOX0NPVU5UIC0gMTtcblxuXHRcdFx0XHRcdGNvbnN0IGJpbiA9IHNhaEJpbnNbIGJpbkluZGV4IF07XG5cdFx0XHRcdFx0YmluLmNvdW50ICsrO1xuXG5cdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJpbi5ib3VuZHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2FjaGUgdGhlIHVuaW9uZWQgYm91bmRzIGZyb20gcmlnaHQgdG8gbGVmdCBzbyB3ZSBkb24ndCBoYXZlIHRvIHJlZ2VuZXJhdGUgdGhlbSBlYWNoIHRpbWVcblx0XHRcdFx0Y29uc3QgbGFzdEJpbiA9IHNhaEJpbnNbIEJJTl9DT1VOVCAtIDEgXTtcblx0XHRcdFx0Y29weUJvdW5kcyggbGFzdEJpbi5ib3VuZHMsIGxhc3RCaW4ucmlnaHRDYWNoZUJvdW5kcyApO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IEJJTl9DT1VOVCAtIDI7IGkgPj0gMDsgaSAtLSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGJpbiA9IHNhaEJpbnNbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBuZXh0QmluID0gc2FoQmluc1sgaSArIDEgXTtcblx0XHRcdFx0XHR1bmlvbkJvdW5kcyggYmluLmJvdW5kcywgbmV4dEJpbi5yaWdodENhY2hlQm91bmRzLCBiaW4ucmlnaHRDYWNoZUJvdW5kcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZXQgbGVmdENvdW50ID0gMDtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgQklOX0NPVU5UIC0gMTsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGJpbiA9IHNhaEJpbnNbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBiaW5Db3VudCA9IGJpbi5jb3VudDtcblx0XHRcdFx0XHRjb25zdCBib3VuZHMgPSBiaW4uYm91bmRzO1xuXG5cdFx0XHRcdFx0Y29uc3QgbmV4dEJpbiA9IHNhaEJpbnNbIGkgKyAxIF07XG5cdFx0XHRcdFx0Y29uc3QgcmlnaHRCb3VuZHMgPSBuZXh0QmluLnJpZ2h0Q2FjaGVCb3VuZHM7XG5cblx0XHRcdFx0XHQvLyBkb24ndCBkbyBhbnl0aGluZyB3aXRoIHRoZSBib3VuZHMgaWYgdGhlIG5ldyBib3VuZHMgaGF2ZSBubyB0cmlhbmdsZXNcblx0XHRcdFx0XHRpZiAoIGJpbkNvdW50ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGxlZnRDb3VudCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb3B5Qm91bmRzKCBib3VuZHMsIGxlZnRCb3VuZHMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR1bmlvbkJvdW5kcyggYm91bmRzLCBsZWZ0Qm91bmRzLCBsZWZ0Qm91bmRzICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxlZnRDb3VudCArPSBiaW5Db3VudDtcblxuXHRcdFx0XHRcdC8vIGNoZWNrIHRoZSBjb3N0IG9mIHRoaXMgc3BsaXRcblx0XHRcdFx0XHRsZXQgbGVmdFByb2IgPSAwO1xuXHRcdFx0XHRcdGxldCByaWdodFByb2IgPSAwO1xuXG5cdFx0XHRcdFx0aWYgKCBsZWZ0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdGxlZnRQcm9iID0gY29tcHV0ZVN1cmZhY2VBcmVhKCBsZWZ0Qm91bmRzICkgLyByb290U3VyZmFjZUFyZWE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCByaWdodENvdW50ID0gY291bnQgLSBsZWZ0Q291bnQ7XG5cdFx0XHRcdFx0aWYgKCByaWdodENvdW50ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0XHRyaWdodFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIHJpZ2h0Qm91bmRzICkgLyByb290U3VyZmFjZUFyZWE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBjb3N0ID0gVFJBVkVSU0FMX0NPU1QgKyBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCAqIChcblx0XHRcdFx0XHRcdGxlZnRQcm9iICogbGVmdENvdW50ICsgcmlnaHRQcm9iICogcmlnaHRDb3VudFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoIGNvc3QgPCBiZXN0Q29zdCApIHtcblxuXHRcdFx0XHRcdFx0YXhpcyA9IGE7XG5cdFx0XHRcdFx0XHRiZXN0Q29zdCA9IGNvc3Q7XG5cdFx0XHRcdFx0XHRwb3MgPSBiaW4uY2FuZGlkYXRlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRjb25zb2xlLndhcm4oIGBNZXNoQlZIOiBJbnZhbGlkIGJ1aWxkIHN0cmF0ZWd5IHZhbHVlICR7IHN0cmF0ZWd5IH0gdXNlZC5gICk7XG5cblx0fVxuXG5cdHJldHVybiB7IGF4aXMsIHBvcyB9O1xuXG59XG5cbi8vIHJldHVybnMgdGhlIGF2ZXJhZ2UgY29vcmRpbmF0ZSBvbiB0aGUgc3BlY2lmaWVkIGF4aXMgb2YgdGhlIGFsbCB0aGUgcHJvdmlkZWQgdHJpYW5nbGVzXG5mdW5jdGlvbiBnZXRBdmVyYWdlKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgYXhpcyApIHtcblxuXHRsZXQgYXZnID0gMDtcblx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGNvdW50OyBpIDwgZW5kOyBpICsrICkge1xuXG5cdFx0YXZnICs9IHRyaWFuZ2xlQm91bmRzWyBpICogNiArIGF4aXMgKiAyIF07XG5cblx0fVxuXG5cdHJldHVybiBhdmcgLyBjb3VudDtcblxufVxuIl0sIm5hbWVzIjpbImdldExvbmdlc3RFZGdlSW5kZXgiLCJjb21wdXRlU3VyZmFjZUFyZWEiLCJjb3B5Qm91bmRzIiwidW5pb25Cb3VuZHMiLCJleHBhbmRCeVRyaWFuZ2xlQm91bmRzIiwiQ0VOVEVSIiwiQVZFUkFHRSIsIlNBSCIsIlRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUIiwiVFJBVkVSU0FMX0NPU1QiLCJCSU5fQ09VTlQiLCJiaW5zU29ydCIsImEiLCJiIiwiY2FuZGlkYXRlIiwic2FoQmlucyIsIkFycmF5IiwiZmlsbCIsIm1hcCIsImNvdW50IiwiYm91bmRzIiwiRmxvYXQzMkFycmF5IiwicmlnaHRDYWNoZUJvdW5kcyIsImxlZnRDYWNoZUJvdW5kcyIsImxlZnRCb3VuZHMiLCJnZXRPcHRpbWFsU3BsaXQiLCJub2RlQm91bmRpbmdEYXRhIiwiY2VudHJvaWRCb3VuZGluZ0RhdGEiLCJ0cmlhbmdsZUJvdW5kcyIsIm9mZnNldCIsInN0cmF0ZWd5IiwiYXhpcyIsInBvcyIsImdldEF2ZXJhZ2UiLCJyb290U3VyZmFjZUFyZWEiLCJiZXN0Q29zdCIsImNTdGFydCIsImNFbmQiLCJheGlzTGVmdCIsImF4aXNSaWdodCIsImF4aXNMZW5ndGgiLCJiaW5XaWR0aCIsInRydW5jYXRlZEJpbnMiLCJsZW5ndGgiLCJjIiwiYmluIiwiZCIsIkluZmluaXR5Iiwic29ydCIsInNwbGl0Q291bnQiLCJiaSIsInNwbGljZSIsImNlbnRlciIsImxlZnRDb3VudCIsInJpZ2h0Q291bnQiLCJyaWdodEJvdW5kcyIsImxlZnRQcm9iIiwicmlnaHRQcm9iIiwiY29zdCIsImkiLCJ0cmlDZW50ZXIiLCJyZWxhdGl2ZUNlbnRlciIsImJpbkluZGV4IiwibGFzdEJpbiIsIm5leHRCaW4iLCJiaW5Db3VudCIsImNvbnNvbGUiLCJ3YXJuIiwiYXZnIiwiZW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/splitUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/bvhcast.js":
/*!**************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/bvhcast.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bvhcast: function() { return /* binding */ bvhcast; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/PrimitivePool.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js\");\n\n\n\n\n\nconst _bufferStack1 = new _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_0__.BufferStack.constructor();\nconst _bufferStack2 = new _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_0__.BufferStack.constructor();\nconst _boxPool = new _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_1__.PrimitivePool(()=>new three__WEBPACK_IMPORTED_MODULE_2__.Box3());\nconst _leftBox1 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3();\nconst _rightBox1 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3();\nconst _leftBox2 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3();\nconst _rightBox2 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3();\nlet _active = false;\nfunction bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {\n    if (_active) {\n        throw new Error(\"MeshBVH: Recursive calls to bvhcast not supported.\");\n    }\n    _active = true;\n    const roots = bvh._roots;\n    const otherRoots = otherBvh._roots;\n    let result;\n    let offset1 = 0;\n    let offset2 = 0;\n    const invMat = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4().copy(matrixToLocal).invert();\n    // iterate over the first set of roots\n    for(let i = 0, il = roots.length; i < il; i++){\n        _bufferStack1.setBuffer(roots[i]);\n        offset2 = 0;\n        // prep the initial root box\n        const localBox = _boxPool.getPrimitive();\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(0), _bufferStack1.float32Array, localBox);\n        localBox.applyMatrix4(invMat);\n        // iterate over the second set of roots\n        for(let j = 0, jl = otherRoots.length; j < jl; j++){\n            _bufferStack2.setBuffer(otherRoots[i]);\n            result = _traverse(0, 0, matrixToLocal, invMat, intersectsRanges, offset1, offset2, 0, 0, localBox);\n            _bufferStack2.clearBuffer();\n            offset2 += otherRoots[j].length;\n            if (result) {\n                break;\n            }\n        }\n        // release stack info\n        _boxPool.releasePrimitive(localBox);\n        _bufferStack1.clearBuffer();\n        offset1 += roots[i].length;\n        if (result) {\n            break;\n        }\n    }\n    _active = false;\n    return result;\n}\nfunction _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc) {\n    let // offsets for ids\n    node1IndexByteOffset = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, node2IndexByteOffset = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0, // tree depth\n    depth1 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 0, depth2 = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0, currBox = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : null, reversed = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : false;\n    // get the buffer stacks associated with the current indices\n    let bufferStack1, bufferStack2;\n    if (reversed) {\n        bufferStack1 = _bufferStack2;\n        bufferStack2 = _bufferStack1;\n    } else {\n        bufferStack1 = _bufferStack1;\n        bufferStack2 = _bufferStack2;\n    }\n    // get the local instances of the typed buffers\n    const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;\n    const node1Index16 = node1Index32 * 2;\n    const node2Index16 = node2Index32 * 2;\n    const isLeaf1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.IS_LEAF)(node1Index16, uint16Array1);\n    const isLeaf2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.IS_LEAF)(node2Index16, uint16Array2);\n    let result = false;\n    if (isLeaf2 && isLeaf1) {\n        // if both bounds are leaf nodes then fire the callback if the boxes intersect\n        if (reversed) {\n            result = intersectsRangesFunc((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(node2Index32, uint32Array2), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(node2Index32 * 2, uint16Array2), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(node1Index32, uint32Array1), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(node1Index32 * 2, uint16Array1), depth2, node2IndexByteOffset + node2Index32, depth1, node1IndexByteOffset + node1Index32);\n        } else {\n            result = intersectsRangesFunc((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(node1Index32, uint32Array1), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(node1Index32 * 2, uint16Array1), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(node2Index32, uint32Array2), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(node2Index32 * 2, uint16Array2), depth1, node1IndexByteOffset + node1Index32, depth2, node2IndexByteOffset + node2Index32);\n        }\n    } else if (isLeaf2) {\n        // SWAP\n        // If we've traversed to the leaf node on the other bvh then we need to swap over\n        // to traverse down the first one\n        // get the new box to use\n        const newBox = _boxPool.getPrimitive();\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(node2Index32), float32Array2, newBox);\n        newBox.applyMatrix4(matrix2to1);\n        // get the child bounds to check before traversal\n        const cl1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.LEFT_NODE)(node1Index32);\n        const cr1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.RIGHT_NODE)(node1Index32, uint32Array1);\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cl1), float32Array1, _leftBox1);\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cr1), float32Array1, _rightBox1);\n        // precompute the intersections otherwise the global boxes will be modified during traversal\n        const intersectCl1 = newBox.intersectsBox(_leftBox1);\n        const intersectCr1 = newBox.intersectsBox(_rightBox1);\n        result = intersectCl1 && _traverse(node2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && _traverse(node2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n        _boxPool.releasePrimitive(newBox);\n    } else {\n        // if neither are leaves then we should swap if one of the children does not\n        // intersect with the current bounds\n        // get the child bounds to check\n        const cl2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.LEFT_NODE)(node2Index32);\n        const cr2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.RIGHT_NODE)(node2Index32, uint32Array2);\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cl2), float32Array2, _leftBox2);\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cr2), float32Array2, _rightBox2);\n        const leftIntersects = currBox.intersectsBox(_leftBox2);\n        const rightIntersects = currBox.intersectsBox(_rightBox2);\n        if (leftIntersects && rightIntersects) {\n            // continue to traverse both children if they both intersect\n            result = _traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed) || _traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n        } else if (leftIntersects) {\n            if (isLeaf1) {\n                // if the current box is a leaf then just continue\n                result = _traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n            } else {\n                // SWAP\n                // if only one box intersects then we have to swap to the other bvh to continue\n                const newBox = _boxPool.getPrimitive();\n                newBox.copy(_leftBox2).applyMatrix4(matrix2to1);\n                const cl1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.LEFT_NODE)(node1Index32);\n                const cr1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.RIGHT_NODE)(node1Index32, uint32Array1);\n                (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cl1), float32Array1, _leftBox1);\n                (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cr1), float32Array1, _rightBox1);\n                // precompute the intersections otherwise the global boxes will be modified during traversal\n                const intersectCl1 = newBox.intersectsBox(_leftBox1);\n                const intersectCr1 = newBox.intersectsBox(_rightBox1);\n                result = intersectCl1 && _traverse(cl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && _traverse(cl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n                _boxPool.releasePrimitive(newBox);\n            }\n        } else if (rightIntersects) {\n            if (isLeaf1) {\n                // if the current box is a leaf then just continue\n                result = _traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n            } else {\n                // SWAP\n                // if only one box intersects then we have to swap to the other bvh to continue\n                const newBox = _boxPool.getPrimitive();\n                newBox.copy(_rightBox2).applyMatrix4(matrix2to1);\n                const cl1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.LEFT_NODE)(node1Index32);\n                const cr1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.RIGHT_NODE)(node1Index32, uint32Array1);\n                (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cl1), float32Array1, _leftBox1);\n                (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cr1), float32Array1, _rightBox1);\n                // precompute the intersections otherwise the global boxes will be modified during traversal\n                const intersectCl1 = newBox.intersectsBox(_leftBox1);\n                const intersectCr1 = newBox.intersectsBox(_rightBox1);\n                result = intersectCl1 && _traverse(cr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && _traverse(cr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n                _boxPool.releasePrimitive(newBox);\n            }\n        }\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L2J2aGNhc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNDO0FBQ2dCO0FBQzJEO0FBQ25EO0FBQ0Q7QUFFN0QsTUFBTVcsZ0JBQWdCLElBQUlULDhEQUFXQSxDQUFDVSxXQUFXO0FBQ2pELE1BQU1DLGdCQUFnQixJQUFJWCw4REFBV0EsQ0FBQ1UsV0FBVztBQUNqRCxNQUFNRSxXQUFXLElBQUlKLGtFQUFhQSxDQUFFLElBQU0sSUFBSVYsdUNBQUlBO0FBQ2xELE1BQU1lLFlBQVksSUFBSWYsdUNBQUlBO0FBQzFCLE1BQU1nQixhQUFhLElBQUloQix1Q0FBSUE7QUFFM0IsTUFBTWlCLFlBQVksSUFBSWpCLHVDQUFJQTtBQUMxQixNQUFNa0IsYUFBYSxJQUFJbEIsdUNBQUlBO0FBRTNCLElBQUltQixVQUFVO0FBRVAsU0FBU0MsUUFBU0MsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsZ0JBQWdCO0lBRXRFLElBQUtMLFNBQVU7UUFFZCxNQUFNLElBQUlNLE1BQU87SUFFbEI7SUFFQU4sVUFBVTtJQUVWLE1BQU1PLFFBQVFMLElBQUlNLE1BQU07SUFDeEIsTUFBTUMsYUFBYU4sU0FBU0ssTUFBTTtJQUNsQyxJQUFJRTtJQUNKLElBQUlDLFVBQVU7SUFDZCxJQUFJQyxVQUFVO0lBQ2QsTUFBTUMsU0FBUyxJQUFJL0IsMENBQU9BLEdBQUdnQyxJQUFJLENBQUVWLGVBQWdCVyxNQUFNO0lBRXpELHNDQUFzQztJQUN0QyxJQUFNLElBQUlDLElBQUksR0FBR0MsS0FBS1YsTUFBTVcsTUFBTSxFQUFFRixJQUFJQyxJQUFJRCxJQUFPO1FBRWxEeEIsY0FBYzJCLFNBQVMsQ0FBRVosS0FBSyxDQUFFUyxFQUFHO1FBQ25DSixVQUFVO1FBRVYsNEJBQTRCO1FBQzVCLE1BQU1RLFdBQVd6QixTQUFTMEIsWUFBWTtRQUN0Qy9CLHVFQUFVQSxDQUFF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U0FBVTtnQkFFZCxrREFBa0Q7Z0JBQ2xEMUMsU0FBU2dCLFVBQ1JHLGNBQWNnQyxLQUFLOUIsWUFBWUMsWUFBWUMsc0JBQzNDQyxzQkFBc0JDLHNCQUFzQkMsUUFBUUMsU0FBUyxHQUM3REMsU0FBU0M7WUFHWCxPQUFPO2dCQUVOLE9BQU87Z0JBQ1AsK0VBQStFO2dCQUMvRSxNQUFNZSxTQUFTM0QsU0FBUzBCLFlBQVk7Z0JBQ3BDaUMsT0FBT3hDLElBQUksQ0FBRWYsWUFBYXdCLFlBQVksQ0FBRVE7Z0JBRXhDLE1BQU13QixNQUFNcEUsb0VBQVNBLENBQUUwQztnQkFDdkIsTUFBTTJCLE1BQU1uRSxxRUFBVUEsQ0FBRXdDLGNBQWNjO2dCQUN0Q3JELHVFQUFVQSxDQUFFTiw4RUFBbUJBLENBQUV1RSxNQUFPYixlQUFlOUM7Z0JBQ3ZETix1RUFBVUEsQ0FBRU4sOEVBQW1CQSxDQUFFd0UsTUFBT2QsZUFBZTdDO2dCQUV2RCw0RkFBNEY7Z0JBQzVGLE1BQU00RCxlQUFlSCxPQUFPSSxhQUFhLENBQUU5RDtnQkFDM0MsTUFBTStELGVBQWVMLE9BQU9JLGFBQWEsQ0FBRTdEO2dCQUMzQ2EsU0FBUyxnQkFDUWdCLFVBQ2ZtQyxLQUFLTixLQUFLdkIsWUFBWUQsWUFBWUUsc0JBQ2xDRSxzQkFBc0JELHNCQUFzQkcsUUFBUUQsU0FBUyxHQUM3RGtCLFFBQVEsQ0FBRWYsYUFHWG9CLGdCQUFnQmpDLFVBQ2ZtQyxLQUFLTCxLQUFLeEIsWUFBWUQsWUFBWUUsc0JBQ2xDRSxzQkFBc0JELHNCQUFzQkcsUUFBUUQsU0FBUyxHQUM3RGtCLFFBQVEsQ0FBRWY7Z0JBSVo1QyxTQUFTaUMsZ0JBQWdCLENBQUUwQjtZQUU1QjtRQUVEO0lBRUQ7SUFFQSxPQUFPNUM7QUFFUiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvY2FzdC9idmhjYXN0LmpzPzk1NmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm94MywgTWF0cml4NCB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEJ1ZmZlclN0YWNrIH0gZnJvbSAnLi4vdXRpbHMvQnVmZmVyU3RhY2suanMnO1xuaW1wb3J0IHsgQk9VTkRJTkdfREFUQV9JTkRFWCwgQ09VTlQsIElTX0xFQUYsIExFRlRfTk9ERSwgT0ZGU0VULCBSSUdIVF9OT0RFIH0gZnJvbSAnLi4vdXRpbHMvbm9kZUJ1ZmZlclV0aWxzLmpzJztcbmltcG9ydCB7IGFycmF5VG9Cb3ggfSBmcm9tICcuLi8uLi91dGlscy9BcnJheUJveFV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBQcmltaXRpdmVQb29sIH0gZnJvbSAnLi4vLi4vdXRpbHMvUHJpbWl0aXZlUG9vbC5qcyc7XG5cbmNvbnN0IF9idWZmZXJTdGFjazEgPSBuZXcgQnVmZmVyU3RhY2suY29uc3RydWN0b3IoKTtcbmNvbnN0IF9idWZmZXJTdGFjazIgPSBuZXcgQnVmZmVyU3RhY2suY29uc3RydWN0b3IoKTtcbmNvbnN0IF9ib3hQb29sID0gbmV3IFByaW1pdGl2ZVBvb2woICgpID0+IG5ldyBCb3gzKCkgKTtcbmNvbnN0IF9sZWZ0Qm94MSA9IG5ldyBCb3gzKCk7XG5jb25zdCBfcmlnaHRCb3gxID0gbmV3IEJveDMoKTtcblxuY29uc3QgX2xlZnRCb3gyID0gbmV3IEJveDMoKTtcbmNvbnN0IF9yaWdodEJveDIgPSBuZXcgQm94MygpO1xuXG5sZXQgX2FjdGl2ZSA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gYnZoY2FzdCggYnZoLCBvdGhlckJ2aCwgbWF0cml4VG9Mb2NhbCwgaW50ZXJzZWN0c1JhbmdlcyApIHtcblxuXHRpZiAoIF9hY3RpdmUgKSB7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBSZWN1cnNpdmUgY2FsbHMgdG8gYnZoY2FzdCBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHR9XG5cblx0X2FjdGl2ZSA9IHRydWU7XG5cblx0Y29uc3Qgcm9vdHMgPSBidmguX3Jvb3RzO1xuXHRjb25zdCBvdGhlclJvb3RzID0gb3RoZXJCdmguX3Jvb3RzO1xuXHRsZXQgcmVzdWx0O1xuXHRsZXQgb2Zmc2V0MSA9IDA7XG5cdGxldCBvZmZzZXQyID0gMDtcblx0Y29uc3QgaW52TWF0ID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBtYXRyaXhUb0xvY2FsICkuaW52ZXJ0KCk7XG5cblx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBmaXJzdCBzZXQgb2Ygcm9vdHNcblx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0X2J1ZmZlclN0YWNrMS5zZXRCdWZmZXIoIHJvb3RzWyBpIF0gKTtcblx0XHRvZmZzZXQyID0gMDtcblxuXHRcdC8vIHByZXAgdGhlIGluaXRpYWwgcm9vdCBib3hcblx0XHRjb25zdCBsb2NhbEJveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIDAgKSwgX2J1ZmZlclN0YWNrMS5mbG9hdDMyQXJyYXksIGxvY2FsQm94ICk7XG5cdFx0bG9jYWxCb3guYXBwbHlNYXRyaXg0KCBpbnZNYXQgKTtcblxuXHRcdC8vIGl0ZXJhdGUgb3ZlciB0aGUgc2Vjb25kIHNldCBvZiByb290c1xuXHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBvdGhlclJvb3RzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRfYnVmZmVyU3RhY2syLnNldEJ1ZmZlciggb3RoZXJSb290c1sgaSBdICk7XG5cblx0XHRcdHJlc3VsdCA9IF90cmF2ZXJzZShcblx0XHRcdFx0MCwgMCwgbWF0cml4VG9Mb2NhbCwgaW52TWF0LCBpbnRlcnNlY3RzUmFuZ2VzLFxuXHRcdFx0XHRvZmZzZXQxLCBvZmZzZXQyLCAwLCAwLFxuXHRcdFx0XHRsb2NhbEJveCxcblx0XHRcdCk7XG5cblx0XHRcdF9idWZmZXJTdGFjazIuY2xlYXJCdWZmZXIoKTtcblx0XHRcdG9mZnNldDIgKz0gb3RoZXJSb290c1sgaiBdLmxlbmd0aDtcblxuXHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHJlbGVhc2Ugc3RhY2sgaW5mb1xuXHRcdF9ib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIGxvY2FsQm94ICk7XG5cdFx0X2J1ZmZlclN0YWNrMS5jbGVhckJ1ZmZlcigpO1xuXHRcdG9mZnNldDEgKz0gcm9vdHNbIGkgXS5sZW5ndGg7XG5cblx0XHRpZiAoIHJlc3VsdCApIHtcblxuXHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9hY3RpdmUgPSBmYWxzZTtcblx0cmV0dXJuIHJlc3VsdDtcblxufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UoXG5cdG5vZGUxSW5kZXgzMixcblx0bm9kZTJJbmRleDMyLFxuXHRtYXRyaXgydG8xLFxuXHRtYXRyaXgxdG8yLFxuXHRpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblxuXHQvLyBvZmZzZXRzIGZvciBpZHNcblx0bm9kZTFJbmRleEJ5dGVPZmZzZXQgPSAwLFxuXHRub2RlMkluZGV4Qnl0ZU9mZnNldCA9IDAsXG5cblx0Ly8gdHJlZSBkZXB0aFxuXHRkZXB0aDEgPSAwLFxuXHRkZXB0aDIgPSAwLFxuXG5cdGN1cnJCb3ggPSBudWxsLFxuXHRyZXZlcnNlZCA9IGZhbHNlLFxuXG4pIHtcblxuXHQvLyBnZXQgdGhlIGJ1ZmZlciBzdGFja3MgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IGluZGljZXNcblx0bGV0IGJ1ZmZlclN0YWNrMSwgYnVmZmVyU3RhY2syO1xuXHRpZiAoIHJldmVyc2VkICkge1xuXG5cdFx0YnVmZmVyU3RhY2sxID0gX2J1ZmZlclN0YWNrMjtcblx0XHRidWZmZXJTdGFjazIgPSBfYnVmZmVyU3RhY2sxO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRidWZmZXJTdGFjazEgPSBfYnVmZmVyU3RhY2sxO1xuXHRcdGJ1ZmZlclN0YWNrMiA9IF9idWZmZXJTdGFjazI7XG5cblx0fVxuXG5cdC8vIGdldCB0aGUgbG9jYWwgaW5zdGFuY2VzIG9mIHRoZSB0eXBlZCBidWZmZXJzXG5cdGNvbnN0XG5cdFx0ZmxvYXQzMkFycmF5MSA9IGJ1ZmZlclN0YWNrMS5mbG9hdDMyQXJyYXksXG5cdFx0dWludDMyQXJyYXkxID0gYnVmZmVyU3RhY2sxLnVpbnQzMkFycmF5LFxuXHRcdHVpbnQxNkFycmF5MSA9IGJ1ZmZlclN0YWNrMS51aW50MTZBcnJheSxcblx0XHRmbG9hdDMyQXJyYXkyID0gYnVmZmVyU3RhY2syLmZsb2F0MzJBcnJheSxcblx0XHR1aW50MzJBcnJheTIgPSBidWZmZXJTdGFjazIudWludDMyQXJyYXksXG5cdFx0dWludDE2QXJyYXkyID0gYnVmZmVyU3RhY2syLnVpbnQxNkFycmF5O1xuXG5cdGNvbnN0IG5vZGUxSW5kZXgxNiA9IG5vZGUxSW5kZXgzMiAqIDI7XG5cdGNvbnN0IG5vZGUySW5kZXgxNiA9IG5vZGUySW5kZXgzMiAqIDI7XG5cdGNvbnN0IGlzTGVhZjEgPSBJU19MRUFGKCBub2RlMUluZGV4MTYsIHVpbnQxNkFycmF5MSApO1xuXHRjb25zdCBpc0xlYWYyID0gSVNfTEVBRiggbm9kZTJJbmRleDE2LCB1aW50MTZBcnJheTIgKTtcblx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXHRpZiAoIGlzTGVhZjIgJiYgaXNMZWFmMSApIHtcblxuXHRcdC8vIGlmIGJvdGggYm91bmRzIGFyZSBsZWFmIG5vZGVzIHRoZW4gZmlyZSB0aGUgY2FsbGJhY2sgaWYgdGhlIGJveGVzIGludGVyc2VjdFxuXHRcdGlmICggcmV2ZXJzZWQgKSB7XG5cblx0XHRcdHJlc3VsdCA9IGludGVyc2VjdHNSYW5nZXNGdW5jKFxuXHRcdFx0XHRPRkZTRVQoIG5vZGUySW5kZXgzMiwgdWludDMyQXJyYXkyICksIENPVU5UKCBub2RlMkluZGV4MzIgKiAyLCB1aW50MTZBcnJheTIgKSxcblx0XHRcdFx0T0ZGU0VUKCBub2RlMUluZGV4MzIsIHVpbnQzMkFycmF5MSApLCBDT1VOVCggbm9kZTFJbmRleDMyICogMiwgdWludDE2QXJyYXkxICksXG5cdFx0XHRcdGRlcHRoMiwgbm9kZTJJbmRleEJ5dGVPZmZzZXQgKyBub2RlMkluZGV4MzIsXG5cdFx0XHRcdGRlcHRoMSwgbm9kZTFJbmRleEJ5dGVPZmZzZXQgKyBub2RlMUluZGV4MzIsXG5cdFx0XHQpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVzdWx0ID0gaW50ZXJzZWN0c1Jhbmdlc0Z1bmMoXG5cdFx0XHRcdE9GRlNFVCggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKSwgQ09VTlQoIG5vZGUxSW5kZXgzMiAqIDIsIHVpbnQxNkFycmF5MSApLFxuXHRcdFx0XHRPRkZTRVQoIG5vZGUySW5kZXgzMiwgdWludDMyQXJyYXkyICksIENPVU5UKCBub2RlMkluZGV4MzIgKiAyLCB1aW50MTZBcnJheTIgKSxcblx0XHRcdFx0ZGVwdGgxLCBub2RlMUluZGV4Qnl0ZU9mZnNldCArIG5vZGUxSW5kZXgzMixcblx0XHRcdFx0ZGVwdGgyLCBub2RlMkluZGV4Qnl0ZU9mZnNldCArIG5vZGUySW5kZXgzMixcblx0XHRcdCk7XG5cblx0XHR9XG5cblx0fSBlbHNlIGlmICggaXNMZWFmMiApIHtcblxuXHRcdC8vIFNXQVBcblx0XHQvLyBJZiB3ZSd2ZSB0cmF2ZXJzZWQgdG8gdGhlIGxlYWYgbm9kZSBvbiB0aGUgb3RoZXIgYnZoIHRoZW4gd2UgbmVlZCB0byBzd2FwIG92ZXJcblx0XHQvLyB0byB0cmF2ZXJzZSBkb3duIHRoZSBmaXJzdCBvbmVcblxuXHRcdC8vIGdldCB0aGUgbmV3IGJveCB0byB1c2Vcblx0XHRjb25zdCBuZXdCb3ggPSBfYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBub2RlMkluZGV4MzIgKSwgZmxvYXQzMkFycmF5MiwgbmV3Qm94ICk7XG5cdFx0bmV3Qm94LmFwcGx5TWF0cml4NCggbWF0cml4MnRvMSApO1xuXG5cdFx0Ly8gZ2V0IHRoZSBjaGlsZCBib3VuZHMgdG8gY2hlY2sgYmVmb3JlIHRyYXZlcnNhbFxuXHRcdGNvbnN0IGNsMSA9IExFRlRfTk9ERSggbm9kZTFJbmRleDMyICk7XG5cdFx0Y29uc3QgY3IxID0gUklHSFRfTk9ERSggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKTtcblx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjbDEgKSwgZmxvYXQzMkFycmF5MSwgX2xlZnRCb3gxICk7XG5cdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY3IxICksIGZsb2F0MzJBcnJheTEsIF9yaWdodEJveDEgKTtcblxuXHRcdC8vIHByZWNvbXB1dGUgdGhlIGludGVyc2VjdGlvbnMgb3RoZXJ3aXNlIHRoZSBnbG9iYWwgYm94ZXMgd2lsbCBiZSBtb2RpZmllZCBkdXJpbmcgdHJhdmVyc2FsXG5cdFx0Y29uc3QgaW50ZXJzZWN0Q2wxID0gbmV3Qm94LmludGVyc2VjdHNCb3goIF9sZWZ0Qm94MSApO1xuXHRcdGNvbnN0IGludGVyc2VjdENyMSA9IG5ld0JveC5pbnRlcnNlY3RzQm94KCBfcmlnaHRCb3gxICk7XG5cdFx0cmVzdWx0ID0gKFxuXHRcdFx0aW50ZXJzZWN0Q2wxICYmIF90cmF2ZXJzZShcblx0XHRcdFx0bm9kZTJJbmRleDMyLCBjbDEsIG1hdHJpeDF0bzIsIG1hdHJpeDJ0bzEsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0bmV3Qm94LCAhIHJldmVyc2VkLFxuXHRcdFx0KVxuXHRcdCkgfHwgKFxuXHRcdFx0aW50ZXJzZWN0Q3IxICYmIF90cmF2ZXJzZShcblx0XHRcdFx0bm9kZTJJbmRleDMyLCBjcjEsIG1hdHJpeDF0bzIsIG1hdHJpeDJ0bzEsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0bmV3Qm94LCAhIHJldmVyc2VkLFxuXHRcdFx0KVxuXHRcdCk7XG5cblx0XHRfYm94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBuZXdCb3ggKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gaWYgbmVpdGhlciBhcmUgbGVhdmVzIHRoZW4gd2Ugc2hvdWxkIHN3YXAgaWYgb25lIG9mIHRoZSBjaGlsZHJlbiBkb2VzIG5vdFxuXHRcdC8vIGludGVyc2VjdCB3aXRoIHRoZSBjdXJyZW50IGJvdW5kc1xuXG5cdFx0Ly8gZ2V0IHRoZSBjaGlsZCBib3VuZHMgdG8gY2hlY2tcblx0XHRjb25zdCBjbDIgPSBMRUZUX05PREUoIG5vZGUySW5kZXgzMiApO1xuXHRcdGNvbnN0IGNyMiA9IFJJR0hUX05PREUoIG5vZGUySW5kZXgzMiwgdWludDMyQXJyYXkyICk7XG5cdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY2wyICksIGZsb2F0MzJBcnJheTIsIF9sZWZ0Qm94MiApO1xuXHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNyMiApLCBmbG9hdDMyQXJyYXkyLCBfcmlnaHRCb3gyICk7XG5cblx0XHRjb25zdCBsZWZ0SW50ZXJzZWN0cyA9IGN1cnJCb3guaW50ZXJzZWN0c0JveCggX2xlZnRCb3gyICk7XG5cdFx0Y29uc3QgcmlnaHRJbnRlcnNlY3RzID0gY3VyckJveC5pbnRlcnNlY3RzQm94KCBfcmlnaHRCb3gyICk7XG5cdFx0aWYgKCBsZWZ0SW50ZXJzZWN0cyAmJiByaWdodEludGVyc2VjdHMgKSB7XG5cblx0XHRcdC8vIGNvbnRpbnVlIHRvIHRyYXZlcnNlIGJvdGggY2hpbGRyZW4gaWYgdGhleSBib3RoIGludGVyc2VjdFxuXHRcdFx0cmVzdWx0ID0gX3RyYXZlcnNlKFxuXHRcdFx0XHRub2RlMUluZGV4MzIsIGNsMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBub2RlMkluZGV4Qnl0ZU9mZnNldCwgZGVwdGgxLCBkZXB0aDIgKyAxLFxuXHRcdFx0XHRjdXJyQm94LCByZXZlcnNlZCxcblx0XHRcdCkgfHwgX3RyYXZlcnNlKFxuXHRcdFx0XHRub2RlMUluZGV4MzIsIGNyMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBub2RlMkluZGV4Qnl0ZU9mZnNldCwgZGVwdGgxLCBkZXB0aDIgKyAxLFxuXHRcdFx0XHRjdXJyQm94LCByZXZlcnNlZCxcblx0XHRcdCk7XG5cblx0XHR9IGVsc2UgaWYgKCBsZWZ0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0aWYgKCBpc0xlYWYxICkge1xuXG5cdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGJveCBpcyBhIGxlYWYgdGhlbiBqdXN0IGNvbnRpbnVlXG5cdFx0XHRcdHJlc3VsdCA9IF90cmF2ZXJzZShcblx0XHRcdFx0XHRub2RlMUluZGV4MzIsIGNsMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQsIG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDEsIGRlcHRoMiArIDEsXG5cdFx0XHRcdFx0Y3VyckJveCwgcmV2ZXJzZWQsXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gU1dBUFxuXHRcdFx0XHQvLyBpZiBvbmx5IG9uZSBib3ggaW50ZXJzZWN0cyB0aGVuIHdlIGhhdmUgdG8gc3dhcCB0byB0aGUgb3RoZXIgYnZoIHRvIGNvbnRpbnVlXG5cdFx0XHRcdGNvbnN0IG5ld0JveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0XHRuZXdCb3guY29weSggX2xlZnRCb3gyICkuYXBwbHlNYXRyaXg0KCBtYXRyaXgydG8xICk7XG5cblx0XHRcdFx0Y29uc3QgY2wxID0gTEVGVF9OT0RFKCBub2RlMUluZGV4MzIgKTtcblx0XHRcdFx0Y29uc3QgY3IxID0gUklHSFRfTk9ERSggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKTtcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY2wxICksIGZsb2F0MzJBcnJheTEsIF9sZWZ0Qm94MSApO1xuXHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjcjEgKSwgZmxvYXQzMkFycmF5MSwgX3JpZ2h0Qm94MSApO1xuXG5cdFx0XHRcdC8vIHByZWNvbXB1dGUgdGhlIGludGVyc2VjdGlvbnMgb3RoZXJ3aXNlIHRoZSBnbG9iYWwgYm94ZXMgd2lsbCBiZSBtb2RpZmllZCBkdXJpbmcgdHJhdmVyc2FsXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdENsMSA9IG5ld0JveC5pbnRlcnNlY3RzQm94KCBfbGVmdEJveDEgKTtcblx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0Q3IxID0gbmV3Qm94LmludGVyc2VjdHNCb3goIF9yaWdodEJveDEgKTtcblx0XHRcdFx0cmVzdWx0ID0gKFxuXHRcdFx0XHRcdGludGVyc2VjdENsMSAmJiBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0XHRjbDIsIGNsMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0XHRcdG5ld0JveCwgISByZXZlcnNlZCxcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCkgfHwgKFxuXHRcdFx0XHRcdGludGVyc2VjdENyMSAmJiBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0XHRjbDIsIGNyMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0XHRcdG5ld0JveCwgISByZXZlcnNlZCxcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0X2JveFBvb2wucmVsZWFzZVByaW1pdGl2ZSggbmV3Qm94ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHJpZ2h0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0aWYgKCBpc0xlYWYxICkge1xuXG5cdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGJveCBpcyBhIGxlYWYgdGhlbiBqdXN0IGNvbnRpbnVlXG5cdFx0XHRcdHJlc3VsdCA9IF90cmF2ZXJzZShcblx0XHRcdFx0XHRub2RlMUluZGV4MzIsIGNyMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQsIG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDEsIGRlcHRoMiArIDEsXG5cdFx0XHRcdFx0Y3VyckJveCwgcmV2ZXJzZWQsXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gU1dBUFxuXHRcdFx0XHQvLyBpZiBvbmx5IG9uZSBib3ggaW50ZXJzZWN0cyB0aGVuIHdlIGhhdmUgdG8gc3dhcCB0byB0aGUgb3RoZXIgYnZoIHRvIGNvbnRpbnVlXG5cdFx0XHRcdGNvbnN0IG5ld0JveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0XHRuZXdCb3guY29weSggX3JpZ2h0Qm94MiApLmFwcGx5TWF0cml4NCggbWF0cml4MnRvMSApO1xuXG5cdFx0XHRcdGNvbnN0IGNsMSA9IExFRlRfTk9ERSggbm9kZTFJbmRleDMyICk7XG5cdFx0XHRcdGNvbnN0IGNyMSA9IFJJR0hUX05PREUoIG5vZGUxSW5kZXgzMiwgdWludDMyQXJyYXkxICk7XG5cdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNsMSApLCBmbG9hdDMyQXJyYXkxLCBfbGVmdEJveDEgKTtcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY3IxICksIGZsb2F0MzJBcnJheTEsIF9yaWdodEJveDEgKTtcblxuXHRcdFx0XHQvLyBwcmVjb21wdXRlIHRoZSBpbnRlcnNlY3Rpb25zIG90aGVyd2lzZSB0aGUgZ2xvYmFsIGJveGVzIHdpbGwgYmUgbW9kaWZpZWQgZHVyaW5nIHRyYXZlcnNhbFxuXHRcdFx0XHRjb25zdCBpbnRlcnNlY3RDbDEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX2xlZnRCb3gxICk7XG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdENyMSA9IG5ld0JveC5pbnRlcnNlY3RzQm94KCBfcmlnaHRCb3gxICk7XG5cdFx0XHRcdHJlc3VsdCA9IChcblx0XHRcdFx0XHRpbnRlcnNlY3RDbDEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0Y3IyLCBjbDEsIG1hdHJpeDF0bzIsIG1hdHJpeDJ0bzEsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRcdFx0bm9kZTJJbmRleEJ5dGVPZmZzZXQsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDIsIGRlcHRoMSArIDEsXG5cdFx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpIHx8IChcblx0XHRcdFx0XHRpbnRlcnNlY3RDcjEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0Y3IyLCBjcjEsIG1hdHJpeDF0bzIsIG1hdHJpeDJ0bzEsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRcdFx0bm9kZTJJbmRleEJ5dGVPZmZzZXQsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDIsIGRlcHRoMSArIDEsXG5cdFx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdF9ib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIG5ld0JveCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG5cbn1cblxuIl0sIm5hbWVzIjpbIkJveDMiLCJNYXRyaXg0IiwiQnVmZmVyU3RhY2siLCJCT1VORElOR19EQVRBX0lOREVYIiwiQ09VTlQiLCJJU19MRUFGIiwiTEVGVF9OT0RFIiwiT0ZGU0VUIiwiUklHSFRfTk9ERSIsImFycmF5VG9Cb3giLCJQcmltaXRpdmVQb29sIiwiX2J1ZmZlclN0YWNrMSIsImNvbnN0cnVjdG9yIiwiX2J1ZmZlclN0YWNrMiIsIl9ib3hQb29sIiwiX2xlZnRCb3gxIiwiX3JpZ2h0Qm94MSIsIl9sZWZ0Qm94MiIsIl9yaWdodEJveDIiLCJfYWN0aXZlIiwiYnZoY2FzdCIsImJ2aCIsIm90aGVyQnZoIiwibWF0cml4VG9Mb2NhbCIsImludGVyc2VjdHNSYW5nZXMiLCJFcnJvciIsInJvb3RzIiwiX3Jvb3RzIiwib3RoZXJSb290cyIsInJlc3VsdCIsIm9mZnNldDEiLCJvZmZzZXQyIiwiaW52TWF0IiwiY29weSIsImludmVydCIsImkiLCJpbCIsImxlbmd0aCIsInNldEJ1ZmZlciIsImxvY2FsQm94IiwiZ2V0UHJpbWl0aXZlIiwiZmxvYXQzMkFycmF5IiwiYXBwbHlNYXRyaXg0IiwiaiIsImpsIiwiX3RyYXZlcnNlIiwiY2xlYXJCdWZmZXIiLCJyZWxlYXNlUHJpbWl0aXZlIiwibm9kZTFJbmRleDMyIiwibm9kZTJJbmRleDMyIiwibWF0cml4MnRvMSIsIm1hdHJpeDF0bzIiLCJpbnRlcnNlY3RzUmFuZ2VzRnVuYyIsIm5vZGUxSW5kZXhCeXRlT2Zmc2V0Iiwibm9kZTJJbmRleEJ5dGVPZmZzZXQiLCJkZXB0aDEiLCJkZXB0aDIiLCJjdXJyQm94IiwicmV2ZXJzZWQiLCJidWZmZXJTdGFjazEiLCJidWZmZXJTdGFjazIiLCJmbG9hdDMyQXJyYXkxIiwidWludDMyQXJyYXkxIiwidWludDMyQXJyYXkiLCJ1aW50MTZBcnJheTEiLCJ1aW50MTZBcnJheSIsImZsb2F0MzJBcnJheTIiLCJ1aW50MzJBcnJheTIiLCJ1aW50MTZBcnJheTIiLCJub2RlMUluZGV4MTYiLCJub2RlMkluZGV4MTYiLCJpc0xlYWYxIiwiaXNMZWFmMiIsIm5ld0JveCIsImNsMSIsImNyMSIsImludGVyc2VjdENsMSIsImludGVyc2VjdHNCb3giLCJpbnRlcnNlY3RDcjEiLCJjbDIiLCJjcjIiLCJsZWZ0SW50ZXJzZWN0cyIsInJpZ2h0SW50ZXJzZWN0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/bvhcast.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointToGeometry: function() { return /* binding */ closestPointToGeometry; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/OrientedBox.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/OrientedBox.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n/* harmony import */ var _build_geometryUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../build/geometryUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/geometryUtils.js\");\n/* harmony import */ var _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/ExtendedTrianglePool.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js\");\n\n\n\n\n\n/*********************************************************************/ /* This file is generated from \"closestPointToGeometry.template.js\". */ /*********************************************************************/ const tempMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__.OrientedBox();\nconst obb2 = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__.OrientedBox();\nconst temp1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp4 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction closestPointToGeometry(bvh, otherGeometry, geometryToBvh) {\n    let target1 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, target2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, minThreshold = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, maxThreshold = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : Infinity;\n    if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n    }\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    obb.needsUpdate = true;\n    const geometry = bvh.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.getPrimitive();\n    const triangle2 = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.getPrimitive();\n    let tempTarget1 = temp1;\n    let tempTargetDest1 = temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n        tempTarget2 = temp3;\n        tempTargetDest2 = temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    tempMatrix.copy(geometryToBvh).invert();\n    obb2.matrix.copy(tempMatrix);\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            return obb.distanceToBox(box);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            if (score < closestDistance && score < maxThreshold) {\n                // if we know the triangles of this bounds will be intersected next then\n                // save the bounds to use during triangle checks.\n                if (isLeaf) {\n                    obb2.min.copy(box.min);\n                    obb2.max.copy(box.max);\n                    obb2.needsUpdate = true;\n                }\n                return true;\n            }\n            return false;\n        },\n        intersectsRange: (offset, count)=>{\n            if (otherGeometry.boundsTree) {\n                // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n                // the closest bounds in the other geometry to check.\n                const otherBvh = otherGeometry.boundsTree;\n                return otherBvh.shapecast({\n                    boundsTraverseOrder: (box)=>{\n                        return obb2.distanceToBox(box);\n                    },\n                    intersectsBounds: (box, isLeaf, score)=>{\n                        return score < closestDistance && score < maxThreshold;\n                    },\n                    intersectsRange: (otherOffset, otherCount)=>{\n                        for(let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++){\n                            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                            triangle2.a.applyMatrix4(geometryToBvh);\n                            triangle2.b.applyMatrix4(geometryToBvh);\n                            triangle2.c.applyMatrix4(geometryToBvh);\n                            triangle2.needsUpdate = true;\n                            for(let i = offset, l = offset + count; i < l; i++){\n                                (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle, 3 * i, index, pos);\n                                triangle.needsUpdate = true;\n                                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                                if (dist < closestDistance) {\n                                    tempTargetDest1.copy(tempTarget1);\n                                    if (tempTargetDest2) {\n                                        tempTargetDest2.copy(tempTarget2);\n                                    }\n                                    closestDistance = dist;\n                                    closestDistanceTriIndex = i;\n                                    closestDistanceOtherTriIndex = i2;\n                                }\n                                // stop traversal if we find a point that's under the given threshold\n                                if (dist < minThreshold) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                });\n            } else {\n                // If no bounds tree then we'll just check every triangle.\n                const triCount = (0,_build_geometryUtils_js__WEBPACK_IMPORTED_MODULE_4__.getTriCount)(otherGeometry);\n                for(let i2 = 0, l2 = triCount; i2 < l2; i2++){\n                    (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                    triangle2.a.applyMatrix4(geometryToBvh);\n                    triangle2.b.applyMatrix4(geometryToBvh);\n                    triangle2.c.applyMatrix4(geometryToBvh);\n                    triangle2.needsUpdate = true;\n                    for(let i = offset, l = offset + count; i < l; i++){\n                        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle, 3 * i, index, pos);\n                        triangle.needsUpdate = true;\n                        const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                        if (dist < closestDistance) {\n                            tempTargetDest1.copy(tempTarget1);\n                            if (tempTargetDest2) {\n                                tempTargetDest2.copy(tempTarget2);\n                            }\n                            closestDistance = dist;\n                            closestDistanceTriIndex = i;\n                            closestDistanceOtherTriIndex = i2;\n                        }\n                        // stop traversal if we find a point that's under the given threshold\n                        if (dist < minThreshold) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    });\n    _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.releasePrimitive(triangle);\n    _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.releasePrimitive(triangle2);\n    if (closestDistance === Infinity) {\n        return null;\n    }\n    if (!target1.point) {\n        target1.point = tempTargetDest1.clone();\n    } else {\n        target1.point.copy(tempTargetDest1);\n    }\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();\n        else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4(tempMatrix);\n        tempTargetDest1.applyMatrix4(tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L2Nsb3Nlc3RQb2ludFRvR2VvbWV0cnkuZ2VuZXJhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF5QztBQUNlO0FBQ087QUFDUDtBQUNtQjtBQUUzRSxxRUFBcUUsR0FDckUscUVBQXFFLEdBQ3JFLHFFQUFxRSxHQUVyRSxNQUFNTSxhQUFhLGFBQWEsR0FBRyxJQUFJTiwwQ0FBT0E7QUFDOUMsTUFBTU8sTUFBTSxhQUFhLEdBQUcsSUFBSUwsNkRBQVdBO0FBQzNDLE1BQU1NLE9BQU8sYUFBYSxHQUFHLElBQUlOLDZEQUFXQTtBQUM1QyxNQUFNTyxRQUFRLGFBQWEsR0FBRyxJQUFJUiwwQ0FBT0E7QUFDekMsTUFBTVMsUUFBUSxhQUFhLEdBQUcsSUFBSVQsMENBQU9BO0FBQ3pDLE1BQU1VLFFBQVEsYUFBYSxHQUFHLElBQUlWLDBDQUFPQTtBQUN6QyxNQUFNVyxRQUFRLGFBQWEsR0FBRyxJQUFJWCwwQ0FBT0E7QUFFekMsU0FBU1ksdUJBQ1JDLEdBQUcsRUFDSEMsYUFBYSxFQUNiQyxhQUFhO1FBQ2JDLFVBQUFBLGlFQUFVLENBQUUsR0FDWkMsVUFBQUEsaUVBQVUsQ0FBRSxHQUNaQyxlQUFBQSxpRUFBZSxHQUNmQyxlQUFBQSxpRUFBZUM7SUFHZixJQUFLLENBQUVOLGNBQWNPLFdBQVcsRUFBRztRQUVsQ1AsY0FBY1Esa0JBQWtCO0lBRWpDO0lBRUFoQixJQUFJaUIsR0FBRyxDQUFFVCxjQUFjTyxXQUFXLENBQUNHLEdBQUcsRUFBRVYsY0FBY08sV0FBVyxDQUFDSSxHQUFHLEVBQUVWO0lBQ3ZFVCxJQUFJb0IsV0FBVyxHQUFHO0lBRWxCLE1BQU1DLFdBQVdkLElBQUljLFFBQVE7SUFDN0IsTUFBTUMsTUFBTUQsU0FBU0UsVUFBVSxDQUFDQyxRQUFRO0lBQ3hDLE1BQU1DLFFBQVFKLFNBQVNJLEtBQUs7SUFDNUIsTUFBTUMsV0FBV2xCLGNB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dEMsT0FBTztRQUVOMUQsUUFBUXlELEtBQUssQ0FBQzdCLElBQUksQ0FBRU47SUFFckI7SUFFQXRCLFFBQVEyRCxRQUFRLEdBQUdsQyxpQkFDbkJ6QixRQUFRNEQsU0FBUyxHQUFHbEM7SUFFcEIsSUFBS3pCLFNBQVU7UUFFZCxJQUFLLENBQUVBLFFBQVF3RCxLQUFLLEVBQUd4RCxRQUFRd0QsS0FBSyxHQUFHakMsZ0JBQWdCa0MsS0FBSzthQUN2RHpELFFBQVF3RCxLQUFLLENBQUM3QixJQUFJLENBQUVKO1FBQ3pCdkIsUUFBUXdELEtBQUssQ0FBQ1QsWUFBWSxDQUFFM0Q7UUFDNUJpQyxnQkFBZ0IwQixZQUFZLENBQUUzRDtRQUM5QlksUUFBUTBELFFBQVEsR0FBR3JDLGdCQUFnQnVDLEdBQUcsQ0FBRTVELFFBQVF3RCxLQUFLLEVBQUdLLE1BQU07UUFDOUQ3RCxRQUFRMkQsU0FBUyxHQUFHakM7SUFFckI7SUFFQSxPQUFPM0I7QUFFUjtBQUVrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvY2FzdC9jbG9zZXN0UG9pbnRUb0dlb21ldHJ5LmdlbmVyYXRlZC5qcz82MzQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeDQsIFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBPcmllbnRlZEJveCB9IGZyb20gJy4uLy4uL21hdGgvT3JpZW50ZWRCb3guanMnO1xuaW1wb3J0IHsgc2V0VHJpYW5nbGUgfSBmcm9tICcuLi8uLi91dGlscy9UcmlhbmdsZVV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBnZXRUcmlDb3VudCB9IGZyb20gJy4uL2J1aWxkL2dlb21ldHJ5VXRpbHMuanMnO1xuaW1wb3J0IHsgRXh0ZW5kZWRUcmlhbmdsZVBvb2wgfSBmcm9tICcuLi8uLi91dGlscy9FeHRlbmRlZFRyaWFuZ2xlUG9vbC5qcyc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jb25zdCB0ZW1wTWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBvYmIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5jb25zdCBvYmIyID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuY29uc3QgdGVtcDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXAyID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgdGVtcDQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcblxuZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9HZW9tZXRyeShcblx0YnZoLFxuXHRvdGhlckdlb21ldHJ5LFxuXHRnZW9tZXRyeVRvQnZoLFxuXHR0YXJnZXQxID0geyB9LFxuXHR0YXJnZXQyID0geyB9LFxuXHRtaW5UaHJlc2hvbGQgPSAwLFxuXHRtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSxcbikge1xuXG5cdGlmICggISBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94ICkge1xuXG5cdFx0b3RoZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHR9XG5cblx0b2JiLnNldCggb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5taW4sIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWF4LCBnZW9tZXRyeVRvQnZoICk7XG5cdG9iYi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdGNvbnN0IHBvcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdGNvbnN0IG90aGVyUG9zID0gb3RoZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRjb25zdCBvdGhlckluZGV4ID0gb3RoZXJHZW9tZXRyeS5pbmRleDtcblx0Y29uc3QgdHJpYW5nbGUgPSBFeHRlbmRlZFRyaWFuZ2xlUG9vbC5nZXRQcmltaXRpdmUoKTtcblx0Y29uc3QgdHJpYW5nbGUyID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cblx0bGV0IHRlbXBUYXJnZXQxID0gdGVtcDE7XG5cdGxldCB0ZW1wVGFyZ2V0RGVzdDEgPSB0ZW1wMjtcblx0bGV0IHRlbXBUYXJnZXQyID0gbnVsbDtcblx0bGV0IHRlbXBUYXJnZXREZXN0MiA9IG51bGw7XG5cblx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0dGVtcFRhcmdldDIgPSB0ZW1wMztcblx0XHR0ZW1wVGFyZ2V0RGVzdDIgPSB0ZW1wNDtcblxuXHR9XG5cblx0bGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXHRsZXQgY2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBudWxsO1xuXHRsZXQgY2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleCA9IG51bGw7XG5cdHRlbXBNYXRyaXguY29weSggZ2VvbWV0cnlUb0J2aCApLmludmVydCgpO1xuXHRvYmIyLm1hdHJpeC5jb3B5KCB0ZW1wTWF0cml4ICk7XG5cdGJ2aC5zaGFwZWNhc3QoXG5cdFx0e1xuXG5cdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyOiBib3ggPT4ge1xuXG5cdFx0XHRcdHJldHVybiBvYmIuZGlzdGFuY2VUb0JveCggYm94ICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGludGVyc2VjdHNCb3VuZHM6ICggYm94LCBpc0xlYWYsIHNjb3JlICkgPT4ge1xuXG5cdFx0XHRcdGlmICggc2NvcmUgPCBjbG9zZXN0RGlzdGFuY2UgJiYgc2NvcmUgPCBtYXhUaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB3ZSBrbm93IHRoZSB0cmlhbmdsZXMgb2YgdGhpcyBib3VuZHMgd2lsbCBiZSBpbnRlcnNlY3RlZCBuZXh0IHRoZW5cblx0XHRcdFx0XHQvLyBzYXZlIHRoZSBib3VuZHMgdG8gdXNlIGR1cmluZyB0cmlhbmdsZSBjaGVja3MuXG5cdFx0XHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0XHRcdG9iYjIubWluLmNvcHkoIGJveC5taW4gKTtcblx0XHRcdFx0XHRcdG9iYjIubWF4LmNvcHkoIGJveC5tYXggKTtcblx0XHRcdFx0XHRcdG9iYjIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fSxcblxuXHRcdFx0aW50ZXJzZWN0c1JhbmdlOiAoIG9mZnNldCwgY291bnQgKSA9PiB7XG5cblx0XHRcdFx0aWYgKCBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgb3RoZXIgZ2VvbWV0cnkgaGFzIGEgYnZoIHRoZW4gdXNlIHRoZSBhY2NlbGVyYXRlZCBwYXRoIHdoZXJlIHdlIHVzZSBzaGFwZWNhc3QgdG8gZmluZFxuXHRcdFx0XHRcdC8vIHRoZSBjbG9zZXN0IGJvdW5kcyBpbiB0aGUgb3RoZXIgZ2VvbWV0cnkgdG8gY2hlY2suXG5cdFx0XHRcdFx0Y29uc3Qgb3RoZXJCdmggPSBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRcdFx0cmV0dXJuIG90aGVyQnZoLnNoYXBlY2FzdCgge1xuXHRcdFx0XHRcdFx0Ym91bmRzVHJhdmVyc2VPcmRlcjogYm94ID0+IHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JiMi5kaXN0YW5jZVRvQm94KCBib3ggKTtcblxuXHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogKCBib3gsIGlzTGVhZiwgc2NvcmUgKSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNjb3JlIDwgY2xvc2VzdERpc3RhbmNlICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkO1xuXG5cdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2U6ICggb3RoZXJPZmZzZXQsIG90aGVyQ291bnQgKSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gb3RoZXJPZmZzZXQsIGwyID0gb3RoZXJPZmZzZXQgKyBvdGhlckNvdW50OyBpMiA8IGwyOyBpMiArKyApIHtcblxuXG5cdFx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmIuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cblx0XHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIGksIGluZGV4LCBwb3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBkaXN0ID0gdHJpYW5nbGUuZGlzdGFuY2VUb1RyaWFuZ2xlKCB0cmlhbmdsZTIsIHRlbXBUYXJnZXQxLCB0ZW1wVGFyZ2V0MiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0MS5jb3B5KCB0ZW1wVGFyZ2V0MSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdGVtcFRhcmdldERlc3QyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QyLmNvcHkoIHRlbXBUYXJnZXQyICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleCA9IGkyO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIHN0b3AgdHJhdmVyc2FsIGlmIHdlIGZpbmQgYSBwb2ludCB0aGF0J3MgdW5kZXIgdGhlIGdpdmVuIHRocmVzaG9sZFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgbWluVGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gSWYgbm8gYm91bmRzIHRyZWUgdGhlbiB3ZSdsbCBqdXN0IGNoZWNrIGV2ZXJ5IHRyaWFuZ2xlLlxuXHRcdFx0XHRcdGNvbnN0IHRyaUNvdW50ID0gZ2V0VHJpQ291bnQoIG90aGVyR2VvbWV0cnkgKTtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwLCBsMiA9IHRyaUNvdW50OyBpMiA8IGwyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5jLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblxuXHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIDMgKiBpLCBpbmRleCwgcG9zICk7XG5cblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGRpc3QgPSB0cmlhbmdsZS5kaXN0YW5jZVRvVHJpYW5nbGUoIHRyaWFuZ2xlMiwgdGVtcFRhcmdldDEsIHRlbXBUYXJnZXQyICk7XG5cdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0MS5jb3B5KCB0ZW1wVGFyZ2V0MSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0ZW1wVGFyZ2V0RGVzdDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0Mi5jb3B5KCB0ZW1wVGFyZ2V0MiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlID0gZGlzdDtcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleCA9IGkyO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBzdG9wIHRyYXZlcnNhbCBpZiB3ZSBmaW5kIGEgcG9pbnQgdGhhdCdzIHVuZGVyIHRoZSBnaXZlbiB0aHJlc2hvbGRcblx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgbWluVGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0fVxuXG5cdCk7XG5cblx0RXh0ZW5kZWRUcmlhbmdsZVBvb2wucmVsZWFzZVByaW1pdGl2ZSggdHJpYW5nbGUgKTtcblx0RXh0ZW5kZWRUcmlhbmdsZVBvb2wucmVsZWFzZVByaW1pdGl2ZSggdHJpYW5nbGUyICk7XG5cblx0aWYgKCBjbG9zZXN0RGlzdGFuY2UgPT09IEluZmluaXR5ICkge1xuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdGlmICggISB0YXJnZXQxLnBvaW50ICkge1xuXG5cdFx0dGFyZ2V0MS5wb2ludCA9IHRlbXBUYXJnZXREZXN0MS5jbG9uZSgpO1xuXG5cdH0gZWxzZSB7XG5cblx0XHR0YXJnZXQxLnBvaW50LmNvcHkoIHRlbXBUYXJnZXREZXN0MSApO1xuXG5cdH1cblxuXHR0YXJnZXQxLmRpc3RhbmNlID0gY2xvc2VzdERpc3RhbmNlLFxuXHR0YXJnZXQxLmZhY2VJbmRleCA9IGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4O1xuXG5cdGlmICggdGFyZ2V0MiApIHtcblxuXHRcdGlmICggISB0YXJnZXQyLnBvaW50ICkgdGFyZ2V0Mi5wb2ludCA9IHRlbXBUYXJnZXREZXN0Mi5jbG9uZSgpO1xuXHRcdGVsc2UgdGFyZ2V0Mi5wb2ludC5jb3B5KCB0ZW1wVGFyZ2V0RGVzdDIgKTtcblx0XHR0YXJnZXQyLnBvaW50LmFwcGx5TWF0cml4NCggdGVtcE1hdHJpeCApO1xuXHRcdHRlbXBUYXJnZXREZXN0MS5hcHBseU1hdHJpeDQoIHRlbXBNYXRyaXggKTtcblx0XHR0YXJnZXQyLmRpc3RhbmNlID0gdGVtcFRhcmdldERlc3QxLnN1YiggdGFyZ2V0Mi5wb2ludCApLmxlbmd0aCgpO1xuXHRcdHRhcmdldDIuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleDtcblxuXHR9XG5cblx0cmV0dXJuIHRhcmdldDE7XG5cbn1cblxuZXhwb3J0IHsgY2xvc2VzdFBvaW50VG9HZW9tZXRyeSB9O1xuIl0sIm5hbWVzIjpbIk1hdHJpeDQiLCJWZWN0b3IzIiwiT3JpZW50ZWRCb3giLCJzZXRUcmlhbmdsZSIsImdldFRyaUNvdW50IiwiRXh0ZW5kZWRUcmlhbmdsZVBvb2wiLCJ0ZW1wTWF0cml4Iiwib2JiIiwib2JiMiIsInRlbXAxIiwidGVtcDIiLCJ0ZW1wMyIsInRlbXA0IiwiY2xvc2VzdFBvaW50VG9HZW9tZXRyeSIsImJ2aCIsIm90aGVyR2VvbWV0cnkiLCJnZW9tZXRyeVRvQnZoIiwidGFyZ2V0MSIsInRhcmdldDIiLCJtaW5UaHJlc2hvbGQiLCJtYXhUaHJlc2hvbGQiLCJJbmZpbml0eSIsImJvdW5kaW5nQm94IiwiY29tcHV0ZUJvdW5kaW5nQm94Iiwic2V0IiwibWluIiwibWF4IiwibmVlZHNVcGRhdGUiLCJnZW9tZXRyeSIsInBvcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsImluZGV4Iiwib3RoZXJQb3MiLCJvdGhlckluZGV4IiwidHJpYW5nbGUiLCJnZXRQcmltaXRpdmUiLCJ0cmlhbmdsZTIiLCJ0ZW1wVGFyZ2V0MSIsInRlbXBUYXJnZXREZXN0MSIsInRlbXBUYXJnZXQyIiwidGVtcFRhcmdldERlc3QyIiwiY2xvc2VzdERpc3RhbmNlIiwiY2xvc2VzdERpc3RhbmNlVHJpSW5kZXgiLCJjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4IiwiY29weSIsImludmVydCIsIm1hdHJpeCIsInNoYXBlY2FzdCIsImJvdW5kc1RyYXZlcnNlT3JkZXIiLCJib3giLCJkaXN0YW5jZVRvQm94IiwiaW50ZXJzZWN0c0JvdW5kcyIsImlzTGVhZiIsInNjb3JlIiwiaW50ZXJzZWN0c1JhbmdlIiwib2Zmc2V0IiwiY291bnQiLCJib3VuZHNUcmVlIiwib3RoZXJCdmgiLCJvdGhlck9mZnNldCIsIm90aGVyQ291bnQiLCJpMiIsImwyIiwiYSIsImFwcGx5TWF0cml4NCIsImIiLCJjIiwiaSIsImwiLCJkaXN0IiwiZGlzdGFuY2VUb1RyaWFuZ2xlIiwidHJpQ291bnQiLCJyZWxlYXNlUHJpbWl0aXZlIiwicG9pbnQiLCJjbG9uZSIsImRpc3RhbmNlIiwiZmFjZUluZGV4Iiwic3ViIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointToGeometry_indirect: function() { return /* binding */ closestPointToGeometry_indirect; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/OrientedBox.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/OrientedBox.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n/* harmony import */ var _build_geometryUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../build/geometryUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/build/geometryUtils.js\");\n/* harmony import */ var _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/ExtendedTrianglePool.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js\");\n\n\n\n\n\n/*********************************************************************/ /* This file is generated from \"closestPointToGeometry.template.js\". */ /*********************************************************************/ const tempMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__.OrientedBox();\nconst obb2 = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__.OrientedBox();\nconst temp1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp4 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction closestPointToGeometry_indirect(bvh, otherGeometry, geometryToBvh) {\n    let target1 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, target2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, minThreshold = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, maxThreshold = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : Infinity;\n    if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n    }\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    obb.needsUpdate = true;\n    const geometry = bvh.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.getPrimitive();\n    const triangle2 = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.getPrimitive();\n    let tempTarget1 = temp1;\n    let tempTargetDest1 = temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n        tempTarget2 = temp3;\n        tempTargetDest2 = temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    tempMatrix.copy(geometryToBvh).invert();\n    obb2.matrix.copy(tempMatrix);\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            return obb.distanceToBox(box);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            if (score < closestDistance && score < maxThreshold) {\n                // if we know the triangles of this bounds will be intersected next then\n                // save the bounds to use during triangle checks.\n                if (isLeaf) {\n                    obb2.min.copy(box.min);\n                    obb2.max.copy(box.max);\n                    obb2.needsUpdate = true;\n                }\n                return true;\n            }\n            return false;\n        },\n        intersectsRange: (offset, count)=>{\n            if (otherGeometry.boundsTree) {\n                // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n                // the closest bounds in the other geometry to check.\n                const otherBvh = otherGeometry.boundsTree;\n                return otherBvh.shapecast({\n                    boundsTraverseOrder: (box)=>{\n                        return obb2.distanceToBox(box);\n                    },\n                    intersectsBounds: (box, isLeaf, score)=>{\n                        return score < closestDistance && score < maxThreshold;\n                    },\n                    intersectsRange: (otherOffset, otherCount)=>{\n                        for(let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++){\n                            const ti2 = otherBvh.resolveTriangleIndex(i2);\n                            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle2, 3 * ti2, otherIndex, otherPos);\n                            triangle2.a.applyMatrix4(geometryToBvh);\n                            triangle2.b.applyMatrix4(geometryToBvh);\n                            triangle2.c.applyMatrix4(geometryToBvh);\n                            triangle2.needsUpdate = true;\n                            for(let i = offset, l = offset + count; i < l; i++){\n                                const ti = bvh.resolveTriangleIndex(i);\n                                (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle, 3 * ti, index, pos);\n                                triangle.needsUpdate = true;\n                                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                                if (dist < closestDistance) {\n                                    tempTargetDest1.copy(tempTarget1);\n                                    if (tempTargetDest2) {\n                                        tempTargetDest2.copy(tempTarget2);\n                                    }\n                                    closestDistance = dist;\n                                    closestDistanceTriIndex = i;\n                                    closestDistanceOtherTriIndex = i2;\n                                }\n                                // stop traversal if we find a point that's under the given threshold\n                                if (dist < minThreshold) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                });\n            } else {\n                // If no bounds tree then we'll just check every triangle.\n                const triCount = (0,_build_geometryUtils_js__WEBPACK_IMPORTED_MODULE_4__.getTriCount)(otherGeometry);\n                for(let i2 = 0, l2 = triCount; i2 < l2; i2++){\n                    (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                    triangle2.a.applyMatrix4(geometryToBvh);\n                    triangle2.b.applyMatrix4(geometryToBvh);\n                    triangle2.c.applyMatrix4(geometryToBvh);\n                    triangle2.needsUpdate = true;\n                    for(let i = offset, l = offset + count; i < l; i++){\n                        const ti = bvh.resolveTriangleIndex(i);\n                        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle, 3 * ti, index, pos);\n                        triangle.needsUpdate = true;\n                        const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                        if (dist < closestDistance) {\n                            tempTargetDest1.copy(tempTarget1);\n                            if (tempTargetDest2) {\n                                tempTargetDest2.copy(tempTarget2);\n                            }\n                            closestDistance = dist;\n                            closestDistanceTriIndex = i;\n                            closestDistanceOtherTriIndex = i2;\n                        }\n                        // stop traversal if we find a point that's under the given threshold\n                        if (dist < minThreshold) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    });\n    _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.releasePrimitive(triangle);\n    _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.releasePrimitive(triangle2);\n    if (closestDistance === Infinity) {\n        return null;\n    }\n    if (!target1.point) {\n        target1.point = tempTargetDest1.clone();\n    } else {\n        target1.point.copy(tempTargetDest1);\n    }\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();\n        else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4(tempMatrix);\n        tempTargetDest1.applyMatrix4(tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L2Nsb3Nlc3RQb2ludFRvR2VvbWV0cnlfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF5QztBQUNlO0FBQ087QUFDUDtBQUNtQjtBQUUzRSxxRUFBcUUsR0FDckUscUVBQXFFLEdBQ3JFLHFFQUFxRSxHQUVyRSxNQUFNTSxhQUFhLGFBQWEsR0FBRyxJQUFJTiwwQ0FBT0E7QUFDOUMsTUFBTU8sTUFBTSxhQUFhLEdBQUcsSUFBSUwsNkRBQVdBO0FBQzNDLE1BQU1NLE9BQU8sYUFBYSxHQUFHLElBQUlOLDZEQUFXQTtBQUM1QyxNQUFNTyxRQUFRLGFBQWEsR0FBRyxJQUFJUiwwQ0FBT0E7QUFDekMsTUFBTVMsUUFBUSxhQUFhLEdBQUcsSUFBSVQsMENBQU9BO0FBQ3pDLE1BQU1VLFFBQVEsYUFBYSxHQUFHLElBQUlWLDBDQUFPQTtBQUN6QyxNQUFNVyxRQUFRLGFBQWEsR0FBRyxJQUFJWCwwQ0FBT0E7QUFFekMsU0FBU1ksZ0NBQ1JDLEdBQUcsRUFDSEMsYUFBYSxFQUNiQyxhQUFhO1FBQ2JDLFVBQUFBLGlFQUFVLENBQUUsR0FDWkMsVUFBQUEsaUVBQVUsQ0FBRSxHQUNaQyxlQUFBQSxpRUFBZSxHQUNmQyxlQUFBQSxpRUFBZUM7SUFHZixJQUFLLENBQUVOLGNBQWNPLFdBQVcsRUFBRztRQUVsQ1AsY0FBY1Esa0JBQWtCO0lBRWpDO0lBRUFoQixJQUFJaUIsR0FBRyxDQUFFVCxjQUFjTyxXQUFXLENBQUNHLEdBQUcsRUFBRVYsY0FBY08sV0FBVyxDQUFDSSxHQUFHLEVBQUVWO0lBQ3ZFVCxJQUFJb0IsV0FBVyxHQUFHO0lBRWxCLE1BQU1DLFdBQVdkLElBQUljLFFBQVE7SUFDN0IsTUFBTUMsTUFBTUQsU0FBU0UsVUFBVSxDQUFDQyxRQUFRO0lBQ3hDLE1BQU1DLFFBQVFKLFNBQVNJLEtBQUs7SUFDNUIsTUFBTUMs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LENBQUV2QztJQUV2QyxJQUFLSyxvQkFBb0JyQixVQUFXO1FBRW5DLE9BQU87SUFFUjtJQUVBLElBQUssQ0FBRUosUUFBUTRELEtBQUssRUFBRztRQUV0QjVELFFBQVE0RCxLQUFLLEdBQUd0QyxnQkFBZ0J1QyxLQUFLO0lBRXRDLE9BQU87UUFFTjdELFFBQVE0RCxLQUFLLENBQUNoQyxJQUFJLENBQUVOO0lBRXJCO0lBRUF0QixRQUFROEQsUUFBUSxHQUFHckMsaUJBQ25CekIsUUFBUStELFNBQVMsR0FBR3JDO0lBRXBCLElBQUt6QixTQUFVO1FBRWQsSUFBSyxDQUFFQSxRQUFRMkQsS0FBSyxFQUFHM0QsUUFBUTJELEtBQUssR0FBR3BDLGdCQUFnQnFDLEtBQUs7YUFDdkQ1RCxRQUFRMkQsS0FBSyxDQUFDaEMsSUFBSSxDQUFFSjtRQUN6QnZCLFFBQVEyRCxLQUFLLENBQUNWLFlBQVksQ0FBRTdEO1FBQzVCaUMsZ0JBQWdCNEIsWUFBWSxDQUFFN0Q7UUFDOUJZLFFBQVE2RCxRQUFRLEdBQUd4QyxnQkFBZ0IwQyxHQUFHLENBQUUvRCxRQUFRMkQsS0FBSyxFQUFHSyxNQUFNO1FBQzlEaEUsUUFBUThELFNBQVMsR0FBR3BDO0lBRXJCO0lBRUEsT0FBTzNCO0FBRVI7QUFFMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvY2xvc2VzdFBvaW50VG9HZW9tZXRyeV9pbmRpcmVjdC5nZW5lcmF0ZWQuanM/OTdjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXRyaXg0LCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgT3JpZW50ZWRCb3ggfSBmcm9tICcuLi8uLi9tYXRoL09yaWVudGVkQm94LmpzJztcbmltcG9ydCB7IHNldFRyaWFuZ2xlIH0gZnJvbSAnLi4vLi4vdXRpbHMvVHJpYW5nbGVVdGlsaXRpZXMuanMnO1xuaW1wb3J0IHsgZ2V0VHJpQ291bnQgfSBmcm9tICcuLi9idWlsZC9nZW9tZXRyeVV0aWxzLmpzJztcbmltcG9ydCB7IEV4dGVuZGVkVHJpYW5nbGVQb29sIH0gZnJvbSAnLi4vLi4vdXRpbHMvRXh0ZW5kZWRUcmlhbmdsZVBvb2wuanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwiY2xvc2VzdFBvaW50VG9HZW9tZXRyeS50ZW1wbGF0ZS5qc1wiLiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY29uc3QgdGVtcE1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWF0cml4NCgpO1xuY29uc3Qgb2JiID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuY29uc3Qgb2JiMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcbmNvbnN0IHRlbXAxID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgdGVtcDMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXA0ID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5cbmZ1bmN0aW9uIGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlfaW5kaXJlY3QoXG5cdGJ2aCxcblx0b3RoZXJHZW9tZXRyeSxcblx0Z2VvbWV0cnlUb0J2aCxcblx0dGFyZ2V0MSA9IHsgfSxcblx0dGFyZ2V0MiA9IHsgfSxcblx0bWluVGhyZXNob2xkID0gMCxcblx0bWF4VGhyZXNob2xkID0gSW5maW5pdHksXG4pIHtcblxuXHRpZiAoICEgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveCApIHtcblxuXHRcdG90aGVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0fVxuXG5cdG9iYi5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRvYmIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRjb25zdCBwb3MgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRjb25zdCBvdGhlclBvcyA9IG90aGVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0Y29uc3Qgb3RoZXJJbmRleCA9IG90aGVyR2VvbWV0cnkuaW5kZXg7XG5cdGNvbnN0IHRyaWFuZ2xlID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdGNvbnN0IHRyaWFuZ2xlMiA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXG5cdGxldCB0ZW1wVGFyZ2V0MSA9IHRlbXAxO1xuXHRsZXQgdGVtcFRhcmdldERlc3QxID0gdGVtcDI7XG5cdGxldCB0ZW1wVGFyZ2V0MiA9IG51bGw7XG5cdGxldCB0ZW1wVGFyZ2V0RGVzdDIgPSBudWxsO1xuXG5cdGlmICggdGFyZ2V0MiApIHtcblxuXHRcdHRlbXBUYXJnZXQyID0gdGVtcDM7XG5cdFx0dGVtcFRhcmdldERlc3QyID0gdGVtcDQ7XG5cblx0fVxuXG5cdGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblx0bGV0IGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gbnVsbDtcblx0bGV0IGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXggPSBudWxsO1xuXHR0ZW1wTWF0cml4LmNvcHkoIGdlb21ldHJ5VG9CdmggKS5pbnZlcnQoKTtcblx0b2JiMi5tYXRyaXguY29weSggdGVtcE1hdHJpeCApO1xuXHRidmguc2hhcGVjYXN0KFxuXHRcdHtcblxuXHRcdFx0Ym91bmRzVHJhdmVyc2VPcmRlcjogYm94ID0+IHtcblxuXHRcdFx0XHRyZXR1cm4gb2JiLmRpc3RhbmNlVG9Cb3goIGJveCApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRpZiAoIHNjb3JlIDwgY2xvc2VzdERpc3RhbmNlICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgd2Uga25vdyB0aGUgdHJpYW5nbGVzIG9mIHRoaXMgYm91bmRzIHdpbGwgYmUgaW50ZXJzZWN0ZWQgbmV4dCB0aGVuXG5cdFx0XHRcdFx0Ly8gc2F2ZSB0aGUgYm91bmRzIHRvIHVzZSBkdXJpbmcgdHJpYW5nbGUgY2hlY2tzLlxuXHRcdFx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdFx0XHRvYmIyLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0XHRcdFx0XHRvYmIyLm1heC5jb3B5KCBib3gubWF4ICk7XG5cdFx0XHRcdFx0XHRvYmIyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH0sXG5cblx0XHRcdGludGVyc2VjdHNSYW5nZTogKCBvZmZzZXQsIGNvdW50ICkgPT4ge1xuXG5cdFx0XHRcdGlmICggb3RoZXJHZW9tZXRyeS5ib3VuZHNUcmVlICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIG90aGVyIGdlb21ldHJ5IGhhcyBhIGJ2aCB0aGVuIHVzZSB0aGUgYWNjZWxlcmF0ZWQgcGF0aCB3aGVyZSB3ZSB1c2Ugc2hhcGVjYXN0IHRvIGZpbmRcblx0XHRcdFx0XHQvLyB0aGUgY2xvc2VzdCBib3VuZHMgaW4gdGhlIG90aGVyIGdlb21ldHJ5IHRvIGNoZWNrLlxuXHRcdFx0XHRcdGNvbnN0IG90aGVyQnZoID0gb3RoZXJHZW9tZXRyeS5ib3VuZHNUcmVlO1xuXHRcdFx0XHRcdHJldHVybiBvdGhlckJ2aC5zaGFwZWNhc3QoIHtcblx0XHRcdFx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXI6IGJveCA9PiB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG9iYjIuZGlzdGFuY2VUb0JveCggYm94ICk7XG5cblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6ICggYm94LCBpc0xlYWYsIHNjb3JlICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBzY29yZSA8IGNsb3Nlc3REaXN0YW5jZSAmJiBzY29yZSA8IG1heFRocmVzaG9sZDtcblxuXHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlOiAoIG90aGVyT2Zmc2V0LCBvdGhlckNvdW50ICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IG90aGVyT2Zmc2V0LCBsMiA9IG90aGVyT2Zmc2V0ICsgb3RoZXJDb3VudDsgaTIgPCBsMjsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCB0aTIgPSBvdGhlckJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaTIgKTtcblx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCAzICogdGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmIuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCB0aSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlLCAzICogdGksIGluZGV4LCBwb3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBkaXN0ID0gdHJpYW5nbGUuZGlzdGFuY2VUb1RyaWFuZ2xlKCB0cmlhbmdsZTIsIHRlbXBUYXJnZXQxLCB0ZW1wVGFyZ2V0MiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0MS5jb3B5KCB0ZW1wVGFyZ2V0MSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdGVtcFRhcmdldERlc3QyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QyLmNvcHkoIHRlbXBUYXJnZXQyICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleCA9IGkyO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIHN0b3AgdHJhdmVyc2FsIGlmIHdlIGZpbmQgYSBwb2ludCB0aGF0J3MgdW5kZXIgdGhlIGdpdmVuIHRocmVzaG9sZFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgbWluVGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gSWYgbm8gYm91bmRzIHRyZWUgdGhlbiB3ZSdsbCBqdXN0IGNoZWNrIGV2ZXJ5IHRyaWFuZ2xlLlxuXHRcdFx0XHRcdGNvbnN0IHRyaUNvdW50ID0gZ2V0VHJpQ291bnQoIG90aGVyR2VvbWV0cnkgKTtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwLCBsMiA9IHRyaUNvdW50OyBpMiA8IGwyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5jLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgdGkgPSBidmgucmVzb2x2ZVRyaWFuZ2xlSW5kZXgoIGkgKTtcblx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlLCAzICogdGksIGluZGV4LCBwb3MgKTtcblxuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHRyaWFuZ2xlLmRpc3RhbmNlVG9UcmlhbmdsZSggdHJpYW5nbGUyLCB0ZW1wVGFyZ2V0MSwgdGVtcFRhcmdldDIgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmNvcHkoIHRlbXBUYXJnZXQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHRlbXBUYXJnZXREZXN0MiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QyLmNvcHkoIHRlbXBUYXJnZXQyICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2UgPSBkaXN0O1xuXHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTI7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHN0b3AgdHJhdmVyc2FsIGlmIHdlIGZpbmQgYSBwb2ludCB0aGF0J3MgdW5kZXIgdGhlIGdpdmVuIHRocmVzaG9sZFxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBtaW5UaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHR9XG5cblx0KTtcblxuXHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZSApO1xuXHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZTIgKTtcblxuXHRpZiAoIGNsb3Nlc3REaXN0YW5jZSA9PT0gSW5maW5pdHkgKSB7XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0aWYgKCAhIHRhcmdldDEucG9pbnQgKSB7XG5cblx0XHR0YXJnZXQxLnBvaW50ID0gdGVtcFRhcmdldERlc3QxLmNsb25lKCk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRhcmdldDEucG9pbnQuY29weSggdGVtcFRhcmdldERlc3QxICk7XG5cblx0fVxuXG5cdHRhcmdldDEuZGlzdGFuY2UgPSBjbG9zZXN0RGlzdGFuY2UsXG5cdHRhcmdldDEuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlVHJpSW5kZXg7XG5cblx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0aWYgKCAhIHRhcmdldDIucG9pbnQgKSB0YXJnZXQyLnBvaW50ID0gdGVtcFRhcmdldERlc3QyLmNsb25lKCk7XG5cdFx0ZWxzZSB0YXJnZXQyLnBvaW50LmNvcHkoIHRlbXBUYXJnZXREZXN0MiApO1xuXHRcdHRhcmdldDIucG9pbnQuYXBwbHlNYXRyaXg0KCB0ZW1wTWF0cml4ICk7XG5cdFx0dGVtcFRhcmdldERlc3QxLmFwcGx5TWF0cml4NCggdGVtcE1hdHJpeCApO1xuXHRcdHRhcmdldDIuZGlzdGFuY2UgPSB0ZW1wVGFyZ2V0RGVzdDEuc3ViKCB0YXJnZXQyLnBvaW50ICkubGVuZ3RoKCk7XG5cdFx0dGFyZ2V0Mi5mYWNlSW5kZXggPSBjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4O1xuXG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0MTtcblxufVxuXG5leHBvcnQgeyBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5X2luZGlyZWN0IH07XG4iXSwibmFtZXMiOlsiTWF0cml4NCIsIlZlY3RvcjMiLCJPcmllbnRlZEJveCIsInNldFRyaWFuZ2xlIiwiZ2V0VHJpQ291bnQiLCJFeHRlbmRlZFRyaWFuZ2xlUG9vbCIsInRlbXBNYXRyaXgiLCJvYmIiLCJvYmIyIiwidGVtcDEiLCJ0ZW1wMiIsInRlbXAzIiwidGVtcDQiLCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5X2luZGlyZWN0IiwiYnZoIiwib3RoZXJHZW9tZXRyeSIsImdlb21ldHJ5VG9CdmgiLCJ0YXJnZXQxIiwidGFyZ2V0MiIsIm1pblRocmVzaG9sZCIsIm1heFRocmVzaG9sZCIsIkluZmluaXR5IiwiYm91bmRpbmdCb3giLCJjb21wdXRlQm91bmRpbmdCb3giLCJzZXQiLCJtaW4iLCJtYXgiLCJuZWVkc1VwZGF0ZSIsImdlb21ldHJ5IiwicG9zIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiaW5kZXgiLCJvdGhlclBvcyIsIm90aGVySW5kZXgiLCJ0cmlhbmdsZSIsImdldFByaW1pdGl2ZSIsInRyaWFuZ2xlMiIsInRlbXBUYXJnZXQxIiwidGVtcFRhcmdldERlc3QxIiwidGVtcFRhcmdldDIiLCJ0ZW1wVGFyZ2V0RGVzdDIiLCJjbG9zZXN0RGlzdGFuY2UiLCJjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCIsImNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXgiLCJjb3B5IiwiaW52ZXJ0IiwibWF0cml4Iiwic2hhcGVjYXN0IiwiYm91bmRzVHJhdmVyc2VPcmRlciIsImJveCIsImRpc3RhbmNlVG9Cb3giLCJpbnRlcnNlY3RzQm91bmRzIiwiaXNMZWFmIiwic2NvcmUiLCJpbnRlcnNlY3RzUmFuZ2UiLCJvZmZzZXQiLCJjb3VudCIsImJvdW5kc1RyZWUiLCJvdGhlckJ2aCIsIm90aGVyT2Zmc2V0Iiwib3RoZXJDb3VudCIsImkyIiwibDIiLCJ0aTIiLCJyZXNvbHZlVHJpYW5nbGVJbmRleCIsImEiLCJhcHBseU1hdHJpeDQiLCJiIiwiYyIsImkiLCJsIiwidGkiLCJkaXN0IiwiZGlzdGFuY2VUb1RyaWFuZ2xlIiwidHJpQ291bnQiLCJyZWxlYXNlUHJpbWl0aXZlIiwicG9pbnQiLCJjbG9uZSIsImRpc3RhbmNlIiwiZmFjZUluZGV4Iiwic3ViIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js":
/*!**************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointToPoint: function() { return /* binding */ closestPointToPoint; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nconst temp = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction closestPointToPoint(bvh, point) {\n    let target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, minThreshold = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, maxThreshold = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Infinity;\n    // early out if under minThreshold\n    // skip checking if over maxThreshold\n    // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n    // returns Infinity if no value found\n    const minThresholdSq = minThreshold * minThreshold;\n    const maxThresholdSq = maxThreshold * maxThreshold;\n    let closestDistanceSq = Infinity;\n    let closestDistanceTriIndex = null;\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            temp.copy(point).clamp(box.min, box.max);\n            return temp.distanceToSquared(point);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: (tri, triIndex)=>{\n            tri.closestPointToPoint(point, temp);\n            const distSq = point.distanceToSquared(temp);\n            if (distSq < closestDistanceSq) {\n                temp1.copy(temp);\n                closestDistanceSq = distSq;\n                closestDistanceTriIndex = triIndex;\n            }\n            if (distSq < minThresholdSq) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    });\n    if (closestDistanceSq === Infinity) return null;\n    const closestDistance = Math.sqrt(closestDistanceSq);\n    if (!target.point) target.point = temp1.clone();\n    else target.point.copy(temp1);\n    target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n    return target;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L2Nsb3Nlc3RQb2ludFRvUG9pbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBZ0M7QUFFaEMsTUFBTUMsT0FBTyxhQUFhLEdBQUcsSUFBSUQsMENBQU9BO0FBQ3hDLE1BQU1FLFFBQVEsYUFBYSxHQUFHLElBQUlGLDBDQUFPQTtBQUVsQyxTQUFTRyxvQkFDZkMsR0FBRyxFQUNIQyxLQUFLO1FBQ0xDLFNBQUFBLGlFQUFTLENBQUUsR0FDWEMsZUFBQUEsaUVBQWUsR0FDZkMsZUFBQUEsaUVBQWVDO0lBR2Ysa0NBQWtDO0lBQ2xDLHFDQUFxQztJQUNyQyxvRkFBb0Y7SUFDcEYscUNBQXFDO0lBQ3JDLE1BQU1DLGlCQUFpQkgsZUFBZUE7SUFDdEMsTUFBTUksaUJBQWlCSCxlQUFlQTtJQUN0QyxJQUFJSSxvQkFBb0JIO0lBQ3hCLElBQUlJLDBCQUEwQjtJQUM5QlQsSUFBSVUsU0FBUyxDQUVaO1FBRUNDLHFCQUFxQkMsQ0FBQUE7WUFFcEJmLEtBQUtnQixJQUFJLENBQUVaLE9BQVFhLEtBQUssQ0FBRUYsSUFBSUcsR0FBRyxFQUFFSCxJQUFJSSxHQUFHO1lBQzFDLE9BQU9uQixLQUFLb0IsaUJBQWlCLENBQUVoQjtRQUVoQztRQUVBaUIsa0JBQWtCLENBQUVOLEtBQUtPLFFBQVFDO1lBRWhDLE9BQU9BLFFBQVFaLHFCQUFxQlksUUFBUWI7UUFFN0M7UUFFQWMsb0JBQW9CLENBQUVDLEtBQUtDO1lBRTFCRCxJQUFJdkIsbUJBQW1CLENBQUVFLE9BQU9KO1lBQ2hDLE1BQU0yQixTQUFTdkIsTUFBTWdCLGlCQUFpQixDQUFFcEI7WUFDeEMsSUFBSzJCLFNBQVNoQixtQkFBb0I7Z0JBRWpDVixNQUFNZSxJQUFJLENBQUVoQjtnQkFDWlcsb0JBQW9CZ0I7Z0JBQ3BCZiwwQkFBMEJjO1lBRTNCO1lBRUEsSUFBS0MsU0FBU2xCLGdCQUFpQjtnQkFFOUIsT0FBTztZQUVSLE9BQU87Z0JBRU4sT0FBTztZQUVSO1FBRUQ7SUFFRDtJQUlELElBQUtFLHNCQUFzQkgsVUFBVyxPQUFPO0lBRTdDLE1BQU1vQixrQkFBa0JDLEtBQUtDLElBQUksQ0FBRW5CO0lBRW5DLElBQUssQ0FBRU4sT0FBT0QsS0FBSyxFQUFHQyxPQUFPRCxLQUFLLEdBQUdILE1BQU04QixLQUFLO1NBQzNDMUIsT0FBT0QsS0FBSyxDQUFDWSxJQUFJLENBQUVmO0lBQ3hCSSxPQUFPMkIsUUFBUSxHQUFHSixpQkFDbEJ2QixPQUFPNEIsU0FBUyxHQUFHckI7SUFFbkIsT0FBT1A7QUFFUiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvY2FzdC9jbG9zZXN0UG9pbnRUb1BvaW50LmpzP2VhOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgdGVtcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgdGVtcDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFRvUG9pbnQoXG5cdGJ2aCxcblx0cG9pbnQsXG5cdHRhcmdldCA9IHsgfSxcblx0bWluVGhyZXNob2xkID0gMCxcblx0bWF4VGhyZXNob2xkID0gSW5maW5pdHksXG4pIHtcblxuXHQvLyBlYXJseSBvdXQgaWYgdW5kZXIgbWluVGhyZXNob2xkXG5cdC8vIHNraXAgY2hlY2tpbmcgaWYgb3ZlciBtYXhUaHJlc2hvbGRcblx0Ly8gc2V0IG1pblRocmVzaG9sZCA9IG1heFRocmVzaG9sZCB0byBxdWlja2x5IGNoZWNrIGlmIGEgcG9pbnQgaXMgd2l0aGluIGEgdGhyZXNob2xkXG5cdC8vIHJldHVybnMgSW5maW5pdHkgaWYgbm8gdmFsdWUgZm91bmRcblx0Y29uc3QgbWluVGhyZXNob2xkU3EgPSBtaW5UaHJlc2hvbGQgKiBtaW5UaHJlc2hvbGQ7XG5cdGNvbnN0IG1heFRocmVzaG9sZFNxID0gbWF4VGhyZXNob2xkICogbWF4VGhyZXNob2xkO1xuXHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblx0bGV0IGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gbnVsbDtcblx0YnZoLnNoYXBlY2FzdChcblxuXHRcdHtcblxuXHRcdFx0Ym91bmRzVHJhdmVyc2VPcmRlcjogYm94ID0+IHtcblxuXHRcdFx0XHR0ZW1wLmNvcHkoIHBvaW50ICkuY2xhbXAoIGJveC5taW4sIGJveC5tYXggKTtcblx0XHRcdFx0cmV0dXJuIHRlbXAuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGludGVyc2VjdHNCb3VuZHM6ICggYm94LCBpc0xlYWYsIHNjb3JlICkgPT4ge1xuXG5cdFx0XHRcdHJldHVybiBzY29yZSA8IGNsb3Nlc3REaXN0YW5jZVNxICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkU3E7XG5cblx0XHRcdH0sXG5cblx0XHRcdGludGVyc2VjdHNUcmlhbmdsZTogKCB0cmksIHRyaUluZGV4ICkgPT4ge1xuXG5cdFx0XHRcdHRyaS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGVtcCApO1xuXHRcdFx0XHRjb25zdCBkaXN0U3EgPSBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGVtcCApO1xuXHRcdFx0XHRpZiAoIGRpc3RTcSA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0dGVtcDEuY29weSggdGVtcCApO1xuXHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdFNxO1xuXHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gdHJpSW5kZXg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZGlzdFNxIDwgbWluVGhyZXNob2xkU3EgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdH1cblxuXHQpO1xuXG5cdGlmICggY2xvc2VzdERpc3RhbmNlU3EgPT09IEluZmluaXR5ICkgcmV0dXJuIG51bGw7XG5cblx0Y29uc3QgY2xvc2VzdERpc3RhbmNlID0gTWF0aC5zcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcSApO1xuXG5cdGlmICggISB0YXJnZXQucG9pbnQgKSB0YXJnZXQucG9pbnQgPSB0ZW1wMS5jbG9uZSgpO1xuXHRlbHNlIHRhcmdldC5wb2ludC5jb3B5KCB0ZW1wMSApO1xuXHR0YXJnZXQuZGlzdGFuY2UgPSBjbG9zZXN0RGlzdGFuY2UsXG5cdHRhcmdldC5mYWNlSW5kZXggPSBjbG9zZXN0RGlzdGFuY2VUcmlJbmRleDtcblxuXHRyZXR1cm4gdGFyZ2V0O1xuXG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsInRlbXAiLCJ0ZW1wMSIsImNsb3Nlc3RQb2ludFRvUG9pbnQiLCJidmgiLCJwb2ludCIsInRhcmdldCIsIm1pblRocmVzaG9sZCIsIm1heFRocmVzaG9sZCIsIkluZmluaXR5IiwibWluVGhyZXNob2xkU3EiLCJtYXhUaHJlc2hvbGRTcSIsImNsb3Nlc3REaXN0YW5jZVNxIiwiY2xvc2VzdERpc3RhbmNlVHJpSW5kZXgiLCJzaGFwZWNhc3QiLCJib3VuZHNUcmF2ZXJzZU9yZGVyIiwiYm94IiwiY29weSIsImNsYW1wIiwibWluIiwibWF4IiwiZGlzdGFuY2VUb1NxdWFyZWQiLCJpbnRlcnNlY3RzQm91bmRzIiwiaXNMZWFmIiwic2NvcmUiLCJpbnRlcnNlY3RzVHJpYW5nbGUiLCJ0cmkiLCJ0cmlJbmRleCIsImRpc3RTcSIsImNsb3Nlc3REaXN0YW5jZSIsIk1hdGgiLCJzcXJ0IiwiY2xvbmUiLCJkaXN0YW5jZSIsImZhY2VJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectsGeometry: function() { return /* binding */ intersectsGeometry; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/OrientedBox.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/OrientedBox.js\");\n/* harmony import */ var _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/ExtendedTriangle.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n\n\n\n\n\n\n\n/*****************************************************************/ /* This file is generated from \"intersectsGeometry.template.js\". */ /*****************************************************************/ /* eslint-disable indent */ const boundingBox = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\nconst triangle = /* @__PURE__ */ new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__.OrientedBox();\nconst obb2 = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__.OrientedBox();\nfunction intersectsGeometry(bvh, root, otherGeometry, geometryToBvh) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack.setBuffer(bvh._roots[root]);\n    const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack.clearBuffer();\n    return result;\n}\nfunction _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh) {\n    let cachedObb = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack;\n    let nodeIndex16 = nodeIndex32 * 2;\n    if (cachedObb === null) {\n        if (!otherGeometry.boundingBox) {\n            otherGeometry.computeBoundingBox();\n        }\n        obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n        cachedObb = obb;\n    }\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const thisGeometry = bvh.geometry;\n        const thisIndex = thisGeometry.index;\n        const thisPos = thisGeometry.attributes.position;\n        const index = otherGeometry.index;\n        const pos = otherGeometry.attributes.position;\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(nodeIndex16, uint16Array);\n        // get the inverse of the geometry matrix so we can transform our triangles into the\n        // geometry space we're trying to test. We assume there are fewer triangles being checked\n        // here.\n        invertedMat.copy(geometryToBvh).invert();\n        if (otherGeometry.boundsTree) {\n            // if there's a bounds tree\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, obb2);\n            obb2.matrix.copy(invertedMat);\n            obb2.needsUpdate = true;\n            // TODO: use a triangle iteration function here\n            const res = otherGeometry.boundsTree.shapecast({\n                intersectsBounds: (box)=>obb2.intersectsBox(box),\n                intersectsTriangle: (tri)=>{\n                    tri.a.applyMatrix4(geometryToBvh);\n                    tri.b.applyMatrix4(geometryToBvh);\n                    tri.c.applyMatrix4(geometryToBvh);\n                    tri.needsUpdate = true;\n                    for(let i = offset * 3, l = (count + offset) * 3; i < l; i += 3){\n                        // this triangle needs to be transformed into the current BVH coordinate frame\n                        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle2, i, thisIndex, thisPos);\n                        triangle2.needsUpdate = true;\n                        if (tri.intersectsTriangle(triangle2)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            });\n            return res;\n        } else {\n            // if we're just dealing with raw geometry\n            for(let i = offset * 3, l = (count + offset) * 3; i < l; i += 3){\n                // this triangle needs to be transformed into the current BVH coordinate frame\n                (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle, i, thisIndex, thisPos);\n                triangle.a.applyMatrix4(invertedMat);\n                triangle.b.applyMatrix4(invertedMat);\n                triangle.c.applyMatrix4(invertedMat);\n                triangle.needsUpdate = true;\n                for(let i2 = 0, l2 = index.count; i2 < l2; i2 += 3){\n                    (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle2, i2, index, pos);\n                    triangle2.needsUpdate = true;\n                    if (triangle.intersectsTriangle(triangle2)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    } else {\n        const left = nodeIndex32 + 8;\n        const right = uint32Array[nodeIndex32 + 6];\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(left), float32Array, boundingBox);\n        const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (leftIntersection) return true;\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(right), float32Array, boundingBox);\n        const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (rightIntersection) return true;\n        return false;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L2ludGVyc2VjdHNHZW9tZXRyeS5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBc0M7QUFDa0I7QUFDVTtBQUNIO0FBQ0Q7QUFDNEI7QUFDcEM7QUFFdEQsaUVBQWlFLEdBQ2pFLGlFQUFpRSxHQUNqRSxpRUFBaUUsR0FDakUseUJBQXlCLEdBRXpCLE1BQU1XLGNBQWMsYUFBYSxHQUFHLElBQUlYLHVDQUFJQTtBQUM1QyxNQUFNWSxXQUFXLGFBQWEsR0FBRyxJQUFJVCx1RUFBZ0JBO0FBQ3JELE1BQU1VLFlBQVksYUFBYSxHQUFHLElBQUlWLHVFQUFnQkE7QUFDdEQsTUFBTVcsY0FBYyxhQUFhLEdBQUcsSUFBSWIsMENBQU9BO0FBRS9DLE1BQU1jLE1BQU0sYUFBYSxHQUFHLElBQUliLDZEQUFXQTtBQUMzQyxNQUFNYyxPQUFPLGFBQWEsR0FBRyxJQUFJZCw2REFBV0E7QUFFNUMsU0FBU2UsbUJBQW9CQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsYUFBYSxFQUFFQyxhQUFhO0lBRW5FWCw4REFBV0EsQ0FBQ1ksU0FBUyxDQUFFSixJQUFJSyxNQUFNLENBQUVKLEtBQU07SUFDekMsTUFBTUssU0FBU0Msb0JBQXFCLEdBQUdQLEtBQUtFLGVBQWVDO0lBQzNEWCw4REFBV0EsQ0FBQ2dCLFdBQVc7SUFFdkIsT0FBT0Y7QUFFUjtBQUVBLFNBQVNDLG9CQUFxQkUsV0FBVyxFQUFFVCxHQUFHLEVBQUVFLGFBQWEsRUFBRUMsYUFBYTtRQUFFTyxZQUFBQSxpRUFBWTtJQUV6RixNQUFNLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBR3JCLDhEQUFXQTtJQUM5RCxJQUFJc0IsY0FBY0wsY0FBYztJQUVoQyxJQUFLQyxjQUFjLE1BQU87UUFFekIsSUFBSyxDQUFFUixjQUFjVCxXQUFXLEVBQUc7WUFFbENTLGNBQWNh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LHVFQUFVQSxDQUFFSSw4RUFBbUJBLENBQUUyRCxPQUFRdkMsY0FBY2xCO1FBQ3ZELE1BQU0yRCxtQkFDTDFDLFVBQVU2QixhQUFhLENBQUU5QyxnQkFDekJjLG9CQUFxQjJDLE1BQU1sRCxLQUFLRSxlQUFlQyxlQUFlTztRQUUvRCxJQUFLMEMsa0JBQW1CLE9BQU87UUFFL0JqRSx1RUFBVUEsQ0FBRUksOEVBQW1CQSxDQUFFNEQsUUFBU3hDLGNBQWNsQjtRQUN4RCxNQUFNNEQsb0JBQ0wzQyxVQUFVNkIsYUFBYSxDQUFFOUMsZ0JBQ3pCYyxvQkFBcUI0QyxPQUFPbkQsS0FBS0UsZUFBZUMsZUFBZU87UUFFaEUsSUFBSzJDLG1CQUFvQixPQUFPO1FBRWhDLE9BQU87SUFFUjtBQUVEO0FBRThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L2ludGVyc2VjdHNHZW9tZXRyeS5nZW5lcmF0ZWQuanM/MWQ5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3gzLCBNYXRyaXg0IH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgT3JpZW50ZWRCb3ggfSBmcm9tICcuLi8uLi9tYXRoL09yaWVudGVkQm94LmpzJztcbmltcG9ydCB7IEV4dGVuZGVkVHJpYW5nbGUgfSBmcm9tICcuLi8uLi9tYXRoL0V4dGVuZGVkVHJpYW5nbGUuanMnO1xuaW1wb3J0IHsgc2V0VHJpYW5nbGUgfSBmcm9tICcuLi8uLi91dGlscy9UcmlhbmdsZVV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBhcnJheVRvQm94IH0gZnJvbSAnLi4vLi4vdXRpbHMvQXJyYXlCb3hVdGlsaXRpZXMuanMnO1xuaW1wb3J0IHsgSVNfTEVBRiwgT0ZGU0VULCBDT1VOVCwgQk9VTkRJTkdfREFUQV9JTkRFWCB9IGZyb20gJy4uL3V0aWxzL25vZGVCdWZmZXJVdGlscy5qcyc7XG5pbXBvcnQgeyBCdWZmZXJTdGFjayB9IGZyb20gJy4uL3V0aWxzL0J1ZmZlclN0YWNrLmpzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwiaW50ZXJzZWN0c0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cblxuY29uc3QgYm91bmRpbmdCb3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IEJveDMoKTtcbmNvbnN0IHRyaWFuZ2xlID0gLyogQF9fUFVSRV9fICovIG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5jb25zdCB0cmlhbmdsZTIgPSAvKiBAX19QVVJFX18gKi8gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcbmNvbnN0IGludmVydGVkTWF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXRyaXg0KCk7XG5cbmNvbnN0IG9iYiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcbmNvbnN0IG9iYjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5cbmZ1bmN0aW9uIGludGVyc2VjdHNHZW9tZXRyeSggYnZoLCByb290LCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoICkge1xuXG5cdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdGNvbnN0IHJlc3VsdCA9IF9pbnRlcnNlY3RzR2VvbWV0cnkoIDAsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCApO1xuXHRCdWZmZXJTdGFjay5jbGVhckJ1ZmZlcigpO1xuXG5cdHJldHVybiByZXN1bHQ7XG5cbn1cblxuZnVuY3Rpb24gX2ludGVyc2VjdHNHZW9tZXRyeSggbm9kZUluZGV4MzIsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiID0gbnVsbCApIHtcblxuXHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXG5cdGlmICggY2FjaGVkT2JiID09PSBudWxsICkge1xuXG5cdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdG90aGVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR9XG5cblx0XHRvYmIuc2V0KCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1pbiwgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5tYXgsIGdlb21ldHJ5VG9CdmggKTtcblx0XHRjYWNoZWRPYmIgPSBvYmI7XG5cblx0fVxuXG5cdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdGNvbnN0IHRoaXNHZW9tZXRyeSA9IGJ2aC5nZW9tZXRyeTtcblx0XHRjb25zdCB0aGlzSW5kZXggPSB0aGlzR2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgdGhpc1BvcyA9IHRoaXNHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBvdGhlckdlb21ldHJ5LmluZGV4O1xuXHRcdGNvbnN0IHBvcyA9IG90aGVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblx0XHQvLyBnZXQgdGhlIGludmVyc2Ugb2YgdGhlIGdlb21ldHJ5IG1hdHJpeCBzbyB3ZSBjYW4gdHJhbnNmb3JtIG91ciB0cmlhbmdsZXMgaW50byB0aGVcblx0XHQvLyBnZW9tZXRyeSBzcGFjZSB3ZSdyZSB0cnlpbmcgdG8gdGVzdC4gV2UgYXNzdW1lIHRoZXJlIGFyZSBmZXdlciB0cmlhbmdsZXMgYmVpbmcgY2hlY2tlZFxuXHRcdC8vIGhlcmUuXG5cdFx0aW52ZXJ0ZWRNYXQuY29weSggZ2VvbWV0cnlUb0J2aCApLmludmVydCgpO1xuXG5cdFx0aWYgKCBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdC8vIGlmIHRoZXJlJ3MgYSBib3VuZHMgdHJlZVxuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbm9kZUluZGV4MzIgKSwgZmxvYXQzMkFycmF5LCBvYmIyICk7XG5cdFx0XHRvYmIyLm1hdHJpeC5jb3B5KCBpbnZlcnRlZE1hdCApO1xuXHRcdFx0b2JiMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdC8vIFRPRE86IHVzZSBhIHRyaWFuZ2xlIGl0ZXJhdGlvbiBmdW5jdGlvbiBoZXJlXG5cdFx0XHRjb25zdCByZXMgPSBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUuc2hhcGVjYXN0KCB7XG5cblx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogYm94ID0+IG9iYjIuaW50ZXJzZWN0c0JveCggYm94ICksXG5cblx0XHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlOiB0cmkgPT4ge1xuXG5cdFx0XHRcdFx0dHJpLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0dHJpLmIuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0dHJpLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0dHJpLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQgKiAzLCBsID0gKCBjb3VudCArIG9mZnNldCApICogMzsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gdGhpcyB0cmlhbmdsZSBuZWVkcyB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIHRoZSBjdXJyZW50IEJWSCBjb29yZGluYXRlIGZyYW1lXG5cdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCBpLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAoIHRyaS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiApICkge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGlmIHdlJ3JlIGp1c3QgZGVhbGluZyB3aXRoIHJhdyBnZW9tZXRyeVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDMsIGwgPSAoIGNvdW50ICsgb2Zmc2V0ICkgKiAzOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdC8vIHRoaXMgdHJpYW5nbGUgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgY3VycmVudCBCVkggY29vcmRpbmF0ZSBmcmFtZVxuXHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIGksIHRoaXNJbmRleCwgdGhpc1BvcyApO1xuXG5cblx0XHRcdFx0dHJpYW5nbGUuYS5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdHRyaWFuZ2xlLmIuYXBwbHlNYXRyaXg0KCBpbnZlcnRlZE1hdCApO1xuXHRcdFx0XHR0cmlhbmdsZS5jLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQgKTtcblx0XHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpMiA9IDAsIGwyID0gaW5kZXguY291bnQ7IGkyIDwgbDI7IGkyICs9IDMgKSB7XG5cblx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCBpMiwgaW5kZXgsIHBvcyApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAoIHRyaWFuZ2xlLmludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUyICkgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9XG5cblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc3QgbGVmdCA9IG5vZGVJbmRleDMyICsgODtcblx0XHRjb25zdCByaWdodCA9IHVpbnQzMkFycmF5WyBub2RlSW5kZXgzMiArIDYgXTtcblxuXHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGxlZnQgKSwgZmxvYXQzMkFycmF5LCBib3VuZGluZ0JveCApO1xuXHRcdGNvbnN0IGxlZnRJbnRlcnNlY3Rpb24gPVxuXHRcdFx0Y2FjaGVkT2JiLmludGVyc2VjdHNCb3goIGJvdW5kaW5nQm94ICkgJiZcblx0XHRcdF9pbnRlcnNlY3RzR2VvbWV0cnkoIGxlZnQsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiICk7XG5cblx0XHRpZiAoIGxlZnRJbnRlcnNlY3Rpb24gKSByZXR1cm4gdHJ1ZTtcblxuXHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIHJpZ2h0ICksIGZsb2F0MzJBcnJheSwgYm91bmRpbmdCb3ggKTtcblx0XHRjb25zdCByaWdodEludGVyc2VjdGlvbiA9XG5cdFx0XHRjYWNoZWRPYmIuaW50ZXJzZWN0c0JveCggYm91bmRpbmdCb3ggKSAmJlxuXHRcdFx0X2ludGVyc2VjdHNHZW9tZXRyeSggcmlnaHQsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiICk7XG5cblx0XHRpZiAoIHJpZ2h0SW50ZXJzZWN0aW9uICkgcmV0dXJuIHRydWU7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IGludGVyc2VjdHNHZW9tZXRyeSB9O1xuIl0sIm5hbWVzIjpbIkJveDMiLCJNYXRyaXg0IiwiT3JpZW50ZWRCb3giLCJFeHRlbmRlZFRyaWFuZ2xlIiwic2V0VHJpYW5nbGUiLCJhcnJheVRvQm94IiwiSVNfTEVBRiIsIk9GRlNFVCIsIkNPVU5UIiwiQk9VTkRJTkdfREFUQV9JTkRFWCIsIkJ1ZmZlclN0YWNrIiwiYm91bmRpbmdCb3giLCJ0cmlhbmdsZSIsInRyaWFuZ2xlMiIsImludmVydGVkTWF0Iiwib2JiIiwib2JiMiIsImludGVyc2VjdHNHZW9tZXRyeSIsImJ2aCIsInJvb3QiLCJvdGhlckdlb21ldHJ5IiwiZ2VvbWV0cnlUb0J2aCIsInNldEJ1ZmZlciIsIl9yb290cyIsInJlc3VsdCIsIl9pbnRlcnNlY3RzR2VvbWV0cnkiLCJjbGVhckJ1ZmZlciIsIm5vZGVJbmRleDMyIiwiY2FjaGVkT2JiIiwiZmxvYXQzMkFycmF5IiwidWludDE2QXJyYXkiLCJ1aW50MzJBcnJheSIsIm5vZGVJbmRleDE2IiwiY29tcHV0ZUJvdW5kaW5nQm94Iiwic2V0IiwibWluIiwibWF4IiwiaXNMZWFmIiwidGhpc0dlb21ldHJ5IiwiZ2VvbWV0cnkiLCJ0aGlzSW5kZXgiLCJpbmRleCIsInRoaXNQb3MiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJwb3MiLCJvZmZzZXQiLCJjb3VudCIsImNvcHkiLCJpbnZlcnQiLCJib3VuZHNUcmVlIiwibWF0cml4IiwibmVlZHNVcGRhdGUiLCJyZXMiLCJzaGFwZWNhc3QiLCJpbnRlcnNlY3RzQm91bmRzIiwiYm94IiwiaW50ZXJzZWN0c0JveCIsImludGVyc2VjdHNUcmlhbmdsZSIsInRyaSIsImEiLCJhcHBseU1hdHJpeDQiLCJiIiwiYyIsImkiLCJsIiwiaTIiLCJsMiIsImxlZnQiLCJyaWdodCIsImxlZnRJbnRlcnNlY3Rpb24iLCJyaWdodEludGVyc2VjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectsGeometry_indirect: function() { return /* binding */ intersectsGeometry_indirect; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/OrientedBox.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/OrientedBox.js\");\n/* harmony import */ var _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/ExtendedTriangle.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n\n\n\n\n\n\n\n/*****************************************************************/ /* This file is generated from \"intersectsGeometry.template.js\". */ /*****************************************************************/ /* eslint-disable indent */ const boundingBox = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\nconst triangle = /* @__PURE__ */ new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__.OrientedBox();\nconst obb2 = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__.OrientedBox();\nfunction intersectsGeometry_indirect(bvh, root, otherGeometry, geometryToBvh) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack.setBuffer(bvh._roots[root]);\n    const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack.clearBuffer();\n    return result;\n}\nfunction _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh) {\n    let cachedObb = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack;\n    let nodeIndex16 = nodeIndex32 * 2;\n    if (cachedObb === null) {\n        if (!otherGeometry.boundingBox) {\n            otherGeometry.computeBoundingBox();\n        }\n        obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n        cachedObb = obb;\n    }\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const thisGeometry = bvh.geometry;\n        const thisIndex = thisGeometry.index;\n        const thisPos = thisGeometry.attributes.position;\n        const index = otherGeometry.index;\n        const pos = otherGeometry.attributes.position;\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(nodeIndex16, uint16Array);\n        // get the inverse of the geometry matrix so we can transform our triangles into the\n        // geometry space we're trying to test. We assume there are fewer triangles being checked\n        // here.\n        invertedMat.copy(geometryToBvh).invert();\n        if (otherGeometry.boundsTree) {\n            // if there's a bounds tree\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, obb2);\n            obb2.matrix.copy(invertedMat);\n            obb2.needsUpdate = true;\n            // TODO: use a triangle iteration function here\n            const res = otherGeometry.boundsTree.shapecast({\n                intersectsBounds: (box)=>obb2.intersectsBox(box),\n                intersectsTriangle: (tri)=>{\n                    tri.a.applyMatrix4(geometryToBvh);\n                    tri.b.applyMatrix4(geometryToBvh);\n                    tri.c.applyMatrix4(geometryToBvh);\n                    tri.needsUpdate = true;\n                    for(let i = offset, l = count + offset; i < l; i++){\n                        // this triangle needs to be transformed into the current BVH coordinate frame\n                        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle2, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);\n                        triangle2.needsUpdate = true;\n                        if (tri.intersectsTriangle(triangle2)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            });\n            return res;\n        } else {\n            // if we're just dealing with raw geometry\n            for(let i = offset, l = count + offset; i < l; i++){\n                // this triangle needs to be transformed into the current BVH coordinate frame\n                const ti = bvh.resolveTriangleIndex(i);\n                (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle, 3 * ti, thisIndex, thisPos);\n                triangle.a.applyMatrix4(invertedMat);\n                triangle.b.applyMatrix4(invertedMat);\n                triangle.c.applyMatrix4(invertedMat);\n                triangle.needsUpdate = true;\n                for(let i2 = 0, l2 = index.count; i2 < l2; i2 += 3){\n                    (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle2, i2, index, pos);\n                    triangle2.needsUpdate = true;\n                    if (triangle.intersectsTriangle(triangle2)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    } else {\n        const left = nodeIndex32 + 8;\n        const right = uint32Array[nodeIndex32 + 6];\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(left), float32Array, boundingBox);\n        const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (leftIntersection) return true;\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(right), float32Array, boundingBox);\n        const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (rightIntersection) return true;\n        return false;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L2ludGVyc2VjdHNHZW9tZXRyeV9pbmRpcmVjdC5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBc0M7QUFDa0I7QUFDVTtBQUNIO0FBQ0Q7QUFDNEI7QUFDcEM7QUFFdEQsaUVBQWlFLEdBQ2pFLGlFQUFpRSxHQUNqRSxpRUFBaUUsR0FDakUseUJBQXlCLEdBRXpCLE1BQU1XLGNBQWMsYUFBYSxHQUFHLElBQUlYLHVDQUFJQTtBQUM1QyxNQUFNWSxXQUFXLGFBQWEsR0FBRyxJQUFJVCx1RUFBZ0JBO0FBQ3JELE1BQU1VLFlBQVksYUFBYSxHQUFHLElBQUlWLHVFQUFnQkE7QUFDdEQsTUFBTVcsY0FBYyxhQUFhLEdBQUcsSUFBSWIsMENBQU9BO0FBRS9DLE1BQU1jLE1BQU0sYUFBYSxHQUFHLElBQUliLDZEQUFXQTtBQUMzQyxNQUFNYyxPQUFPLGFBQWEsR0FBRyxJQUFJZCw2REFBV0E7QUFFNUMsU0FBU2UsNEJBQTZCQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsYUFBYSxFQUFFQyxhQUFhO0lBRTVFWCw4REFBV0EsQ0FBQ1ksU0FBUyxDQUFFSixJQUFJSyxNQUFNLENBQUVKLEtBQU07SUFDekMsTUFBTUssU0FBU0Msb0JBQXFCLEdBQUdQLEtBQUtFLGVBQWVDO0lBQzNEWCw4REFBV0EsQ0FBQ2dCLFdBQVc7SUFFdkIsT0FBT0Y7QUFFUjtBQUVBLFNBQVNDLG9CQUFxQkUsV0FBVyxFQUFFVCxHQUFHLEVBQUVFLGFBQWEsRUFBRUMsYUFBYTtRQUFFTyxZQUFBQSxpRUFBWTtJQUV6RixNQUFNLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBR3JCLDhEQUFXQTtJQUM5RCxJQUFJc0IsY0FBY0wsY0FBYztJQUVoQyxJQUFLQyxjQUFjLE1BQU87UUFFekIsSUFBSyxDQUFFUixjQUFjVCxXQUFXLEVBQUc7WUFF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LFdBQVcsQ0FBRUosY0FBYyxFQUFHO1FBRTVDdEIsdUVBQVVBLENBQUVJLDhFQUFtQkEsQ0FBRTZELE9BQVF6QyxjQUFjbEI7UUFDdkQsTUFBTTZELG1CQUNMNUMsVUFBVTZCLGFBQWEsQ0FBRTlDLGdCQUN6QmMsb0JBQXFCNkMsTUFBTXBELEtBQUtFLGVBQWVDLGVBQWVPO1FBRS9ELElBQUs0QyxrQkFBbUIsT0FBTztRQUUvQm5FLHVFQUFVQSxDQUFFSSw4RUFBbUJBLENBQUU4RCxRQUFTMUMsY0FBY2xCO1FBQ3hELE1BQU04RCxvQkFDTDdDLFVBQVU2QixhQUFhLENBQUU5QyxnQkFDekJjLG9CQUFxQjhDLE9BQU9yRCxLQUFLRSxlQUFlQyxlQUFlTztRQUVoRSxJQUFLNkMsbUJBQW9CLE9BQU87UUFFaEMsT0FBTztJQUVSO0FBRUQ7QUFFdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0LmdlbmVyYXRlZC5qcz9hMzA0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJveDMsIE1hdHJpeDQgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBPcmllbnRlZEJveCB9IGZyb20gJy4uLy4uL21hdGgvT3JpZW50ZWRCb3guanMnO1xuaW1wb3J0IHsgRXh0ZW5kZWRUcmlhbmdsZSB9IGZyb20gJy4uLy4uL21hdGgvRXh0ZW5kZWRUcmlhbmdsZS5qcyc7XG5pbXBvcnQgeyBzZXRUcmlhbmdsZSB9IGZyb20gJy4uLy4uL3V0aWxzL1RyaWFuZ2xlVXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IGFycmF5VG9Cb3ggfSBmcm9tICcuLi8uLi91dGlscy9BcnJheUJveFV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBJU19MRUFGLCBPRkZTRVQsIENPVU5ULCBCT1VORElOR19EQVRBX0lOREVYIH0gZnJvbSAnLi4vdXRpbHMvbm9kZUJ1ZmZlclV0aWxzLmpzJztcbmltcG9ydCB7IEJ1ZmZlclN0YWNrIH0gZnJvbSAnLi4vdXRpbHMvQnVmZmVyU3RhY2suanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJpbnRlcnNlY3RzR2VvbWV0cnkudGVtcGxhdGUuanNcIi4gKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuXG5jb25zdCBib3VuZGluZ0JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQm94MygpO1xuY29uc3QgdHJpYW5nbGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcbmNvbnN0IHRyaWFuZ2xlMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRXh0ZW5kZWRUcmlhbmdsZSgpO1xuY29uc3QgaW52ZXJ0ZWRNYXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hdHJpeDQoKTtcblxuY29uc3Qgb2JiID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuY29uc3Qgb2JiMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblxuZnVuY3Rpb24gaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0KCBidmgsIHJvb3QsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmggKSB7XG5cblx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblx0Y29uc3QgcmVzdWx0ID0gX2ludGVyc2VjdHNHZW9tZXRyeSggMCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoICk7XG5cdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufVxuXG5mdW5jdGlvbiBfaW50ZXJzZWN0c0dlb21ldHJ5KCBub2RlSW5kZXgzMiwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgPSBudWxsICkge1xuXG5cdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0aWYgKCBjYWNoZWRPYmIgPT09IG51bGwgKSB7XG5cblx0XHRpZiAoICEgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveCApIHtcblxuXHRcdFx0b3RoZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdH1cblxuXHRcdG9iYi5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdGNhY2hlZE9iYiA9IG9iYjtcblxuXHR9XG5cblx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdGlmICggaXNMZWFmICkge1xuXG5cdFx0Y29uc3QgdGhpc0dlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IHRoaXNJbmRleCA9IHRoaXNHZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCB0aGlzUG9zID0gdGhpc0dlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRjb25zdCBpbmRleCA9IG90aGVyR2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgcG9zID0gb3RoZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdC8vIGdldCB0aGUgaW52ZXJzZSBvZiB0aGUgZ2VvbWV0cnkgbWF0cml4IHNvIHdlIGNhbiB0cmFuc2Zvcm0gb3VyIHRyaWFuZ2xlcyBpbnRvIHRoZVxuXHRcdC8vIGdlb21ldHJ5IHNwYWNlIHdlJ3JlIHRyeWluZyB0byB0ZXN0LiBXZSBhc3N1bWUgdGhlcmUgYXJlIGZld2VyIHRyaWFuZ2xlcyBiZWluZyBjaGVja2VkXG5cdFx0Ly8gaGVyZS5cblx0XHRpbnZlcnRlZE1hdC5jb3B5KCBnZW9tZXRyeVRvQnZoICkuaW52ZXJ0KCk7XG5cblx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0Ly8gaWYgdGhlcmUncyBhIGJvdW5kcyB0cmVlXG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBub2RlSW5kZXgzMiApLCBmbG9hdDMyQXJyYXksIG9iYjIgKTtcblx0XHRcdG9iYjIubWF0cml4LmNvcHkoIGludmVydGVkTWF0ICk7XG5cdFx0XHRvYmIyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0Ly8gVE9ETzogdXNlIGEgdHJpYW5nbGUgaXRlcmF0aW9uIGZ1bmN0aW9uIGhlcmVcblx0XHRcdGNvbnN0IHJlcyA9IG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZS5zaGFwZWNhc3QoIHtcblxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiBib3ggPT4gb2JiMi5pbnRlcnNlY3RzQm94KCBib3ggKSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IHRyaSA9PiB7XG5cblx0XHRcdFx0XHR0cmkuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHR0cmkuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHR0cmkuYy5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHR0cmkubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBjb3VudCArIG9mZnNldDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHRoaXMgdHJpYW5nbGUgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgY3VycmVudCBCVkggY29vcmRpbmF0ZSBmcmFtZVxuXHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAoIHRyaS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiApICkge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGlmIHdlJ3JlIGp1c3QgZGVhbGluZyB3aXRoIHJhdyBnZW9tZXRyeVxuXHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBjb3VudCArIG9mZnNldDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly8gdGhpcyB0cmlhbmdsZSBuZWVkcyB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIHRoZSBjdXJyZW50IEJWSCBjb29yZGluYXRlIGZyYW1lXG5cdFx0XHRcdGNvbnN0IHRpID0gYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICk7XG5cdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIHRpLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblxuXG5cdFx0XHRcdHRyaWFuZ2xlLmEuYXBwbHlNYXRyaXg0KCBpbnZlcnRlZE1hdCApO1xuXHRcdFx0XHR0cmlhbmdsZS5iLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQgKTtcblx0XHRcdFx0dHJpYW5nbGUuYy5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwLCBsMiA9IGluZGV4LmNvdW50OyBpMiA8IGwyOyBpMiArPSAzICkge1xuXG5cdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgaTIsIGluZGV4LCBwb3MgKTtcblx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKCB0cmlhbmdsZS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiApICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRjb25zdCBsZWZ0ID0gbm9kZUluZGV4MzIgKyA4O1xuXHRcdGNvbnN0IHJpZ2h0ID0gdWludDMyQXJyYXlbIG5vZGVJbmRleDMyICsgNiBdO1xuXG5cdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbGVmdCApLCBmbG9hdDMyQXJyYXksIGJvdW5kaW5nQm94ICk7XG5cdFx0Y29uc3QgbGVmdEludGVyc2VjdGlvbiA9XG5cdFx0XHRjYWNoZWRPYmIuaW50ZXJzZWN0c0JveCggYm91bmRpbmdCb3ggKSAmJlxuXHRcdFx0X2ludGVyc2VjdHNHZW9tZXRyeSggbGVmdCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgKTtcblxuXHRcdGlmICggbGVmdEludGVyc2VjdGlvbiApIHJldHVybiB0cnVlO1xuXG5cdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggcmlnaHQgKSwgZmxvYXQzMkFycmF5LCBib3VuZGluZ0JveCApO1xuXHRcdGNvbnN0IHJpZ2h0SW50ZXJzZWN0aW9uID1cblx0XHRcdGNhY2hlZE9iYi5pbnRlcnNlY3RzQm94KCBib3VuZGluZ0JveCApICYmXG5cdFx0XHRfaW50ZXJzZWN0c0dlb21ldHJ5KCByaWdodCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgKTtcblxuXHRcdGlmICggcmlnaHRJbnRlcnNlY3Rpb24gKSByZXR1cm4gdHJ1ZTtcblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0IH07XG4iXSwibmFtZXMiOlsiQm94MyIsIk1hdHJpeDQiLCJPcmllbnRlZEJveCIsIkV4dGVuZGVkVHJpYW5nbGUiLCJzZXRUcmlhbmdsZSIsImFycmF5VG9Cb3giLCJJU19MRUFGIiwiT0ZGU0VUIiwiQ09VTlQiLCJCT1VORElOR19EQVRBX0lOREVYIiwiQnVmZmVyU3RhY2siLCJib3VuZGluZ0JveCIsInRyaWFuZ2xlIiwidHJpYW5nbGUyIiwiaW52ZXJ0ZWRNYXQiLCJvYmIiLCJvYmIyIiwiaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0IiwiYnZoIiwicm9vdCIsIm90aGVyR2VvbWV0cnkiLCJnZW9tZXRyeVRvQnZoIiwic2V0QnVmZmVyIiwiX3Jvb3RzIiwicmVzdWx0IiwiX2ludGVyc2VjdHNHZW9tZXRyeSIsImNsZWFyQnVmZmVyIiwibm9kZUluZGV4MzIiLCJjYWNoZWRPYmIiLCJmbG9hdDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsInVpbnQzMkFycmF5Iiwibm9kZUluZGV4MTYiLCJjb21wdXRlQm91bmRpbmdCb3giLCJzZXQiLCJtaW4iLCJtYXgiLCJpc0xlYWYiLCJ0aGlzR2VvbWV0cnkiLCJnZW9tZXRyeSIsInRoaXNJbmRleCIsImluZGV4IiwidGhpc1BvcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsInBvcyIsIm9mZnNldCIsImNvdW50IiwiY29weSIsImludmVydCIsImJvdW5kc1RyZWUiLCJtYXRyaXgiLCJuZWVkc1VwZGF0ZSIsInJlcyIsInNoYXBlY2FzdCIsImludGVyc2VjdHNCb3VuZHMiLCJib3giLCJpbnRlcnNlY3RzQm94IiwiaW50ZXJzZWN0c1RyaWFuZ2xlIiwidHJpIiwiYSIsImFwcGx5TWF0cml4NCIsImIiLCJjIiwiaSIsImwiLCJyZXNvbHZlVHJpYW5nbGVJbmRleCIsInRpIiwiaTIiLCJsMiIsImxlZnQiLCJyaWdodCIsImxlZnRJbnRlcnNlY3Rpb24iLCJyaWdodEludGVyc2VjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js":
/*!************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raycast: function() { return /* binding */ raycast; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/intersectUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n/* harmony import */ var _utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/iterationUtils.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js\");\n\n\n\n\n\n\n/******************************************************/ /* This file is generated from \"raycast.template.js\". */ /******************************************************/ const _boxIntersection = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction raycast(bvh, root, side, ray, intersects) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.setBuffer(bvh._roots[root]);\n    _raycast(0, bvh, side, ray, intersects);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.clearBuffer();\n}\nfunction _raycast(nodeIndex32, bvh, side, ray, intersects) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack;\n    const nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.COUNT)(nodeIndex16, uint16Array);\n        (0,_utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_3__.intersectTris)(bvh, side, ray, offset, count, intersects);\n    } else {\n        const leftIndex = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n        if ((0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(leftIndex, float32Array, ray, _boxIntersection)) {\n            _raycast(leftIndex, bvh, side, ray, intersects);\n        }\n        const rightIndex = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n        if ((0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(rightIndex, float32Array, ray, _boxIntersection)) {\n            _raycast(rightIndex, bvh, side, ray, intersects);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3JheWNhc3QuZ2VuZXJhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFnQztBQUMwQjtBQUNrQztBQUN0QztBQUNlO0FBQ2Q7QUFFdkQsc0RBQXNELEdBQ3RELHNEQUFzRCxHQUN0RCxzREFBc0QsR0FFdEQsTUFBTVMsbUJBQW1CLGFBQWEsR0FBRyxJQUFJVCwwQ0FBT0E7QUFDcEQsU0FBU1UsUUFBU0MsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxVQUFVO0lBRWpEUiw4REFBV0EsQ0FBQ1MsU0FBUyxDQUFFTCxJQUFJTSxNQUFNLENBQUVMLEtBQU07SUFDekNNLFNBQVUsR0FBR1AsS0FBS0UsTUFBTUMsS0FBS0M7SUFDN0JSLDhEQUFXQSxDQUFDWSxXQUFXO0FBRXhCO0FBRUEsU0FBU0QsU0FBVUUsV0FBVyxFQUFFVCxHQUFHLEVBQUVFLElBQUksRUFBRUMsR0FBRyxFQUFFQyxVQUFVO0lBRXpELE1BQU0sRUFBRU0sWUFBWSxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRSxHQUFHaEIsOERBQVdBO0lBQzlELE1BQU1pQixjQUFjSixjQUFjO0lBQ2xDLE1BQU1LLFNBQVN2QixrRUFBT0EsQ0FBRXNCLGFBQWFGO0lBQ3JDLElBQUtHLFFBQVM7UUFFYixNQUFNQyxTQUFTdkIsaUVBQU1BLENBQUVpQixhQUFhRztRQUNwQyxNQUFNSSxRQUFRdkIsZ0VBQUtBLENBQUVvQixhQUFhRjtRQUdsQ2QsaUZBQWFBLENBQUVHLEtBQUtFLE1BQU1DLEtBQUtZLFFBQVFDLE9BQU9aO0lBRy9DLE9BQU87UUFFTixNQUFNYSxZQUFZdkIsb0VBQVNBLENBQUVlO1FBQzdCLElBQUtuQixzRUFBWUEsQ0FBRTJCLFdBQVdQLGNBQWNQLEtBQUtMLG1CQUFxQjtZQUVyRVMsU0FBVVUsV0FBV2pCLEtBQUtFLE1BQU1DLEtBQUtDO1FBRXRDO1FBRUEsTUFBTWMsYUFBYXZCLHFFQUFVQSxDQUFFYyxhQUFhRztRQUM1QyxJQUFLdEIsc0VBQVlBLENBQUU0QixZQUFZUixjQUFjUCxLQUFLTCxtQkFBcUI7WUFFdEVTLFNBQVVXLFlBQVlsQixLQUFLRSxNQUFNQyxLQUFLQztRQUV2QztJQUVEO0FBRUQ7QUFFbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvcmF5Y2FzdC5nZW5lcmF0ZWQuanM/MDhhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgaW50ZXJzZWN0UmF5IH0gZnJvbSAnLi4vdXRpbHMvaW50ZXJzZWN0VXRpbHMuanMnO1xuaW1wb3J0IHsgSVNfTEVBRiwgT0ZGU0VULCBDT1VOVCwgTEVGVF9OT0RFLCBSSUdIVF9OT0RFIH0gZnJvbSAnLi4vdXRpbHMvbm9kZUJ1ZmZlclV0aWxzLmpzJztcbmltcG9ydCB7IEJ1ZmZlclN0YWNrIH0gZnJvbSAnLi4vdXRpbHMvQnVmZmVyU3RhY2suanMnO1xuaW1wb3J0IHsgaW50ZXJzZWN0VHJpcyB9IGZyb20gJy4uL3V0aWxzL2l0ZXJhdGlvblV0aWxzLmdlbmVyYXRlZC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2l0ZXJhdGlvblV0aWxzX2luZGlyZWN0LmdlbmVyYXRlZC5qcyc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyYXljYXN0LnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jb25zdCBfYm94SW50ZXJzZWN0aW9uID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5mdW5jdGlvbiByYXljYXN0KCBidmgsIHJvb3QsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApIHtcblxuXHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXHRfcmF5Y2FzdCggMCwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMgKTtcblx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblxufVxuXG5mdW5jdGlvbiBfcmF5Y2FzdCggbm9kZUluZGV4MzIsIGJ2aCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzICkge1xuXG5cdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRjb25zdCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdGlmICggaXNMZWFmICkge1xuXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXG5cdFx0aW50ZXJzZWN0VHJpcyggYnZoLCBzaWRlLCByYXksIG9mZnNldCwgY291bnQsIGludGVyc2VjdHMgKTtcblxuXG5cdH0gZWxzZSB7XG5cblx0XHRjb25zdCBsZWZ0SW5kZXggPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0aWYgKCBpbnRlcnNlY3RSYXkoIGxlZnRJbmRleCwgZmxvYXQzMkFycmF5LCByYXksIF9ib3hJbnRlcnNlY3Rpb24gKSApIHtcblxuXHRcdFx0X3JheWNhc3QoIGxlZnRJbmRleCwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHJpZ2h0SW5kZXggPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRpZiAoIGludGVyc2VjdFJheSggcmlnaHRJbmRleCwgZmxvYXQzMkFycmF5LCByYXksIF9ib3hJbnRlcnNlY3Rpb24gKSApIHtcblxuXHRcdFx0X3JheWNhc3QoIHJpZ2h0SW5kZXgsIGJ2aCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IHJheWNhc3QgfTtcbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiaW50ZXJzZWN0UmF5IiwiSVNfTEVBRiIsIk9GRlNFVCIsIkNPVU5UIiwiTEVGVF9OT0RFIiwiUklHSFRfTk9ERSIsIkJ1ZmZlclN0YWNrIiwiaW50ZXJzZWN0VHJpcyIsIl9ib3hJbnRlcnNlY3Rpb24iLCJyYXljYXN0IiwiYnZoIiwicm9vdCIsInNpZGUiLCJyYXkiLCJpbnRlcnNlY3RzIiwic2V0QnVmZmVyIiwiX3Jvb3RzIiwiX3JheWNhc3QiLCJjbGVhckJ1ZmZlciIsIm5vZGVJbmRleDMyIiwiZmxvYXQzMkFycmF5IiwidWludDE2QXJyYXkiLCJ1aW50MzJBcnJheSIsIm5vZGVJbmRleDE2IiwiaXNMZWFmIiwib2Zmc2V0IiwiY291bnQiLCJsZWZ0SW5kZXgiLCJyaWdodEluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raycastFirst: function() { return /* binding */ raycastFirst; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n/* harmony import */ var _utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/intersectUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js\");\n/* harmony import */ var _utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/iterationUtils.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js\");\n\n\n\n\n\n\n/***********************************************************/ /* This file is generated from \"raycastFirst.template.js\". */ /***********************************************************/ const _boxIntersection = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _xyzFields = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nfunction raycastFirst(bvh, root, side, ray) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.setBuffer(bvh._roots[root]);\n    const result = _raycastFirst(0, bvh, side, ray);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.clearBuffer();\n    return result;\n}\nfunction _raycastFirst(nodeIndex32, bvh, side, ray) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack;\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.COUNT)(nodeIndex16, uint16Array);\n        return (0,_utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_3__.intersectClosestTri)(bvh, side, ray, offset, count);\n    } else {\n        // consider the position of the split plane with respect to the oncoming ray; whichever direction\n        // the ray is coming from, look for an intersection among that side of the tree first\n        const splitAxis = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.SPLIT_AXIS)(nodeIndex32, uint32Array);\n        const xyzAxis = _xyzFields[splitAxis];\n        const rayDir = ray.direction[xyzAxis];\n        const leftToRight = rayDir >= 0;\n        // c1 is the child to check first\n        let c1, c2;\n        if (leftToRight) {\n            c1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n            c2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n        } else {\n            c1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n            c2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n        }\n        const c1Intersection = (0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(c1, float32Array, ray, _boxIntersection);\n        const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray) : null;\n        // if we got an intersection in the first node and it's closer than the second node's bounding\n        // box, we don't need to consider the second node because it couldn't possibly be a better result\n        if (c1Result) {\n            // check if the point is within the second bounds\n            // \"point\" is in the local frame of the bvh\n            const point = c1Result.point[xyzAxis];\n            const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n            if (isOutside) {\n                return c1Result;\n            }\n        }\n        // either there was no intersection in the first node, or there could still be a closer\n        // intersection in the second, so check the second node and then take the better of the two\n        const c2Intersection = (0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(c2, float32Array, ray, _boxIntersection);\n        const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray) : null;\n        if (c1Result && c2Result) {\n            return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n        } else {\n            return c1Result || c2Result || null;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3JheWNhc3RGaXJzdC5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWdDO0FBQ3dFO0FBQ2xEO0FBQ0k7QUFDaUI7QUFDcEI7QUFFdkQsMkRBQTJELEdBQzNELDJEQUEyRCxHQUMzRCwyREFBMkQsR0FDM0QsTUFBTVUsbUJBQW1CLGFBQWEsR0FBRyxJQUFJViwwQ0FBT0E7QUFDcEQsTUFBTVcsYUFBYTtJQUFFO0lBQUs7SUFBSztDQUFLO0FBQ3BDLFNBQVNDLGFBQWNDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLEdBQUc7SUFFMUNULDhEQUFXQSxDQUFDVSxTQUFTLENBQUVKLElBQUlLLE1BQU0sQ0FBRUosS0FBTTtJQUN6QyxNQUFNSyxTQUFTQyxjQUFlLEdBQUdQLEtBQUtFLE1BQU1DO0lBQzVDVCw4REFBV0EsQ0FBQ2MsV0FBVztJQUV2QixPQUFPRjtBQUVSO0FBRUEsU0FBU0MsY0FBZUUsV0FBVyxFQUFFVCxHQUFHLEVBQUVFLElBQUksRUFBRUMsR0FBRztJQUVsRCxNQUFNLEVBQUVPLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBR2xCLDhEQUFXQTtJQUM5RCxJQUFJbUIsY0FBY0osY0FBYztJQUVoQyxNQUFNSyxTQUFTMUIsa0VBQU9BLENBQUV5QixhQUFhRjtJQUNyQyxJQUFLRyxRQUFTO1FBRWIsTUFBTUMsU0FBUzFCLGlFQUFNQSxDQUFFb0IsYUFBYUc7UUFDcEMsTUFBTUksUUFBUTFCLGdFQUFLQSxDQUFFdUIsYUFBYUY7UUFHbEMsT0FBT2YsdUZBQW1CQSxDQUFFSSxLQUFLRSxNQUFNQyxLQUFLWSxRQUFRQztJQUdyRCxPQUFPO1FBRU4saUdBQWlHO1FBQ2pHLHFGQUFxRjtRQUNyRixNQUFNQyxZQUFZMUIscUVBQVVBLENBQUVrQixhQUFhRztRQUMzQyxNQUFNTSxVQUFVcEIsVUFBVSxDQUFFbUIsVUFBVztRQUN2QyxNQUFNRSxTQUFTaEIsSUFBSWlCLFNBQVMsQ0FBRUYsUUFBUztRQUN2QyxNQUFNRyxjQUFjRixVQUFVO1FBRTlCLGlDQUFpQztRQUNqQyxJQUFJRyxJQUFJQztRQUNSLElBQUtGLGFBQWM7WUFFbEJDLEtBQUs5QixvRUFBU0EsQ0FBRWlCO1lBQ2hCYyxLQUFLOUIscUVBQVVBLENBQUVnQixhQUFhRztRQUUvQixPQUFPO1lBRU5VLEtBQUs3QixxRUFBVUEsQ0FBRWdCLGFBQWFHO1lBQzlCVyxLQUFLL0Isb0VBQVNBLENBQUVpQjtRQUVqQjtRQUVBLE1BQU1lLGlCQUFpQjdCLHNFQUFZQSxDQUFFMkIsSUFBSVosY0FBY1AsS0FBS047UUFDNUQsTUFBTTRCLFdBQVdELGlCQUFpQmpCLGNBQWVlLElBQUl0QixLQUFLRSxNQUFNQyxPQUFRO1FBRXhFLDhGQUE4RjtRQUM5RixpR0FBaUc7UUFDakcsSUFBS3NCLFVBQVc7WUFFZixpREFBaUQ7WUFDakQsMkNBQTJDO1lBQzNDLE1BQU1DLFFBQVFELFNBQVNDLEtBQUssQ0FBRVIsUUFBUztZQUN2QyxNQUFNUyxZQUFZTixjQUNqQkssU0FBU2hCLFlBQVksQ0FBRWEsS0FBS04sVUFBVyxHQUN2Q1MsU0FBU2hCLFlBQVksQ0FBRWEsS0FBS04sWUFBWSxFQUFHLEVBQUUsb0JBQW9CO1lBRWxFLElBQUtVLFdBQVk7Z0JBRWhCLE9BQU9GO1lBRVI7UUFFRDtRQUVBLHVGQUF1RjtRQUN2RiwyRkFBMkY7UUFDM0YsTUFBTUcsaUJBQWlCakMsc0VBQVlBLENBQUU0QixJQUFJYixjQUFjUCxLQUFLTjtRQUM1RCxNQUFNZ0MsV0FBV0QsaUJBQWlCckIsY0FBZWdCLElBQUl2QixLQUFLRSxNQUFNQyxPQUFRO1FBRXhFLElBQUtzQixZQUFZSSxVQUFXO1lBRTNCLE9BQU9KLFNBQVNLLFFBQVEsSUFBSUQsU0FBU0MsUUFBUSxHQUFHTCxXQUFXSTtRQUU1RCxPQUFPO1lBRU4sT0FBT0osWUFBWUksWUFBWTtRQUVoQztJQUVEO0FBRUQ7QUFFd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvcmF5Y2FzdEZpcnN0LmdlbmVyYXRlZC5qcz9kNWZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBJU19MRUFGLCBPRkZTRVQsIENPVU5ULCBTUExJVF9BWElTLCBMRUZUX05PREUsIFJJR0hUX05PREUgfSBmcm9tICcuLi91dGlscy9ub2RlQnVmZmVyVXRpbHMuanMnO1xuaW1wb3J0IHsgQnVmZmVyU3RhY2sgfSBmcm9tICcuLi91dGlscy9CdWZmZXJTdGFjay5qcyc7XG5pbXBvcnQgeyBpbnRlcnNlY3RSYXkgfSBmcm9tICcuLi91dGlscy9pbnRlcnNlY3RVdGlscy5qcyc7XG5pbXBvcnQgeyBpbnRlcnNlY3RDbG9zZXN0VHJpIH0gZnJvbSAnLi4vdXRpbHMvaXRlcmF0aW9uVXRpbHMuZ2VuZXJhdGVkLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvaXRlcmF0aW9uVXRpbHNfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwicmF5Y2FzdEZpcnN0LnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5jb25zdCBfYm94SW50ZXJzZWN0aW9uID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfeHl6RmllbGRzID0gWyAneCcsICd5JywgJ3onIF07XG5mdW5jdGlvbiByYXljYXN0Rmlyc3QoIGJ2aCwgcm9vdCwgc2lkZSwgcmF5ICkge1xuXG5cdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdGNvbnN0IHJlc3VsdCA9IF9yYXljYXN0Rmlyc3QoIDAsIGJ2aCwgc2lkZSwgcmF5ICk7XG5cdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufVxuXG5mdW5jdGlvbiBfcmF5Y2FzdEZpcnN0KCBub2RlSW5kZXgzMiwgYnZoLCBzaWRlLCByYXkgKSB7XG5cblx0Y29uc3QgeyBmbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXG5cblx0XHRyZXR1cm4gaW50ZXJzZWN0Q2xvc2VzdFRyaSggYnZoLCBzaWRlLCByYXksIG9mZnNldCwgY291bnQgKTtcblxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBjb25zaWRlciB0aGUgcG9zaXRpb24gb2YgdGhlIHNwbGl0IHBsYW5lIHdpdGggcmVzcGVjdCB0byB0aGUgb25jb21pbmcgcmF5OyB3aGljaGV2ZXIgZGlyZWN0aW9uXG5cdFx0Ly8gdGhlIHJheSBpcyBjb21pbmcgZnJvbSwgbG9vayBmb3IgYW4gaW50ZXJzZWN0aW9uIGFtb25nIHRoYXQgc2lkZSBvZiB0aGUgdHJlZSBmaXJzdFxuXHRcdGNvbnN0IHNwbGl0QXhpcyA9IFNQTElUX0FYSVMoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdGNvbnN0IHh5ekF4aXMgPSBfeHl6RmllbGRzWyBzcGxpdEF4aXMgXTtcblx0XHRjb25zdCByYXlEaXIgPSByYXkuZGlyZWN0aW9uWyB4eXpBeGlzIF07XG5cdFx0Y29uc3QgbGVmdFRvUmlnaHQgPSByYXlEaXIgPj0gMDtcblxuXHRcdC8vIGMxIGlzIHRoZSBjaGlsZCB0byBjaGVjayBmaXJzdFxuXHRcdGxldCBjMSwgYzI7XG5cdFx0aWYgKCBsZWZ0VG9SaWdodCApIHtcblxuXHRcdFx0YzEgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRjMiA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YzEgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGMyID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYzFJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMxLCBmbG9hdDMyQXJyYXksIHJheSwgX2JveEludGVyc2VjdGlvbiApO1xuXHRcdGNvbnN0IGMxUmVzdWx0ID0gYzFJbnRlcnNlY3Rpb24gPyBfcmF5Y2FzdEZpcnN0KCBjMSwgYnZoLCBzaWRlLCByYXkgKSA6IG51bGw7XG5cblx0XHQvLyBpZiB3ZSBnb3QgYW4gaW50ZXJzZWN0aW9uIGluIHRoZSBmaXJzdCBub2RlIGFuZCBpdCdzIGNsb3NlciB0aGFuIHRoZSBzZWNvbmQgbm9kZSdzIGJvdW5kaW5nXG5cdFx0Ly8gYm94LCB3ZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBzZWNvbmQgbm9kZSBiZWNhdXNlIGl0IGNvdWxkbid0IHBvc3NpYmx5IGJlIGEgYmV0dGVyIHJlc3VsdFxuXHRcdGlmICggYzFSZXN1bHQgKSB7XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIHNlY29uZCBib3VuZHNcblx0XHRcdC8vIFwicG9pbnRcIiBpcyBpbiB0aGUgbG9jYWwgZnJhbWUgb2YgdGhlIGJ2aFxuXHRcdFx0Y29uc3QgcG9pbnQgPSBjMVJlc3VsdC5wb2ludFsgeHl6QXhpcyBdO1xuXHRcdFx0Y29uc3QgaXNPdXRzaWRlID0gbGVmdFRvUmlnaHQgP1xuXHRcdFx0XHRwb2ludCA8PSBmbG9hdDMyQXJyYXlbIGMyICsgc3BsaXRBeGlzIF0gOiAvLyBtaW4gYm91bmRpbmcgZGF0YVxuXHRcdFx0XHRwb2ludCA+PSBmbG9hdDMyQXJyYXlbIGMyICsgc3BsaXRBeGlzICsgMyBdOyAvLyBtYXggYm91bmRpbmcgZGF0YVxuXG5cdFx0XHRpZiAoIGlzT3V0c2lkZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGVpdGhlciB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uIGluIHRoZSBmaXJzdCBub2RlLCBvciB0aGVyZSBjb3VsZCBzdGlsbCBiZSBhIGNsb3NlclxuXHRcdC8vIGludGVyc2VjdGlvbiBpbiB0aGUgc2Vjb25kLCBzbyBjaGVjayB0aGUgc2Vjb25kIG5vZGUgYW5kIHRoZW4gdGFrZSB0aGUgYmV0dGVyIG9mIHRoZSB0d29cblx0XHRjb25zdCBjMkludGVyc2VjdGlvbiA9IGludGVyc2VjdFJheSggYzIsIGZsb2F0MzJBcnJheSwgcmF5LCBfYm94SW50ZXJzZWN0aW9uICk7XG5cdFx0Y29uc3QgYzJSZXN1bHQgPSBjMkludGVyc2VjdGlvbiA/IF9yYXljYXN0Rmlyc3QoIGMyLCBidmgsIHNpZGUsIHJheSApIDogbnVsbDtcblxuXHRcdGlmICggYzFSZXN1bHQgJiYgYzJSZXN1bHQgKSB7XG5cblx0XHRcdHJldHVybiBjMVJlc3VsdC5kaXN0YW5jZSA8PSBjMlJlc3VsdC5kaXN0YW5jZSA/IGMxUmVzdWx0IDogYzJSZXN1bHQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gYzFSZXN1bHQgfHwgYzJSZXN1bHQgfHwgbnVsbDtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgcmF5Y2FzdEZpcnN0IH07XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIklTX0xFQUYiLCJPRkZTRVQiLCJDT1VOVCIsIlNQTElUX0FYSVMiLCJMRUZUX05PREUiLCJSSUdIVF9OT0RFIiwiQnVmZmVyU3RhY2siLCJpbnRlcnNlY3RSYXkiLCJpbnRlcnNlY3RDbG9zZXN0VHJpIiwiX2JveEludGVyc2VjdGlvbiIsIl94eXpGaWVsZHMiLCJyYXljYXN0Rmlyc3QiLCJidmgiLCJyb290Iiwic2lkZSIsInJheSIsInNldEJ1ZmZlciIsIl9yb290cyIsInJlc3VsdCIsIl9yYXljYXN0Rmlyc3QiLCJjbGVhckJ1ZmZlciIsIm5vZGVJbmRleDMyIiwiZmxvYXQzMkFycmF5IiwidWludDE2QXJyYXkiLCJ1aW50MzJBcnJheSIsIm5vZGVJbmRleDE2IiwiaXNMZWFmIiwib2Zmc2V0IiwiY291bnQiLCJzcGxpdEF4aXMiLCJ4eXpBeGlzIiwicmF5RGlyIiwiZGlyZWN0aW9uIiwibGVmdFRvUmlnaHQiLCJjMSIsImMyIiwiYzFJbnRlcnNlY3Rpb24iLCJjMVJlc3VsdCIsInBvaW50IiwiaXNPdXRzaWRlIiwiYzJJbnRlcnNlY3Rpb24iLCJjMlJlc3VsdCIsImRpc3RhbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raycastFirst_indirect: function() { return /* binding */ raycastFirst_indirect; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n/* harmony import */ var _utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/intersectUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js\");\n/* harmony import */ var _utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/iterationUtils_indirect.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js\");\n\n\n\n\n\n\n/***********************************************************/ /* This file is generated from \"raycastFirst.template.js\". */ /***********************************************************/ const _boxIntersection = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _xyzFields = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nfunction raycastFirst_indirect(bvh, root, side, ray) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.setBuffer(bvh._roots[root]);\n    const result = _raycastFirst(0, bvh, side, ray);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.clearBuffer();\n    return result;\n}\nfunction _raycastFirst(nodeIndex32, bvh, side, ray) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack;\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.COUNT)(nodeIndex16, uint16Array);\n        return (0,_utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_3__.intersectClosestTri_indirect)(bvh, side, ray, offset, count);\n    } else {\n        // consider the position of the split plane with respect to the oncoming ray; whichever direction\n        // the ray is coming from, look for an intersection among that side of the tree first\n        const splitAxis = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.SPLIT_AXIS)(nodeIndex32, uint32Array);\n        const xyzAxis = _xyzFields[splitAxis];\n        const rayDir = ray.direction[xyzAxis];\n        const leftToRight = rayDir >= 0;\n        // c1 is the child to check first\n        let c1, c2;\n        if (leftToRight) {\n            c1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n            c2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n        } else {\n            c1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n            c2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n        }\n        const c1Intersection = (0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(c1, float32Array, ray, _boxIntersection);\n        const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray) : null;\n        // if we got an intersection in the first node and it's closer than the second node's bounding\n        // box, we don't need to consider the second node because it couldn't possibly be a better result\n        if (c1Result) {\n            // check if the point is within the second bounds\n            // \"point\" is in the local frame of the bvh\n            const point = c1Result.point[xyzAxis];\n            const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n            if (isOutside) {\n                return c1Result;\n            }\n        }\n        // either there was no intersection in the first node, or there could still be a closer\n        // intersection in the second, so check the second node and then take the better of the two\n        const c2Intersection = (0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(c2, float32Array, ray, _boxIntersection);\n        const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray) : null;\n        if (c1Result && c2Result) {\n            return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n        } else {\n            return c1Result || c2Result || null;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3JheWNhc3RGaXJzdF9pbmRpcmVjdC5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWdDO0FBQ3dFO0FBQ2xEO0FBQ0k7QUFDWjtBQUMrQztBQUU3RiwyREFBMkQsR0FDM0QsMkRBQTJELEdBQzNELDJEQUEyRCxHQUMzRCxNQUFNVSxtQkFBbUIsYUFBYSxHQUFHLElBQUlWLDBDQUFPQTtBQUNwRCxNQUFNVyxhQUFhO0lBQUU7SUFBSztJQUFLO0NBQUs7QUFDcEMsU0FBU0Msc0JBQXVCQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxHQUFHO0lBRW5EVCw4REFBV0EsQ0FBQ1UsU0FBUyxDQUFFSixJQUFJSyxNQUFNLENBQUVKLEtBQU07SUFDekMsTUFBTUssU0FBU0MsY0FBZSxHQUFHUCxLQUFLRSxNQUFNQztJQUM1Q1QsOERBQVdBLENBQUNjLFdBQVc7SUFFdkIsT0FBT0Y7QUFFUjtBQUVBLFNBQVNDLGNBQWVFLFdBQVcsRUFBRVQsR0FBRyxFQUFFRSxJQUFJLEVBQUVDLEdBQUc7SUFFbEQsTUFBTSxFQUFFTyxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFLEdBQUdsQiw4REFBV0E7SUFDOUQsSUFBSW1CLGNBQWNKLGNBQWM7SUFFaEMsTUFBTUssU0FBUzFCLGtFQUFPQSxDQUFFeUIsYUFBYUY7SUFDckMsSUFBS0csUUFBUztRQUViLE1BQU1DLFNBQVMxQixpRUFBTUEsQ0FBRW9CLGFBQWFHO1FBQ3BDLE1BQU1JLFFBQVExQixnRUFBS0EsQ0FBRXVCLGFBQWFGO1FBRWxDLE9BQU9mLHlHQUE0QkEsQ0FBRUksS0FBS0UsTUFBTUMsS0FBS1ksUUFBUUM7SUFHOUQsT0FBTztRQUVOLGlHQUFpRztRQUNqRyxxRkFBcUY7UUFDckYsTUFBTUMsWUFBWTFCLHFFQUFVQSxDQUFFa0IsYUFBYUc7UUFDM0MsTUFBTU0sVUFBVXBCLFVBQVUsQ0FBRW1CLFVBQVc7UUFDdkMsTUFBTUUsU0FBU2hCLElBQUlpQixTQUFTLENBQUVGLFFBQVM7UUFDdkMsTUFBTUcsY0FBY0YsVUFBVTtRQUU5QixpQ0FBaUM7UUFDakMsSUFBSUcsSUFBSUM7UUFDUixJQUFLRixhQUFjO1lBRWxCQyxLQUFLOUIsb0VBQVNBLENBQUVpQjtZQUNoQmMsS0FBSzlCLHFFQUFVQSxDQUFFZ0IsYUFBYUc7UUFFL0IsT0FBTztZQUVOVSxLQUFLN0IscUVBQVVBLENBQUVnQixhQUFhRztZQUM5QlcsS0FBSy9CLG9FQUFTQSxDQUFFaUI7UUFFakI7UUFFQSxNQUFNZSxpQkFBaUI3QixzRUFBWUEsQ0FBRTJCLElBQUlaLGNBQWNQLEtBQUtOO1FBQzVELE1BQU00QixXQUFXRCxpQkFBaUJqQixjQUFlZSxJQUFJdEIsS0FBS0UsTUFBTUMsT0FBUTtRQUV4RSw4RkFBOEY7UUFDOUYsaUdBQWlHO1FBQ2pHLElBQUtzQixVQUFXO1lBRWYsaURBQWlEO1lBQ2pELDJDQUEyQztZQUMzQyxNQUFNQyxRQUFRRCxTQUFTQyxLQUFLLENBQUVSLFFBQVM7WUFDdkMsTUFBTVMsWUFBWU4sY0FDakJLLFNBQVNoQixZQUFZLENBQUVhLEtBQUtOLFVBQVcsR0FDdkNTLFNBQVNoQixZQUFZLENBQUVhLEtBQUtOLFlBQVksRUFBRyxFQUFFLG9CQUFvQjtZQUVsRSxJQUFLVSxXQUFZO2dCQUVoQixPQUFPRjtZQUVSO1FBRUQ7UUFFQSx1RkFBdUY7UUFDdkYsMkZBQTJGO1FBQzNGLE1BQU1HLGlCQUFpQmpDLHNFQUFZQSxDQUFFNEIsSUFBSWIsY0FBY1AsS0FBS047UUFDNUQsTUFBTWdDLFdBQVdELGlCQUFpQnJCLGNBQWVnQixJQUFJdkIsS0FBS0UsTUFBTUMsT0FBUTtRQUV4RSxJQUFLc0IsWUFBWUksVUFBVztZQUUzQixPQUFPSixTQUFTSyxRQUFRLElBQUlELFNBQVNDLFFBQVEsR0FBR0wsV0FBV0k7UUFFNUQsT0FBTztZQUVOLE9BQU9KLFlBQVlJLFlBQVk7UUFFaEM7SUFFRDtBQUVEO0FBRWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3JheWNhc3RGaXJzdF9pbmRpcmVjdC5nZW5lcmF0ZWQuanM/OWRmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgSVNfTEVBRiwgT0ZGU0VULCBDT1VOVCwgU1BMSVRfQVhJUywgTEVGVF9OT0RFLCBSSUdIVF9OT0RFIH0gZnJvbSAnLi4vdXRpbHMvbm9kZUJ1ZmZlclV0aWxzLmpzJztcbmltcG9ydCB7IEJ1ZmZlclN0YWNrIH0gZnJvbSAnLi4vdXRpbHMvQnVmZmVyU3RhY2suanMnO1xuaW1wb3J0IHsgaW50ZXJzZWN0UmF5IH0gZnJvbSAnLi4vdXRpbHMvaW50ZXJzZWN0VXRpbHMuanMnO1xuaW1wb3J0ICcuLi91dGlscy9pdGVyYXRpb25VdGlscy5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgaW50ZXJzZWN0Q2xvc2VzdFRyaV9pbmRpcmVjdCB9IGZyb20gJy4uL3V0aWxzL2l0ZXJhdGlvblV0aWxzX2luZGlyZWN0LmdlbmVyYXRlZC5qcyc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInJheWNhc3RGaXJzdC50ZW1wbGF0ZS5qc1wiLiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuY29uc3QgX2JveEludGVyc2VjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3h5ekZpZWxkcyA9IFsgJ3gnLCAneScsICd6JyBdO1xuZnVuY3Rpb24gcmF5Y2FzdEZpcnN0X2luZGlyZWN0KCBidmgsIHJvb3QsIHNpZGUsIHJheSApIHtcblxuXHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXHRjb25zdCByZXN1bHQgPSBfcmF5Y2FzdEZpcnN0KCAwLCBidmgsIHNpZGUsIHJheSApO1xuXHRCdWZmZXJTdGFjay5jbGVhckJ1ZmZlcigpO1xuXG5cdHJldHVybiByZXN1bHQ7XG5cbn1cblxuZnVuY3Rpb24gX3JheWNhc3RGaXJzdCggbm9kZUluZGV4MzIsIGJ2aCwgc2lkZSwgcmF5ICkge1xuXG5cdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdGlmICggaXNMZWFmICkge1xuXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdHJldHVybiBpbnRlcnNlY3RDbG9zZXN0VHJpX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCApO1xuXG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIGNvbnNpZGVyIHRoZSBwb3NpdGlvbiBvZiB0aGUgc3BsaXQgcGxhbmUgd2l0aCByZXNwZWN0IHRvIHRoZSBvbmNvbWluZyByYXk7IHdoaWNoZXZlciBkaXJlY3Rpb25cblx0XHQvLyB0aGUgcmF5IGlzIGNvbWluZyBmcm9tLCBsb29rIGZvciBhbiBpbnRlcnNlY3Rpb24gYW1vbmcgdGhhdCBzaWRlIG9mIHRoZSB0cmVlIGZpcnN0XG5cdFx0Y29uc3Qgc3BsaXRBeGlzID0gU1BMSVRfQVhJUyggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0Y29uc3QgeHl6QXhpcyA9IF94eXpGaWVsZHNbIHNwbGl0QXhpcyBdO1xuXHRcdGNvbnN0IHJheURpciA9IHJheS5kaXJlY3Rpb25bIHh5ekF4aXMgXTtcblx0XHRjb25zdCBsZWZ0VG9SaWdodCA9IHJheURpciA+PSAwO1xuXG5cdFx0Ly8gYzEgaXMgdGhlIGNoaWxkIHRvIGNoZWNrIGZpcnN0XG5cdFx0bGV0IGMxLCBjMjtcblx0XHRpZiAoIGxlZnRUb1JpZ2h0ICkge1xuXG5cdFx0XHRjMSA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblx0XHRcdGMyID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjMSA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0YzIgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBjMUludGVyc2VjdGlvbiA9IGludGVyc2VjdFJheSggYzEsIGZsb2F0MzJBcnJheSwgcmF5LCBfYm94SW50ZXJzZWN0aW9uICk7XG5cdFx0Y29uc3QgYzFSZXN1bHQgPSBjMUludGVyc2VjdGlvbiA/IF9yYXljYXN0Rmlyc3QoIGMxLCBidmgsIHNpZGUsIHJheSApIDogbnVsbDtcblxuXHRcdC8vIGlmIHdlIGdvdCBhbiBpbnRlcnNlY3Rpb24gaW4gdGhlIGZpcnN0IG5vZGUgYW5kIGl0J3MgY2xvc2VyIHRoYW4gdGhlIHNlY29uZCBub2RlJ3MgYm91bmRpbmdcblx0XHQvLyBib3gsIHdlIGRvbid0IG5lZWQgdG8gY29uc2lkZXIgdGhlIHNlY29uZCBub2RlIGJlY2F1c2UgaXQgY291bGRuJ3QgcG9zc2libHkgYmUgYSBiZXR0ZXIgcmVzdWx0XG5cdFx0aWYgKCBjMVJlc3VsdCApIHtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgc2Vjb25kIGJvdW5kc1xuXHRcdFx0Ly8gXCJwb2ludFwiIGlzIGluIHRoZSBsb2NhbCBmcmFtZSBvZiB0aGUgYnZoXG5cdFx0XHRjb25zdCBwb2ludCA9IGMxUmVzdWx0LnBvaW50WyB4eXpBeGlzIF07XG5cdFx0XHRjb25zdCBpc091dHNpZGUgPSBsZWZ0VG9SaWdodCA/XG5cdFx0XHRcdHBvaW50IDw9IGZsb2F0MzJBcnJheVsgYzIgKyBzcGxpdEF4aXMgXSA6IC8vIG1pbiBib3VuZGluZyBkYXRhXG5cdFx0XHRcdHBvaW50ID49IGZsb2F0MzJBcnJheVsgYzIgKyBzcGxpdEF4aXMgKyAzIF07IC8vIG1heCBib3VuZGluZyBkYXRhXG5cblx0XHRcdGlmICggaXNPdXRzaWRlICkge1xuXG5cdFx0XHRcdHJldHVybiBjMVJlc3VsdDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZWl0aGVyIHRoZXJlIHdhcyBubyBpbnRlcnNlY3Rpb24gaW4gdGhlIGZpcnN0IG5vZGUsIG9yIHRoZXJlIGNvdWxkIHN0aWxsIGJlIGEgY2xvc2VyXG5cdFx0Ly8gaW50ZXJzZWN0aW9uIGluIHRoZSBzZWNvbmQsIHNvIGNoZWNrIHRoZSBzZWNvbmQgbm9kZSBhbmQgdGhlbiB0YWtlIHRoZSBiZXR0ZXIgb2YgdGhlIHR3b1xuXHRcdGNvbnN0IGMySW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmF5KCBjMiwgZmxvYXQzMkFycmF5LCByYXksIF9ib3hJbnRlcnNlY3Rpb24gKTtcblx0XHRjb25zdCBjMlJlc3VsdCA9IGMySW50ZXJzZWN0aW9uID8gX3JheWNhc3RGaXJzdCggYzIsIGJ2aCwgc2lkZSwgcmF5ICkgOiBudWxsO1xuXG5cdFx0aWYgKCBjMVJlc3VsdCAmJiBjMlJlc3VsdCApIHtcblxuXHRcdFx0cmV0dXJuIGMxUmVzdWx0LmRpc3RhbmNlIDw9IGMyUmVzdWx0LmRpc3RhbmNlID8gYzFSZXN1bHQgOiBjMlJlc3VsdDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBjMVJlc3VsdCB8fCBjMlJlc3VsdCB8fCBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyByYXljYXN0Rmlyc3RfaW5kaXJlY3QgfTtcbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiSVNfTEVBRiIsIk9GRlNFVCIsIkNPVU5UIiwiU1BMSVRfQVhJUyIsIkxFRlRfTk9ERSIsIlJJR0hUX05PREUiLCJCdWZmZXJTdGFjayIsImludGVyc2VjdFJheSIsImludGVyc2VjdENsb3Nlc3RUcmlfaW5kaXJlY3QiLCJfYm94SW50ZXJzZWN0aW9uIiwiX3h5ekZpZWxkcyIsInJheWNhc3RGaXJzdF9pbmRpcmVjdCIsImJ2aCIsInJvb3QiLCJzaWRlIiwicmF5Iiwic2V0QnVmZmVyIiwiX3Jvb3RzIiwicmVzdWx0IiwiX3JheWNhc3RGaXJzdCIsImNsZWFyQnVmZmVyIiwibm9kZUluZGV4MzIiLCJmbG9hdDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsInVpbnQzMkFycmF5Iiwibm9kZUluZGV4MTYiLCJpc0xlYWYiLCJvZmZzZXQiLCJjb3VudCIsInNwbGl0QXhpcyIsInh5ekF4aXMiLCJyYXlEaXIiLCJkaXJlY3Rpb24iLCJsZWZ0VG9SaWdodCIsImMxIiwiYzIiLCJjMUludGVyc2VjdGlvbiIsImMxUmVzdWx0IiwicG9pbnQiLCJpc091dHNpZGUiLCJjMkludGVyc2VjdGlvbiIsImMyUmVzdWx0IiwiZGlzdGFuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raycast_indirect: function() { return /* binding */ raycast_indirect; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/intersectUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n/* harmony import */ var _utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/iterationUtils_indirect.generated.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js\");\n\n\n\n\n\n\n/******************************************************/ /* This file is generated from \"raycast.template.js\". */ /******************************************************/ const _boxIntersection = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction raycast_indirect(bvh, root, side, ray, intersects) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.setBuffer(bvh._roots[root]);\n    _raycast(0, bvh, side, ray, intersects);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.clearBuffer();\n}\nfunction _raycast(nodeIndex32, bvh, side, ray, intersects) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack;\n    const nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.COUNT)(nodeIndex16, uint16Array);\n        (0,_utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_3__.intersectTris_indirect)(bvh, side, ray, offset, count, intersects);\n    } else {\n        const leftIndex = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n        if ((0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(leftIndex, float32Array, ray, _boxIntersection)) {\n            _raycast(leftIndex, bvh, side, ray, intersects);\n        }\n        const rightIndex = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n        if ((0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(rightIndex, float32Array, ray, _boxIntersection)) {\n            _raycast(rightIndex, bvh, side, ray, intersects);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3JheWNhc3RfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFnQztBQUMwQjtBQUNrQztBQUN0QztBQUNSO0FBQ3lDO0FBRXZGLHNEQUFzRCxHQUN0RCxzREFBc0QsR0FDdEQsc0RBQXNELEdBRXRELE1BQU1TLG1CQUFtQixhQUFhLEdBQUcsSUFBSVQsMENBQU9BO0FBQ3BELFNBQVNVLGlCQUFrQkMsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxVQUFVO0lBRTFEUiw4REFBV0EsQ0FBQ1MsU0FBUyxDQUFFTCxJQUFJTSxNQUFNLENBQUVMLEtBQU07SUFDekNNLFNBQVUsR0FBR1AsS0FBS0UsTUFBTUMsS0FBS0M7SUFDN0JSLDhEQUFXQSxDQUFDWSxXQUFXO0FBRXhCO0FBRUEsU0FBU0QsU0FBVUUsV0FBVyxFQUFFVCxHQUFHLEVBQUVFLElBQUksRUFBRUMsR0FBRyxFQUFFQyxVQUFVO0lBRXpELE1BQU0sRUFBRU0sWUFBWSxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRSxHQUFHaEIsOERBQVdBO0lBQzlELE1BQU1pQixjQUFjSixjQUFjO0lBQ2xDLE1BQU1LLFNBQVN2QixrRUFBT0EsQ0FBRXNCLGFBQWFGO0lBQ3JDLElBQUtHLFFBQVM7UUFFYixNQUFNQyxTQUFTdkIsaUVBQU1BLENBQUVpQixhQUFhRztRQUNwQyxNQUFNSSxRQUFRdkIsZ0VBQUtBLENBQUVvQixhQUFhRjtRQUVsQ2QsbUdBQXNCQSxDQUFFRyxLQUFLRSxNQUFNQyxLQUFLWSxRQUFRQyxPQUFPWjtJQUd4RCxPQUFPO1FBRU4sTUFBTWEsWUFBWXZCLG9FQUFTQSxDQUFFZTtRQUM3QixJQUFLbkIsc0VBQVlBLENBQUUyQixXQUFXUCxjQUFjUCxLQUFLTCxtQkFBcUI7WUFFckVTLFNBQVVVLFdBQVdqQixLQUFLRSxNQUFNQyxLQUFLQztRQUV0QztRQUVBLE1BQU1jLGFBQWF2QixxRUFBVUEsQ0FBRWMsYUFBYUc7UUFDNUMsSUFBS3RCLHNFQUFZQSxDQUFFNEIsWUFBWVIsY0FBY1AsS0FBS0wsbUJBQXFCO1lBRXRFUyxTQUFVVyxZQUFZbEIsS0FBS0UsTUFBTUMsS0FBS0M7UUFFdkM7SUFFRDtBQUVEO0FBRTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3JheWNhc3RfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzP2MxYTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGludGVyc2VjdFJheSB9IGZyb20gJy4uL3V0aWxzL2ludGVyc2VjdFV0aWxzLmpzJztcbmltcG9ydCB7IElTX0xFQUYsIE9GRlNFVCwgQ09VTlQsIExFRlRfTk9ERSwgUklHSFRfTk9ERSB9IGZyb20gJy4uL3V0aWxzL25vZGVCdWZmZXJVdGlscy5qcyc7XG5pbXBvcnQgeyBCdWZmZXJTdGFjayB9IGZyb20gJy4uL3V0aWxzL0J1ZmZlclN0YWNrLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvaXRlcmF0aW9uVXRpbHMuZ2VuZXJhdGVkLmpzJztcbmltcG9ydCB7IGludGVyc2VjdFRyaXNfaW5kaXJlY3QgfSBmcm9tICcuLi91dGlscy9pdGVyYXRpb25VdGlsc19pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwicmF5Y2FzdC50ZW1wbGF0ZS5qc1wiLiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY29uc3QgX2JveEludGVyc2VjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuZnVuY3Rpb24gcmF5Y2FzdF9pbmRpcmVjdCggYnZoLCByb290LCBzaWRlLCByYXksIGludGVyc2VjdHMgKSB7XG5cblx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblx0X3JheWNhc3QoIDAsIGJ2aCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzICk7XG5cdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cbn1cblxuZnVuY3Rpb24gX3JheWNhc3QoIG5vZGVJbmRleDMyLCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApIHtcblxuXHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0Y29uc3Qgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblx0XHRpbnRlcnNlY3RUcmlzX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgaW50ZXJzZWN0cyApO1xuXG5cblx0fSBlbHNlIHtcblxuXHRcdGNvbnN0IGxlZnRJbmRleCA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblx0XHRpZiAoIGludGVyc2VjdFJheSggbGVmdEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgX2JveEludGVyc2VjdGlvbiApICkge1xuXG5cdFx0XHRfcmF5Y2FzdCggbGVmdEluZGV4LCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcmlnaHRJbmRleCA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdGlmICggaW50ZXJzZWN0UmF5KCByaWdodEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgX2JveEludGVyc2VjdGlvbiApICkge1xuXG5cdFx0XHRfcmF5Y2FzdCggcmlnaHRJbmRleCwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgcmF5Y2FzdF9pbmRpcmVjdCB9O1xuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJpbnRlcnNlY3RSYXkiLCJJU19MRUFGIiwiT0ZGU0VUIiwiQ09VTlQiLCJMRUZUX05PREUiLCJSSUdIVF9OT0RFIiwiQnVmZmVyU3RhY2siLCJpbnRlcnNlY3RUcmlzX2luZGlyZWN0IiwiX2JveEludGVyc2VjdGlvbiIsInJheWNhc3RfaW5kaXJlY3QiLCJidmgiLCJyb290Iiwic2lkZSIsInJheSIsImludGVyc2VjdHMiLCJzZXRCdWZmZXIiLCJfcm9vdHMiLCJfcmF5Y2FzdCIsImNsZWFyQnVmZmVyIiwibm9kZUluZGV4MzIiLCJmbG9hdDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsInVpbnQzMkFycmF5Iiwibm9kZUluZGV4MTYiLCJpc0xlYWYiLCJvZmZzZXQiLCJjb3VudCIsImxlZnRJbmRleCIsInJpZ2h0SW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/refit.generated.js":
/*!**********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/refit.generated.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   refit: function() { return /* binding */ refit; }\n/* harmony export */ });\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Constants.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/Constants.js\");\n\n/****************************************************/ /* This file is generated from \"refit.template.js\". */ /****************************************************/ function refit(bvh) {\n    let nodeIndices = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n    }\n    const geometry = bvh.geometry;\n    const indexArr = geometry.index ? geometry.index.array : null;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = bvh._roots;\n    for(let i = 0, l = roots.length; i < l; i++){\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset) {\n        let force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const node16Index = node32Index * 2;\n        const isLeaf = uint16Array[node16Index + 15] === _Constants_js__WEBPACK_IMPORTED_MODULE_0__.IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n            const offset = uint32Array[node32Index + 6];\n            const count = uint16Array[node16Index + 14];\n            let minx = Infinity;\n            let miny = Infinity;\n            let minz = Infinity;\n            let maxx = -Infinity;\n            let maxy = -Infinity;\n            let maxz = -Infinity;\n            for(let i = 3 * offset, l = 3 * (offset + count); i < l; i++){\n                let index = indexArr[i];\n                const x = posAttr.getX(index);\n                const y = posAttr.getY(index);\n                const z = posAttr.getZ(index);\n                if (x < minx) minx = x;\n                if (x > maxx) maxx = x;\n                if (y < miny) miny = y;\n                if (y > maxy) maxy = y;\n                if (z < minz) minz = z;\n                if (z > maxz) maxz = z;\n            }\n            if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n                float32Array[node32Index + 0] = minx;\n                float32Array[node32Index + 1] = miny;\n                float32Array[node32Index + 2] = minz;\n                float32Array[node32Index + 3] = maxx;\n                float32Array[node32Index + 4] = maxy;\n                float32Array[node32Index + 5] = maxz;\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            const left = node32Index + 8;\n            const right = uint32Array[node32Index + 6];\n            // the identifying node indices provided by the shapecast function include offsets of all\n            // root buffers to guarantee they're unique between roots so offset left and right indices here.\n            const offsetLeft = left + byteOffset;\n            const offsetRight = right + byteOffset;\n            let forceChildren = force;\n            let includesLeft = false;\n            let includesRight = false;\n            if (nodeIndices) {\n                // if we see that neither the left or right child are included in the set that need to be updated\n                // then we assume that all children need to be updated.\n                if (!forceChildren) {\n                    includesLeft = nodeIndices.has(offsetLeft);\n                    includesRight = nodeIndices.has(offsetRight);\n                    forceChildren = !includesLeft && !includesRight;\n                }\n            } else {\n                includesLeft = true;\n                includesRight = true;\n            }\n            const traverseLeft = forceChildren || includesLeft;\n            const traverseRight = forceChildren || includesRight;\n            let leftChange = false;\n            if (traverseLeft) {\n                leftChange = _traverse(left, byteOffset, forceChildren);\n            }\n            let rightChange = false;\n            if (traverseRight) {\n                rightChange = _traverse(right, byteOffset, forceChildren);\n            }\n            const didChange = leftChange || rightChange;\n            if (didChange) {\n                for(let i = 0; i < 3; i++){\n                    const lefti = left + i;\n                    const righti = right + i;\n                    const minLeftValue = float32Array[lefti];\n                    const maxLeftValue = float32Array[lefti + 3];\n                    const minRightValue = float32Array[righti];\n                    const maxRightValue = float32Array[righti + 3];\n                    float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n                    float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n                }\n            }\n            return didChange;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3JlZml0LmdlbmVyYXRlZC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFtRDtBQUVuRCxvREFBb0QsR0FDcEQsb0RBQW9ELEdBQ3BELG9EQUFvRCxHQUVwRCxTQUFTQyxNQUFPQyxHQUFHO1FBQUVDLGNBQUFBLGlFQUFjO0lBRWxDLElBQUtBLGVBQWVDLE1BQU1DLE9BQU8sQ0FBRUYsY0FBZ0I7UUFFbERBLGNBQWMsSUFBSUcsSUFBS0g7SUFFeEI7SUFFQSxNQUFNSSxXQUFXTCxJQUFJSyxRQUFRO0lBQzdCLE1BQU1DLFdBQVdELFNBQVNFLEtBQUssR0FBR0YsU0FBU0UsS0FBSyxDQUFDQyxLQUFLLEdBQUc7SUFDekQsTUFBTUMsVUFBVUosU0FBU0ssVUFBVSxDQUFDQyxRQUFRO0lBRTVDLElBQUlDLFFBQVFDLGFBQWFDLGFBQWFDO0lBQ3RDLElBQUlDLGFBQWE7SUFDakIsTUFBTUMsUUFBUWpCLElBQUlrQixNQUFNO0lBQ3hCLElBQU0sSUFBSUMsSUFBSSxHQUFHQyxJQUFJSCxNQUFNSSxNQUFNLEVBQUVGLElBQUlDLEdBQUdELElBQU87UUFFaERQLFNBQVNLLEtBQUssQ0FBRUUsRUFBRztRQUNuQk4sY0FBYyxJQUFJUyxZQUFhVjtRQUMvQkUsY0FBYyxJQUFJUyxZQUFhWDtRQUMvQkcsZUFBZSxJQUFJUyxhQUFjWjtRQUVqQ2EsVUFBVyxHQUFHVDtRQUNkQSxjQUFjSixPQUFPYyxVQUFVO0lBRWhDO0lBRUEsU0FBU0QsVUFBV0UsV0FBVyxFQUFFWCxVQUFVO1lBQUVZLFFBQUFBLGlFQUFRO1FBRXBELE1BQU1DLGNBQWNGLGNBQWM7UUFDbEMsTUFBTUcsU0FBU2hCLFdBQVcsQ0FBRWUsY0FBYyxHQUFJLEtBQUsvQiwyREFBZ0JBO1FBQ25FLElBQUtnQyxRQUFTO1lBRWIsTUFBTUMsU0FBU2xCLFdBQVcsQ0FBRWMsY0FBYyxFQUFHO1lBQzdDLE1BQU1LLFFBQVFsQixXQUFXLENBQUVlLGNBQWMsR0FBSTtZQUU3QyxJQUFJSSxPQUFPQztZQUNYLElBQUlDLE9BQU9EO1lBQ1gsSUFBSUUsT0FBT0Y7WUFDWCxJQUFJRyxPQUFPLENBQUVIO1lBQ2IsSUFBSUksT0FBTyxDQUFFSjtZQUNiLElBQUlLLE9BQU8sQ0FBRUw7WUFHYixJQUFNLElBQUlmLElBQUksSUFBSVksUUFBUVgsSUFBSSxJQUFNVyxDQUFBQSxTQUFTQyxLQUFJLEdBQUtiLElBQUlDLEdBQUdELElBQU87Z0JBRW5FLElBQUlaLFFBQVFELFFBQVEsQ0FBRWEsRUFBRztnQkFDekIsTUFBTXFCLElBQUkvQixRQUFRZ0MsSUFBSSxDQUFFbEM7Z0JBQ3hCLE1BQU1tQyxJQUFJakMsUUFBUWtDLElBQUksQ0FBRXBDO2dCQUN4QixNQUFNcUMsSUFBSW5DLFFBQVFvQyxJQUFJLENBQUV0QztnQkFFeEIsSUFBS2lDLElBQUlQLE1BQU9BLE9BQU9PO2dCQUN2QixJQUFLQSxJQUFJSCxNQUFPQSxPQUFPRztnQkFFdkIsSUFBS0UsSUFBSVAsTUFBT0EsT0FBT087Z0JBQ3ZCLElBQUtBLElBQUlKLE1BQU9BLE9BQU9JO2dCQUV2QixJQUFLRSxJQUFJUixNQUFPQSxPQUFPUTtnQkFDdkIsSUFBS0EsSUFBSUwsTUFBT0EsT0FBT0s7WUFFeEI7WUFHQSxJQUNDN0IsWUFBWSxDQUFFWSxjQUFjLEVBQUcsS0FBS00sUUFDcENsQixZQUFZLENBQUVZLGNBQWMsRUFBRyxLQUFLUSxRQUNwQ3BCLFlBQVksQ0FBRVksY0FBYyxFQUFHLEtBQUtTLFFBRXBDckIsWUFBWSxDQUFFWSxjQUFjLEVBQUcsS0FBS1UsUUFDcEN0QixZQUFZLENBQUVZLGNBQWMsRUFBRyxLQUFLVyxRQUNwQ3ZCLFlBQVksQ0FBRVksY0FBYyxFQUFHLEtBQUtZLE1BQ25DO2dCQUVEeEIsWUFBWSxDQUFFWSxjQUFjLEVBQUcsR0FBR007Z0JBQ2xDbEIsWUFBWSxDQUFFWSxjQUFjLEVBQUcsR0FBR1E7Z0JBQ2xDcEIsWUFBWSxDQUFFWSxjQUFjLEVBQUcsR0FBR1M7Z0JBRWxDckIsWUFBWSxDQUFFWSxjQUFjLEVBQUcsR0FBR1U7Z0JBQ2xDdEIsWUFBWSxDQUFFWSxjQUFjLEVBQUcsR0FBR1c7Z0JBQ2xDdkIsWUFBWSxDQUFFWSxjQUFjLEVBQUcsR0FBR1k7Z0JBRWxDLE9BQU87WUFFUixPQUFPO2dCQUVOLE9BQU87WUFFUjtRQUVELE9BQU87WUFFTixNQUFNTyxPQUFPbkIsY0FBYztZQUMzQixNQUFNb0IsUUFBUWxDLFdBQVcsQ0FBRWMsY0FBYyxFQUFHO1lBRTVDLHlGQUF5RjtZQUN6RixnR0FBZ0c7WUFDaEcsTUFBTXFCLGFBQWFGLE9BQU85QjtZQUMxQixNQUFNaUMsY0FBY0YsUUFBUS9CO1lBQzVCLElBQUlrQyxnQkFBZ0J0QjtZQUNwQixJQUFJdUIsZUFBZTtZQUNuQixJQUFJQyxnQkFBZ0I7WUFFcEIsSUFBS25ELGFBQWM7Z0JBRWxCLGlHQUFpRztnQkFDakcsdURBQXVEO2dCQUN2RCxJQUFLLENBQUVpRCxlQUFnQjtvQkFFdEJDLGVBQWVsRCxZQUFZb0QsR0FBRyxDQUFFTDtvQkFDaENJLGdCQUFnQm5ELFlBQVlvRCxHQUFHLENBQUVKO29CQUNqQ0MsZ0JBQWdCLENBQUVDLGdCQUFnQixDQUFFQztnQkFFckM7WUFFRCxPQUFPO2dCQUVORCxlQUFlO2dCQUNmQyxnQkFBZ0I7WUFFakI7WUFFQSxNQUFNRSxlQUFlSixpQkFBaUJDO1lBQ3RDLE1BQU1JLGdCQUFnQkwsaUJBQWlCRTtZQUV2QyxJQUFJSSxhQUFhO1lBQ2pCLElBQUtGLGNBQWU7Z0JBRW5CRSxhQUFhL0IsVUFBV3FCLE1BQU05QixZQUFZa0M7WUFFM0M7WUFFQSxJQUFJTyxjQUFjO1lBQ2xCLElBQUtGLGVBQWdCO2dCQUVwQkUsY0FBY2hDLFVBQVdzQixPQUFPL0IsWUFBWWtDO1lBRTdDO1lBRUEsTUFBTVEsWUFBWUYsY0FBY0M7WUFDaEMsSUFBS0MsV0FBWTtnQkFFaEIsSUFBTSxJQUFJdkMsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQU87b0JBRTlCLE1BQU13QyxRQUFRYixPQUFPM0I7b0JBQ3JCLE1BQU15QyxTQUFTYixRQUFRNUI7b0JBQ3ZCLE1BQU0wQyxlQUFlOUMsWUFBWSxDQUFFNEMsTUFBTztvQkFDMUMsTUFBTUcsZUFBZS9DLFlBQVksQ0FBRTRDLFFBQVEsRUFBRztvQkFDOUMsTUFBTUksZ0JBQWdCaEQsWUFBWSxDQUFFNkMsT0FBUTtvQkFDNUMsTUFBTUksZ0JBQWdCakQsWUFBWSxDQUFFNkMsU0FBUyxFQUFHO29CQUVoRDdDLFlBQVksQ0FBRVksY0FBY1IsRUFBRyxHQUFHMEMsZUFBZUUsZ0JBQWdCRixlQUFlRTtvQkFDaEZoRCxZQUFZLENBQUVZLGNBQWNSLElBQUksRUFBRyxHQUFHMkMsZUFBZUUsZ0JBQWdCRixlQUFlRTtnQkFFckY7WUFFRDtZQUVBLE9BQU9OO1FBRVI7SUFFRDtBQUVEO0FBRWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3JlZml0LmdlbmVyYXRlZC5qcz83MDBlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElTX0xFQUZOT0RFX0ZMQUcgfSBmcm9tICcuLi9Db25zdGFudHMuanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInJlZml0LnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gcmVmaXQoIGJ2aCwgbm9kZUluZGljZXMgPSBudWxsICkge1xuXG5cdGlmICggbm9kZUluZGljZXMgJiYgQXJyYXkuaXNBcnJheSggbm9kZUluZGljZXMgKSApIHtcblxuXHRcdG5vZGVJbmRpY2VzID0gbmV3IFNldCggbm9kZUluZGljZXMgKTtcblxuXHR9XG5cblx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdGNvbnN0IGluZGV4QXJyID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IG51bGw7XG5cdGNvbnN0IHBvc0F0dHIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdGxldCBidWZmZXIsIHVpbnQzMkFycmF5LCB1aW50MTZBcnJheSwgZmxvYXQzMkFycmF5O1xuXHRsZXQgYnl0ZU9mZnNldCA9IDA7XG5cdGNvbnN0IHJvb3RzID0gYnZoLl9yb290cztcblx0Zm9yICggbGV0IGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGJ1ZmZlciA9IHJvb3RzWyBpIF07XG5cdFx0dWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRcdHVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBidWZmZXIgKTtcblx0XHRmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblxuXHRcdF90cmF2ZXJzZSggMCwgYnl0ZU9mZnNldCApO1xuXHRcdGJ5dGVPZmZzZXQgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF90cmF2ZXJzZSggbm9kZTMySW5kZXgsIGJ5dGVPZmZzZXQsIGZvcmNlID0gZmFsc2UgKSB7XG5cblx0XHRjb25zdCBub2RlMTZJbmRleCA9IG5vZGUzMkluZGV4ICogMjtcblx0XHRjb25zdCBpc0xlYWYgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNSBdID09PSBJU19MRUFGTk9ERV9GTEFHO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cdFx0XHRjb25zdCBjb3VudCA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE0IF07XG5cblx0XHRcdGxldCBtaW54ID0gSW5maW5pdHk7XG5cdFx0XHRsZXQgbWlueSA9IEluZmluaXR5O1xuXHRcdFx0bGV0IG1pbnogPSBJbmZpbml0eTtcblx0XHRcdGxldCBtYXh4ID0gLSBJbmZpbml0eTtcblx0XHRcdGxldCBtYXh5ID0gLSBJbmZpbml0eTtcblx0XHRcdGxldCBtYXh6ID0gLSBJbmZpbml0eTtcblxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDMgKiBvZmZzZXQsIGwgPSAzICogKCBvZmZzZXQgKyBjb3VudCApOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgaW5kZXggPSBpbmRleEFyclsgaSBdO1xuXHRcdFx0XHRjb25zdCB4ID0gcG9zQXR0ci5nZXRYKCBpbmRleCApO1xuXHRcdFx0XHRjb25zdCB5ID0gcG9zQXR0ci5nZXRZKCBpbmRleCApO1xuXHRcdFx0XHRjb25zdCB6ID0gcG9zQXR0ci5nZXRaKCBpbmRleCApO1xuXG5cdFx0XHRcdGlmICggeCA8IG1pbnggKSBtaW54ID0geDtcblx0XHRcdFx0aWYgKCB4ID4gbWF4eCApIG1heHggPSB4O1xuXG5cdFx0XHRcdGlmICggeSA8IG1pbnkgKSBtaW55ID0geTtcblx0XHRcdFx0aWYgKCB5ID4gbWF4eSApIG1heHkgPSB5O1xuXG5cdFx0XHRcdGlmICggeiA8IG1pbnogKSBtaW56ID0gejtcblx0XHRcdFx0aWYgKCB6ID4gbWF4eiApIG1heHogPSB6O1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdICE9PSBtaW54IHx8XG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gIT09IG1pbnkgfHxcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDIgXSAhPT0gbWlueiB8fFxuXG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gIT09IG1heHggfHxcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSAhPT0gbWF4eSB8fFxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNSBdICE9PSBtYXh6XG5cdFx0XHQpIHtcblxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdID0gbWlueDtcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDEgXSA9IG1pbnk7XG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAyIF0gPSBtaW56O1xuXG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gPSBtYXh4O1xuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNCBdID0gbWF4eTtcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDUgXSA9IG1heHo7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0ID0gbm9kZTMySW5kZXggKyA4O1xuXHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cblx0XHRcdC8vIHRoZSBpZGVudGlmeWluZyBub2RlIGluZGljZXMgcHJvdmlkZWQgYnkgdGhlIHNoYXBlY2FzdCBmdW5jdGlvbiBpbmNsdWRlIG9mZnNldHMgb2YgYWxsXG5cdFx0XHQvLyByb290IGJ1ZmZlcnMgdG8gZ3VhcmFudGVlIHRoZXkncmUgdW5pcXVlIGJldHdlZW4gcm9vdHMgc28gb2Zmc2V0IGxlZnQgYW5kIHJpZ2h0IGluZGljZXMgaGVyZS5cblx0XHRcdGNvbnN0IG9mZnNldExlZnQgPSBsZWZ0ICsgYnl0ZU9mZnNldDtcblx0XHRcdGNvbnN0IG9mZnNldFJpZ2h0ID0gcmlnaHQgKyBieXRlT2Zmc2V0O1xuXHRcdFx0bGV0IGZvcmNlQ2hpbGRyZW4gPSBmb3JjZTtcblx0XHRcdGxldCBpbmNsdWRlc0xlZnQgPSBmYWxzZTtcblx0XHRcdGxldCBpbmNsdWRlc1JpZ2h0ID0gZmFsc2U7XG5cblx0XHRcdGlmICggbm9kZUluZGljZXMgKSB7XG5cblx0XHRcdFx0Ly8gaWYgd2Ugc2VlIHRoYXQgbmVpdGhlciB0aGUgbGVmdCBvciByaWdodCBjaGlsZCBhcmUgaW5jbHVkZWQgaW4gdGhlIHNldCB0aGF0IG5lZWQgdG8gYmUgdXBkYXRlZFxuXHRcdFx0XHQvLyB0aGVuIHdlIGFzc3VtZSB0aGF0IGFsbCBjaGlsZHJlbiBuZWVkIHRvIGJlIHVwZGF0ZWQuXG5cdFx0XHRcdGlmICggISBmb3JjZUNoaWxkcmVuICkge1xuXG5cdFx0XHRcdFx0aW5jbHVkZXNMZWZ0ID0gbm9kZUluZGljZXMuaGFzKCBvZmZzZXRMZWZ0ICk7XG5cdFx0XHRcdFx0aW5jbHVkZXNSaWdodCA9IG5vZGVJbmRpY2VzLmhhcyggb2Zmc2V0UmlnaHQgKTtcblx0XHRcdFx0XHRmb3JjZUNoaWxkcmVuID0gISBpbmNsdWRlc0xlZnQgJiYgISBpbmNsdWRlc1JpZ2h0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpbmNsdWRlc0xlZnQgPSB0cnVlO1xuXHRcdFx0XHRpbmNsdWRlc1JpZ2h0ID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0cmF2ZXJzZUxlZnQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzTGVmdDtcblx0XHRcdGNvbnN0IHRyYXZlcnNlUmlnaHQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzUmlnaHQ7XG5cblx0XHRcdGxldCBsZWZ0Q2hhbmdlID0gZmFsc2U7XG5cdFx0XHRpZiAoIHRyYXZlcnNlTGVmdCApIHtcblxuXHRcdFx0XHRsZWZ0Q2hhbmdlID0gX3RyYXZlcnNlKCBsZWZ0LCBieXRlT2Zmc2V0LCBmb3JjZUNoaWxkcmVuICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IHJpZ2h0Q2hhbmdlID0gZmFsc2U7XG5cdFx0XHRpZiAoIHRyYXZlcnNlUmlnaHQgKSB7XG5cblx0XHRcdFx0cmlnaHRDaGFuZ2UgPSBfdHJhdmVyc2UoIHJpZ2h0LCBieXRlT2Zmc2V0LCBmb3JjZUNoaWxkcmVuICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGlkQ2hhbmdlID0gbGVmdENoYW5nZSB8fCByaWdodENoYW5nZTtcblx0XHRcdGlmICggZGlkQ2hhbmdlICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBsZWZ0aSA9IGxlZnQgKyBpO1xuXHRcdFx0XHRcdGNvbnN0IHJpZ2h0aSA9IHJpZ2h0ICsgaTtcblx0XHRcdFx0XHRjb25zdCBtaW5MZWZ0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIGxlZnRpIF07XG5cdFx0XHRcdFx0Y29uc3QgbWF4TGVmdFZhbHVlID0gZmxvYXQzMkFycmF5WyBsZWZ0aSArIDMgXTtcblx0XHRcdFx0XHRjb25zdCBtaW5SaWdodFZhbHVlID0gZmxvYXQzMkFycmF5WyByaWdodGkgXTtcblx0XHRcdFx0XHRjb25zdCBtYXhSaWdodFZhbHVlID0gZmxvYXQzMkFycmF5WyByaWdodGkgKyAzIF07XG5cblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgaSBdID0gbWluTGVmdFZhbHVlIDwgbWluUmlnaHRWYWx1ZSA/IG1pbkxlZnRWYWx1ZSA6IG1pblJpZ2h0VmFsdWU7XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIGkgKyAzIF0gPSBtYXhMZWZ0VmFsdWUgPiBtYXhSaWdodFZhbHVlID8gbWF4TGVmdFZhbHVlIDogbWF4UmlnaHRWYWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRpZENoYW5nZTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgcmVmaXQgfTtcbiJdLCJuYW1lcyI6WyJJU19MRUFGTk9ERV9GTEFHIiwicmVmaXQiLCJidmgiLCJub2RlSW5kaWNlcyIsIkFycmF5IiwiaXNBcnJheSIsIlNldCIsImdlb21ldHJ5IiwiaW5kZXhBcnIiLCJpbmRleCIsImFycmF5IiwicG9zQXR0ciIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsImJ1ZmZlciIsInVpbnQzMkFycmF5IiwidWludDE2QXJyYXkiLCJmbG9hdDMyQXJyYXkiLCJieXRlT2Zmc2V0Iiwicm9vdHMiLCJfcm9vdHMiLCJpIiwibCIsImxlbmd0aCIsIlVpbnQzMkFycmF5IiwiVWludDE2QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJfdHJhdmVyc2UiLCJieXRlTGVuZ3RoIiwibm9kZTMySW5kZXgiLCJmb3JjZSIsIm5vZGUxNkluZGV4IiwiaXNMZWFmIiwib2Zmc2V0IiwiY291bnQiLCJtaW54IiwiSW5maW5pdHkiLCJtaW55IiwibWlueiIsIm1heHgiLCJtYXh5IiwibWF4eiIsIngiLCJnZXRYIiwieSIsImdldFkiLCJ6IiwiZ2V0WiIsImxlZnQiLCJyaWdodCIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsImZvcmNlQ2hpbGRyZW4iLCJpbmNsdWRlc0xlZnQiLCJpbmNsdWRlc1JpZ2h0IiwiaGFzIiwidHJhdmVyc2VMZWZ0IiwidHJhdmVyc2VSaWdodCIsImxlZnRDaGFuZ2UiLCJyaWdodENoYW5nZSIsImRpZENoYW5nZSIsImxlZnRpIiwicmlnaHRpIiwibWluTGVmdFZhbHVlIiwibWF4TGVmdFZhbHVlIiwibWluUmlnaHRWYWx1ZSIsIm1heFJpZ2h0VmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/refit.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   refit_indirect: function() { return /* binding */ refit_indirect; }\n/* harmony export */ });\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Constants.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/Constants.js\");\n\n/****************************************************/ /* This file is generated from \"refit.template.js\". */ /****************************************************/ function refit_indirect(bvh) {\n    let nodeIndices = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n    if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n    }\n    const geometry = bvh.geometry;\n    const indexArr = geometry.index ? geometry.index.array : null;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = bvh._roots;\n    for(let i = 0, l = roots.length; i < l; i++){\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset) {\n        let force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const node16Index = node32Index * 2;\n        const isLeaf = uint16Array[node16Index + 15] === _Constants_js__WEBPACK_IMPORTED_MODULE_0__.IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n            const offset = uint32Array[node32Index + 6];\n            const count = uint16Array[node16Index + 14];\n            let minx = Infinity;\n            let miny = Infinity;\n            let minz = Infinity;\n            let maxx = -Infinity;\n            let maxy = -Infinity;\n            let maxz = -Infinity;\n            for(let i = offset, l = offset + count; i < l; i++){\n                const t = 3 * bvh.resolveTriangleIndex(i);\n                for(let j = 0; j < 3; j++){\n                    let index = t + j;\n                    index = indexArr ? indexArr[index] : index;\n                    const x = posAttr.getX(index);\n                    const y = posAttr.getY(index);\n                    const z = posAttr.getZ(index);\n                    if (x < minx) minx = x;\n                    if (x > maxx) maxx = x;\n                    if (y < miny) miny = y;\n                    if (y > maxy) maxy = y;\n                    if (z < minz) minz = z;\n                    if (z > maxz) maxz = z;\n                }\n            }\n            if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n                float32Array[node32Index + 0] = minx;\n                float32Array[node32Index + 1] = miny;\n                float32Array[node32Index + 2] = minz;\n                float32Array[node32Index + 3] = maxx;\n                float32Array[node32Index + 4] = maxy;\n                float32Array[node32Index + 5] = maxz;\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            const left = node32Index + 8;\n            const right = uint32Array[node32Index + 6];\n            // the identifying node indices provided by the shapecast function include offsets of all\n            // root buffers to guarantee they're unique between roots so offset left and right indices here.\n            const offsetLeft = left + byteOffset;\n            const offsetRight = right + byteOffset;\n            let forceChildren = force;\n            let includesLeft = false;\n            let includesRight = false;\n            if (nodeIndices) {\n                // if we see that neither the left or right child are included in the set that need to be updated\n                // then we assume that all children need to be updated.\n                if (!forceChildren) {\n                    includesLeft = nodeIndices.has(offsetLeft);\n                    includesRight = nodeIndices.has(offsetRight);\n                    forceChildren = !includesLeft && !includesRight;\n                }\n            } else {\n                includesLeft = true;\n                includesRight = true;\n            }\n            const traverseLeft = forceChildren || includesLeft;\n            const traverseRight = forceChildren || includesRight;\n            let leftChange = false;\n            if (traverseLeft) {\n                leftChange = _traverse(left, byteOffset, forceChildren);\n            }\n            let rightChange = false;\n            if (traverseRight) {\n                rightChange = _traverse(right, byteOffset, forceChildren);\n            }\n            const didChange = leftChange || rightChange;\n            if (didChange) {\n                for(let i = 0; i < 3; i++){\n                    const lefti = left + i;\n                    const righti = right + i;\n                    const minLeftValue = float32Array[lefti];\n                    const maxLeftValue = float32Array[lefti + 3];\n                    const minRightValue = float32Array[righti];\n                    const maxRightValue = float32Array[righti + 3];\n                    float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n                    float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n                }\n            }\n            return didChange;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3JlZml0X2luZGlyZWN0LmdlbmVyYXRlZC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFtRDtBQUVuRCxvREFBb0QsR0FDcEQsb0RBQW9ELEdBQ3BELG9EQUFvRCxHQUVwRCxTQUFTQyxlQUFnQkMsR0FBRztRQUFFQyxjQUFBQSxpRUFBYztJQUUzQyxJQUFLQSxlQUFlQyxNQUFNQyxPQUFPLENBQUVGLGNBQWdCO1FBRWxEQSxjQUFjLElBQUlHLElBQUtIO0lBRXhCO0lBRUEsTUFBTUksV0FBV0wsSUFBSUssUUFBUTtJQUM3QixNQUFNQyxXQUFXRCxTQUFTRSxLQUFLLEdBQUdGLFNBQVNFLEtBQUssQ0FBQ0MsS0FBSyxHQUFHO0lBQ3pELE1BQU1DLFVBQVVKLFNBQVNLLFVBQVUsQ0FBQ0MsUUFBUTtJQUU1QyxJQUFJQyxRQUFRQyxhQUFhQyxhQUFhQztJQUN0QyxJQUFJQyxhQUFhO0lBQ2pCLE1BQU1DLFFBQVFqQixJQUFJa0IsTUFBTTtJQUN4QixJQUFNLElBQUlDLElBQUksR0FBR0MsSUFBSUgsTUFBTUksTUFBTSxFQUFFRixJQUFJQyxHQUFHRCxJQUFPO1FBRWhEUCxTQUFTSyxLQUFLLENBQUVFLEVBQUc7UUFDbkJOLGNBQWMsSUFBSVMsWUFBYVY7UUFDL0JFLGNBQWMsSUFBSVMsWUFBYVg7UUFDL0JHLGVBQWUsSUFBSVMsYUFBY1o7UUFFakNhLFVBQVcsR0FBR1Q7UUFDZEEsY0FBY0osT0FBT2MsVUFBVTtJQUVoQztJQUVBLFNBQVNELFVBQVdFLFdBQVcsRUFBRVgsVUFBVTtZQUFFWSxRQUFBQSxpRUFBUTtRQUVwRCxNQUFNQyxjQUFjRixjQUFjO1FBQ2xDLE1BQU1HLFNBQVNoQixXQUFXLENBQUVlLGNBQWMsR0FBSSxLQUFLL0IsMkRBQWdCQTtRQUNuRSxJQUFLZ0MsUUFBUztZQUViLE1BQU1DLFNBQVNsQixXQUFXLENBQUVjLGNBQWMsRUFBRztZ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WUFBWXFDO1lBRTdDO1lBRUEsTUFBTVEsWUFBWUYsY0FBY0M7WUFDaEMsSUFBS0MsV0FBWTtnQkFFaEIsSUFBTSxJQUFJMUMsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQU87b0JBRTlCLE1BQU0yQyxRQUFRYixPQUFPOUI7b0JBQ3JCLE1BQU00QyxTQUFTYixRQUFRL0I7b0JBQ3ZCLE1BQU02QyxlQUFlakQsWUFBWSxDQUFFK0MsTUFBTztvQkFDMUMsTUFBTUcsZUFBZWxELFlBQVksQ0FBRStDLFFBQVEsRUFBRztvQkFDOUMsTUFBTUksZ0JBQWdCbkQsWUFBWSxDQUFFZ0QsT0FBUTtvQkFDNUMsTUFBTUksZ0JBQWdCcEQsWUFBWSxDQUFFZ0QsU0FBUyxFQUFHO29CQUVoRGhELFlBQVksQ0FBRVksY0FBY1IsRUFBRyxHQUFHNkMsZUFBZUUsZ0JBQWdCRixlQUFlRTtvQkFDaEZuRCxZQUFZLENBQUVZLGNBQWNSLElBQUksRUFBRyxHQUFHOEMsZUFBZUUsZ0JBQWdCRixlQUFlRTtnQkFFckY7WUFFRDtZQUVBLE9BQU9OO1FBRVI7SUFFRDtBQUVEO0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3JlZml0X2luZGlyZWN0LmdlbmVyYXRlZC5qcz9kZWE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElTX0xFQUZOT0RFX0ZMQUcgfSBmcm9tICcuLi9Db25zdGFudHMuanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInJlZml0LnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gcmVmaXRfaW5kaXJlY3QoIGJ2aCwgbm9kZUluZGljZXMgPSBudWxsICkge1xuXG5cdGlmICggbm9kZUluZGljZXMgJiYgQXJyYXkuaXNBcnJheSggbm9kZUluZGljZXMgKSApIHtcblxuXHRcdG5vZGVJbmRpY2VzID0gbmV3IFNldCggbm9kZUluZGljZXMgKTtcblxuXHR9XG5cblx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdGNvbnN0IGluZGV4QXJyID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IG51bGw7XG5cdGNvbnN0IHBvc0F0dHIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdGxldCBidWZmZXIsIHVpbnQzMkFycmF5LCB1aW50MTZBcnJheSwgZmxvYXQzMkFycmF5O1xuXHRsZXQgYnl0ZU9mZnNldCA9IDA7XG5cdGNvbnN0IHJvb3RzID0gYnZoLl9yb290cztcblx0Zm9yICggbGV0IGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGJ1ZmZlciA9IHJvb3RzWyBpIF07XG5cdFx0dWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRcdHVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBidWZmZXIgKTtcblx0XHRmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblxuXHRcdF90cmF2ZXJzZSggMCwgYnl0ZU9mZnNldCApO1xuXHRcdGJ5dGVPZmZzZXQgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF90cmF2ZXJzZSggbm9kZTMySW5kZXgsIGJ5dGVPZmZzZXQsIGZvcmNlID0gZmFsc2UgKSB7XG5cblx0XHRjb25zdCBub2RlMTZJbmRleCA9IG5vZGUzMkluZGV4ICogMjtcblx0XHRjb25zdCBpc0xlYWYgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNSBdID09PSBJU19MRUFGTk9ERV9GTEFHO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cdFx0XHRjb25zdCBjb3VudCA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE0IF07XG5cblx0XHRcdGxldCBtaW54ID0gSW5maW5pdHk7XG5cdFx0XHRsZXQgbWlueSA9IEluZmluaXR5O1xuXHRcdFx0bGV0IG1pbnogPSBJbmZpbml0eTtcblx0XHRcdGxldCBtYXh4ID0gLSBJbmZpbml0eTtcblx0XHRcdGxldCBtYXh5ID0gLSBJbmZpbml0eTtcblx0XHRcdGxldCBtYXh6ID0gLSBJbmZpbml0eTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdCA9IDMgKiBidmgucmVzb2x2ZVRyaWFuZ2xlSW5kZXgoIGkgKTtcblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdGxldCBpbmRleCA9IHQgKyBqO1xuXHRcdFx0XHRcdGluZGV4ID0gaW5kZXhBcnIgPyBpbmRleEFyclsgaW5kZXggXSA6IGluZGV4O1xuXG5cdFx0XHRcdFx0Y29uc3QgeCA9IHBvc0F0dHIuZ2V0WCggaW5kZXggKTtcblx0XHRcdFx0XHRjb25zdCB5ID0gcG9zQXR0ci5nZXRZKCBpbmRleCApO1xuXHRcdFx0XHRcdGNvbnN0IHogPSBwb3NBdHRyLmdldFooIGluZGV4ICk7XG5cblx0XHRcdFx0XHRpZiAoIHggPCBtaW54ICkgbWlueCA9IHg7XG5cdFx0XHRcdFx0aWYgKCB4ID4gbWF4eCApIG1heHggPSB4O1xuXG5cdFx0XHRcdFx0aWYgKCB5IDwgbWlueSApIG1pbnkgPSB5O1xuXHRcdFx0XHRcdGlmICggeSA+IG1heHkgKSBtYXh5ID0geTtcblxuXHRcdFx0XHRcdGlmICggeiA8IG1pbnogKSBtaW56ID0gejtcblx0XHRcdFx0XHRpZiAoIHogPiBtYXh6ICkgbWF4eiA9IHo7XG5cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAwIF0gIT09IG1pbnggfHxcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDEgXSAhPT0gbWlueSB8fFxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMiBdICE9PSBtaW56IHx8XG5cblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDMgXSAhPT0gbWF4eCB8fFxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNCBdICE9PSBtYXh5IHx8XG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA1IF0gIT09IG1heHpcblx0XHRcdCkge1xuXG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAwIF0gPSBtaW54O1xuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMSBdID0gbWlueTtcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDIgXSA9IG1pbno7XG5cblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDMgXSA9IG1heHg7XG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA0IF0gPSBtYXh5O1xuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNSBdID0gbWF4ejtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGxlZnQgPSBub2RlMzJJbmRleCArIDg7XG5cdFx0XHRjb25zdCByaWdodCA9IHVpbnQzMkFycmF5WyBub2RlMzJJbmRleCArIDYgXTtcblxuXHRcdFx0Ly8gdGhlIGlkZW50aWZ5aW5nIG5vZGUgaW5kaWNlcyBwcm92aWRlZCBieSB0aGUgc2hhcGVjYXN0IGZ1bmN0aW9uIGluY2x1ZGUgb2Zmc2V0cyBvZiBhbGxcblx0XHRcdC8vIHJvb3QgYnVmZmVycyB0byBndWFyYW50ZWUgdGhleSdyZSB1bmlxdWUgYmV0d2VlbiByb290cyBzbyBvZmZzZXQgbGVmdCBhbmQgcmlnaHQgaW5kaWNlcyBoZXJlLlxuXHRcdFx0Y29uc3Qgb2Zmc2V0TGVmdCA9IGxlZnQgKyBieXRlT2Zmc2V0O1xuXHRcdFx0Y29uc3Qgb2Zmc2V0UmlnaHQgPSByaWdodCArIGJ5dGVPZmZzZXQ7XG5cdFx0XHRsZXQgZm9yY2VDaGlsZHJlbiA9IGZvcmNlO1xuXHRcdFx0bGV0IGluY2x1ZGVzTGVmdCA9IGZhbHNlO1xuXHRcdFx0bGV0IGluY2x1ZGVzUmlnaHQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBub2RlSW5kaWNlcyApIHtcblxuXHRcdFx0XHQvLyBpZiB3ZSBzZWUgdGhhdCBuZWl0aGVyIHRoZSBsZWZ0IG9yIHJpZ2h0IGNoaWxkIGFyZSBpbmNsdWRlZCBpbiB0aGUgc2V0IHRoYXQgbmVlZCB0byBiZSB1cGRhdGVkXG5cdFx0XHRcdC8vIHRoZW4gd2UgYXNzdW1lIHRoYXQgYWxsIGNoaWxkcmVuIG5lZWQgdG8gYmUgdXBkYXRlZC5cblx0XHRcdFx0aWYgKCAhIGZvcmNlQ2hpbGRyZW4gKSB7XG5cblx0XHRcdFx0XHRpbmNsdWRlc0xlZnQgPSBub2RlSW5kaWNlcy5oYXMoIG9mZnNldExlZnQgKTtcblx0XHRcdFx0XHRpbmNsdWRlc1JpZ2h0ID0gbm9kZUluZGljZXMuaGFzKCBvZmZzZXRSaWdodCApO1xuXHRcdFx0XHRcdGZvcmNlQ2hpbGRyZW4gPSAhIGluY2x1ZGVzTGVmdCAmJiAhIGluY2x1ZGVzUmlnaHQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGluY2x1ZGVzTGVmdCA9IHRydWU7XG5cdFx0XHRcdGluY2x1ZGVzUmlnaHQgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRyYXZlcnNlTGVmdCA9IGZvcmNlQ2hpbGRyZW4gfHwgaW5jbHVkZXNMZWZ0O1xuXHRcdFx0Y29uc3QgdHJhdmVyc2VSaWdodCA9IGZvcmNlQ2hpbGRyZW4gfHwgaW5jbHVkZXNSaWdodDtcblxuXHRcdFx0bGV0IGxlZnRDaGFuZ2UgPSBmYWxzZTtcblx0XHRcdGlmICggdHJhdmVyc2VMZWZ0ICkge1xuXG5cdFx0XHRcdGxlZnRDaGFuZ2UgPSBfdHJhdmVyc2UoIGxlZnQsIGJ5dGVPZmZzZXQsIGZvcmNlQ2hpbGRyZW4gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcmlnaHRDaGFuZ2UgPSBmYWxzZTtcblx0XHRcdGlmICggdHJhdmVyc2VSaWdodCApIHtcblxuXHRcdFx0XHRyaWdodENoYW5nZSA9IF90cmF2ZXJzZSggcmlnaHQsIGJ5dGVPZmZzZXQsIGZvcmNlQ2hpbGRyZW4gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBkaWRDaGFuZ2UgPSBsZWZ0Q2hhbmdlIHx8IHJpZ2h0Q2hhbmdlO1xuXHRcdFx0aWYgKCBkaWRDaGFuZ2UgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGxlZnRpID0gbGVmdCArIGk7XG5cdFx0XHRcdFx0Y29uc3QgcmlnaHRpID0gcmlnaHQgKyBpO1xuXHRcdFx0XHRcdGNvbnN0IG1pbkxlZnRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgbGVmdGkgXTtcblx0XHRcdFx0XHRjb25zdCBtYXhMZWZ0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIGxlZnRpICsgMyBdO1xuXHRcdFx0XHRcdGNvbnN0IG1pblJpZ2h0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIHJpZ2h0aSBdO1xuXHRcdFx0XHRcdGNvbnN0IG1heFJpZ2h0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIHJpZ2h0aSArIDMgXTtcblxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyBpIF0gPSBtaW5MZWZ0VmFsdWUgPCBtaW5SaWdodFZhbHVlID8gbWluTGVmdFZhbHVlIDogbWluUmlnaHRWYWx1ZTtcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgaSArIDMgXSA9IG1heExlZnRWYWx1ZSA+IG1heFJpZ2h0VmFsdWUgPyBtYXhMZWZ0VmFsdWUgOiBtYXhSaWdodFZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGlkQ2hhbmdlO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyByZWZpdF9pbmRpcmVjdCB9O1xuIl0sIm5hbWVzIjpbIklTX0xFQUZOT0RFX0ZMQUciLCJyZWZpdF9pbmRpcmVjdCIsImJ2aCIsIm5vZGVJbmRpY2VzIiwiQXJyYXkiLCJpc0FycmF5IiwiU2V0IiwiZ2VvbWV0cnkiLCJpbmRleEFyciIsImluZGV4IiwiYXJyYXkiLCJwb3NBdHRyIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiYnVmZmVyIiwidWludDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsImZsb2F0MzJBcnJheSIsImJ5dGVPZmZzZXQiLCJyb290cyIsIl9yb290cyIsImkiLCJsIiwibGVuZ3RoIiwiVWludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsIkZsb2F0MzJBcnJheSIsIl90cmF2ZXJzZSIsImJ5dGVMZW5ndGgiLCJub2RlMzJJbmRleCIsImZvcmNlIiwibm9kZTE2SW5kZXgiLCJpc0xlYWYiLCJvZmZzZXQiLCJjb3VudCIsIm1pbngiLCJJbmZpbml0eSIsIm1pbnkiLCJtaW56IiwibWF4eCIsIm1heHkiLCJtYXh6IiwidCIsInJlc29sdmVUcmlhbmdsZUluZGV4IiwiaiIsIngiLCJnZXRYIiwieSIsImdldFkiLCJ6IiwiZ2V0WiIsImxlZnQiLCJyaWdodCIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsImZvcmNlQ2hpbGRyZW4iLCJpbmNsdWRlc0xlZnQiLCJpbmNsdWRlc1JpZ2h0IiwiaGFzIiwidHJhdmVyc2VMZWZ0IiwidHJhdmVyc2VSaWdodCIsImxlZnRDaGFuZ2UiLCJyaWdodENoYW5nZSIsImRpZENoYW5nZSIsImxlZnRpIiwicmlnaHRpIiwibWluTGVmdFZhbHVlIiwibWF4TGVmdFZhbHVlIiwibWluUmlnaHRWYWx1ZSIsIm1heFJpZ2h0VmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/shapecast.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/cast/shapecast.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shapecast: function() { return /* binding */ shapecast; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Constants.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/Constants.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/PrimitivePool.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n\n\n\n\n\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_0__.PrimitivePool(()=>new three__WEBPACK_IMPORTED_MODULE_1__.Box3());\nfunction shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {\n    // setup\n    _box1 = boxPool.getPrimitive();\n    _box2 = boxPool.getPrimitive();\n    boxStack.push(_box1, _box2);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__.BufferStack.setBuffer(bvh._roots[root]);\n    const result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n    // cleanup\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__.BufferStack.clearBuffer();\n    boxPool.releasePrimitive(_box1);\n    boxPool.releasePrimitive(_box2);\n    boxStack.pop();\n    boxStack.pop();\n    const length = boxStack.length;\n    if (length > 0) {\n        _box2 = boxStack[length - 1];\n        _box1 = boxStack[length - 2];\n    }\n    return result;\n}\nfunction shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc) {\n    let nodeScoreFunc = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, nodeIndexByteOffset = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, depth = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__.BufferStack;\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.COUNT)(nodeIndex16, uint16Array);\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, _box1);\n        return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);\n    } else {\n        const left = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.LEFT_NODE)(nodeIndex32);\n        const right = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.RIGHT_NODE)(nodeIndex32, uint32Array);\n        let c1 = left;\n        let c2 = right;\n        let score1, score2;\n        let box1, box2;\n        if (nodeScoreFunc) {\n            box1 = _box1;\n            box2 = _box2;\n            // bounding data is not offset\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.BOUNDING_DATA_INDEX)(c1), float32Array, box1);\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.BOUNDING_DATA_INDEX)(c2), float32Array, box2);\n            score1 = nodeScoreFunc(box1);\n            score2 = nodeScoreFunc(box2);\n            if (score2 < score1) {\n                c1 = right;\n                c2 = left;\n                const temp = score1;\n                score1 = score2;\n                score2 = temp;\n                box1 = box2;\n            // box2 is always set before use below\n            }\n        }\n        // Check box 1 intersection\n        if (!box1) {\n            box1 = _box1;\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.BOUNDING_DATA_INDEX)(c1), float32Array, box1);\n        }\n        const isC1Leaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.IS_LEAF)(c1 * 2, uint16Array);\n        const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n        let c1StopTraversal;\n        if (c1Intersection === _Constants_js__WEBPACK_IMPORTED_MODULE_5__.CONTAINED) {\n            const offset = getLeftOffset(c1);\n            const end = getRightEndOffset(c1);\n            const count = end - offset;\n            c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n        } else {\n            c1StopTraversal = c1Intersection && shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n        }\n        if (c1StopTraversal) return true;\n        // Check box 2 intersection\n        // cached box2 will have been overwritten by previous traversal\n        box2 = _box2;\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.BOUNDING_DATA_INDEX)(c2), float32Array, box2);\n        const isC2Leaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.IS_LEAF)(c2 * 2, uint16Array);\n        const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n        let c2StopTraversal;\n        if (c2Intersection === _Constants_js__WEBPACK_IMPORTED_MODULE_5__.CONTAINED) {\n            const offset = getLeftOffset(c2);\n            const end = getRightEndOffset(c2);\n            const count = end - offset;\n            c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);\n        } else {\n            c2StopTraversal = c2Intersection && shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n        }\n        if (c2StopTraversal) return true;\n        return false;\n        // Define these inside the function so it has access to the local variables needed\n        // when converting to the buffer equivalents\n        function getLeftOffset(nodeIndex32) {\n            const { uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__.BufferStack;\n            let nodeIndex16 = nodeIndex32 * 2;\n            // traverse until we find a leaf\n            while(!(0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.IS_LEAF)(nodeIndex16, uint16Array)){\n                nodeIndex32 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.LEFT_NODE)(nodeIndex32);\n                nodeIndex16 = nodeIndex32 * 2;\n            }\n            return (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.OFFSET)(nodeIndex32, uint32Array);\n        }\n        function getRightEndOffset(nodeIndex32) {\n            const { uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__.BufferStack;\n            let nodeIndex16 = nodeIndex32 * 2;\n            // traverse until we find a leaf\n            while(!(0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.IS_LEAF)(nodeIndex16, uint16Array)){\n                // adjust offset to point to the right node\n                nodeIndex32 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.RIGHT_NODE)(nodeIndex32, uint32Array);\n                nodeIndex16 = nodeIndex32 * 2;\n            }\n            // return the end offset of the triangle range\n            return (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.OFFSET)(nodeIndex32, uint32Array) + (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.COUNT)(nodeIndex16, uint16Array);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3NoYXBlY2FzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTZCO0FBQ2U7QUFDa0I7QUFDRDtBQUNvRDtBQUMzRDtBQUV0RCxJQUFJVyxPQUFPQztBQUNYLE1BQU1DLFdBQVcsRUFBRTtBQUNuQixNQUFNQyxVQUFVLGFBQWEsR0FBRyxJQUFJWCxrRUFBYUEsQ0FBRSxJQUFNLElBQUlILHVDQUFJQTtBQUUxRCxTQUFTZSxVQUFXQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUMsbUJBQW1CLEVBQUVDLFVBQVU7SUFFdkcsUUFBUTtJQUNSVixRQUFRRyxRQUFRUSxZQUFZO0lBQzVCVixRQUFRRSxRQUFRUSxZQUFZO0lBQzVCVCxTQUFTVSxJQUFJLENBQUVaLE9BQU9DO0lBQ3RCRiw4REFBV0EsQ0FBQ2MsU0FBUyxDQUFFUixJQUFJUyxNQUFNLENBQUVSLEtBQU07SUFFekMsTUFBTVMsU0FBU0Msa0JBQW1CLEdBQUdYLElBQUlZLFFBQVEsRUFBRVYsa0JBQWtCQyxpQkFBaUJDLHFCQUFxQkM7SUFFM0csVUFBVTtJQUNWWCw4REFBV0EsQ0FBQ21CLFdBQVc7SUFDdkJmLFFBQVFnQixnQkFBZ0IsQ0FBRW5CO0lBQzFCRyxRQUFRZ0IsZ0JBQWdCLENBQUVsQjtJQUMxQkMsU0FBU2tCLEdBQUc7SUFDWmxCLFNBQVNrQixHQUFHO0lBRVosTUFBTUMsU0FBU25CLFNBQVNtQixNQUFNO0lBQzlCLElBQUtBLFNBQVMsR0FBSTtRQUVqQnBCLFFBQVFDLFFBQVEsQ0FBRW1CLFNBQVMsRUFBRztRQUM5QnJCLFFBQVFFLFFBQVEsQ0FBRW1CLFNBQVMsRUFBRztJQUUvQjtJQUVBLE9BQU9OO0FBRVI7QUFFQSxTQUFTQyxrQkFDUk0sV0FBVyxFQUNYTCxRQUFRLEVBQ1JNLG9CQUFvQixFQUNwQkMsbUJBQW1CO1FBQ25CQyxnQkFBQUEsaUVBQWdCLE1BQ2hCQyxzQkFBQUEsaUVBQXNCLEdBQ3RCQyxRQUFBQSxpRUFBUTtJQUdSLE1BQU0sRUFBRUMsWUFBWSxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRSxHQUFHL0IsOERBQVdBO0lBQzlELElBQUlnQyxjQUFjVCxjQUFjO0lBRWhDLE1BQU1VLFNBQVNuQyxrRUFBT0EsQ0FBRWtDLGFBQWFGO0lBQ3JDLElBQUtHLFFBQVM7UUFFYixNQUFNQyxTQUFTdkMsaUVBQU1BLENBQUU0QixhQUFhUTtRQUNwQyxNQUFNSSxRQUFRekMsZ0VBQUtBLENBQUVzQyxhQUFhRjtRQUNsQ3RDLHVFQUFVQSxDQUFFTyw4RUFBbUJBLENBQUV3QixjQUFlTSxjQUFjNUI7UUFDOUQsT0FBT3dCLG9CQUFxQlMsUUFBUUMsT0FBTyxPQUFPUCxPQUFPRCxzQkFBc0JKLGFBQWF0QjtJQUU3RixPQUFPO1FBRU4sTUFBTW1DLE9BQU94QyxvRUFBU0EsQ0FBRTJCO1FBQ3hCLE1BQU1jLFFBQVF4QyxxRUFBVUEsQ0FBRTBCLGFBQWFRO1FBQ3ZDLElBQUlPLEtBQUtGO1FBQ1QsSUFBSUcsS0FBS0Y7UUFFVCxJQUFJRyxRQUFRQztRQUNaLElBQUlDLE1BQU1DO1FBQ1YsSUFBS2pCLGVBQWdCO1lBRXBCZ0IsT0FBT3pDO1lBQ1AwQyxPQUFPekM7WUFFUCw4QkFBOEI7WUFDOUJWLHVFQUFVQSxDQUFFTyw4RUFBbUJBLENBQUV1QyxLQUFNVCxjQUFjYTtZQUNyRGxELHVFQUFVQSxDQUFFTyw4RUFBbUJBLENBQUV3QyxLQUFNVixjQUFjYztZQUVyREgsU0FBU2QsY0FBZWdCO1lBQ3hCRCxTQUFTZixjQUFlaUI7WUFFeEIsSUFBS0YsU0FBU0QsUUFBUztnQkFFdEJGLEtBQUtEO2dCQUNMRSxLQUFLSDtnQkFFTCxNQUFNUSxPQUFPSjtnQkFDYkEsU0FBU0M7Z0JBQ1RBLFNBQVNHO2dCQUVURixPQUFPQztZQUNQLHNDQUFzQztZQUV2QztRQUVEO1FBRUEsMkJBQTJCO1FBQzNCLElBQUssQ0FBRUQsTUFBTztZQUViQSxPQUFPekM7WUFDUFQsdUVBQVVBLENBQUVPLDhFQUFtQkEsQ0FBRXVDLEtBQU1ULGNBQWNhO1FBRXREO1FBRUEsTUFBTUcsV0FBVy9DLGtFQUFPQSxDQUFFd0MsS0FBSyxHQUFHUjtRQUNsQyxNQUFNZ0IsaUJBQWlCdEIscUJBQXNCa0IsTUFBTUcsVUFBVUwsUUFBUVosUUFBUSxHQUFHRCxzQkFBc0JXO1FBRXRHLElBQUlTO1FBQ0osSUFBS0QsbUJBQW1CdkQsb0RBQVNBLEVBQUc7WUFFbkMsTUFBTTJDLFNBQVNjLGNBQWVWO1lBQzlCLE1BQU1XLE1BQU1DLGtCQUFtQlo7WUFDL0IsTUFBTUgsUUFBUWMsTUFBTWY7WUFFcEJhLGtCQUFrQnRCLG9CQUFxQlMsUUFBUUMsT0FBTyxNQUFNUCxRQUFRLEdBQUdELHNCQUFzQlcsSUFBSUk7UUFFbEcsT0FBTztZQUVOSyxrQkFDQ0Qsa0JBQ0E3QixrQkFDQ3FCLElBQ0FwQixVQUNBTSxzQkFDQUMscUJBQ0FDLGVBQ0FDLHFCQUNBQyxRQUFRO1FBR1g7UUFFQSxJQUFLbUIsaUJBQWtCLE9BQU87UUFFOUIsMkJBQTJCO1FBQzNCLCtEQUErRDtRQUMvREosT0FBT3pDO1FBQ1BWLHVFQUFVQSxDQUFFTyw4RUFBbUJBLENBQUV3QyxLQUFNVixjQUFjYztRQUVyRCxNQUFNUSxXQUFXckQsa0VBQU9BLENBQUV5QyxLQUFLLEdBQUdUO1FBQ2xDLE1BQU1zQixpQkFBaUI1QixxQkFBc0JtQixNQUFNUSxVQUFVVixRQUFRYixRQUFRLEdBQUdELHNCQUFzQlk7UUFFdEcsSUFBSWM7UUFDSixJQUFLRCxtQkFBbUI3RCxvREFBU0EsRUFBRztZQUVuQyxNQUFNMkMsU0FBU2MsY0FBZVQ7WUFDOUIsTUFBTVUsTUFBTUMsa0JBQW1CWDtZQUMvQixNQUFNSixRQUFRYyxNQUFNZjtZQUVwQm1CLGtCQUFrQjVCLG9CQUFxQlMsUUFBUUMsT0FBTyxNQUFNUCxRQUFRLEdBQUdELHNCQUFzQlksSUFBSUk7UUFFbEcsT0FBTztZQUVOVSxrQkFDQ0Qsa0JBQ0FuQyxrQkFDQ3NCLElBQ0FyQixVQUNBTSxzQkFDQUMscUJBQ0FDLGVBQ0FDLHFCQUNBQyxRQUFRO1FBR1g7UUFFQSxJQUFLeUIsaUJBQWtCLE9BQU87UUFFOUIsT0FBTztRQUVQLGtGQUFrRjtRQUNsRiw0Q0FBNEM7UUFDNUMsU0FBU0wsY0FBZXpCLFdBQVc7WUFFbEMsTUFBTSxFQUFFTyxXQUFXLEVBQUVDLFdBQVcsRUFBRSxHQUFHL0IsOERBQVdBO1lBQ2hELElBQUlnQyxjQUFjVCxjQUFjO1lBRWhDLGdDQUFnQztZQUNoQyxNQUFRLENBQUV6QixrRUFBT0EsQ0FBRWtDLGFBQWFGLGFBQWdCO2dCQUUvQ1AsY0FBYzNCLG9FQUFTQSxDQUFFMkI7Z0JBQ3pCUyxjQUFjVCxjQUFjO1lBRTdCO1lBRUEsT0FBTzVCLGlFQUFNQSxDQUFFNEIsYUFBYVE7UUFFN0I7UUFFQSxTQUFTbUIsa0JBQW1CM0IsV0FBVztZQUV0QyxNQUFNLEVBQUVPLFdBQVcsRUFBRUMsV0FBVyxFQUFFLEdBQUcvQiw4REFBV0E7WUFDaEQsSUFBSWdDLGNBQWNULGNBQWM7WUFFaEMsZ0NBQWdDO1lBQ2hDLE1BQVEsQ0FBRXpCLGtFQUFPQSxDQUFFa0MsYUFBYUYsYUFBZ0I7Z0JBRS9DLDJDQUEyQztnQkFDM0NQLGNBQWMxQixxRUFBVUEsQ0FBRTBCLGFBQWFRO2dCQUN2Q0MsY0FBY1QsY0FBYztZQUU3QjtZQUVBLDhDQUE4QztZQUM5QyxPQUFPNUIsaUVBQU1BLENBQUU0QixhQUFhUSxlQUFnQnJDLGdFQUFLQSxDQUFFc0MsYUFBYUY7UUFFakU7SUFFRDtBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L3NoYXBlY2FzdC5qcz84YzI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJveDMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBDT05UQUlORUQgfSBmcm9tICcuLi9Db25zdGFudHMuanMnO1xuaW1wb3J0IHsgYXJyYXlUb0JveCB9IGZyb20gJy4uLy4uL3V0aWxzL0FycmF5Qm94VXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IFByaW1pdGl2ZVBvb2wgfSBmcm9tICcuLi8uLi91dGlscy9QcmltaXRpdmVQb29sLmpzJztcbmltcG9ydCB7IENPVU5ULCBPRkZTRVQsIExFRlRfTk9ERSwgUklHSFRfTk9ERSwgSVNfTEVBRiwgQk9VTkRJTkdfREFUQV9JTkRFWCB9IGZyb20gJy4uL3V0aWxzL25vZGVCdWZmZXJVdGlscy5qcyc7XG5pbXBvcnQgeyBCdWZmZXJTdGFjayB9IGZyb20gJy4uL3V0aWxzL0J1ZmZlclN0YWNrLmpzJztcblxubGV0IF9ib3gxLCBfYm94MjtcbmNvbnN0IGJveFN0YWNrID0gW107XG5jb25zdCBib3hQb29sID0gLyogQF9fUFVSRV9fICovIG5ldyBQcmltaXRpdmVQb29sKCAoKSA9PiBuZXcgQm94MygpICk7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGFwZWNhc3QoIGJ2aCwgcm9vdCwgaW50ZXJzZWN0c0JvdW5kcywgaW50ZXJzZWN0c1JhbmdlLCBib3VuZHNUcmF2ZXJzZU9yZGVyLCBieXRlT2Zmc2V0ICkge1xuXG5cdC8vIHNldHVwXG5cdF9ib3gxID0gYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0X2JveDIgPSBib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRib3hTdGFjay5wdXNoKCBfYm94MSwgX2JveDIgKTtcblx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblxuXHRjb25zdCByZXN1bHQgPSBzaGFwZWNhc3RUcmF2ZXJzZSggMCwgYnZoLmdlb21ldHJ5LCBpbnRlcnNlY3RzQm91bmRzLCBpbnRlcnNlY3RzUmFuZ2UsIGJvdW5kc1RyYXZlcnNlT3JkZXIsIGJ5dGVPZmZzZXQgKTtcblxuXHQvLyBjbGVhbnVwXG5cdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cdGJveFBvb2wucmVsZWFzZVByaW1pdGl2ZSggX2JveDEgKTtcblx0Ym94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBfYm94MiApO1xuXHRib3hTdGFjay5wb3AoKTtcblx0Ym94U3RhY2sucG9wKCk7XG5cblx0Y29uc3QgbGVuZ3RoID0gYm94U3RhY2subGVuZ3RoO1xuXHRpZiAoIGxlbmd0aCA+IDAgKSB7XG5cblx0XHRfYm94MiA9IGJveFN0YWNrWyBsZW5ndGggLSAxIF07XG5cdFx0X2JveDEgPSBib3hTdGFja1sgbGVuZ3RoIC0gMiBdO1xuXG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xuXG59XG5cbmZ1bmN0aW9uIHNoYXBlY2FzdFRyYXZlcnNlKFxuXHRub2RlSW5kZXgzMixcblx0Z2VvbWV0cnksXG5cdGludGVyc2VjdHNCb3VuZHNGdW5jLFxuXHRpbnRlcnNlY3RzUmFuZ2VGdW5jLFxuXHRub2RlU2NvcmVGdW5jID0gbnVsbCxcblx0bm9kZUluZGV4Qnl0ZU9mZnNldCA9IDAsIC8vIG9mZnNldCBmb3IgdW5pcXVlIG5vZGUgaWRlbnRpZmllclxuXHRkZXB0aCA9IDBcbikge1xuXG5cdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdGlmICggaXNMZWFmICkge1xuXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBub2RlSW5kZXgzMiApLCBmbG9hdDMyQXJyYXksIF9ib3gxICk7XG5cdFx0cmV0dXJuIGludGVyc2VjdHNSYW5nZUZ1bmMoIG9mZnNldCwgY291bnQsIGZhbHNlLCBkZXB0aCwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIG5vZGVJbmRleDMyLCBfYm94MSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRjb25zdCBsZWZ0ID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXHRcdGNvbnN0IHJpZ2h0ID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0bGV0IGMxID0gbGVmdDtcblx0XHRsZXQgYzIgPSByaWdodDtcblxuXHRcdGxldCBzY29yZTEsIHNjb3JlMjtcblx0XHRsZXQgYm94MSwgYm94Mjtcblx0XHRpZiAoIG5vZGVTY29yZUZ1bmMgKSB7XG5cblx0XHRcdGJveDEgPSBfYm94MTtcblx0XHRcdGJveDIgPSBfYm94MjtcblxuXHRcdFx0Ly8gYm91bmRpbmcgZGF0YSBpcyBub3Qgb2Zmc2V0XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMSApLCBmbG9hdDMyQXJyYXksIGJveDEgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGMyICksIGZsb2F0MzJBcnJheSwgYm94MiApO1xuXG5cdFx0XHRzY29yZTEgPSBub2RlU2NvcmVGdW5jKCBib3gxICk7XG5cdFx0XHRzY29yZTIgPSBub2RlU2NvcmVGdW5jKCBib3gyICk7XG5cblx0XHRcdGlmICggc2NvcmUyIDwgc2NvcmUxICkge1xuXG5cdFx0XHRcdGMxID0gcmlnaHQ7XG5cdFx0XHRcdGMyID0gbGVmdDtcblxuXHRcdFx0XHRjb25zdCB0ZW1wID0gc2NvcmUxO1xuXHRcdFx0XHRzY29yZTEgPSBzY29yZTI7XG5cdFx0XHRcdHNjb3JlMiA9IHRlbXA7XG5cblx0XHRcdFx0Ym94MSA9IGJveDI7XG5cdFx0XHRcdC8vIGJveDIgaXMgYWx3YXlzIHNldCBiZWZvcmUgdXNlIGJlbG93XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGJveCAxIGludGVyc2VjdGlvblxuXHRcdGlmICggISBib3gxICkge1xuXG5cdFx0XHRib3gxID0gX2JveDE7XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMSApLCBmbG9hdDMyQXJyYXksIGJveDEgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGlzQzFMZWFmID0gSVNfTEVBRiggYzEgKiAyLCB1aW50MTZBcnJheSApO1xuXHRcdGNvbnN0IGMxSW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0c0JvdW5kc0Z1bmMoIGJveDEsIGlzQzFMZWFmLCBzY29yZTEsIGRlcHRoICsgMSwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIGMxICk7XG5cblx0XHRsZXQgYzFTdG9wVHJhdmVyc2FsO1xuXHRcdGlmICggYzFJbnRlcnNlY3Rpb24gPT09IENPTlRBSU5FRCApIHtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gZ2V0TGVmdE9mZnNldCggYzEgKTtcblx0XHRcdGNvbnN0IGVuZCA9IGdldFJpZ2h0RW5kT2Zmc2V0KCBjMSApO1xuXHRcdFx0Y29uc3QgY291bnQgPSBlbmQgLSBvZmZzZXQ7XG5cblx0XHRcdGMxU3RvcFRyYXZlcnNhbCA9IGludGVyc2VjdHNSYW5nZUZ1bmMoIG9mZnNldCwgY291bnQsIHRydWUsIGRlcHRoICsgMSwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIGMxLCBib3gxICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjMVN0b3BUcmF2ZXJzYWwgPVxuXHRcdFx0XHRjMUludGVyc2VjdGlvbiAmJlxuXHRcdFx0XHRzaGFwZWNhc3RUcmF2ZXJzZShcblx0XHRcdFx0XHRjMSxcblx0XHRcdFx0XHRnZW9tZXRyeSxcblx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzRnVuYyxcblx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2VGdW5jLFxuXHRcdFx0XHRcdG5vZGVTY29yZUZ1bmMsXG5cdFx0XHRcdFx0bm9kZUluZGV4Qnl0ZU9mZnNldCxcblx0XHRcdFx0XHRkZXB0aCArIDFcblx0XHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdGlmICggYzFTdG9wVHJhdmVyc2FsICkgcmV0dXJuIHRydWU7XG5cblx0XHQvLyBDaGVjayBib3ggMiBpbnRlcnNlY3Rpb25cblx0XHQvLyBjYWNoZWQgYm94MiB3aWxsIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiBieSBwcmV2aW91cyB0cmF2ZXJzYWxcblx0XHRib3gyID0gX2JveDI7XG5cdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggYzIgKSwgZmxvYXQzMkFycmF5LCBib3gyICk7XG5cblx0XHRjb25zdCBpc0MyTGVhZiA9IElTX0xFQUYoIGMyICogMiwgdWludDE2QXJyYXkgKTtcblx0XHRjb25zdCBjMkludGVyc2VjdGlvbiA9IGludGVyc2VjdHNCb3VuZHNGdW5jKCBib3gyLCBpc0MyTGVhZiwgc2NvcmUyLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMiApO1xuXG5cdFx0bGV0IGMyU3RvcFRyYXZlcnNhbDtcblx0XHRpZiAoIGMySW50ZXJzZWN0aW9uID09PSBDT05UQUlORUQgKSB7XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IGdldExlZnRPZmZzZXQoIGMyICk7XG5cdFx0XHRjb25zdCBlbmQgPSBnZXRSaWdodEVuZE9mZnNldCggYzIgKTtcblx0XHRcdGNvbnN0IGNvdW50ID0gZW5kIC0gb2Zmc2V0O1xuXG5cdFx0XHRjMlN0b3BUcmF2ZXJzYWwgPSBpbnRlcnNlY3RzUmFuZ2VGdW5jKCBvZmZzZXQsIGNvdW50LCB0cnVlLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMiwgYm94MiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YzJTdG9wVHJhdmVyc2FsID1cblx0XHRcdFx0YzJJbnRlcnNlY3Rpb24gJiZcblx0XHRcdFx0c2hhcGVjYXN0VHJhdmVyc2UoXG5cdFx0XHRcdFx0YzIsXG5cdFx0XHRcdFx0Z2VvbWV0cnksXG5cdFx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kc0Z1bmMsXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlRnVuYyxcblx0XHRcdFx0XHRub2RlU2NvcmVGdW5jLFxuXHRcdFx0XHRcdG5vZGVJbmRleEJ5dGVPZmZzZXQsXG5cdFx0XHRcdFx0ZGVwdGggKyAxXG5cdFx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGMyU3RvcFRyYXZlcnNhbCApIHJldHVybiB0cnVlO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0Ly8gRGVmaW5lIHRoZXNlIGluc2lkZSB0aGUgZnVuY3Rpb24gc28gaXQgaGFzIGFjY2VzcyB0byB0aGUgbG9jYWwgdmFyaWFibGVzIG5lZWRlZFxuXHRcdC8vIHdoZW4gY29udmVydGluZyB0byB0aGUgYnVmZmVyIGVxdWl2YWxlbnRzXG5cdFx0ZnVuY3Rpb24gZ2V0TGVmdE9mZnNldCggbm9kZUluZGV4MzIgKSB7XG5cblx0XHRcdGNvbnN0IHsgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0XHRcdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdFx0Ly8gdHJhdmVyc2UgdW50aWwgd2UgZmluZCBhIGxlYWZcblx0XHRcdHdoaWxlICggISBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKSApIHtcblxuXHRcdFx0XHRub2RlSW5kZXgzMiA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblx0XHRcdFx0bm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRSaWdodEVuZE9mZnNldCggbm9kZUluZGV4MzIgKSB7XG5cblx0XHRcdGNvbnN0IHsgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0XHRcdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdFx0Ly8gdHJhdmVyc2UgdW50aWwgd2UgZmluZCBhIGxlYWZcblx0XHRcdHdoaWxlICggISBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKSApIHtcblxuXHRcdFx0XHQvLyBhZGp1c3Qgb2Zmc2V0IHRvIHBvaW50IHRvIHRoZSByaWdodCBub2RlXG5cdFx0XHRcdG5vZGVJbmRleDMyID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRcdG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJldHVybiB0aGUgZW5kIG9mZnNldCBvZiB0aGUgdHJpYW5nbGUgcmFuZ2Vcblx0XHRcdHJldHVybiBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApICsgQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuIl0sIm5hbWVzIjpbIkJveDMiLCJDT05UQUlORUQiLCJhcnJheVRvQm94IiwiUHJpbWl0aXZlUG9vbCIsIkNPVU5UIiwiT0ZGU0VUIiwiTEVGVF9OT0RFIiwiUklHSFRfTk9ERSIsIklTX0xFQUYiLCJCT1VORElOR19EQVRBX0lOREVYIiwiQnVmZmVyU3RhY2siLCJfYm94MSIsIl9ib3gyIiwiYm94U3RhY2siLCJib3hQb29sIiwic2hhcGVjYXN0IiwiYnZoIiwicm9vdCIsImludGVyc2VjdHNCb3VuZHMiLCJpbnRlcnNlY3RzUmFuZ2UiLCJib3VuZHNUcmF2ZXJzZU9yZGVyIiwiYnl0ZU9mZnNldCIsImdldFByaW1pdGl2ZSIsInB1c2giLCJzZXRCdWZmZXIiLCJfcm9vdHMiLCJyZXN1bHQiLCJzaGFwZWNhc3RUcmF2ZXJzZSIsImdlb21ldHJ5IiwiY2xlYXJCdWZmZXIiLCJyZWxlYXNlUHJpbWl0aXZlIiwicG9wIiwibGVuZ3RoIiwibm9kZUluZGV4MzIiLCJpbnRlcnNlY3RzQm91bmRzRnVuYyIsImludGVyc2VjdHNSYW5nZUZ1bmMiLCJub2RlU2NvcmVGdW5jIiwibm9kZUluZGV4Qnl0ZU9mZnNldCIsImRlcHRoIiwiZmxvYXQzMkFycmF5IiwidWludDE2QXJyYXkiLCJ1aW50MzJBcnJheSIsIm5vZGVJbmRleDE2IiwiaXNMZWFmIiwib2Zmc2V0IiwiY291bnQiLCJsZWZ0IiwicmlnaHQiLCJjMSIsImMyIiwic2NvcmUxIiwic2NvcmUyIiwiYm94MSIsImJveDIiLCJ0ZW1wIiwiaXNDMUxlYWYiLCJjMUludGVyc2VjdGlvbiIsImMxU3RvcFRyYXZlcnNhbCIsImdldExlZnRPZmZzZXQiLCJlbmQiLCJnZXRSaWdodEVuZE9mZnNldCIsImlzQzJMZWFmIiwiYzJJbnRlcnNlY3Rpb24iLCJjMlN0b3BUcmF2ZXJzYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/cast/shapecast.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferStack: function() { return /* binding */ BufferStack; }\n/* harmony export */ });\nclass _BufferStack {\n    constructor(){\n        this.float32Array = null;\n        this.uint16Array = null;\n        this.uint32Array = null;\n        const stack = [];\n        let prevBuffer = null;\n        this.setBuffer = (buffer)=>{\n            if (prevBuffer) {\n                stack.push(prevBuffer);\n            }\n            prevBuffer = buffer;\n            this.float32Array = new Float32Array(buffer);\n            this.uint16Array = new Uint16Array(buffer);\n            this.uint32Array = new Uint32Array(buffer);\n        };\n        this.clearBuffer = ()=>{\n            prevBuffer = null;\n            this.float32Array = null;\n            this.uint16Array = null;\n            this.uint32Array = null;\n            if (stack.length !== 0) {\n                this.setBuffer(stack.pop());\n            }\n        };\n    }\n}\nconst BufferStack = new _BufferStack();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS91dGlscy9CdWZmZXJTdGFjay5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUE7SUFFTEMsYUFBYztRQUViLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBRW5CLE1BQU1DLFFBQVEsRUFBRTtRQUNoQixJQUFJQyxhQUFhO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQyxDQUFBQTtZQUVoQixJQUFLRixZQUFhO2dCQUVqQkQsTUFBTUksSUFBSSxDQUFFSDtZQUViO1lBRUFBLGFBQWFFO1lBQ2IsSUFBSSxDQUFDTixZQUFZLEdBQUcsSUFBSVEsYUFBY0Y7WUFDdEMsSUFBSSxDQUFDTCxXQUFXLEdBQUcsSUFBSVEsWUFBYUg7WUFDcEMsSUFBSSxDQUFDSixXQUFXLEdBQUcsSUFBSVEsWUFBYUo7UUFFckM7UUFFQSxJQUFJLENBQUNLLFdBQVcsR0FBRztZQUVsQlAsYUFBYTtZQUNiLElBQUksQ0FBQ0osWUFBWSxHQUFHO1lBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1lBQ25CLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1lBRW5CLElBQUtDLE1BQU1TLE1BQU0sS0FBSyxHQUFJO2dCQUV6QixJQUFJLENBQUNQLFNBQVMsQ0FBRUYsTUFBTVUsR0FBRztZQUUxQjtRQUVEO0lBRUQ7QUFFRDtBQUVPLE1BQU1DLGNBQWMsSUFBSWhCLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL3V0aWxzL0J1ZmZlclN0YWNrLmpzPzFlNDciXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgX0J1ZmZlclN0YWNrIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMuZmxvYXQzMkFycmF5ID0gbnVsbDtcblx0XHR0aGlzLnVpbnQxNkFycmF5ID0gbnVsbDtcblx0XHR0aGlzLnVpbnQzMkFycmF5ID0gbnVsbDtcblxuXHRcdGNvbnN0IHN0YWNrID0gW107XG5cdFx0bGV0IHByZXZCdWZmZXIgPSBudWxsO1xuXHRcdHRoaXMuc2V0QnVmZmVyID0gYnVmZmVyID0+IHtcblxuXHRcdFx0aWYgKCBwcmV2QnVmZmVyICkge1xuXG5cdFx0XHRcdHN0YWNrLnB1c2goIHByZXZCdWZmZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwcmV2QnVmZmVyID0gYnVmZmVyO1xuXHRcdFx0dGhpcy5mbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblx0XHRcdHRoaXMudWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGJ1ZmZlciApO1xuXHRcdFx0dGhpcy51aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5jbGVhckJ1ZmZlciA9ICgpID0+IHtcblxuXHRcdFx0cHJldkJ1ZmZlciA9IG51bGw7XG5cdFx0XHR0aGlzLmZsb2F0MzJBcnJheSA9IG51bGw7XG5cdFx0XHR0aGlzLnVpbnQxNkFycmF5ID0gbnVsbDtcblx0XHRcdHRoaXMudWludDMyQXJyYXkgPSBudWxsO1xuXG5cdFx0XHRpZiAoIHN0YWNrLmxlbmd0aCAhPT0gMCApIHtcblxuXHRcdFx0XHR0aGlzLnNldEJ1ZmZlciggc3RhY2sucG9wKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGNvbnN0IEJ1ZmZlclN0YWNrID0gbmV3IF9CdWZmZXJTdGFjaygpO1xuIl0sIm5hbWVzIjpbIl9CdWZmZXJTdGFjayIsImNvbnN0cnVjdG9yIiwiZmxvYXQzMkFycmF5IiwidWludDE2QXJyYXkiLCJ1aW50MzJBcnJheSIsInN0YWNrIiwicHJldkJ1ZmZlciIsInNldEJ1ZmZlciIsImJ1ZmZlciIsInB1c2giLCJGbG9hdDMyQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiY2xlYXJCdWZmZXIiLCJsZW5ndGgiLCJwb3AiLCJCdWZmZXJTdGFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectRay: function() { return /* binding */ intersectRay; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n\n\nconst _boundingBox = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\nfunction intersectRay(nodeIndex32, array, ray, target) {\n    (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.arrayToBox)(nodeIndex32, array, _boundingBox);\n    return ray.intersectBox(_boundingBox, target);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS91dGlscy9pbnRlcnNlY3RVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkI7QUFDaUM7QUFFOUQsTUFBTUUsZUFBZSxhQUFhLEdBQUcsSUFBSUYsdUNBQUlBO0FBQ3RDLFNBQVNHLGFBQWNDLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxHQUFHLEVBQUVDLE1BQU07SUFFNUROLHVFQUFVQSxDQUFFRyxhQUFhQyxPQUFPSDtJQUNoQyxPQUFPSSxJQUFJRSxZQUFZLENBQUVOLGNBQWNLO0FBRXhDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS91dGlscy9pbnRlcnNlY3RVdGlscy5qcz8wYTE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJveDMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBhcnJheVRvQm94IH0gZnJvbSAnLi4vLi4vdXRpbHMvQXJyYXlCb3hVdGlsaXRpZXMuanMnO1xuXG5jb25zdCBfYm91bmRpbmdCb3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IEJveDMoKTtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RSYXkoIG5vZGVJbmRleDMyLCBhcnJheSwgcmF5LCB0YXJnZXQgKSB7XG5cblx0YXJyYXlUb0JveCggbm9kZUluZGV4MzIsIGFycmF5LCBfYm91bmRpbmdCb3ggKTtcblx0cmV0dXJuIHJheS5pbnRlcnNlY3RCb3goIF9ib3VuZGluZ0JveCwgdGFyZ2V0ICk7XG5cbn1cbiJdLCJuYW1lcyI6WyJCb3gzIiwiYXJyYXlUb0JveCIsIl9ib3VuZGluZ0JveCIsImludGVyc2VjdFJheSIsIm5vZGVJbmRleDMyIiwiYXJyYXkiLCJyYXkiLCJ0YXJnZXQiLCJpbnRlcnNlY3RCb3giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js":
/*!********************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectClosestTri: function() { return /* binding */ intersectClosestTri; },\n/* harmony export */   intersectTris: function() { return /* binding */ intersectTris; },\n/* harmony export */   iterateOverTriangles: function() { return /* binding */ iterateOverTriangles; }\n/* harmony export */ });\n/* harmony import */ var _utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/ThreeRayIntersectUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n\n\n/*************************************************************/ /* This file is generated from \"iterationUtils.template.js\". */ /*************************************************************/ /* eslint-disable indent */ function intersectTris(bvh, side, ray, offset, count, intersections) {\n    const { geometry, _indirectBuffer } = bvh;\n    for(let i = offset, end = offset + count; i < end; i++){\n        (0,_utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__.intersectTri)(geometry, side, ray, i, intersections);\n    }\n}\nfunction intersectClosestTri(bvh, side, ray, offset, count) {\n    const { geometry, _indirectBuffer } = bvh;\n    let dist = Infinity;\n    let res = null;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let intersection;\n        intersection = (0,_utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__.intersectTri)(geometry, side, ray, i);\n        if (intersection && intersection.distance < dist) {\n            res = intersection;\n            dist = intersection.distance;\n        }\n    }\n    return res;\n}\nfunction iterateOverTriangles(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle) {\n    const { geometry } = bvh;\n    const { index } = geometry;\n    const pos = geometry.attributes.position;\n    for(let i = offset, l = count + offset; i < l; i++){\n        let tri;\n        tri = i;\n        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_1__.setTriangle)(triangle, tri * 3, index, pos);\n        triangle.needsUpdate = true;\n        if (intersectsTriangleFunc(triangle, tri, contained, depth)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS91dGlscy9pdGVyYXRpb25VdGlscy5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUU7QUFDVjtBQUUvRCw2REFBNkQsR0FDN0QsNkRBQTZELEdBQzdELDZEQUE2RCxHQUM3RCx5QkFBeUIsR0FFekIsU0FBU0UsY0FBZUMsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLGFBQWE7SUFFbkUsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLGVBQWUsRUFBRSxHQUFHUDtJQUN0QyxJQUFNLElBQUlRLElBQUlMLFFBQVFNLE1BQU1OLFNBQVNDLE9BQU9JLElBQUlDLEtBQUtELElBQU87UUFHM0RYLGtGQUFZQSxDQUFFUyxVQUFVTCxNQUFNQyxLQUFLTSxHQUFHSDtJQUd2QztBQUVEO0FBRUEsU0FBU0ssb0JBQXFCVixHQUFHLEVBQUVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLEtBQUs7SUFFMUQsTUFBTSxFQUFFRSxRQUFRLEVBQUVDLGVBQWUsRUFBRSxHQUFHUDtJQUN0QyxJQUFJVyxPQUFPQztJQUNYLElBQUlDLE1BQU07SUFDVixJQUFNLElBQUlMLElBQUlMLFFBQVFNLE1BQU1OLFNBQVNDLE9BQU9JLElBQUlDLEtBQUtELElBQU87UUFFM0QsSUFBSU07UUFFSkEsZUFBZWpCLGtGQUFZQSxDQUFFUyxVQUFVTCxNQUFNQyxLQUFLTTtRQUdsRCxJQUFLTSxnQkFBZ0JBLGFBQWFDLFFBQVEsR0FBR0osTUFBTztZQUVuREUsTUFBTUM7WUFDTkgsT0FBT0csYUFBYUMsUUFBUTtRQUU3QjtJQUVEO0lBRUEsT0FBT0Y7QUFFUjtBQUVBLFNBQVNHLHFCQUNSYixNQUFNLEVBQ05DLEtBQUssRUFDTEosR0FBRyxFQUNIaUIsc0JBQXNCLEVBQ3RCQyxTQUFTLEVBQ1RDLEtBQUssRUFDTEMsUUFBUTtJQUdSLE1BQU0sRUFBRWQsUUFBUSxFQUFFLEdBQUdOO0lBQ3JCLE1BQU0sRUFBRXFCLEtBQUssRUFBRSxHQUFHZjtJQUNsQixNQUFNZ0IsTUFBTWhCLFNBQVNpQixVQUFVLENBQUNDLFFBQVE7SUFDeEMsSUFBTSxJQUFJaEIsSUFBSUwsUUFBUXNCLElBQUlyQixRQUFRRCxRQUFRSyxJQUFJaUIsR0FBR2pCLElBQU87UUFFdkQsSUFBSWtCO1FBRUpBLE1BQU1sQjtRQUVOVix3RUFBV0EsQ0FBRXNCLFVBQVVNLE1BQU0sR0FBR0wsT0FBT0M7UUFDdkNGLFNBQVNPLFdBQVcsR0FBRztRQUV2QixJQUFLVix1QkFBd0JHLFVBQVVNLEtBQUtSLFdBQVdDLFFBQVU7WUFFaEUsT0FBTztRQUVSO0lBRUQ7SUFFQSxPQUFPO0FBRVI7QUFFb0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL3V0aWxzL2l0ZXJhdGlvblV0aWxzLmdlbmVyYXRlZC5qcz85MDQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGludGVyc2VjdFRyaSB9IGZyb20gJy4uLy4uL3V0aWxzL1RocmVlUmF5SW50ZXJzZWN0VXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IHNldFRyaWFuZ2xlIH0gZnJvbSAnLi4vLi4vdXRpbHMvVHJpYW5nbGVVdGlsaXRpZXMuanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcIml0ZXJhdGlvblV0aWxzLnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuXG5mdW5jdGlvbiBpbnRlcnNlY3RUcmlzKCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgaW50ZXJzZWN0aW9ucyApIHtcblxuXHRjb25zdCB7IGdlb21ldHJ5LCBfaW5kaXJlY3RCdWZmZXIgfSA9IGJ2aDtcblx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGNvdW50OyBpIDwgZW5kOyBpICsrICkge1xuXG5cblx0XHRpbnRlcnNlY3RUcmkoIGdlb21ldHJ5LCBzaWRlLCByYXksIGksIGludGVyc2VjdGlvbnMgKTtcblxuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RDbG9zZXN0VHJpKCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCApIHtcblxuXHRjb25zdCB7IGdlb21ldHJ5LCBfaW5kaXJlY3RCdWZmZXIgfSA9IGJ2aDtcblx0bGV0IGRpc3QgPSBJbmZpbml0eTtcblx0bGV0IHJlcyA9IG51bGw7XG5cdGZvciAoIGxldCBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGVuZDsgaSArKyApIHtcblxuXHRcdGxldCBpbnRlcnNlY3Rpb247XG5cblx0XHRpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RUcmkoIGdlb21ldHJ5LCBzaWRlLCByYXksIGkgKTtcblxuXG5cdFx0aWYgKCBpbnRlcnNlY3Rpb24gJiYgaW50ZXJzZWN0aW9uLmRpc3RhbmNlIDwgZGlzdCApIHtcblxuXHRcdFx0cmVzID0gaW50ZXJzZWN0aW9uO1xuXHRcdFx0ZGlzdCA9IGludGVyc2VjdGlvbi5kaXN0YW5jZTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHJlcztcblxufVxuXG5mdW5jdGlvbiBpdGVyYXRlT3ZlclRyaWFuZ2xlcyhcblx0b2Zmc2V0LFxuXHRjb3VudCxcblx0YnZoLFxuXHRpbnRlcnNlY3RzVHJpYW5nbGVGdW5jLFxuXHRjb250YWluZWQsXG5cdGRlcHRoLFxuXHR0cmlhbmdsZVxuKSB7XG5cblx0Y29uc3QgeyBnZW9tZXRyeSB9ID0gYnZoO1xuXHRjb25zdCB7IGluZGV4IH0gPSBnZW9tZXRyeTtcblx0Y29uc3QgcG9zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBjb3VudCArIG9mZnNldDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRsZXQgdHJpO1xuXG5cdFx0dHJpID0gaTtcblxuXHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgdHJpICogMywgaW5kZXgsIHBvcyApO1xuXHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyggdHJpYW5nbGUsIHRyaSwgY29udGFpbmVkLCBkZXB0aCApICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xuXG59XG5cbmV4cG9ydCB7IGludGVyc2VjdENsb3Nlc3RUcmksIGludGVyc2VjdFRyaXMsIGl0ZXJhdGVPdmVyVHJpYW5nbGVzIH07XG4iXSwibmFtZXMiOlsiaW50ZXJzZWN0VHJpIiwic2V0VHJpYW5nbGUiLCJpbnRlcnNlY3RUcmlzIiwiYnZoIiwic2lkZSIsInJheSIsIm9mZnNldCIsImNvdW50IiwiaW50ZXJzZWN0aW9ucyIsImdlb21ldHJ5IiwiX2luZGlyZWN0QnVmZmVyIiwiaSIsImVuZCIsImludGVyc2VjdENsb3Nlc3RUcmkiLCJkaXN0IiwiSW5maW5pdHkiLCJyZXMiLCJpbnRlcnNlY3Rpb24iLCJkaXN0YW5jZSIsIml0ZXJhdGVPdmVyVHJpYW5nbGVzIiwiaW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyIsImNvbnRhaW5lZCIsImRlcHRoIiwidHJpYW5nbGUiLCJpbmRleCIsInBvcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsImwiLCJ0cmkiLCJuZWVkc1VwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectClosestTri_indirect: function() { return /* binding */ intersectClosestTri_indirect; },\n/* harmony export */   intersectTris_indirect: function() { return /* binding */ intersectTris_indirect; },\n/* harmony export */   iterateOverTriangles_indirect: function() { return /* binding */ iterateOverTriangles_indirect; }\n/* harmony export */ });\n/* harmony import */ var _utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/ThreeRayIntersectUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n\n\n/*************************************************************/ /* This file is generated from \"iterationUtils.template.js\". */ /*************************************************************/ /* eslint-disable indent */ function intersectTris_indirect(bvh, side, ray, offset, count, intersections) {\n    const { geometry, _indirectBuffer } = bvh;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let vi = _indirectBuffer ? _indirectBuffer[i] : i;\n        (0,_utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__.intersectTri)(geometry, side, ray, vi, intersections);\n    }\n}\nfunction intersectClosestTri_indirect(bvh, side, ray, offset, count) {\n    const { geometry, _indirectBuffer } = bvh;\n    let dist = Infinity;\n    let res = null;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let intersection;\n        intersection = (0,_utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__.intersectTri)(geometry, side, ray, _indirectBuffer ? _indirectBuffer[i] : i);\n        if (intersection && intersection.distance < dist) {\n            res = intersection;\n            dist = intersection.distance;\n        }\n    }\n    return res;\n}\nfunction iterateOverTriangles_indirect(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle) {\n    const { geometry } = bvh;\n    const { index } = geometry;\n    const pos = geometry.attributes.position;\n    for(let i = offset, l = count + offset; i < l; i++){\n        let tri;\n        tri = bvh.resolveTriangleIndex(i);\n        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_1__.setTriangle)(triangle, tri * 3, index, pos);\n        triangle.needsUpdate = true;\n        if (intersectsTriangleFunc(triangle, tri, contained, depth)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS91dGlscy9pdGVyYXRpb25VdGlsc19pbmRpcmVjdC5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUU7QUFDVjtBQUUvRCw2REFBNkQsR0FDN0QsNkRBQTZELEdBQzdELDZEQUE2RCxHQUM3RCx5QkFBeUIsR0FFekIsU0FBU0UsdUJBQXdCQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsYUFBYTtJQUU1RSxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsZUFBZSxFQUFFLEdBQUdQO0lBQ3RDLElBQU0sSUFBSVEsSUFBSUwsUUFBUU0sTUFBTU4sU0FBU0MsT0FBT0ksSUFBSUMsS0FBS0QsSUFBTztRQUUzRCxJQUFJRSxLQUFLSCxrQkFBa0JBLGVBQWUsQ0FBRUMsRUFBRyxHQUFHQTtRQUNsRFgsa0ZBQVlBLENBQUVTLFVBQVVMLE1BQU1DLEtBQUtRLElBQUlMO0lBR3hDO0FBRUQ7QUFFQSxTQUFTTSw2QkFBOEJYLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsS0FBSztJQUVuRSxNQUFNLEVBQUVFLFFBQVEsRUFBRUMsZUFBZSxFQUFFLEdBQUdQO0lBQ3RDLElBQUlZLE9BQU9DO0lBQ1gsSUFBSUMsTUFBTTtJQUNWLElBQU0sSUFBSU4sSUFBSUwsUUFBUU0sTUFBTU4sU0FBU0MsT0FBT0ksSUFBSUMsS0FBS0QsSUFBTztRQUUzRCxJQUFJTztRQUNKQSxlQUFlbEIsa0ZBQVlBLENBQUVTLFVBQVVMLE1BQU1DLEtBQUtLLGtCQUFrQkEsZUFBZSxDQUFFQyxFQUFHLEdBQUdBO1FBRzNGLElBQUtPLGdCQUFnQkEsYUFBYUMsUUFBUSxHQUFHSixNQUFPO1lBRW5ERSxNQUFNQztZQUNOSCxPQUFPRyxhQUFhQyxRQUFRO1FBRTdCO0lBRUQ7SUFFQSxPQUFPRjtBQUVSO0FBRUEsU0FBU0csOEJBQ1JkLE1BQU0sRUFDTkMsS0FBSyxFQUNMSixHQUFHLEVBQ0hrQixzQkFBc0IsRUFDdEJDLFNBQVMsRUFDVEMsS0FBSyxFQUNMQyxRQUFRO0lBR1IsTUFBTSxFQUFFZixRQUFRLEVBQUUsR0FBR047SUFDckIsTUFBTSxFQUFFc0IsS0FBSyxFQUFFLEdBQUdoQjtJQUNsQixNQUFNaUIsTUFBTWpCLFNBQVNrQixVQUFVLENBQUNDLFFBQVE7SUFDeEMsSUFBTSxJQUFJakIsSUFBSUwsUUFBUXVCLElBQUl0QixRQUFRRCxRQUFRSyxJQUFJa0IsR0FBR2xCLElBQU87UUFFdkQsSUFBSW1CO1FBQ0pBLE1BQU0zQixJQUFJNEIsb0JBQW9CLENBQUVwQjtRQUVoQ1Ysd0VBQVdBLENBQUV1QixVQUFVTSxNQUFNLEdBQUdMLE9BQU9DO1FBQ3ZDRixTQUFTUSxXQUFXLEdBQUc7UUFFdkIsSUFBS1gsdUJBQXdCRyxVQUFVTSxLQUFLUixXQUFXQyxRQUFVO1lBRWhFLE9BQU87UUFFUjtJQUVEO0lBRUEsT0FBTztBQUVSO0FBRStGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS91dGlscy9pdGVyYXRpb25VdGlsc19pbmRpcmVjdC5nZW5lcmF0ZWQuanM/Y2U4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbnRlcnNlY3RUcmkgfSBmcm9tICcuLi8uLi91dGlscy9UaHJlZVJheUludGVyc2VjdFV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBzZXRUcmlhbmdsZSB9IGZyb20gJy4uLy4uL3V0aWxzL1RyaWFuZ2xlVXRpbGl0aWVzLmpzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJpdGVyYXRpb25VdGlscy50ZW1wbGF0ZS5qc1wiLiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cblxuZnVuY3Rpb24gaW50ZXJzZWN0VHJpc19pbmRpcmVjdCggYnZoLCBzaWRlLCByYXksIG9mZnNldCwgY291bnQsIGludGVyc2VjdGlvbnMgKSB7XG5cblx0Y29uc3QgeyBnZW9tZXRyeSwgX2luZGlyZWN0QnVmZmVyIH0gPSBidmg7XG5cdGZvciAoIGxldCBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGVuZDsgaSArKyApIHtcblxuXHRcdGxldCB2aSA9IF9pbmRpcmVjdEJ1ZmZlciA/IF9pbmRpcmVjdEJ1ZmZlclsgaSBdIDogaTtcblx0XHRpbnRlcnNlY3RUcmkoIGdlb21ldHJ5LCBzaWRlLCByYXksIHZpLCBpbnRlcnNlY3Rpb25zICk7XG5cblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0Q2xvc2VzdFRyaV9pbmRpcmVjdCggYnZoLCBzaWRlLCByYXksIG9mZnNldCwgY291bnQgKSB7XG5cblx0Y29uc3QgeyBnZW9tZXRyeSwgX2luZGlyZWN0QnVmZmVyIH0gPSBidmg7XG5cdGxldCBkaXN0ID0gSW5maW5pdHk7XG5cdGxldCByZXMgPSBudWxsO1xuXHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblx0XHRsZXQgaW50ZXJzZWN0aW9uO1xuXHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdFRyaSggZ2VvbWV0cnksIHNpZGUsIHJheSwgX2luZGlyZWN0QnVmZmVyID8gX2luZGlyZWN0QnVmZmVyWyBpIF0gOiBpICk7XG5cblxuXHRcdGlmICggaW50ZXJzZWN0aW9uICYmIGludGVyc2VjdGlvbi5kaXN0YW5jZSA8IGRpc3QgKSB7XG5cblx0XHRcdHJlcyA9IGludGVyc2VjdGlvbjtcblx0XHRcdGRpc3QgPSBpbnRlcnNlY3Rpb24uZGlzdGFuY2U7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiByZXM7XG5cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZU92ZXJUcmlhbmdsZXNfaW5kaXJlY3QoXG5cdG9mZnNldCxcblx0Y291bnQsXG5cdGJ2aCxcblx0aW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyxcblx0Y29udGFpbmVkLFxuXHRkZXB0aCxcblx0dHJpYW5nbGVcbikge1xuXG5cdGNvbnN0IHsgZ2VvbWV0cnkgfSA9IGJ2aDtcblx0Y29uc3QgeyBpbmRleCB9ID0gZ2VvbWV0cnk7XG5cdGNvbnN0IHBvcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gY291bnQgKyBvZmZzZXQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0bGV0IHRyaTtcblx0XHR0cmkgPSBidmgucmVzb2x2ZVRyaWFuZ2xlSW5kZXgoIGkgKTtcblxuXHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgdHJpICogMywgaW5kZXgsIHBvcyApO1xuXHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyggdHJpYW5nbGUsIHRyaSwgY29udGFpbmVkLCBkZXB0aCApICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xuXG59XG5cbmV4cG9ydCB7IGludGVyc2VjdENsb3Nlc3RUcmlfaW5kaXJlY3QsIGludGVyc2VjdFRyaXNfaW5kaXJlY3QsIGl0ZXJhdGVPdmVyVHJpYW5nbGVzX2luZGlyZWN0IH07XG4iXSwibmFtZXMiOlsiaW50ZXJzZWN0VHJpIiwic2V0VHJpYW5nbGUiLCJpbnRlcnNlY3RUcmlzX2luZGlyZWN0IiwiYnZoIiwic2lkZSIsInJheSIsIm9mZnNldCIsImNvdW50IiwiaW50ZXJzZWN0aW9ucyIsImdlb21ldHJ5IiwiX2luZGlyZWN0QnVmZmVyIiwiaSIsImVuZCIsInZpIiwiaW50ZXJzZWN0Q2xvc2VzdFRyaV9pbmRpcmVjdCIsImRpc3QiLCJJbmZpbml0eSIsInJlcyIsImludGVyc2VjdGlvbiIsImRpc3RhbmNlIiwiaXRlcmF0ZU92ZXJUcmlhbmdsZXNfaW5kaXJlY3QiLCJpbnRlcnNlY3RzVHJpYW5nbGVGdW5jIiwiY29udGFpbmVkIiwiZGVwdGgiLCJ0cmlhbmdsZSIsImluZGV4IiwicG9zIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwibCIsInRyaSIsInJlc29sdmVUcmlhbmdsZUluZGV4IiwibmVlZHNVcGRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BOUNDING_DATA_INDEX: function() { return /* binding */ BOUNDING_DATA_INDEX; },\n/* harmony export */   COUNT: function() { return /* binding */ COUNT; },\n/* harmony export */   IS_LEAF: function() { return /* binding */ IS_LEAF; },\n/* harmony export */   LEFT_NODE: function() { return /* binding */ LEFT_NODE; },\n/* harmony export */   OFFSET: function() { return /* binding */ OFFSET; },\n/* harmony export */   RIGHT_NODE: function() { return /* binding */ RIGHT_NODE; },\n/* harmony export */   SPLIT_AXIS: function() { return /* binding */ SPLIT_AXIS; }\n/* harmony export */ });\nfunction IS_LEAF(n16, uint16Array) {\n    return uint16Array[n16 + 15] === 0xFFFF;\n}\n_c = IS_LEAF;\nfunction OFFSET(n32, uint32Array) {\n    return uint32Array[n32 + 6];\n}\n_c1 = OFFSET;\nfunction COUNT(n16, uint16Array) {\n    return uint16Array[n16 + 14];\n}\n_c2 = COUNT;\nfunction LEFT_NODE(n32) {\n    return n32 + 8;\n}\n_c3 = LEFT_NODE;\nfunction RIGHT_NODE(n32, uint32Array) {\n    return uint32Array[n32 + 6];\n}\n_c4 = RIGHT_NODE;\nfunction SPLIT_AXIS(n32, uint32Array) {\n    return uint32Array[n32 + 7];\n}\n_c5 = SPLIT_AXIS;\nfunction BOUNDING_DATA_INDEX(n32) {\n    return n32;\n}\n_c6 = BOUNDING_DATA_INDEX;\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6;\n$RefreshReg$(_c, \"IS_LEAF\");\n$RefreshReg$(_c1, \"OFFSET\");\n$RefreshReg$(_c2, \"COUNT\");\n$RefreshReg$(_c3, \"LEFT_NODE\");\n$RefreshReg$(_c4, \"RIGHT_NODE\");\n$RefreshReg$(_c5, \"SPLIT_AXIS\");\n$RefreshReg$(_c6, \"BOUNDING_DATA_INDEX\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS91dGlscy9ub2RlQnVmZmVyVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFPLFNBQVNBLFFBQVNDLEdBQUcsRUFBRUMsV0FBVztJQUV4QyxPQUFPQSxXQUFXLENBQUVELE1BQU0sR0FBSSxLQUFLO0FBRXBDO0tBSmdCRDtBQU1ULFNBQVNHLE9BQVFDLEdBQUcsRUFBRUMsV0FBVztJQUV2QyxPQUFPQSxXQUFXLENBQUVELE1BQU0sRUFBRztBQUU5QjtNQUpnQkQ7QUFNVCxTQUFTRyxNQUFPTCxHQUFHLEVBQUVDLFdBQVc7SUFFdEMsT0FBT0EsV0FBVyxDQUFFRCxNQUFNLEdBQUk7QUFFL0I7TUFKZ0JLO0FBTVQsU0FBU0MsVUFBV0gsR0FBRztJQUU3QixPQUFPQSxNQUFNO0FBRWQ7TUFKZ0JHO0FBTVQsU0FBU0MsV0FBWUosR0FBRyxFQUFFQyxXQUFXO0lBRTNDLE9BQU9BLFdBQVcsQ0FBRUQsTUFBTSxFQUFHO0FBRTlCO01BSmdCSTtBQU1ULFNBQVNDLFdBQVlMLEdBQUcsRUFBRUMsV0FBVztJQUUzQyxPQUFPQSxXQUFXLENBQUVELE1BQU0sRUFBRztBQUU5QjtNQUpnQks7QUFNVCxTQUFTQyxvQkFBcUJOLEdBQUc7SUFFdkMsT0FBT0E7QUFFUjtNQUpnQk0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL3V0aWxzL25vZGVCdWZmZXJVdGlscy5qcz83YTg1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBJU19MRUFGKCBuMTYsIHVpbnQxNkFycmF5ICkge1xuXG5cdHJldHVybiB1aW50MTZBcnJheVsgbjE2ICsgMTUgXSA9PT0gMHhGRkZGO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPRkZTRVQoIG4zMiwgdWludDMyQXJyYXkgKSB7XG5cblx0cmV0dXJuIHVpbnQzMkFycmF5WyBuMzIgKyA2IF07XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENPVU5UKCBuMTYsIHVpbnQxNkFycmF5ICkge1xuXG5cdHJldHVybiB1aW50MTZBcnJheVsgbjE2ICsgMTQgXTtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gTEVGVF9OT0RFKCBuMzIgKSB7XG5cblx0cmV0dXJuIG4zMiArIDg7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJJR0hUX05PREUoIG4zMiwgdWludDMyQXJyYXkgKSB7XG5cblx0cmV0dXJuIHVpbnQzMkFycmF5WyBuMzIgKyA2IF07XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFNQTElUX0FYSVMoIG4zMiwgdWludDMyQXJyYXkgKSB7XG5cblx0cmV0dXJuIHVpbnQzMkFycmF5WyBuMzIgKyA3IF07XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEJPVU5ESU5HX0RBVEFfSU5ERVgoIG4zMiApIHtcblxuXHRyZXR1cm4gbjMyO1xuXG59XG4iXSwibmFtZXMiOlsiSVNfTEVBRiIsIm4xNiIsInVpbnQxNkFycmF5IiwiT0ZGU0VUIiwibjMyIiwidWludDMyQXJyYXkiLCJDT1VOVCIsIkxFRlRfTk9ERSIsIlJJR0hUX05PREUiLCJTUExJVF9BWElTIiwiQk9VTkRJTkdfREFUQV9JTkRFWCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js":
/*!******************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtendedTriangle: function() { return /* binding */ ExtendedTriangle; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SeparatingAxisBounds.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js\");\n/* harmony import */ var _MathUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MathUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/MathUtilities.js\");\n\n\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero(value) {\n    return Math.abs(value) < ZERO_EPSILON;\n}\nclass ExtendedTriangle extends three__WEBPACK_IMPORTED_MODULE_0__.Triangle {\n    intersectsSphere(sphere) {\n        return (0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_1__.sphereIntersectTriangle)(sphere, this);\n    }\n    update() {\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const points = this.points;\n        const satAxes = this.satAxes;\n        const satBounds = this.satBounds;\n        const axis0 = satAxes[0];\n        const sab0 = satBounds[0];\n        this.getNormal(axis0);\n        sab0.setFromPoints(axis0, points);\n        const axis1 = satAxes[1];\n        const sab1 = satBounds[1];\n        axis1.subVectors(a, b);\n        sab1.setFromPoints(axis1, points);\n        const axis2 = satAxes[2];\n        const sab2 = satBounds[2];\n        axis2.subVectors(b, c);\n        sab2.setFromPoints(axis2, points);\n        const axis3 = satAxes[3];\n        const sab3 = satBounds[3];\n        axis3.subVectors(c, a);\n        sab3.setFromPoints(axis3, points);\n        this.sphere.setFromPoints(this.points);\n        this.plane.setFromNormalAndCoplanarPoint(axis0, a);\n        this.needsUpdate = false;\n    }\n    constructor(...args){\n        super(...args);\n        this.isExtendedTriangle = true;\n        this.satAxes = new Array(4).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n        this.satBounds = new Array(4).fill().map(()=>new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_2__.SeparatingAxisBounds());\n        this.points = [\n            this.a,\n            this.b,\n            this.c\n        ];\n        this.sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.plane = new three__WEBPACK_IMPORTED_MODULE_0__.Plane();\n        this.needsUpdate = true;\n    }\n}\nExtendedTriangle.prototype.closestPointToSegment = function() {\n    const point1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const point2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const edge = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    return function distanceToSegment(segment) {\n        let target1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, target2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n        const { start, end } = segment;\n        const points = this.points;\n        let distSq;\n        let closestDistanceSq = Infinity;\n        // check the triangle edges\n        for(let i = 0; i < 3; i++){\n            const nexti = (i + 1) % 3;\n            edge.start.copy(points[i]);\n            edge.end.copy(points[nexti]);\n            (0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_1__.closestPointsSegmentToSegment)(edge, segment, point1, point2);\n            distSq = point1.distanceToSquared(point2);\n            if (distSq < closestDistanceSq) {\n                closestDistanceSq = distSq;\n                if (target1) target1.copy(point1);\n                if (target2) target2.copy(point2);\n            }\n        }\n        // check end points\n        this.closestPointToPoint(start, point1);\n        distSq = start.distanceToSquared(point1);\n        if (distSq < closestDistanceSq) {\n            closestDistanceSq = distSq;\n            if (target1) target1.copy(point1);\n            if (target2) target2.copy(start);\n        }\n        this.closestPointToPoint(end, point1);\n        distSq = end.distanceToSquared(point1);\n        if (distSq < closestDistanceSq) {\n            closestDistanceSq = distSq;\n            if (target1) target1.copy(point1);\n            if (target2) target2.copy(end);\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\nExtendedTriangle.prototype.intersectsTriangle = function() {\n    const saTri2 = new ExtendedTriangle();\n    const arr1 = new Array(3);\n    const arr2 = new Array(3);\n    const cachedSatBounds = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_2__.SeparatingAxisBounds();\n    const cachedSatBounds2 = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_2__.SeparatingAxisBounds();\n    const cachedAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const dir = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const dir1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const dir2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempDir = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const edge = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    const edge1 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    const edge2 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    const tempPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function triIntersectPlane(tri, plane, targetEdge) {\n        // find the edge that intersects the other triangle plane\n        const points = tri.points;\n        let count = 0;\n        let startPointIntersection = -1;\n        for(let i = 0; i < 3; i++){\n            const { start, end } = edge;\n            start.copy(points[i]);\n            end.copy(points[(i + 1) % 3]);\n            edge.delta(dir);\n            const startIntersects = isNearZero(plane.distanceToPoint(start));\n            if (isNearZero(plane.normal.dot(dir)) && startIntersects) {\n                // if the edge lies on the plane then take the line\n                targetEdge.copy(edge);\n                count = 2;\n                break;\n            }\n            // check if the start point is near the plane because \"intersectLine\" is not robust to that case\n            const doesIntersect = plane.intersectLine(edge, tempPoint);\n            if (!doesIntersect && startIntersects) {\n                tempPoint.copy(start);\n            }\n            // ignore the end point\n            if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {\n                if (count <= 1) {\n                    // assign to the start or end point and save which index was snapped to\n                    // the start point if necessary\n                    const point = count === 1 ? targetEdge.start : targetEdge.end;\n                    point.copy(tempPoint);\n                    if (startIntersects) {\n                        startPointIntersection = count;\n                    }\n                } else if (count >= 2) {\n                    // if we're here that means that there must have been one point that had\n                    // snapped to the start point so replace it here\n                    const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n                    point.copy(tempPoint);\n                    count = 2;\n                    break;\n                }\n                count++;\n                if (count === 2 && startPointIntersection === -1) {\n                    break;\n                }\n            }\n        }\n        return count;\n    }\n    // TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n    // be a line contained by both triangles if not a different special case somehow represented in the return result.\n    return function intersectsTriangle(other) {\n        let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, suppressLog = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        if (this.needsUpdate) {\n            this.update();\n        }\n        if (!other.isExtendedTriangle) {\n            saTri2.copy(other);\n            saTri2.update();\n            other = saTri2;\n        } else if (other.needsUpdate) {\n            other.update();\n        }\n        const plane1 = this.plane;\n        const plane2 = other.plane;\n        if (Math.abs(plane1.normal.dot(plane2.normal)) > 1.0 - 1e-10) {\n            // perform separating axis intersection test only for coplanar triangles\n            const satBounds1 = this.satBounds;\n            const satAxes1 = this.satAxes;\n            arr2[0] = other.a;\n            arr2[1] = other.b;\n            arr2[2] = other.c;\n            for(let i = 0; i < 4; i++){\n                const sb = satBounds1[i];\n                const sa = satAxes1[i];\n                cachedSatBounds.setFromPoints(sa, arr2);\n                if (sb.isSeparated(cachedSatBounds)) return false;\n            }\n            const satBounds2 = other.satBounds;\n            const satAxes2 = other.satAxes;\n            arr1[0] = this.a;\n            arr1[1] = this.b;\n            arr1[2] = this.c;\n            for(let i = 0; i < 4; i++){\n                const sb = satBounds2[i];\n                const sa = satAxes2[i];\n                cachedSatBounds.setFromPoints(sa, arr1);\n                if (sb.isSeparated(cachedSatBounds)) return false;\n            }\n            // check crossed axes\n            for(let i = 0; i < 4; i++){\n                const sa1 = satAxes1[i];\n                for(let i2 = 0; i2 < 4; i2++){\n                    const sa2 = satAxes2[i2];\n                    cachedAxis.crossVectors(sa1, sa2);\n                    cachedSatBounds.setFromPoints(cachedAxis, arr1);\n                    cachedSatBounds2.setFromPoints(cachedAxis, arr2);\n                    if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n                }\n            }\n            if (target) {\n                // TODO find two points that intersect on the edges and make that the result\n                if (!suppressLog) {\n                    console.warn(\"ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.\");\n                }\n                target.start.set(0, 0, 0);\n                target.end.set(0, 0, 0);\n            }\n            return true;\n        } else {\n            // find the edge that intersects the other triangle plane\n            const count1 = triIntersectPlane(this, plane2, edge1);\n            if (count1 === 1 && other.containsPoint(edge1.end)) {\n                if (target) {\n                    target.start.copy(edge1.end);\n                    target.end.copy(edge1.end);\n                }\n                return true;\n            } else if (count1 !== 2) {\n                return false;\n            }\n            // find the other triangles edge that intersects this plane\n            const count2 = triIntersectPlane(other, plane1, edge2);\n            if (count2 === 1 && this.containsPoint(edge2.end)) {\n                if (target) {\n                    target.start.copy(edge2.end);\n                    target.end.copy(edge2.end);\n                }\n                return true;\n            } else if (count2 !== 2) {\n                return false;\n            }\n            // find swap the second edge so both lines are running the same direction\n            edge1.delta(dir1);\n            edge2.delta(dir2);\n            if (dir1.dot(dir2) < 0) {\n                let tmp = edge2.start;\n                edge2.start = edge2.end;\n                edge2.end = tmp;\n            }\n            // check if the edges are overlapping\n            const s1 = edge1.start.dot(dir1);\n            const e1 = edge1.end.dot(dir1);\n            const s2 = edge2.start.dot(dir1);\n            const e2 = edge2.end.dot(dir1);\n            const separated1 = e1 < s2;\n            const separated2 = s1 < e2;\n            if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {\n                return false;\n            }\n            // assign the target output\n            if (target) {\n                tempDir.subVectors(edge1.start, edge2.start);\n                if (tempDir.dot(dir1) > 0) {\n                    target.start.copy(edge1.start);\n                } else {\n                    target.start.copy(edge2.start);\n                }\n                tempDir.subVectors(edge1.end, edge2.end);\n                if (tempDir.dot(dir1) < 0) {\n                    target.end.copy(edge1.end);\n                } else {\n                    target.end.copy(edge2.end);\n                }\n            }\n            return true;\n        }\n    };\n}();\nExtendedTriangle.prototype.distanceToPoint = function() {\n    const target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function distanceToPoint(point) {\n        this.closestPointToPoint(point, target);\n        return point.distanceTo(target);\n    };\n}();\nExtendedTriangle.prototype.distanceToTriangle = function() {\n    const point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const point2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const cornerFields = [\n        \"a\",\n        \"b\",\n        \"c\"\n    ];\n    const line1 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    const line2 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    return function distanceToTriangle(other) {\n        let target1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, target2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n        const lineTarget = target1 || target2 ? line1 : null;\n        if (this.intersectsTriangle(other, lineTarget)) {\n            if (target1 || target2) {\n                if (target1) lineTarget.getCenter(target1);\n                if (target2) lineTarget.getCenter(target2);\n            }\n            return 0;\n        }\n        let closestDistanceSq = Infinity;\n        // check all point distances\n        for(let i = 0; i < 3; i++){\n            let dist;\n            const field = cornerFields[i];\n            const otherVec = other[field];\n            this.closestPointToPoint(otherVec, point);\n            dist = otherVec.distanceToSquared(point);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(point);\n                if (target2) target2.copy(otherVec);\n            }\n            const thisVec = this[field];\n            other.closestPointToPoint(thisVec, point);\n            dist = thisVec.distanceToSquared(point);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(thisVec);\n                if (target2) target2.copy(point);\n            }\n        }\n        for(let i = 0; i < 3; i++){\n            const f11 = cornerFields[i];\n            const f12 = cornerFields[(i + 1) % 3];\n            line1.set(this[f11], this[f12]);\n            for(let i2 = 0; i2 < 3; i2++){\n                const f21 = cornerFields[i2];\n                const f22 = cornerFields[(i2 + 1) % 3];\n                line2.set(other[f21], other[f22]);\n                (0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_1__.closestPointsSegmentToSegment)(line1, line2, point, point2);\n                const dist = point.distanceToSquared(point2);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point);\n                    if (target2) target2.copy(point2);\n                }\n            }\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvbWF0aC9FeHRlbmRlZFRyaWFuZ2xlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0U7QUFDQztBQUMyQjtBQUU1RixNQUFNUSxlQUFlO0FBQ3JCLFNBQVNDLFdBQVlDLEtBQUs7SUFFekIsT0FBT0MsS0FBS0MsR0FBRyxDQUFFRixTQUFVRjtBQUU1QjtBQUVPLE1BQU1LLHlCQUF5QmIsMkNBQVFBO0lBZ0I3Q2MsaUJBQWtCQyxNQUFNLEVBQUc7UUFFMUIsT0FBT1IsMEVBQXVCQSxDQUFFUSxRQUFRLElBQUk7SUFFN0M7SUFFQUMsU0FBUztRQUVSLE1BQU1DLElBQUksSUFBSSxDQUFDQSxDQUFDO1FBQ2hCLE1BQU1DLElBQUksSUFBSSxDQUFDQSxDQUFDO1FBQ2hCLE1BQU1DLElBQUksSUFBSSxDQUFDQSxDQUFDO1FBQ2hCLE1BQU1DLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBRTFCLE1BQU1DLFVBQVUsSUFBSSxDQUFDQSxPQUFPO1FBQzVCLE1BQU1DLFlBQVksSUFBSSxDQUFDQSxTQUFTO1FBRWhDLE1BQU1DLFFBQVFGLE9BQU8sQ0FBRSxFQUFHO1FBQzFCLE1BQU1HLE9BQU9GLFNBQVMsQ0FBRSxFQUFHO1FBQzNCLElBQUksQ0FBQ0csU0FBUyxDQUFFRjtRQUNoQkMsS0FBS0UsYUFBYSxDQUFFSCxPQUFPSDtRQUUzQixNQUFNTyxRQUFRTixPQUFPLENBQUUsRUFBRztRQUMxQixNQUFNTyxPQUFPTixTQUFTLENBQUUsRUFBRztRQUMzQkssTUFBTUUsVUFBVSxDQUFFWixHQUFHQztRQUNyQlUsS0FBS0YsYUFBYSxDQUFFQyxPQUFPUDtRQUUzQixNQUFNVSxRQUFRVCxPQUFPLENBQUUsRUFBRztRQUMxQixNQUFNVSxPQUFPVCxTQUFTLENBQUUsRUFBRztRQUMzQlEsTUFBTUQsVUFBVSxDQUFFWCxHQUFHQztRQUNyQlksS0FBS0wsYUFBYSxDQUFFSSxPQUFPVjtRQUUz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SUFBSzVFLFNBQVVBLFFBQVFTLElBQUksQ0FBRXNFO2dCQUM3QixJQUFLOUUsU0FBVUEsUUFBUVEsSUFBSSxDQUFFK0I7WUFFOUI7UUFFRDtRQUVBLElBQU0sSUFBSWpDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFPO1lBRTlCLE1BQU15RSxNQUFNVCxZQUFZLENBQUVoRSxFQUFHO1lBQzdCLE1BQU0wRSxNQUFNVixZQUFZLENBQUUsQ0FBRWhFLElBQUksS0FBTSxFQUFHO1lBQ3pDaUUsTUFBTWIsR0FBRyxDQUFFLElBQUksQ0FBRXFCLElBQUssRUFBRSxJQUFJLENBQUVDLElBQUs7WUFDbkMsSUFBTSxJQUFJM0IsS0FBSyxHQUFHQSxLQUFLLEdBQUdBLEtBQVE7Z0JBRWpDLE1BQU00QixNQUFNWCxZQUFZLENBQUVqQixHQUFJO2dCQUM5QixNQUFNNkIsTUFBTVosWUFBWSxDQUFFLENBQUVqQixLQUFLLEtBQU0sRUFBRztnQkFDMUNtQixNQUFNZCxHQUFHLENBQUVsQixLQUFLLENBQUV5QyxJQUFLLEVBQUV6QyxLQUFLLENBQUUwQyxJQUFLO2dCQUVyQy9ILGdGQUE2QkEsQ0FBRW9ILE9BQU9DLE9BQU9qQyxPQUFPNUM7Z0JBRXBELE1BQU1nRixPQUFPcEMsTUFBTTlCLGlCQUFpQixDQUFFZDtnQkFDdEMsSUFBS2dGLE9BQU92RSxtQkFBb0I7b0JBRS9CQSxvQkFBb0J1RTtvQkFDcEIsSUFBSzVFLFNBQVVBLFFBQVFTLElBQUksQ0FBRStCO29CQUM3QixJQUFLdkMsU0FBVUEsUUFBUVEsSUFBSSxDQUFFYjtnQkFFOUI7WUFFRDtRQUVEO1FBRUEsT0FBT25DLEtBQUttRCxJQUFJLENBQUVQO0lBRW5CO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9tYXRoL0V4dGVuZGVkVHJpYW5nbGUuanM/NjYzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmlhbmdsZSwgVmVjdG9yMywgTGluZTMsIFNwaGVyZSwgUGxhbmUgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBTZXBhcmF0aW5nQXhpc0JvdW5kcyB9IGZyb20gJy4vU2VwYXJhdGluZ0F4aXNCb3VuZHMuanMnO1xuaW1wb3J0IHsgY2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQsIHNwaGVyZUludGVyc2VjdFRyaWFuZ2xlIH0gZnJvbSAnLi9NYXRoVXRpbGl0aWVzLmpzJztcblxuY29uc3QgWkVST19FUFNJTE9OID0gMWUtMTU7XG5mdW5jdGlvbiBpc05lYXJaZXJvKCB2YWx1ZSApIHtcblxuXHRyZXR1cm4gTWF0aC5hYnMoIHZhbHVlICkgPCBaRVJPX0VQU0lMT047XG5cbn1cblxuZXhwb3J0IGNsYXNzIEV4dGVuZGVkVHJpYW5nbGUgZXh0ZW5kcyBUcmlhbmdsZSB7XG5cblx0Y29uc3RydWN0b3IoIC4uLmFyZ3MgKSB7XG5cblx0XHRzdXBlciggLi4uYXJncyApO1xuXG5cdFx0dGhpcy5pc0V4dGVuZGVkVHJpYW5nbGUgPSB0cnVlO1xuXHRcdHRoaXMuc2F0QXhlcyA9IG5ldyBBcnJheSggNCApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBWZWN0b3IzKCkgKTtcblx0XHR0aGlzLnNhdEJvdW5kcyA9IG5ldyBBcnJheSggNCApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpICk7XG5cdFx0dGhpcy5wb2ludHMgPSBbIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgXTtcblx0XHR0aGlzLnNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblx0XHR0aGlzLnBsYW5lID0gbmV3IFBsYW5lKCk7XG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdHJldHVybiBzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSggc3BoZXJlLCB0aGlzICk7XG5cblx0fVxuXG5cdHVwZGF0ZSgpIHtcblxuXHRcdGNvbnN0IGEgPSB0aGlzLmE7XG5cdFx0Y29uc3QgYiA9IHRoaXMuYjtcblx0XHRjb25zdCBjID0gdGhpcy5jO1xuXHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXG5cdFx0Y29uc3Qgc2F0QXhlcyA9IHRoaXMuc2F0QXhlcztcblx0XHRjb25zdCBzYXRCb3VuZHMgPSB0aGlzLnNhdEJvdW5kcztcblxuXHRcdGNvbnN0IGF4aXMwID0gc2F0QXhlc1sgMCBdO1xuXHRcdGNvbnN0IHNhYjAgPSBzYXRCb3VuZHNbIDAgXTtcblx0XHR0aGlzLmdldE5vcm1hbCggYXhpczAgKTtcblx0XHRzYWIwLnNldEZyb21Qb2ludHMoIGF4aXMwLCBwb2ludHMgKTtcblxuXHRcdGNvbnN0IGF4aXMxID0gc2F0QXhlc1sgMSBdO1xuXHRcdGNvbnN0IHNhYjEgPSBzYXRCb3VuZHNbIDEgXTtcblx0XHRheGlzMS5zdWJWZWN0b3JzKCBhLCBiICk7XG5cdFx0c2FiMS5zZXRGcm9tUG9pbnRzKCBheGlzMSwgcG9pbnRzICk7XG5cblx0XHRjb25zdCBheGlzMiA9IHNhdEF4ZXNbIDIgXTtcblx0XHRjb25zdCBzYWIyID0gc2F0Qm91bmRzWyAyIF07XG5cdFx0YXhpczIuc3ViVmVjdG9ycyggYiwgYyApO1xuXHRcdHNhYjIuc2V0RnJvbVBvaW50cyggYXhpczIsIHBvaW50cyApO1xuXG5cdFx0Y29uc3QgYXhpczMgPSBzYXRBeGVzWyAzIF07XG5cdFx0Y29uc3Qgc2FiMyA9IHNhdEJvdW5kc1sgMyBdO1xuXHRcdGF4aXMzLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHRzYWIzLnNldEZyb21Qb2ludHMoIGF4aXMzLCBwb2ludHMgKTtcblxuXHRcdHRoaXMuc3BoZXJlLnNldEZyb21Qb2ludHMoIHRoaXMucG9pbnRzICk7XG5cdFx0dGhpcy5wbGFuZS5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggYXhpczAsIGEgKTtcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0fVxuXG59XG5cbkV4dGVuZGVkVHJpYW5nbGUucHJvdG90eXBlLmNsb3Nlc3RQb2ludFRvU2VnbWVudCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdGNvbnN0IHBvaW50MSA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IHBvaW50MiA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IGVkZ2UgPSBuZXcgTGluZTMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1NlZ21lbnQoIHNlZ21lbnQsIHRhcmdldDEgPSBudWxsLCB0YXJnZXQyID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VnbWVudDtcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRsZXQgZGlzdFNxO1xuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2VTcSA9IEluZmluaXR5O1xuXG5cdFx0Ly8gY2hlY2sgdGhlIHRyaWFuZ2xlIGVkZ2VzXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgbmV4dGkgPSAoIGkgKyAxICkgJSAzO1xuXHRcdFx0ZWRnZS5zdGFydC5jb3B5KCBwb2ludHNbIGkgXSApO1xuXHRcdFx0ZWRnZS5lbmQuY29weSggcG9pbnRzWyBuZXh0aSBdICk7XG5cblx0XHRcdGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBlZGdlLCBzZWdtZW50LCBwb2ludDEsIHBvaW50MiApO1xuXG5cdFx0XHRkaXN0U3EgPSBwb2ludDEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MiApO1xuXHRcdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludDEgKTtcblx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgZW5kIHBvaW50c1xuXHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggc3RhcnQsIHBvaW50MSApO1xuXHRcdGRpc3RTcSA9IHN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludDEgKTtcblx0XHRpZiAoIGRpc3RTcSA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHN0YXJ0ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGVuZCwgcG9pbnQxICk7XG5cdFx0ZGlzdFNxID0gZW5kLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludDEgKTtcblx0XHRpZiAoIGRpc3RTcSA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIGVuZCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggY2xvc2VzdERpc3RhbmNlU3EgKTtcblxuXHR9O1xuXG59ICkoKTtcblxuRXh0ZW5kZWRUcmlhbmdsZS5wcm90b3R5cGUuaW50ZXJzZWN0c1RyaWFuZ2xlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0Y29uc3Qgc2FUcmkyID0gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcblx0Y29uc3QgYXJyMSA9IG5ldyBBcnJheSggMyApO1xuXHRjb25zdCBhcnIyID0gbmV3IEFycmF5KCAzICk7XG5cdGNvbnN0IGNhY2hlZFNhdEJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRjb25zdCBjYWNoZWRTYXRCb3VuZHMyID0gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCk7XG5cdGNvbnN0IGNhY2hlZEF4aXMgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBkaXIgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBkaXIxID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgZGlyMiA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXBEaXIgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBlZGdlID0gbmV3IExpbmUzKCk7XG5cdGNvbnN0IGVkZ2UxID0gbmV3IExpbmUzKCk7XG5cdGNvbnN0IGVkZ2UyID0gbmV3IExpbmUzKCk7XG5cdGNvbnN0IHRlbXBQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0ZnVuY3Rpb24gdHJpSW50ZXJzZWN0UGxhbmUoIHRyaSwgcGxhbmUsIHRhcmdldEVkZ2UgKSB7XG5cblx0XHQvLyBmaW5kIHRoZSBlZGdlIHRoYXQgaW50ZXJzZWN0cyB0aGUgb3RoZXIgdHJpYW5nbGUgcGxhbmVcblx0XHRjb25zdCBwb2ludHMgPSB0cmkucG9pbnRzO1xuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0bGV0IHN0YXJ0UG9pbnRJbnRlcnNlY3Rpb24gPSAtIDE7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgeyBzdGFydCwgZW5kIH0gPSBlZGdlO1xuXHRcdFx0c3RhcnQuY29weSggcG9pbnRzWyBpIF0gKTtcblx0XHRcdGVuZC5jb3B5KCBwb2ludHNbICggaSArIDEgKSAlIDMgXSApO1xuXHRcdFx0ZWRnZS5kZWx0YSggZGlyICk7XG5cblx0XHRcdGNvbnN0IHN0YXJ0SW50ZXJzZWN0cyA9IGlzTmVhclplcm8oIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggc3RhcnQgKSApO1xuXHRcdFx0aWYgKCBpc05lYXJaZXJvKCBwbGFuZS5ub3JtYWwuZG90KCBkaXIgKSApICYmIHN0YXJ0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0XHQvLyBpZiB0aGUgZWRnZSBsaWVzIG9uIHRoZSBwbGFuZSB0aGVuIHRha2UgdGhlIGxpbmVcblx0XHRcdFx0dGFyZ2V0RWRnZS5jb3B5KCBlZGdlICk7XG5cdFx0XHRcdGNvdW50ID0gMjtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHN0YXJ0IHBvaW50IGlzIG5lYXIgdGhlIHBsYW5lIGJlY2F1c2UgXCJpbnRlcnNlY3RMaW5lXCIgaXMgbm90IHJvYnVzdCB0byB0aGF0IGNhc2Vcblx0XHRcdGNvbnN0IGRvZXNJbnRlcnNlY3QgPSBwbGFuZS5pbnRlcnNlY3RMaW5lKCBlZGdlLCB0ZW1wUG9pbnQgKTtcblx0XHRcdGlmICggISBkb2VzSW50ZXJzZWN0ICYmIHN0YXJ0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0XHR0ZW1wUG9pbnQuY29weSggc3RhcnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZ25vcmUgdGhlIGVuZCBwb2ludFxuXHRcdFx0aWYgKCAoIGRvZXNJbnRlcnNlY3QgfHwgc3RhcnRJbnRlcnNlY3RzICkgJiYgISBpc05lYXJaZXJvKCB0ZW1wUG9pbnQuZGlzdGFuY2VUbyggZW5kICkgKSApIHtcblxuXHRcdFx0XHRpZiAoIGNvdW50IDw9IDEgKSB7XG5cblx0XHRcdFx0XHQvLyBhc3NpZ24gdG8gdGhlIHN0YXJ0IG9yIGVuZCBwb2ludCBhbmQgc2F2ZSB3aGljaCBpbmRleCB3YXMgc25hcHBlZCB0b1xuXHRcdFx0XHRcdC8vIHRoZSBzdGFydCBwb2ludCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRjb25zdCBwb2ludCA9IGNvdW50ID09PSAxID8gdGFyZ2V0RWRnZS5zdGFydCA6IHRhcmdldEVkZ2UuZW5kO1xuXHRcdFx0XHRcdHBvaW50LmNvcHkoIHRlbXBQb2ludCApO1xuXHRcdFx0XHRcdGlmICggc3RhcnRJbnRlcnNlY3RzICkge1xuXG5cdFx0XHRcdFx0XHRzdGFydFBvaW50SW50ZXJzZWN0aW9uID0gY291bnQ7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY291bnQgPj0gMiApIHtcblxuXHRcdFx0XHRcdC8vIGlmIHdlJ3JlIGhlcmUgdGhhdCBtZWFucyB0aGF0IHRoZXJlIG11c3QgaGF2ZSBiZWVuIG9uZSBwb2ludCB0aGF0IGhhZFxuXHRcdFx0XHRcdC8vIHNuYXBwZWQgdG8gdGhlIHN0YXJ0IHBvaW50IHNvIHJlcGxhY2UgaXQgaGVyZVxuXHRcdFx0XHRcdGNvbnN0IHBvaW50ID0gc3RhcnRQb2ludEludGVyc2VjdGlvbiA9PT0gMSA/IHRhcmdldEVkZ2Uuc3RhcnQgOiB0YXJnZXRFZGdlLmVuZDtcblx0XHRcdFx0XHRwb2ludC5jb3B5KCB0ZW1wUG9pbnQgKTtcblx0XHRcdFx0XHRjb3VudCA9IDI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvdW50ICsrO1xuXHRcdFx0XHRpZiAoIGNvdW50ID09PSAyICYmIHN0YXJ0UG9pbnRJbnRlcnNlY3Rpb24gPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvdW50O1xuXG5cdH1cblxuXHQvLyBUT0RPOiBJZiB0aGUgdHJpYW5nbGVzIGFyZSBjb3BsYW5hciBhbmQgaW50ZXJzZWN0aW5nIHRoZSB0YXJnZXQgaXMgbm9uc2Vuc2ljYWwuIEl0IHNob3VsZCBhdCBsZWFzdFxuXHQvLyBiZSBhIGxpbmUgY29udGFpbmVkIGJ5IGJvdGggdHJpYW5nbGVzIGlmIG5vdCBhIGRpZmZlcmVudCBzcGVjaWFsIGNhc2Ugc29tZWhvdyByZXByZXNlbnRlZCBpbiB0aGUgcmV0dXJuIHJlc3VsdC5cblx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNUcmlhbmdsZSggb3RoZXIsIHRhcmdldCA9IG51bGwsIHN1cHByZXNzTG9nID0gZmFsc2UgKSB7XG5cblx0XHRpZiAoIHRoaXMubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoICEgb3RoZXIuaXNFeHRlbmRlZFRyaWFuZ2xlICkge1xuXG5cdFx0XHRzYVRyaTIuY29weSggb3RoZXIgKTtcblx0XHRcdHNhVHJpMi51cGRhdGUoKTtcblx0XHRcdG90aGVyID0gc2FUcmkyO1xuXG5cdFx0fSBlbHNlIGlmICggb3RoZXIubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdG90aGVyLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcGxhbmUxID0gdGhpcy5wbGFuZTtcblx0XHRjb25zdCBwbGFuZTIgPSBvdGhlci5wbGFuZTtcblxuXHRcdGlmICggTWF0aC5hYnMoIHBsYW5lMS5ub3JtYWwuZG90KCBwbGFuZTIubm9ybWFsICkgKSA+IDEuMCAtIDFlLTEwICkge1xuXG5cdFx0XHQvLyBwZXJmb3JtIHNlcGFyYXRpbmcgYXhpcyBpbnRlcnNlY3Rpb24gdGVzdCBvbmx5IGZvciBjb3BsYW5hciB0cmlhbmdsZXNcblx0XHRcdGNvbnN0IHNhdEJvdW5kczEgPSB0aGlzLnNhdEJvdW5kcztcblx0XHRcdGNvbnN0IHNhdEF4ZXMxID0gdGhpcy5zYXRBeGVzO1xuXHRcdFx0YXJyMlsgMCBdID0gb3RoZXIuYTtcblx0XHRcdGFycjJbIDEgXSA9IG90aGVyLmI7XG5cdFx0XHRhcnIyWyAyIF0gPSBvdGhlci5jO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBzYiA9IHNhdEJvdW5kczFbIGkgXTtcblx0XHRcdFx0Y29uc3Qgc2EgPSBzYXRBeGVzMVsgaSBdO1xuXHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIGFycjIgKTtcblx0XHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzMiA9IG90aGVyLnNhdEJvdW5kcztcblx0XHRcdGNvbnN0IHNhdEF4ZXMyID0gb3RoZXIuc2F0QXhlcztcblx0XHRcdGFycjFbIDAgXSA9IHRoaXMuYTtcblx0XHRcdGFycjFbIDEgXSA9IHRoaXMuYjtcblx0XHRcdGFycjFbIDIgXSA9IHRoaXMuYztcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHMyWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczJbIGkgXTtcblx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBhcnIxICk7XG5cdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGNyb3NzZWQgYXhlc1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBzYTEgPSBzYXRBeGVzMVsgaSBdO1xuXHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8IDQ7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2EyID0gc2F0QXhlczJbIGkyIF07XG5cdFx0XHRcdFx0Y2FjaGVkQXhpcy5jcm9zc1ZlY3RvcnMoIHNhMSwgc2EyICk7XG5cdFx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIGNhY2hlZEF4aXMsIGFycjEgKTtcblx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMyLnNldEZyb21Qb2ludHMoIGNhY2hlZEF4aXMsIGFycjIgKTtcblx0XHRcdFx0XHRpZiAoIGNhY2hlZFNhdEJvdW5kcy5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzMiApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRhcmdldCApIHtcblxuXHRcdFx0XHQvLyBUT0RPIGZpbmQgdHdvIHBvaW50cyB0aGF0IGludGVyc2VjdCBvbiB0aGUgZWRnZXMgYW5kIG1ha2UgdGhhdCB0aGUgcmVzdWx0XG5cdFx0XHRcdGlmICggISBzdXBwcmVzc0xvZyApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ0V4dGVuZGVkVHJpYW5nbGUuaW50ZXJzZWN0c1RyaWFuZ2xlOiBUcmlhbmdsZXMgYXJlIGNvcGxhbmFyIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgYW4gb3V0cHV0IGVkZ2UuIFNldHRpbmcgZWRnZSB0byAwLCAwLCAwLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0LnN0YXJ0LnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHR0YXJnZXQuZW5kLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gZmluZCB0aGUgZWRnZSB0aGF0IGludGVyc2VjdHMgdGhlIG90aGVyIHRyaWFuZ2xlIHBsYW5lXG5cdFx0XHRjb25zdCBjb3VudDEgPSB0cmlJbnRlcnNlY3RQbGFuZSggdGhpcywgcGxhbmUyLCBlZGdlMSApO1xuXHRcdFx0aWYgKCBjb3VudDEgPT09IDEgJiYgb3RoZXIuY29udGFpbnNQb2ludCggZWRnZTEuZW5kICkgKSB7XG5cblx0XHRcdFx0aWYgKCB0YXJnZXQgKSB7XG5cblx0XHRcdFx0XHR0YXJnZXQuc3RhcnQuY29weSggZWRnZTEuZW5kICk7XG5cdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMS5lbmQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGNvdW50MSAhPT0gMiApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZmluZCB0aGUgb3RoZXIgdHJpYW5nbGVzIGVkZ2UgdGhhdCBpbnRlcnNlY3RzIHRoaXMgcGxhbmVcblx0XHRcdGNvbnN0IGNvdW50MiA9IHRyaUludGVyc2VjdFBsYW5lKCBvdGhlciwgcGxhbmUxLCBlZGdlMiApO1xuXHRcdFx0aWYgKCBjb3VudDIgPT09IDEgJiYgdGhpcy5jb250YWluc1BvaW50KCBlZGdlMi5lbmQgKSApIHtcblxuXHRcdFx0XHRpZiAoIHRhcmdldCApIHtcblxuXHRcdFx0XHRcdHRhcmdldC5zdGFydC5jb3B5KCBlZGdlMi5lbmQgKTtcblx0XHRcdFx0XHR0YXJnZXQuZW5kLmNvcHkoIGVkZ2UyLmVuZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIGlmICggY291bnQyICE9PSAyICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmaW5kIHN3YXAgdGhlIHNlY29uZCBlZGdlIHNvIGJvdGggbGluZXMgYXJlIHJ1bm5pbmcgdGhlIHNhbWUgZGlyZWN0aW9uXG5cdFx0XHRlZGdlMS5kZWx0YSggZGlyMSApO1xuXHRcdFx0ZWRnZTIuZGVsdGEoIGRpcjIgKTtcblxuXHRcdFx0aWYgKCBkaXIxLmRvdCggZGlyMiApIDwgMCApIHtcblxuXHRcdFx0XHRsZXQgdG1wID0gZWRnZTIuc3RhcnQ7XG5cdFx0XHRcdGVkZ2UyLnN0YXJ0ID0gZWRnZTIuZW5kO1xuXHRcdFx0XHRlZGdlMi5lbmQgPSB0bXA7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIGVkZ2VzIGFyZSBvdmVybGFwcGluZ1xuXHRcdFx0Y29uc3QgczEgPSBlZGdlMS5zdGFydC5kb3QoIGRpcjEgKTtcblx0XHRcdGNvbnN0IGUxID0gZWRnZTEuZW5kLmRvdCggZGlyMSApO1xuXHRcdFx0Y29uc3QgczIgPSBlZGdlMi5zdGFydC5kb3QoIGRpcjEgKTtcblx0XHRcdGNvbnN0IGUyID0gZWRnZTIuZW5kLmRvdCggZGlyMSApO1xuXHRcdFx0Y29uc3Qgc2VwYXJhdGVkMSA9IGUxIDwgczI7XG5cdFx0XHRjb25zdCBzZXBhcmF0ZWQyID0gczEgPCBlMjtcblxuXHRcdFx0aWYgKCBzMSAhPT0gZTIgJiYgczIgIT09IGUxICYmIHNlcGFyYXRlZDEgPT09IHNlcGFyYXRlZDIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFzc2lnbiB0aGUgdGFyZ2V0IG91dHB1dFxuXHRcdFx0aWYgKCB0YXJnZXQgKSB7XG5cblx0XHRcdFx0dGVtcERpci5zdWJWZWN0b3JzKCBlZGdlMS5zdGFydCwgZWRnZTIuc3RhcnQgKTtcblx0XHRcdFx0aWYgKCB0ZW1wRGlyLmRvdCggZGlyMSApID4gMCApIHtcblxuXHRcdFx0XHRcdHRhcmdldC5zdGFydC5jb3B5KCBlZGdlMS5zdGFydCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0YXJnZXQuc3RhcnQuY29weSggZWRnZTIuc3RhcnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGVtcERpci5zdWJWZWN0b3JzKCBlZGdlMS5lbmQsIGVkZ2UyLmVuZCApO1xuXHRcdFx0XHRpZiAoIHRlbXBEaXIuZG90KCBkaXIxICkgPCAwICkge1xuXG5cdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMS5lbmQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMi5lbmQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0fTtcblxufSApKCk7XG5cblxuRXh0ZW5kZWRUcmlhbmdsZS5wcm90b3R5cGUuZGlzdGFuY2VUb1BvaW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0Y29uc3QgdGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcblx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCB0YXJnZXQgKTtcblx0XHRyZXR1cm4gcG9pbnQuZGlzdGFuY2VUbyggdGFyZ2V0ICk7XG5cblx0fTtcblxufSApKCk7XG5cblxuRXh0ZW5kZWRUcmlhbmdsZS5wcm90b3R5cGUuZGlzdGFuY2VUb1RyaWFuZ2xlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0Y29uc3QgcG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBwb2ludDIgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBjb3JuZXJGaWVsZHMgPSBbICdhJywgJ2InLCAnYycgXTtcblx0Y29uc3QgbGluZTEgPSBuZXcgTGluZTMoKTtcblx0Y29uc3QgbGluZTIgPSBuZXcgTGluZTMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1RyaWFuZ2xlKCBvdGhlciwgdGFyZ2V0MSA9IG51bGwsIHRhcmdldDIgPSBudWxsICkge1xuXG5cdFx0Y29uc3QgbGluZVRhcmdldCA9IHRhcmdldDEgfHwgdGFyZ2V0MiA/IGxpbmUxIDogbnVsbDtcblx0XHRpZiAoIHRoaXMuaW50ZXJzZWN0c1RyaWFuZ2xlKCBvdGhlciwgbGluZVRhcmdldCApICkge1xuXG5cdFx0XHRpZiAoIHRhcmdldDEgfHwgdGFyZ2V0MiApIHtcblxuXHRcdFx0XHRpZiAoIHRhcmdldDEgKSBsaW5lVGFyZ2V0LmdldENlbnRlciggdGFyZ2V0MSApO1xuXHRcdFx0XHRpZiAoIHRhcmdldDIgKSBsaW5lVGFyZ2V0LmdldENlbnRlciggdGFyZ2V0MiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGNsb3Nlc3REaXN0YW5jZVNxID0gSW5maW5pdHk7XG5cblx0XHQvLyBjaGVjayBhbGwgcG9pbnQgZGlzdGFuY2VzXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0bGV0IGRpc3Q7XG5cdFx0XHRjb25zdCBmaWVsZCA9IGNvcm5lckZpZWxkc1sgaSBdO1xuXHRcdFx0Y29uc3Qgb3RoZXJWZWMgPSBvdGhlclsgZmllbGQgXTtcblx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggb3RoZXJWZWMsIHBvaW50ICk7XG5cblx0XHRcdGRpc3QgPSBvdGhlclZlYy5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0O1xuXHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50ICk7XG5cdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggb3RoZXJWZWMgKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGNvbnN0IHRoaXNWZWMgPSB0aGlzWyBmaWVsZCBdO1xuXHRcdFx0b3RoZXIuY2xvc2VzdFBvaW50VG9Qb2ludCggdGhpc1ZlYywgcG9pbnQgKTtcblxuXHRcdFx0ZGlzdCA9IHRoaXNWZWMuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCB0aGlzVmVjICk7XG5cdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgZjExID0gY29ybmVyRmllbGRzWyBpIF07XG5cdFx0XHRjb25zdCBmMTIgPSBjb3JuZXJGaWVsZHNbICggaSArIDEgKSAlIDMgXTtcblx0XHRcdGxpbmUxLnNldCggdGhpc1sgZjExIF0sIHRoaXNbIGYxMiBdICk7XG5cdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8IDM7IGkyICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGYyMSA9IGNvcm5lckZpZWxkc1sgaTIgXTtcblx0XHRcdFx0Y29uc3QgZjIyID0gY29ybmVyRmllbGRzWyAoIGkyICsgMSApICUgMyBdO1xuXHRcdFx0XHRsaW5lMi5zZXQoIG90aGVyWyBmMjEgXSwgb3RoZXJbIGYyMiBdICk7XG5cblx0XHRcdFx0Y2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQoIGxpbmUxLCBsaW5lMiwgcG9pbnQsIHBvaW50MiApO1xuXG5cdFx0XHRcdGNvbnN0IGRpc3QgPSBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0O1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQgKTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggY2xvc2VzdERpc3RhbmNlU3EgKTtcblxuXHR9O1xuXG59ICkoKTtcbiJdLCJuYW1lcyI6WyJUcmlhbmdsZSIsIlZlY3RvcjMiLCJMaW5lMyIsIlNwaGVyZSIsIlBsYW5lIiwiU2VwYXJhdGluZ0F4aXNCb3VuZHMiLCJjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCIsInNwaGVyZUludGVyc2VjdFRyaWFuZ2xlIiwiWkVST19FUFNJTE9OIiwiaXNOZWFyWmVybyIsInZhbHVlIiwiTWF0aCIsImFicyIsIkV4dGVuZGVkVHJpYW5nbGUiLCJpbnRlcnNlY3RzU3BoZXJlIiwic3BoZXJlIiwidXBkYXRlIiwiYSIsImIiLCJjIiwicG9pbnRzIiwic2F0QXhlcyIsInNhdEJvdW5kcyIsImF4aXMwIiwic2FiMCIsImdldE5vcm1hbCIsInNldEZyb21Qb2ludHMiLCJheGlzMSIsInNhYjEiLCJzdWJWZWN0b3JzIiwiYXhpczIiLCJzYWIyIiwiYXhpczMiLCJzYWIzIiwicGxhbmUiLCJzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCIsIm5lZWRzVXBkYXRlIiwiY29uc3RydWN0b3IiLCJhcmdzIiwiaXNFeHRlbmRlZFRyaWFuZ2xlIiwiQXJyYXkiLCJmaWxsIiwibWFwIiwicHJvdG90eXBlIiwiY2xvc2VzdFBvaW50VG9TZWdtZW50IiwicG9pbnQxIiwicG9pbnQyIiwiZWRnZSIsImRpc3RhbmNlVG9TZWdtZW50Iiwic2VnbWVudCIsInRhcmdldDEiLCJ0YXJnZXQyIiwic3RhcnQiLCJlbmQiLCJkaXN0U3EiLCJjbG9zZXN0RGlzdGFuY2VTcSIsIkluZmluaXR5IiwiaSIsIm5leHRpIiwiY29weSIsImRpc3RhbmNlVG9TcXVhcmVkIiwiY2xvc2VzdFBvaW50VG9Qb2ludCIsInNxcnQiLCJpbnRlcnNlY3RzVHJpYW5nbGUiLCJzYVRyaTIiLCJhcnIxIiwiYXJyMiIsImNhY2hlZFNhdEJvdW5kcyIsImNhY2hlZFNhdEJvdW5kczIiLCJjYWNoZWRBeGlzIiwiZGlyIiwiZGlyMSIsImRpcjIiLCJ0ZW1wRGlyIiwiZWRnZTEiLCJlZGdlMiIsInRlbXBQb2ludCIsInRyaUludGVyc2VjdFBsYW5lIiwidHJpIiwidGFyZ2V0RWRnZSIsImNvdW50Iiwic3RhcnRQb2ludEludGVyc2VjdGlvbiIsImRlbHRhIiwic3RhcnRJbnRlcnNlY3RzIiwiZGlzdGFuY2VUb1BvaW50Iiwibm9ybWFsIiwiZG90IiwiZG9lc0ludGVyc2VjdCIsImludGVyc2VjdExpbmUiLCJkaXN0YW5jZVRvIiwicG9pbnQiLCJvdGhlciIsInRhcmdldCIsInN1cHByZXNzTG9nIiwicGxhbmUxIiwicGxhbmUyIiwic2F0Qm91bmRzMSIsInNhdEF4ZXMxIiwic2IiLCJzYSIsImlzU2VwYXJhdGVkIiwic2F0Qm91bmRzMiIsInNhdEF4ZXMyIiwic2ExIiwiaTIiLCJzYTIiLCJjcm9zc1ZlY3RvcnMiLCJjb25zb2xlIiwid2FybiIsInNldCIsImNvdW50MSIsImNvbnRhaW5zUG9pbnQiLCJjb3VudDIiLCJ0bXAiLCJzMSIsImUxIiwiczIiLCJlMiIsInNlcGFyYXRlZDEiLCJzZXBhcmF0ZWQyIiwiZGlzdGFuY2VUb1RyaWFuZ2xlIiwiY29ybmVyRmllbGRzIiwibGluZTEiLCJsaW5lMiIsImxpbmVUYXJnZXQiLCJnZXRDZW50ZXIiLCJkaXN0IiwiZmllbGQiLCJvdGhlclZlYyIsInRoaXNWZWMiLCJmMTEiLCJmMTIiLCJmMjEiLCJmMjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/MathUtilities.js":
/*!***************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/math/MathUtilities.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointLineToLine: function() { return /* binding */ closestPointLineToLine; },\n/* harmony export */   closestPointsSegmentToSegment: function() { return /* binding */ closestPointsSegmentToSegment; },\n/* harmony export */   sphereIntersectTriangle: function() { return /* binding */ sphereIntersectTriangle; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nconst closestPointLineToLine = function() {\n    // https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n    const dir1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const dir2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const v02 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function closestPointLineToLine(l1, l2, result) {\n        const v0 = l1.start;\n        const v10 = dir1;\n        const v2 = l2.start;\n        const v32 = dir2;\n        v02.subVectors(v0, v2);\n        dir1.subVectors(l1.end, l1.start);\n        dir2.subVectors(l2.end, l2.start);\n        // float d0232 = v02.Dot(v32);\n        const d0232 = v02.dot(v32);\n        // float d3210 = v32.Dot(v10);\n        const d3210 = v32.dot(v10);\n        // float d3232 = v32.Dot(v32);\n        const d3232 = v32.dot(v32);\n        // float d0210 = v02.Dot(v10);\n        const d0210 = v02.dot(v10);\n        // float d1010 = v10.Dot(v10);\n        const d1010 = v10.dot(v10);\n        // float denom = d1010*d3232 - d3210*d3210;\n        const denom = d1010 * d3232 - d3210 * d3210;\n        let d, d2;\n        if (denom !== 0) {\n            d = (d0232 * d3210 - d0210 * d3232) / denom;\n        } else {\n            d = 0;\n        }\n        d2 = (d0232 + d * d3210) / d3232;\n        result.x = d;\n        result.y = d2;\n    };\n}();\nconst closestPointsSegmentToSegment = function() {\n    // https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n    const paramResult = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const temp1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const temp2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function closestPointsSegmentToSegment(l1, l2, target1, target2) {\n        closestPointLineToLine(l1, l2, paramResult);\n        let d = paramResult.x;\n        let d2 = paramResult.y;\n        if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {\n            l1.at(d, target1);\n            l2.at(d2, target2);\n            return;\n        } else if (d >= 0 && d <= 1) {\n            // Only d2 is out of bounds.\n            if (d2 < 0) {\n                l2.at(0, target2);\n            } else {\n                l2.at(1, target2);\n            }\n            l1.closestPointToPoint(target2, true, target1);\n            return;\n        } else if (d2 >= 0 && d2 <= 1) {\n            // Only d is out of bounds.\n            if (d < 0) {\n                l1.at(0, target1);\n            } else {\n                l1.at(1, target1);\n            }\n            l2.closestPointToPoint(target1, true, target2);\n            return;\n        } else {\n            // Both u and u2 are out of bounds.\n            let p;\n            if (d < 0) {\n                p = l1.start;\n            } else {\n                p = l1.end;\n            }\n            let p2;\n            if (d2 < 0) {\n                p2 = l2.start;\n            } else {\n                p2 = l2.end;\n            }\n            const closestPoint = temp1;\n            const closestPoint2 = temp2;\n            l1.closestPointToPoint(p2, true, temp1);\n            l2.closestPointToPoint(p, true, temp2);\n            if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {\n                target1.copy(closestPoint);\n                target2.copy(p2);\n                return;\n            } else {\n                target1.copy(p);\n                target2.copy(closestPoint2);\n                return;\n            }\n        }\n    };\n}();\nconst sphereIntersectTriangle = function() {\n    // https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n    const closestPointTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const projectedPointTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const planeTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Plane();\n    const lineTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    return function sphereIntersectTriangle(sphere, triangle) {\n        const { radius, center } = sphere;\n        const { a, b, c } = triangle;\n        // phase 1\n        lineTemp.start = a;\n        lineTemp.end = b;\n        const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint1.distanceTo(center) <= radius) return true;\n        lineTemp.start = a;\n        lineTemp.end = c;\n        const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint2.distanceTo(center) <= radius) return true;\n        lineTemp.start = b;\n        lineTemp.end = c;\n        const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint3.distanceTo(center) <= radius) return true;\n        // phase 2\n        const plane = triangle.getPlane(planeTemp);\n        const dp = Math.abs(plane.distanceToPoint(center));\n        if (dp <= radius) {\n            const pp = plane.projectPoint(center, projectedPointTemp);\n            const cp = triangle.containsPoint(pp);\n            if (cp) return true;\n        }\n        return false;\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvbWF0aC9NYXRoVXRpbGl0aWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUQ7QUFFaEQsTUFBTUkseUJBQXlCO0lBRXJDLDBFQUEwRTtJQUMxRSxNQUFNQyxPQUFPLElBQUlMLDBDQUFPQTtJQUN4QixNQUFNTSxPQUFPLElBQUlOLDBDQUFPQTtJQUN4QixNQUFNTyxNQUFNLElBQUlQLDBDQUFPQTtJQUN2QixPQUFPLFNBQVNJLHVCQUF3QkksRUFBRSxFQUFFQyxFQUFFLEVBQUVDLE1BQU07UUFFckQsTUFBTUMsS0FBS0gsR0FBR0ksS0FBSztRQUNuQixNQUFNQyxNQUFNUjtRQUNaLE1BQU1TLEtBQUtMLEdBQUdHLEtBQUs7UUFDbkIsTUFBTUcsTUFBTVQ7UUFFWkMsSUFBSVMsVUFBVSxDQUFFTCxJQUFJRztRQUNwQlQsS0FBS1csVUFBVSxDQUFFUixHQUFHUyxHQUFHLEVBQUVULEdBQUdJLEtBQUs7UUFDakNOLEtBQUtVLFVBQVUsQ0FBRVAsR0FBR1EsR0FBRyxFQUFFUixHQUFHRyxLQUFLO1FBRWpDLDhCQUE4QjtRQUM5QixNQUFNTSxRQUFRWCxJQUFJWSxHQUFHLENBQUVKO1FBRXZCLDhCQUE4QjtRQUM5QixNQUFNSyxRQUFRTCxJQUFJSSxHQUFHLENBQUVOO1FBRXZCLDhCQUE4QjtRQUM5QixNQUFNUSxRQUFRTixJQUFJSSxHQUFHLENBQUVKO1FBRXZCLDhCQUE4QjtRQUM5QixNQUFNTyxRQUFRZixJQUFJWSxHQUFHLENBQUVOO1FBRXZCLDhCQUE4QjtRQUM5QixNQUFNVSxRQUFRVixJQUFJTSxHQUFHLENBQUVOO1FBRXZCLDJDQUEyQztRQUMzQyxNQUFNVyxRQUFRRCxRQUFRRixRQUFRRCxRQUFRQTtRQUV0QyxJQUFJSyxHQUFHQztRQUNQLElBQUtGLFVBQVUsR0FBSTtZQUVsQkMsSUFBSSxDQUFFUCxRQUFRRSxRQUFRRSxRQUFRRCxLQUFJLElBQU1HO1FB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akJMLFNBQVM5QixHQUFHLEdBQUdvQztRQUNmLE1BQU1FLGdCQUFnQlIsU0FBU1gsbUJBQW1CLENBQUVlLFFBQVEsTUFBTVA7UUFDbEUsSUFBS1csY0FBY0MsVUFBVSxDQUFFTCxXQUFZRCxRQUFTLE9BQU87UUFFM0RILFNBQVNuQyxLQUFLLEdBQUd3QztRQUNqQkwsU0FBUzlCLEdBQUcsR0FBR3FDO1FBQ2YsTUFBTWQsZ0JBQWdCTyxTQUFTWCxtQkFBbUIsQ0FBRWUsUUFBUSxNQUFNUDtRQUNsRSxJQUFLSixjQUFjZ0IsVUFBVSxDQUFFTCxXQUFZRCxRQUFTLE9BQU87UUFFM0RILFNBQVNuQyxLQUFLLEdBQUd5QztRQUNqQk4sU0FBUzlCLEdBQUcsR0FBR3FDO1FBQ2YsTUFBTUcsZ0JBQWdCVixTQUFTWCxtQkFBbUIsQ0FBRWUsUUFBUSxNQUFNUDtRQUNsRSxJQUFLYSxjQUFjRCxVQUFVLENBQUVMLFdBQVlELFFBQVMsT0FBTztRQUUzRCxVQUFVO1FBQ1YsTUFBTVEsUUFBUVQsU0FBU1UsUUFBUSxDQUFFYjtRQUNqQyxNQUFNYyxLQUFLQyxLQUFLQyxHQUFHLENBQUVKLE1BQU1LLGVBQWUsQ0FBRVo7UUFDNUMsSUFBS1MsTUFBTVYsUUFBUztZQUVuQixNQUFNYyxLQUFLTixNQUFNTyxZQUFZLENBQUVkLFFBQVFOO1lBQ3ZDLE1BQU1xQixLQUFLakIsU0FBU2tCLGFBQWEsQ0FBRUg7WUFDbkMsSUFBS0UsSUFBSyxPQUFPO1FBRWxCO1FBRUEsT0FBTztJQUVSO0FBRUQsSUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL21hdGgvTWF0aFV0aWxpdGllcy5qcz9kYzFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMsIFZlY3RvcjIsIFBsYW5lLCBMaW5lMyB9IGZyb20gJ3RocmVlJztcblxuZXhwb3J0IGNvbnN0IGNsb3Nlc3RQb2ludExpbmVUb0xpbmUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vanVqL01hdGhHZW9MaWIvYmxvYi9tYXN0ZXIvc3JjL0dlb21ldHJ5L0xpbmUuY3BwI0w1NlxuXHRjb25zdCBkaXIxID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgZGlyMiA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IHYwMiA9IG5ldyBWZWN0b3IzKCk7XG5cdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRMaW5lVG9MaW5lKCBsMSwgbDIsIHJlc3VsdCApIHtcblxuXHRcdGNvbnN0IHYwID0gbDEuc3RhcnQ7XG5cdFx0Y29uc3QgdjEwID0gZGlyMTtcblx0XHRjb25zdCB2MiA9IGwyLnN0YXJ0O1xuXHRcdGNvbnN0IHYzMiA9IGRpcjI7XG5cblx0XHR2MDIuc3ViVmVjdG9ycyggdjAsIHYyICk7XG5cdFx0ZGlyMS5zdWJWZWN0b3JzKCBsMS5lbmQsIGwxLnN0YXJ0ICk7XG5cdFx0ZGlyMi5zdWJWZWN0b3JzKCBsMi5lbmQsIGwyLnN0YXJ0ICk7XG5cblx0XHQvLyBmbG9hdCBkMDIzMiA9IHYwMi5Eb3QodjMyKTtcblx0XHRjb25zdCBkMDIzMiA9IHYwMi5kb3QoIHYzMiApO1xuXG5cdFx0Ly8gZmxvYXQgZDMyMTAgPSB2MzIuRG90KHYxMCk7XG5cdFx0Y29uc3QgZDMyMTAgPSB2MzIuZG90KCB2MTAgKTtcblxuXHRcdC8vIGZsb2F0IGQzMjMyID0gdjMyLkRvdCh2MzIpO1xuXHRcdGNvbnN0IGQzMjMyID0gdjMyLmRvdCggdjMyICk7XG5cblx0XHQvLyBmbG9hdCBkMDIxMCA9IHYwMi5Eb3QodjEwKTtcblx0XHRjb25zdCBkMDIxMCA9IHYwMi5kb3QoIHYxMCApO1xuXG5cdFx0Ly8gZmxvYXQgZDEwMTAgPSB2MTAuRG90KHYxMCk7XG5cdFx0Y29uc3QgZDEwMTAgPSB2MTAuZG90KCB2MTAgKTtcblxuXHRcdC8vIGZsb2F0IGRlbm9tID0gZDEwMTAqZDMyMzIgLSBkMzIxMCpkMzIxMDtcblx0XHRjb25zdCBkZW5vbSA9IGQxMDEwICogZDMyMzIgLSBkMzIxMCAqIGQzMjEwO1xuXG5cdFx0bGV0IGQsIGQyO1xuXHRcdGlmICggZGVub20gIT09IDAgKSB7XG5cblx0XHRcdGQgPSAoIGQwMjMyICogZDMyMTAgLSBkMDIxMCAqIGQzMjMyICkgLyBkZW5vbTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGQgPSAwO1xuXG5cdFx0fVxuXG5cdFx0ZDIgPSAoIGQwMjMyICsgZCAqIGQzMjEwICkgLyBkMzIzMjtcblxuXHRcdHJlc3VsdC54ID0gZDtcblx0XHRyZXN1bHQueSA9IGQyO1xuXG5cdH07XG5cbn0gKSgpO1xuXG5leHBvcnQgY29uc3QgY2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vanVqL01hdGhHZW9MaWIvYmxvYi9tYXN0ZXIvc3JjL0dlb21ldHJ5L0xpbmVTZWdtZW50LmNwcCNMMTg3XG5cdGNvbnN0IHBhcmFtUmVzdWx0ID0gbmV3IFZlY3RvcjIoKTtcblx0Y29uc3QgdGVtcDEgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wMiA9IG5ldyBWZWN0b3IzKCk7XG5cdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCggbDEsIGwyLCB0YXJnZXQxLCB0YXJnZXQyICkge1xuXG5cdFx0Y2xvc2VzdFBvaW50TGluZVRvTGluZSggbDEsIGwyLCBwYXJhbVJlc3VsdCApO1xuXG5cdFx0bGV0IGQgPSBwYXJhbVJlc3VsdC54O1xuXHRcdGxldCBkMiA9IHBhcmFtUmVzdWx0Lnk7XG5cdFx0aWYgKCBkID49IDAgJiYgZCA8PSAxICYmIGQyID49IDAgJiYgZDIgPD0gMSApIHtcblxuXHRcdFx0bDEuYXQoIGQsIHRhcmdldDEgKTtcblx0XHRcdGwyLmF0KCBkMiwgdGFyZ2V0MiApO1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9IGVsc2UgaWYgKCBkID49IDAgJiYgZCA8PSAxICkge1xuXG5cdFx0XHQvLyBPbmx5IGQyIGlzIG91dCBvZiBib3VuZHMuXG5cdFx0XHRpZiAoIGQyIDwgMCApIHtcblxuXHRcdFx0XHRsMi5hdCggMCwgdGFyZ2V0MiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGwyLmF0KCAxLCB0YXJnZXQyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bDEuY2xvc2VzdFBvaW50VG9Qb2ludCggdGFyZ2V0MiwgdHJ1ZSwgdGFyZ2V0MSApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fSBlbHNlIGlmICggZDIgPj0gMCAmJiBkMiA8PSAxICkge1xuXG5cdFx0XHQvLyBPbmx5IGQgaXMgb3V0IG9mIGJvdW5kcy5cblx0XHRcdGlmICggZCA8IDAgKSB7XG5cblx0XHRcdFx0bDEuYXQoIDAsIHRhcmdldDEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsMS5hdCggMSwgdGFyZ2V0MSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGwyLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHRhcmdldDEsIHRydWUsIHRhcmdldDIgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEJvdGggdSBhbmQgdTIgYXJlIG91dCBvZiBib3VuZHMuXG5cdFx0XHRsZXQgcDtcblx0XHRcdGlmICggZCA8IDAgKSB7XG5cblx0XHRcdFx0cCA9IGwxLnN0YXJ0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHAgPSBsMS5lbmQ7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IHAyO1xuXHRcdFx0aWYgKCBkMiA8IDAgKSB7XG5cblx0XHRcdFx0cDIgPSBsMi5zdGFydDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRwMiA9IGwyLmVuZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjbG9zZXN0UG9pbnQgPSB0ZW1wMTtcblx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludDIgPSB0ZW1wMjtcblx0XHRcdGwxLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHAyLCB0cnVlLCB0ZW1wMSApO1xuXHRcdFx0bDIuY2xvc2VzdFBvaW50VG9Qb2ludCggcCwgdHJ1ZSwgdGVtcDIgKTtcblxuXHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICkgPD0gY2xvc2VzdFBvaW50Mi5kaXN0YW5jZVRvU3F1YXJlZCggcCApICkge1xuXG5cdFx0XHRcdHRhcmdldDEuY29weSggY2xvc2VzdFBvaW50ICk7XG5cdFx0XHRcdHRhcmdldDIuY29weSggcDIgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRhcmdldDEuY29weSggcCApO1xuXHRcdFx0XHR0YXJnZXQyLmNvcHkoIGNsb3Nlc3RQb2ludDIgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxufSApKCk7XG5cblxuZXhwb3J0IGNvbnN0IHNwaGVyZUludGVyc2VjdFRyaWFuZ2xlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQwNDM5NTUvZGV0ZWN0LWNvbGxpc2lvbi1iZXR3ZWVuLXNwaGVyZS1hbmQtdHJpYW5nbGUtaW4tdGhyZWUtanNcblx0Y29uc3QgY2xvc2VzdFBvaW50VGVtcCA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IHByb2plY3RlZFBvaW50VGVtcCA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IHBsYW5lVGVtcCA9IG5ldyBQbGFuZSgpO1xuXHRjb25zdCBsaW5lVGVtcCA9IG5ldyBMaW5lMygpO1xuXHRyZXR1cm4gZnVuY3Rpb24gc3BoZXJlSW50ZXJzZWN0VHJpYW5nbGUoIHNwaGVyZSwgdHJpYW5nbGUgKSB7XG5cblx0XHRjb25zdCB7IHJhZGl1cywgY2VudGVyIH0gPSBzcGhlcmU7XG5cdFx0Y29uc3QgeyBhLCBiLCBjIH0gPSB0cmlhbmdsZTtcblxuXHRcdC8vIHBoYXNlIDFcblx0XHRsaW5lVGVtcC5zdGFydCA9IGE7XG5cdFx0bGluZVRlbXAuZW5kID0gYjtcblx0XHRjb25zdCBjbG9zZXN0UG9pbnQxID0gbGluZVRlbXAuY2xvc2VzdFBvaW50VG9Qb2ludCggY2VudGVyLCB0cnVlLCBjbG9zZXN0UG9pbnRUZW1wICk7XG5cdFx0aWYgKCBjbG9zZXN0UG9pbnQxLmRpc3RhbmNlVG8oIGNlbnRlciApIDw9IHJhZGl1cyApIHJldHVybiB0cnVlO1xuXG5cdFx0bGluZVRlbXAuc3RhcnQgPSBhO1xuXHRcdGxpbmVUZW1wLmVuZCA9IGM7XG5cdFx0Y29uc3QgY2xvc2VzdFBvaW50MiA9IGxpbmVUZW1wLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGNlbnRlciwgdHJ1ZSwgY2xvc2VzdFBvaW50VGVtcCApO1xuXHRcdGlmICggY2xvc2VzdFBvaW50Mi5kaXN0YW5jZVRvKCBjZW50ZXIgKSA8PSByYWRpdXMgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdGxpbmVUZW1wLnN0YXJ0ID0gYjtcblx0XHRsaW5lVGVtcC5lbmQgPSBjO1xuXHRcdGNvbnN0IGNsb3Nlc3RQb2ludDMgPSBsaW5lVGVtcC5jbG9zZXN0UG9pbnRUb1BvaW50KCBjZW50ZXIsIHRydWUsIGNsb3Nlc3RQb2ludFRlbXAgKTtcblx0XHRpZiAoIGNsb3Nlc3RQb2ludDMuZGlzdGFuY2VUbyggY2VudGVyICkgPD0gcmFkaXVzICkgcmV0dXJuIHRydWU7XG5cblx0XHQvLyBwaGFzZSAyXG5cdFx0Y29uc3QgcGxhbmUgPSB0cmlhbmdsZS5nZXRQbGFuZSggcGxhbmVUZW1wICk7XG5cdFx0Y29uc3QgZHAgPSBNYXRoLmFicyggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKSApO1xuXHRcdGlmICggZHAgPD0gcmFkaXVzICkge1xuXG5cdFx0XHRjb25zdCBwcCA9IHBsYW5lLnByb2plY3RQb2ludCggY2VudGVyLCBwcm9qZWN0ZWRQb2ludFRlbXAgKTtcblx0XHRcdGNvbnN0IGNwID0gdHJpYW5nbGUuY29udGFpbnNQb2ludCggcHAgKTtcblx0XHRcdGlmICggY3AgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9O1xuXG59ICkoKTtcbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiVmVjdG9yMiIsIlBsYW5lIiwiTGluZTMiLCJjbG9zZXN0UG9pbnRMaW5lVG9MaW5lIiwiZGlyMSIsImRpcjIiLCJ2MDIiLCJsMSIsImwyIiwicmVzdWx0IiwidjAiLCJzdGFydCIsInYxMCIsInYyIiwidjMyIiwic3ViVmVjdG9ycyIsImVuZCIsImQwMjMyIiwiZG90IiwiZDMyMTAiLCJkMzIzMiIsImQwMjEwIiwiZDEwMTAiLCJkZW5vbSIsImQiLCJkMiIsIngiLCJ5IiwiY2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQiLCJwYXJhbVJlc3VsdCIsInRlbXAxIiwidGVtcDIiLCJ0YXJnZXQxIiwidGFyZ2V0MiIsImF0IiwiY2xvc2VzdFBvaW50VG9Qb2ludCIsInAiLCJwMiIsImNsb3Nlc3RQb2ludCIsImNsb3Nlc3RQb2ludDIiLCJkaXN0YW5jZVRvU3F1YXJlZCIsImNvcHkiLCJzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSIsImNsb3Nlc3RQb2ludFRlbXAiLCJwcm9qZWN0ZWRQb2ludFRlbXAiLCJwbGFuZVRlbXAiLCJsaW5lVGVtcCIsInNwaGVyZSIsInRyaWFuZ2xlIiwicmFkaXVzIiwiY2VudGVyIiwiYSIsImIiLCJjIiwiY2xvc2VzdFBvaW50MSIsImRpc3RhbmNlVG8iLCJjbG9zZXN0UG9pbnQzIiwicGxhbmUiLCJnZXRQbGFuZSIsImRwIiwiTWF0aCIsImFicyIsImRpc3RhbmNlVG9Qb2ludCIsInBwIiwicHJvamVjdFBvaW50IiwiY3AiLCJjb250YWluc1BvaW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/MathUtilities.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/OrientedBox.js":
/*!*************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/math/OrientedBox.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrientedBox: function() { return /* binding */ OrientedBox; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SeparatingAxisBounds.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js\");\n/* harmony import */ var _ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExtendedTriangle.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js\");\n/* harmony import */ var _MathUtilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MathUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/MathUtilities.js\");\n\n\n\n\nclass OrientedBox {\n    set(min, max, matrix) {\n        this.min.copy(min);\n        this.max.copy(max);\n        this.matrix.copy(matrix);\n        this.needsUpdate = true;\n    }\n    copy(other) {\n        this.min.copy(other.min);\n        this.max.copy(other.max);\n        this.matrix.copy(other.matrix);\n        this.needsUpdate = true;\n    }\n    constructor(min, max, matrix){\n        this.isOrientedBox = true;\n        this.min = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.max = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.invMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.points = new Array(8).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n        this.satAxes = new Array(3).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n        this.satBounds = new Array(3).fill().map(()=>new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds());\n        this.alignedSatBounds = new Array(3).fill().map(()=>new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds());\n        this.needsUpdate = false;\n        if (min) this.min.copy(min);\n        if (max) this.max.copy(max);\n        if (matrix) this.matrix.copy(matrix);\n    }\n}\nOrientedBox.prototype.update = function() {\n    return function update() {\n        const matrix = this.matrix;\n        const min = this.min;\n        const max = this.max;\n        const points = this.points;\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++){\n                for(let z = 0; z <= 1; z++){\n                    const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;\n                    const v = points[i];\n                    v.x = x ? max.x : min.x;\n                    v.y = y ? max.y : min.y;\n                    v.z = z ? max.z : min.z;\n                    v.applyMatrix4(matrix);\n                }\n            }\n        }\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        const minVec = points[0];\n        for(let i = 0; i < 3; i++){\n            const axis = satAxes[i];\n            const sb = satBounds[i];\n            const index = 1 << i;\n            const pi = points[index];\n            axis.subVectors(minVec, pi);\n            sb.setFromPoints(axis, points);\n        }\n        const alignedSatBounds = this.alignedSatBounds;\n        alignedSatBounds[0].setFromPointsField(points, \"x\");\n        alignedSatBounds[1].setFromPointsField(points, \"y\");\n        alignedSatBounds[2].setFromPointsField(points, \"z\");\n        this.invMatrix.copy(this.matrix).invert();\n        this.needsUpdate = false;\n    };\n}();\nOrientedBox.prototype.intersectsBox = function() {\n    const aabbBounds = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();\n    return function intersectsBox(box) {\n        // TODO: should this be doing SAT against the AABB?\n        if (this.needsUpdate) {\n            this.update();\n        }\n        const min = box.min;\n        const max = box.max;\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        const alignedSatBounds = this.alignedSatBounds;\n        aabbBounds.min = min.x;\n        aabbBounds.max = max.x;\n        if (alignedSatBounds[0].isSeparated(aabbBounds)) return false;\n        aabbBounds.min = min.y;\n        aabbBounds.max = max.y;\n        if (alignedSatBounds[1].isSeparated(aabbBounds)) return false;\n        aabbBounds.min = min.z;\n        aabbBounds.max = max.z;\n        if (alignedSatBounds[2].isSeparated(aabbBounds)) return false;\n        for(let i = 0; i < 3; i++){\n            const axis = satAxes[i];\n            const sb = satBounds[i];\n            aabbBounds.setFromBox(axis, box);\n            if (sb.isSeparated(aabbBounds)) return false;\n        }\n        return true;\n    };\n}();\nOrientedBox.prototype.intersectsTriangle = function() {\n    const saTri = new _ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTriangle();\n    const pointsArr = new Array(3);\n    const cachedSatBounds = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();\n    const cachedSatBounds2 = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();\n    const cachedAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function intersectsTriangle(triangle) {\n        if (this.needsUpdate) {\n            this.update();\n        }\n        if (!triangle.isExtendedTriangle) {\n            saTri.copy(triangle);\n            saTri.update();\n            triangle = saTri;\n        } else if (triangle.needsUpdate) {\n            triangle.update();\n        }\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        pointsArr[0] = triangle.a;\n        pointsArr[1] = triangle.b;\n        pointsArr[2] = triangle.c;\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds[i];\n            const sa = satAxes[i];\n            cachedSatBounds.setFromPoints(sa, pointsArr);\n            if (sb.isSeparated(cachedSatBounds)) return false;\n        }\n        const triSatBounds = triangle.satBounds;\n        const triSatAxes = triangle.satAxes;\n        const points = this.points;\n        for(let i = 0; i < 3; i++){\n            const sb = triSatBounds[i];\n            const sa = triSatAxes[i];\n            cachedSatBounds.setFromPoints(sa, points);\n            if (sb.isSeparated(cachedSatBounds)) return false;\n        }\n        // check crossed axes\n        for(let i = 0; i < 3; i++){\n            const sa1 = satAxes[i];\n            for(let i2 = 0; i2 < 4; i2++){\n                const sa2 = triSatAxes[i2];\n                cachedAxis.crossVectors(sa1, sa2);\n                cachedSatBounds.setFromPoints(cachedAxis, pointsArr);\n                cachedSatBounds2.setFromPoints(cachedAxis, points);\n                if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n            }\n        }\n        return true;\n    };\n}();\nOrientedBox.prototype.closestPointToPoint = function() {\n    return function closestPointToPoint(point, target1) {\n        if (this.needsUpdate) {\n            this.update();\n        }\n        target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);\n        return target1;\n    };\n}();\nOrientedBox.prototype.distanceToPoint = function() {\n    const target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function distanceToPoint(point) {\n        this.closestPointToPoint(point, target);\n        return point.distanceTo(target);\n    };\n}();\nOrientedBox.prototype.distanceToBox = function() {\n    const xyzFields = [\n        \"x\",\n        \"y\",\n        \"z\"\n    ];\n    const segments1 = new Array(12).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_0__.Line3());\n    const segments2 = new Array(12).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_0__.Line3());\n    const point1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const point2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    // early out if we find a value below threshold\n    return function distanceToBox(box) {\n        let threshold = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, target1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, target2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n        if (this.needsUpdate) {\n            this.update();\n        }\n        if (this.intersectsBox(box)) {\n            if (target1 || target2) {\n                box.getCenter(point2);\n                this.closestPointToPoint(point2, point1);\n                box.closestPointToPoint(point1, point2);\n                if (target1) target1.copy(point1);\n                if (target2) target2.copy(point2);\n            }\n            return 0;\n        }\n        const threshold2 = threshold * threshold;\n        const min = box.min;\n        const max = box.max;\n        const points = this.points;\n        // iterate over every edge and compare distances\n        let closestDistanceSq = Infinity;\n        // check over all these points\n        for(let i = 0; i < 8; i++){\n            const p = points[i];\n            point2.copy(p).clamp(min, max);\n            const dist = p.distanceToSquared(point2);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(p);\n                if (target2) target2.copy(point2);\n                if (dist < threshold2) return Math.sqrt(dist);\n            }\n        }\n        // generate and check all line segment distances\n        let count = 0;\n        for(let i = 0; i < 3; i++){\n            for(let i1 = 0; i1 <= 1; i1++){\n                for(let i2 = 0; i2 <= 1; i2++){\n                    const nextIndex = (i + 1) % 3;\n                    const nextIndex2 = (i + 2) % 3;\n                    // get obb line segments\n                    const index = i1 << nextIndex | i2 << nextIndex2;\n                    const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n                    const p1 = points[index];\n                    const p2 = points[index2];\n                    const line1 = segments1[count];\n                    line1.set(p1, p2);\n                    // get aabb line segments\n                    const f1 = xyzFields[i];\n                    const f2 = xyzFields[nextIndex];\n                    const f3 = xyzFields[nextIndex2];\n                    const line2 = segments2[count];\n                    const start = line2.start;\n                    const end = line2.end;\n                    start[f1] = min[f1];\n                    start[f2] = i1 ? min[f2] : max[f2];\n                    start[f3] = i2 ? min[f3] : max[f2];\n                    end[f1] = max[f1];\n                    end[f2] = i1 ? min[f2] : max[f2];\n                    end[f3] = i2 ? min[f3] : max[f2];\n                    count++;\n                }\n            }\n        }\n        // check all the other boxes point\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++){\n                for(let z = 0; z <= 1; z++){\n                    point2.x = x ? max.x : min.x;\n                    point2.y = y ? max.y : min.y;\n                    point2.z = z ? max.z : min.z;\n                    this.closestPointToPoint(point2, point1);\n                    const dist = point2.distanceToSquared(point1);\n                    if (dist < closestDistanceSq) {\n                        closestDistanceSq = dist;\n                        if (target1) target1.copy(point1);\n                        if (target2) target2.copy(point2);\n                        if (dist < threshold2) return Math.sqrt(dist);\n                    }\n                }\n            }\n        }\n        for(let i = 0; i < 12; i++){\n            const l1 = segments1[i];\n            for(let i2 = 0; i2 < 12; i2++){\n                const l2 = segments2[i2];\n                (0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_3__.closestPointsSegmentToSegment)(l1, l2, point1, point2);\n                const dist = point1.distanceToSquared(point2);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point1);\n                    if (target2) target2.copy(point2);\n                    if (dist < threshold2) return Math.sqrt(dist);\n                }\n            }\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvbWF0aC9PcmllbnRlZEJveC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnRDtBQUNpQjtBQUNSO0FBQ1U7QUFFNUQsTUFBTU07SUFxQlpDLElBQUtDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxNQUFNLEVBQUc7UUFFdkIsSUFBSSxDQUFDRixHQUFHLENBQUNHLElBQUksQ0FBRUg7UUFDZixJQUFJLENBQUNDLEdBQUcsQ0FBQ0UsSUFBSSxDQUFFRjtRQUNmLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxJQUFJLENBQUVEO1FBQ2xCLElBQUksQ0FBQ0UsV0FBVyxHQUFHO0lBRXBCO0lBRUFELEtBQU1FLEtBQUssRUFBRztRQUViLElBQUksQ0FBQ0wsR0FBRyxDQUFDRyxJQUFJLENBQUVFLE1BQU1MLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxHQUFHLENBQUNFLElBQUksQ0FBRUUsTUFBTUosR0FBRztRQUN4QixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFFRSxNQUFNSCxNQUFNO1FBQzlCLElBQUksQ0FBQ0UsV0FBVyxHQUFHO0lBRXBCO0lBbkNBRSxZQUFhTixHQUFHLEVBQUVDLEdBQUcsRUFBRUMsTUFBTSxDQUFHO1FBRS9CLElBQUksQ0FBQ0ssYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ1AsR0FBRyxHQUFHLElBQUlSLDBDQUFPQTtRQUN0QixJQUFJLENBQUNTLEdBQUcsR0FBRyxJQUFJVCwwQ0FBT0E7UUFDdEIsSUFBSSxDQUFDVSxNQUFNLEdBQUcsSUFBSVQsMENBQU9BO1FBQ3pCLElBQUksQ0FBQ2UsU0FBUyxHQUFHLElBQUlmLDBDQUFPQTtRQUM1QixJQUFJLENBQUNnQixNQUFNLEdBQUcsSUFBSUMsTUFBTyxHQUFJQyxJQUFJLEdBQUdDLEdBQUcsQ0FBRSxJQUFNLElBQUlwQiwwQ0FBT0E7UUFDMUQsSUFBSSxDQUFDcUIsT0FBTyxHQUFHLElBQUlILE1B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QixJQUFJbUIsQ0FBQztvQkFDNUJpRCxPQUFPaEQsQ0FBQyxHQUFHQSxJQUFJbkIsSUFBSW1CLENBQUMsR0FBR3BCLElBQUlvQixDQUFDO29CQUU1QixJQUFJLENBQUNvQyxtQkFBbUIsQ0FBRVksUUFBUUQ7b0JBQ2xDLE1BQU1TLE9BQU9SLE9BQU9TLGlCQUFpQixDQUFFVjtvQkFDdkMsSUFBS1MsT0FBT0gsbUJBQW9CO3dCQUUvQkEsb0JBQW9CRzt3QkFDcEIsSUFBS2xCLFNBQVVBLFFBQVF2RCxJQUFJLENBQUVnRTt3QkFDN0IsSUFBS0csU0FBVUEsUUFBUW5FLElBQUksQ0FBRWlFO3dCQUU3QixJQUFLUSxPQUFPSixZQUFhLE9BQU9NLEtBQUtDLElBQUksQ0FBRUg7b0JBRTVDO2dCQUVEO1lBRUQ7UUFFRDtRQUVBLElBQU0sSUFBSXZELElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFPO1lBRS9CLE1BQU15RSxLQUFLN0IsU0FBUyxDQUFFNUMsRUFBRztZQUN6QixJQUFNLElBQUlnQyxLQUFLLEdBQUdBLEtBQUssSUFBSUEsS0FBUTtnQkFFbEMsTUFBTTBDLEtBQUs3QixTQUFTLENBQUViLEdBQUk7Z0JBQzFCeEQsZ0ZBQTZCQSxDQUFFaUcsSUFBSUMsSUFBSTVCLFFBQVFDO2dCQUMvQyxNQUFNUSxPQUFPVCxPQUFPVSxpQkFBaUIsQ0FBRVQ7Z0JBQ3ZDLElBQUtRLE9BQU9ILG1CQUFvQjtvQkFFL0JBLG9CQUFvQkc7b0JBQ3BCLElBQUtsQixTQUFVQSxRQUFRdkQsSUFBSSxDQUFFZ0U7b0JBQzdCLElBQUtHLFNBQVVBLFFBQVFuRSxJQUFJLENBQUVpRTtvQkFFN0IsSUFBS1EsT0FBT0osWUFBYSxPQUFPTSxLQUFLQyxJQUFJLENBQUVIO2dCQUU1QztZQUVEO1FBRUQ7UUFFQSxPQUFPRSxLQUFLQyxJQUFJLENBQUVOO0lBRW5CO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9tYXRoL09yaWVudGVkQm94LmpzPzMxMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMywgTWF0cml4NCwgTGluZTMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBTZXBhcmF0aW5nQXhpc0JvdW5kcyB9IGZyb20gJy4vU2VwYXJhdGluZ0F4aXNCb3VuZHMuanMnO1xuaW1wb3J0IHsgRXh0ZW5kZWRUcmlhbmdsZSB9IGZyb20gJy4vRXh0ZW5kZWRUcmlhbmdsZS5qcyc7XG5pbXBvcnQgeyBjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCB9IGZyb20gJy4vTWF0aFV0aWxpdGllcy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBPcmllbnRlZEJveCB7XG5cblx0Y29uc3RydWN0b3IoIG1pbiwgbWF4LCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLmlzT3JpZW50ZWRCb3ggPSB0cnVlO1xuXHRcdHRoaXMubWluID0gbmV3IFZlY3RvcjMoKTtcblx0XHR0aGlzLm1heCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdHRoaXMuaW52TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLnBvaW50cyA9IG5ldyBBcnJheSggOCApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBWZWN0b3IzKCkgKTtcblx0XHR0aGlzLnNhdEF4ZXMgPSBuZXcgQXJyYXkoIDMgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgVmVjdG9yMygpICk7XG5cdFx0dGhpcy5zYXRCb3VuZHMgPSBuZXcgQXJyYXkoIDMgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKSApO1xuXHRcdHRoaXMuYWxpZ25lZFNhdEJvdW5kcyA9IG5ldyBBcnJheSggMyApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpICk7XG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0aWYgKCBtaW4gKSB0aGlzLm1pbi5jb3B5KCBtaW4gKTtcblx0XHRpZiAoIG1heCApIHRoaXMubWF4LmNvcHkoIG1heCApO1xuXHRcdGlmICggbWF0cml4ICkgdGhpcy5tYXRyaXguY29weSggbWF0cml4ICk7XG5cblx0fVxuXG5cdHNldCggbWluLCBtYXgsIG1hdHJpeCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXHRcdHRoaXMubWF0cml4LmNvcHkoIG1hdHJpeCApO1xuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRjb3B5KCBvdGhlciApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG90aGVyLm1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG90aGVyLm1heCApO1xuXHRcdHRoaXMubWF0cml4LmNvcHkoIG90aGVyLm1hdHJpeCApO1xuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG5PcmllbnRlZEJveC5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdGNvbnN0IG1hdHJpeCA9IHRoaXMubWF0cml4O1xuXHRcdGNvbnN0IG1pbiA9IHRoaXMubWluO1xuXHRcdGNvbnN0IG1heCA9IHRoaXMubWF4O1xuXG5cdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IDE7IHggKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8PSAxOyB5ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCB6ID0gMDsgeiA8PSAxOyB6ICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaSA9ICggKCAxIDw8IDAgKSAqIHggKSB8ICggKCAxIDw8IDEgKSAqIHkgKSB8ICggKCAxIDw8IDIgKSAqIHogKTtcblx0XHRcdFx0XHRjb25zdCB2ID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdFx0di54ID0geCA/IG1heC54IDogbWluLng7XG5cdFx0XHRcdFx0di55ID0geSA/IG1heC55IDogbWluLnk7XG5cdFx0XHRcdFx0di56ID0geiA/IG1heC56IDogbWluLno7XG5cblx0XHRcdFx0XHR2LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBzYXRCb3VuZHMgPSB0aGlzLnNhdEJvdW5kcztcblx0XHRjb25zdCBzYXRBeGVzID0gdGhpcy5zYXRBeGVzO1xuXHRcdGNvbnN0IG1pblZlYyA9IHBvaW50c1sgMCBdO1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGF4aXMgPSBzYXRBeGVzWyBpIF07XG5cdFx0XHRjb25zdCBzYiA9IHNhdEJvdW5kc1sgaSBdO1xuXHRcdFx0Y29uc3QgaW5kZXggPSAxIDw8IGk7XG5cdFx0XHRjb25zdCBwaSA9IHBvaW50c1sgaW5kZXggXTtcblxuXHRcdFx0YXhpcy5zdWJWZWN0b3JzKCBtaW5WZWMsIHBpICk7XG5cdFx0XHRzYi5zZXRGcm9tUG9pbnRzKCBheGlzLCBwb2ludHMgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGFsaWduZWRTYXRCb3VuZHMgPSB0aGlzLmFsaWduZWRTYXRCb3VuZHM7XG5cdFx0YWxpZ25lZFNhdEJvdW5kc1sgMCBdLnNldEZyb21Qb2ludHNGaWVsZCggcG9pbnRzLCAneCcgKTtcblx0XHRhbGlnbmVkU2F0Qm91bmRzWyAxIF0uc2V0RnJvbVBvaW50c0ZpZWxkKCBwb2ludHMsICd5JyApO1xuXHRcdGFsaWduZWRTYXRCb3VuZHNbIDIgXS5zZXRGcm9tUG9pbnRzRmllbGQoIHBvaW50cywgJ3onICk7XG5cblx0XHR0aGlzLmludk1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeCApLmludmVydCgpO1xuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHR9O1xuXG59ICkoKTtcblxuT3JpZW50ZWRCb3gucHJvdG90eXBlLmludGVyc2VjdHNCb3ggPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRjb25zdCBhYWJiQm91bmRzID0gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCk7XG5cdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHQvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBkb2luZyBTQVQgYWdhaW5zdCB0aGUgQUFCQj9cblx0XHRpZiAoIHRoaXMubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBtaW4gPSBib3gubWluO1xuXHRcdGNvbnN0IG1heCA9IGJveC5tYXg7XG5cdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cdFx0Y29uc3Qgc2F0QXhlcyA9IHRoaXMuc2F0QXhlcztcblx0XHRjb25zdCBhbGlnbmVkU2F0Qm91bmRzID0gdGhpcy5hbGlnbmVkU2F0Qm91bmRzO1xuXG5cdFx0YWFiYkJvdW5kcy5taW4gPSBtaW4ueDtcblx0XHRhYWJiQm91bmRzLm1heCA9IG1heC54O1xuXHRcdGlmICggYWxpZ25lZFNhdEJvdW5kc1sgMCBdLmlzU2VwYXJhdGVkKCBhYWJiQm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRhYWJiQm91bmRzLm1pbiA9IG1pbi55O1xuXHRcdGFhYmJCb3VuZHMubWF4ID0gbWF4Lnk7XG5cdFx0aWYgKCBhbGlnbmVkU2F0Qm91bmRzWyAxIF0uaXNTZXBhcmF0ZWQoIGFhYmJCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdGFhYmJCb3VuZHMubWluID0gbWluLno7XG5cdFx0YWFiYkJvdW5kcy5tYXggPSBtYXguejtcblx0XHRpZiAoIGFsaWduZWRTYXRCb3VuZHNbIDIgXS5pc1NlcGFyYXRlZCggYWFiYkJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgYXhpcyA9IHNhdEF4ZXNbIGkgXTtcblx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzWyBpIF07XG5cdFx0XHRhYWJiQm91bmRzLnNldEZyb21Cb3goIGF4aXMsIGJveCApO1xuXHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggYWFiYkJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fTtcblxufSApKCk7XG5cbk9yaWVudGVkQm94LnByb3RvdHlwZS5pbnRlcnNlY3RzVHJpYW5nbGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRjb25zdCBzYVRyaSA9IG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdGNvbnN0IHBvaW50c0FyciA9IG5ldyBBcnJheSggMyApO1xuXHRjb25zdCBjYWNoZWRTYXRCb3VuZHMgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0Y29uc3QgY2FjaGVkU2F0Qm91bmRzMiA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRjb25zdCBjYWNoZWRBeGlzID0gbmV3IFZlY3RvcjMoKTtcblx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUgKSB7XG5cblx0XHRpZiAoIHRoaXMubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoICEgdHJpYW5nbGUuaXNFeHRlbmRlZFRyaWFuZ2xlICkge1xuXG5cdFx0XHRzYVRyaS5jb3B5KCB0cmlhbmdsZSApO1xuXHRcdFx0c2FUcmkudXBkYXRlKCk7XG5cdFx0XHR0cmlhbmdsZSA9IHNhVHJpO1xuXG5cdFx0fSBlbHNlIGlmICggdHJpYW5nbGUubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdHRyaWFuZ2xlLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cdFx0Y29uc3Qgc2F0QXhlcyA9IHRoaXMuc2F0QXhlcztcblxuXHRcdHBvaW50c0FyclsgMCBdID0gdHJpYW5nbGUuYTtcblx0XHRwb2ludHNBcnJbIDEgXSA9IHRyaWFuZ2xlLmI7XG5cdFx0cG9pbnRzQXJyWyAyIF0gPSB0cmlhbmdsZS5jO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHNbIGkgXTtcblx0XHRcdGNvbnN0IHNhID0gc2F0QXhlc1sgaSBdO1xuXHRcdFx0Y2FjaGVkU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBwb2ludHNBcnIgKTtcblx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdHJpU2F0Qm91bmRzID0gdHJpYW5nbGUuc2F0Qm91bmRzO1xuXHRcdGNvbnN0IHRyaVNhdEF4ZXMgPSB0cmlhbmdsZS5zYXRBeGVzO1xuXHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHNiID0gdHJpU2F0Qm91bmRzWyBpIF07XG5cdFx0XHRjb25zdCBzYSA9IHRyaVNhdEF4ZXNbIGkgXTtcblx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBzYSwgcG9pbnRzICk7XG5cdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdC8vIGNoZWNrIGNyb3NzZWQgYXhlc1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHNhMSA9IHNhdEF4ZXNbIGkgXTtcblx0XHRcdGZvciAoIGxldCBpMiA9IDA7IGkyIDwgNDsgaTIgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2EyID0gdHJpU2F0QXhlc1sgaTIgXTtcblx0XHRcdFx0Y2FjaGVkQXhpcy5jcm9zc1ZlY3RvcnMoIHNhMSwgc2EyICk7XG5cdFx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBjYWNoZWRBeGlzLCBwb2ludHNBcnIgKTtcblx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzMi5zZXRGcm9tUG9pbnRzKCBjYWNoZWRBeGlzLCBwb2ludHMgKTtcblx0XHRcdFx0aWYgKCBjYWNoZWRTYXRCb3VuZHMuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kczIgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fTtcblxufSApKCk7XG5cbk9yaWVudGVkQm94LnByb3RvdHlwZS5jbG9zZXN0UG9pbnRUb1BvaW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCB0YXJnZXQxICkge1xuXG5cdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0MVxuXHRcdFx0LmNvcHkoIHBvaW50IClcblx0XHRcdC5hcHBseU1hdHJpeDQoIHRoaXMuaW52TWF0cml4IClcblx0XHRcdC5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4IClcblx0XHRcdC5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4ICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0MTtcblxuXHR9O1xuXG59ICkoKTtcblxuT3JpZW50ZWRCb3gucHJvdG90eXBlLmRpc3RhbmNlVG9Qb2ludCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdGNvbnN0IHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XG5cdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGFyZ2V0ICk7XG5cdFx0cmV0dXJuIHBvaW50LmRpc3RhbmNlVG8oIHRhcmdldCApO1xuXG5cdH07XG5cbn0gKSgpO1xuXG5PcmllbnRlZEJveC5wcm90b3R5cGUuZGlzdGFuY2VUb0JveCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdGNvbnN0IHh5ekZpZWxkcyA9IFsgJ3gnLCAneScsICd6JyBdO1xuXHRjb25zdCBzZWdtZW50czEgPSBuZXcgQXJyYXkoIDEyICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IExpbmUzKCkgKTtcblx0Y29uc3Qgc2VnbWVudHMyID0gbmV3IEFycmF5KCAxMiApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBMaW5lMygpICk7XG5cblx0Y29uc3QgcG9pbnQxID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgcG9pbnQyID0gbmV3IFZlY3RvcjMoKTtcblxuXHQvLyBlYXJseSBvdXQgaWYgd2UgZmluZCBhIHZhbHVlIGJlbG93IHRocmVzaG9sZFxuXHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb0JveCggYm94LCB0aHJlc2hvbGQgPSAwLCB0YXJnZXQxID0gbnVsbCwgdGFyZ2V0MiA9IG51bGwgKSB7XG5cblx0XHRpZiAoIHRoaXMubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICkgKSB7XG5cblx0XHRcdGlmICggdGFyZ2V0MSB8fCB0YXJnZXQyICkge1xuXG5cdFx0XHRcdGJveC5nZXRDZW50ZXIoIHBvaW50MiApO1xuXHRcdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50MiwgcG9pbnQxICk7XG5cdFx0XHRcdGJveC5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludDEsIHBvaW50MiApO1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0aHJlc2hvbGQyID0gdGhyZXNob2xkICogdGhyZXNob2xkO1xuXHRcdGNvbnN0IG1pbiA9IGJveC5taW47XG5cdFx0Y29uc3QgbWF4ID0gYm94Lm1heDtcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuXG5cdFx0Ly8gaXRlcmF0ZSBvdmVyIGV2ZXJ5IGVkZ2UgYW5kIGNvbXBhcmUgZGlzdGFuY2VzXG5cdFx0bGV0IGNsb3Nlc3REaXN0YW5jZVNxID0gSW5maW5pdHk7XG5cblx0XHQvLyBjaGVjayBvdmVyIGFsbCB0aGVzZSBwb2ludHNcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA4OyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwID0gcG9pbnRzWyBpIF07XG5cdFx0XHRwb2ludDIuY29weSggcCApLmNsYW1wKCBtaW4sIG1heCApO1xuXG5cdFx0XHRjb25zdCBkaXN0ID0gcC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcCApO1xuXHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdGlmICggZGlzdCA8IHRocmVzaG9sZDIgKSByZXR1cm4gTWF0aC5zcXJ0KCBkaXN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRlIGFuZCBjaGVjayBhbGwgbGluZSBzZWdtZW50IGRpc3RhbmNlc1xuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkxID0gMDsgaTEgPD0gMTsgaTEgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPD0gMTsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBuZXh0SW5kZXggPSAoIGkgKyAxICkgJSAzO1xuXHRcdFx0XHRcdGNvbnN0IG5leHRJbmRleDIgPSAoIGkgKyAyICkgJSAzO1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IG9iYiBsaW5lIHNlZ21lbnRzXG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBpMSA8PCBuZXh0SW5kZXggfCBpMiA8PCBuZXh0SW5kZXgyO1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4MiA9IDEgPDwgaSB8IGkxIDw8IG5leHRJbmRleCB8IGkyIDw8IG5leHRJbmRleDI7XG5cdFx0XHRcdFx0Y29uc3QgcDEgPSBwb2ludHNbIGluZGV4IF07XG5cdFx0XHRcdFx0Y29uc3QgcDIgPSBwb2ludHNbIGluZGV4MiBdO1xuXHRcdFx0XHRcdGNvbnN0IGxpbmUxID0gc2VnbWVudHMxWyBjb3VudCBdO1xuXHRcdFx0XHRcdGxpbmUxLnNldCggcDEsIHAyICk7XG5cblxuXHRcdFx0XHRcdC8vIGdldCBhYWJiIGxpbmUgc2VnbWVudHNcblx0XHRcdFx0XHRjb25zdCBmMSA9IHh5ekZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IGYyID0geHl6RmllbGRzWyBuZXh0SW5kZXggXTtcblx0XHRcdFx0XHRjb25zdCBmMyA9IHh5ekZpZWxkc1sgbmV4dEluZGV4MiBdO1xuXHRcdFx0XHRcdGNvbnN0IGxpbmUyID0gc2VnbWVudHMyWyBjb3VudCBdO1xuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gbGluZTIuc3RhcnQ7XG5cdFx0XHRcdFx0Y29uc3QgZW5kID0gbGluZTIuZW5kO1xuXG5cdFx0XHRcdFx0c3RhcnRbIGYxIF0gPSBtaW5bIGYxIF07XG5cdFx0XHRcdFx0c3RhcnRbIGYyIF0gPSBpMSA/IG1pblsgZjIgXSA6IG1heFsgZjIgXTtcblx0XHRcdFx0XHRzdGFydFsgZjMgXSA9IGkyID8gbWluWyBmMyBdIDogbWF4WyBmMiBdO1xuXG5cdFx0XHRcdFx0ZW5kWyBmMSBdID0gbWF4WyBmMSBdO1xuXHRcdFx0XHRcdGVuZFsgZjIgXSA9IGkxID8gbWluWyBmMiBdIDogbWF4WyBmMiBdO1xuXHRcdFx0XHRcdGVuZFsgZjMgXSA9IGkyID8gbWluWyBmMyBdIDogbWF4WyBmMiBdO1xuXG5cdFx0XHRcdFx0Y291bnQgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBjaGVjayBhbGwgdGhlIG90aGVyIGJveGVzIHBvaW50XG5cdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IDE7IHggKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8PSAxOyB5ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCB6ID0gMDsgeiA8PSAxOyB6ICsrICkge1xuXG5cdFx0XHRcdFx0cG9pbnQyLnggPSB4ID8gbWF4LnggOiBtaW4ueDtcblx0XHRcdFx0XHRwb2ludDIueSA9IHkgPyBtYXgueSA6IG1pbi55O1xuXHRcdFx0XHRcdHBvaW50Mi56ID0geiA/IG1heC56IDogbWluLno7XG5cblx0XHRcdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50MiwgcG9pbnQxICk7XG5cdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHBvaW50Mi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQxICk7XG5cdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCB0aHJlc2hvbGQyICkgcmV0dXJuIE1hdGguc3FydCggZGlzdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMTI7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGwxID0gc2VnbWVudHMxWyBpIF07XG5cdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8IDEyOyBpMiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBsMiA9IHNlZ21lbnRzMlsgaTIgXTtcblx0XHRcdFx0Y2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQoIGwxLCBsMiwgcG9pbnQxLCBwb2ludDIgKTtcblx0XHRcdFx0Y29uc3QgZGlzdCA9IHBvaW50MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0O1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0XHRcdGlmICggZGlzdCA8IHRocmVzaG9sZDIgKSByZXR1cm4gTWF0aC5zcXJ0KCBkaXN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcSApO1xuXG5cdH07XG5cbn0gKSgpO1xuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJNYXRyaXg0IiwiTGluZTMiLCJTZXBhcmF0aW5nQXhpc0JvdW5kcyIsIkV4dGVuZGVkVHJpYW5nbGUiLCJjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCIsIk9yaWVudGVkQm94Iiwic2V0IiwibWluIiwibWF4IiwibWF0cml4IiwiY29weSIsIm5lZWRzVXBkYXRlIiwib3RoZXIiLCJjb25zdHJ1Y3RvciIsImlzT3JpZW50ZWRCb3giLCJpbnZNYXRyaXgiLCJwb2ludHMiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJzYXRBeGVzIiwic2F0Qm91bmRzIiwiYWxpZ25lZFNhdEJvdW5kcyIsInByb3RvdHlwZSIsInVwZGF0ZSIsIngiLCJ5IiwieiIsImkiLCJ2IiwiYXBwbHlNYXRyaXg0IiwibWluVmVjIiwiYXhpcyIsInNiIiwiaW5kZXgiLCJwaSIsInN1YlZlY3RvcnMiLCJzZXRGcm9tUG9pbnRzIiwic2V0RnJvbVBvaW50c0ZpZWxkIiwiaW52ZXJ0IiwiaW50ZXJzZWN0c0JveCIsImFhYmJCb3VuZHMiLCJib3giLCJpc1NlcGFyYXRlZCIsInNldEZyb21Cb3giLCJpbnRlcnNlY3RzVHJpYW5nbGUiLCJzYVRyaSIsInBvaW50c0FyciIsImNhY2hlZFNhdEJvdW5kcyIsImNhY2hlZFNhdEJvdW5kczIiLCJjYWNoZWRBeGlzIiwidHJpYW5nbGUiLCJpc0V4dGVuZGVkVHJpYW5nbGUiLCJhIiwiYiIsImMiLCJzYSIsInRyaVNhdEJvdW5kcyIsInRyaVNhdEF4ZXMiLCJzYTEiLCJpMiIsInNhMiIsImNyb3NzVmVjdG9ycyIsImNsb3Nlc3RQb2ludFRvUG9pbnQiLCJwb2ludCIsInRhcmdldDEiLCJjbGFtcCIsImRpc3RhbmNlVG9Qb2ludCIsInRhcmdldCIsImRpc3RhbmNlVG8iLCJkaXN0YW5jZVRvQm94IiwieHl6RmllbGRzIiwic2VnbWVudHMxIiwic2VnbWVudHMyIiwicG9pbnQxIiwicG9pbnQyIiwidGhyZXNob2xkIiwidGFyZ2V0MiIsImdldENlbnRlciIsInRocmVzaG9sZDIiLCJjbG9zZXN0RGlzdGFuY2VTcSIsIkluZmluaXR5IiwicCIsImRpc3QiLCJkaXN0YW5jZVRvU3F1YXJlZCIsIk1hdGgiLCJzcXJ0IiwiY291bnQiLCJpMSIsIm5leHRJbmRleCIsIm5leHRJbmRleDIiLCJpbmRleDIiLCJwMSIsInAyIiwibGluZTEiLCJmMSIsImYyIiwiZjMiLCJsaW5lMiIsInN0YXJ0IiwiZW5kIiwibDEiLCJsMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/OrientedBox.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js":
/*!**********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SeparatingAxisBounds: function() { return /* binding */ SeparatingAxisBounds; },\n/* harmony export */   areIntersecting: function() { return /* binding */ areIntersecting; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nclass SeparatingAxisBounds {\n    setFromPointsField(points, field) {\n        let min = Infinity;\n        let max = -Infinity;\n        for(let i = 0, l = points.length; i < l; i++){\n            const p = points[i];\n            const val = p[field];\n            min = val < min ? val : min;\n            max = val > max ? val : max;\n        }\n        this.min = min;\n        this.max = max;\n    }\n    setFromPoints(axis, points) {\n        let min = Infinity;\n        let max = -Infinity;\n        for(let i = 0, l = points.length; i < l; i++){\n            const p = points[i];\n            const val = axis.dot(p);\n            min = val < min ? val : min;\n            max = val > max ? val : max;\n        }\n        this.min = min;\n        this.max = max;\n    }\n    isSeparated(other) {\n        return this.min > other.max || other.min > this.max;\n    }\n    constructor(){\n        this.min = Infinity;\n        this.max = -Infinity;\n    }\n}\nSeparatingAxisBounds.prototype.setFromBox = function() {\n    const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function setFromBox(axis, box) {\n        const boxMin = box.min;\n        const boxMax = box.max;\n        let min = Infinity;\n        let max = -Infinity;\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++){\n                for(let z = 0; z <= 1; z++){\n                    p.x = boxMin.x * x + boxMax.x * (1 - x);\n                    p.y = boxMin.y * y + boxMax.y * (1 - y);\n                    p.z = boxMin.z * z + boxMax.z * (1 - z);\n                    const val = axis.dot(p);\n                    min = Math.min(val, min);\n                    max = Math.max(val, max);\n                }\n            }\n        }\n        this.min = min;\n        this.max = max;\n    };\n}();\nconst areIntersecting = function() {\n    const cacheSatBounds = new SeparatingAxisBounds();\n    return function areIntersecting(shape1, shape2) {\n        const points1 = shape1.points;\n        const satAxes1 = shape1.satAxes;\n        const satBounds1 = shape1.satBounds;\n        const points2 = shape2.points;\n        const satAxes2 = shape2.satAxes;\n        const satBounds2 = shape2.satBounds;\n        // check axes of the first shape\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds1[i];\n            const sa = satAxes1[i];\n            cacheSatBounds.setFromPoints(sa, points2);\n            if (sb.isSeparated(cacheSatBounds)) return false;\n        }\n        // check axes of the second shape\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds2[i];\n            const sa = satAxes2[i];\n            cacheSatBounds.setFromPoints(sa, points1);\n            if (sb.isSeparated(cacheSatBounds)) return false;\n        }\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvbWF0aC9TZXBhcmF0aW5nQXhpc0JvdW5kcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0M7QUFFekIsTUFBTUM7SUFTWkMsbUJBQW9CQyxNQUFNLEVBQUVDLEtBQUssRUFBRztRQUVuQyxJQUFJQyxNQUFNQztRQUNWLElBQUlDLE1BQU0sQ0FBRUQ7UUFDWixJQUFNLElBQUlFLElBQUksR0FBR0MsSUFBSU4sT0FBT08sTUFBTSxFQUFFRixJQUFJQyxHQUFHRCxJQUFPO1lBRWpELE1BQU1HLElBQUlSLE1BQU0sQ0FBRUssRUFBRztZQUNyQixNQUFNSSxNQUFNRCxDQUFDLENBQUVQLE1BQU87WUFDdEJDLE1BQU1PLE1BQU1QLE1BQU1PLE1BQU1QO1lBQ3hCRSxNQUFNSyxNQUFNTCxNQUFNSyxNQUFNTDtRQUV6QjtRQUVBLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0UsR0FBRyxHQUFHQTtJQUVaO0lBRUFNLGNBQWVDLElBQUksRUFBRVgsTUFBTSxFQUFHO1FBRTdCLElBQUlFLE1BQU1DO1FBQ1YsSUFBSUMsTUFBTSxDQUFFRDtRQUNaLElBQU0sSUFBSUUsSUFBSSxHQUFHQyxJQUFJTixPQUFPTyxNQUFNLEVBQUVGLElBQUlDLEdBQUdELElBQU87WUFFakQsTUFBTUcsSUFBSVIsTUFBTSxDQUFFSyxFQUFHO1lBQ3JCLE1BQU1JLE1BQU1FLEtBQUtDLEdBQUcsQ0FBRUo7WUFDdEJOLE1BQU1PLE1BQU1QLE1BQU1PLE1BQU1QO1lBQ3hCRSxNQUFNSyxNQUFNTCxNQUFNSyxNQUFNTDtRQUV6QjtRQUVBLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0UsR0FBRyxHQUFHQTtJQUVaO0lBRUFTLFlBQWFDLEtBQUssRUFBRztRQUVwQixPQUFPLElBQUksQ0FBQ1osR0FBRyxHQUFHWSxNQUFNVixHQUFHLElBQUlVLE1BQU1aLEdBQUcsR0FBRyxJQUFJLENBQUNFLEdBQUc7SUFFcEQ7SUEvQ0FXLGFBQWM7UUFFYixJQUFJLENBQUNiLEdBQUcsR0FBR0M7UUFDWCxJQUFJLENBQUNDLEdBQUcsR0FBRyxDQUFFRDtJQUVkO0FBNENEO0FBRUFMLHFCQUFxQmtCLFNBQVMsQ0FBQ0MsVUFBVSxHQUFHO0lBRTNDLE1BQU1ULElBQUksSUFBSVgsMENBQU9BO0lBQ3JCLE9BQU8sU0FBU29CLFdBQVlOLElBQUksRUFBRU8sR0FBRztRQUVwQyxNQUFNQyxTQUFTRCxJQUFJaEIsR0FBRztRQUN0QixNQUFNa0IsU0FBU0YsSUFBSWQsR0FBRztRQUN0QixJQUFJRixNQUFNQztRQUNWLElBQUlDLE1BQU0sQ0FBRUQ7UUFDWixJQUFNLElBQUlrQixJQUFJLEdBQUdBLEtBQUssR0FBR0EsSUFBTztZQUUvQixJQUFNLElBQUlDLElBQUksR0FBR0EsS0FBSyxHQUFHQSxJQUFPO2dCQUUvQixJQUFNLElBQUlDLElBQUksR0FBR0EsS0FBSyxHQUFHQSxJQUFPO29CQUUvQmYsRUFBRWEsQ0FBQyxHQUFHRixPQUFPRSxDQUFDLEdBQUdBLElBQUlELE9BQU9DLENBQUMsR0FBSyxLQUFJQSxDQUFBQTtvQkFDdENiLEVBQUVjLENBQUMsR0FBR0gsT0FBT0csQ0FBQyxHQUFHQSxJQUFJRixPQUFPRSxDQUFDLEdBQUssS0FBSUEsQ0FBQUE7b0JBQ3RDZCxFQUFFZSxDQUFDLEdBQUdKLE9BQU9JLENBQUMsR0FBR0EsSUFBSUgsT0FBT0csQ0FBQyxHQUFLLEtBQUlBLENBQUFBO29CQUV0QyxNQUFNZCxNQUFNRSxLQUFLQyxHQUFHLENBQUVKO29CQUN0Qk4sTUFBTXNCLEtBQUt0QixHQUFHLENBQUVPLEtBQUtQO29CQUNyQkUsTUFBTW9CLEtBQUtwQixHQUFHLENBQUVLLEtBQUtMO2dCQUV0QjtZQUVEO1FBRUQ7UUFFQSxJQUFJLENBQUNGLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNFLEdBQUcsR0FBR0E7SUFFWjtBQUVEO0FBRU8sTUFBTXFCLGtCQUFrQjtJQUU5QixNQUFNQyxpQkFBaUIsSUFBSTVCO0lBQzNCLE9BQU8sU0FBUzJCLGdCQUFpQkUsTUFBTSxFQUFFQyxNQUFNO1FBRTlDLE1BQU1DLFVBQVVGLE9BQU8zQixNQUFNO1FBQzdCLE1BQU04QixXQUFXSCxPQUFPSSxPQUFPO1FBQy9CLE1BQU1DLGFBQWFMLE9BQU9NLFNBQVM7UUFFbkMsTUFBTUMsVUFBVU4sT0FBTzVCLE1BQU07UUFDN0IsTUFBTW1DLFdBQVdQLE9BQU9HLE9BQU87UUFDL0IsTUFBTUssYUFBYVIsT0FBT0ssU0FBUztRQUVuQyxnQ0FBZ0M7UUFDaEMsSUFBTSxJQUFJNUIsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQU87WUFFOUIsTUFBTWdDLEtBQUtMLFVBQVUsQ0FBRTNCLEVBQUc7WUFDMUIsTUFBTWlDLEtBQUtSLFFBQVEsQ0FBRXpCLEVBQUc7WUFDeEJxQixlQUFlaEIsYUFBYSxDQUFFNEIsSUFBSUo7WUFDbEMsSUFBS0csR0FBR3hCLFdBQVcsQ0FBRWEsaUJBQW1CLE9BQU87UUFFaEQ7UUFFQSxpQ0FBaUM7UUFDakMsSUFBTSxJQUFJckIsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQU87WUFFOUIsTUFBTWdDLEtBQUtELFVBQVUsQ0FBRS9CLEVBQUc7WUFDMUIsTUFBTWlDLEtBQUtILFFBQVEsQ0FBRTlCLEVBQUc7WUFDeEJxQixlQUFlaEIsYUFBYSxDQUFFNEIsSUFBSVQ7WUFDbEMsSUFBS1EsR0FBR3hCLFdBQVcsQ0FBRWEsaUJBQW1CLE9BQU87UUFFaEQ7SUFFRDtBQUVELElBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9tYXRoL1NlcGFyYXRpbmdBeGlzQm91bmRzLmpzPzQzODYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcblxuZXhwb3J0IGNsYXNzIFNlcGFyYXRpbmdBeGlzQm91bmRzIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMubWluID0gSW5maW5pdHk7XG5cdFx0dGhpcy5tYXggPSAtIEluZmluaXR5O1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzRmllbGQoIHBvaW50cywgZmllbGQgKSB7XG5cblx0XHRsZXQgbWluID0gSW5maW5pdHk7XG5cdFx0bGV0IG1heCA9IC0gSW5maW5pdHk7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHAgPSBwb2ludHNbIGkgXTtcblx0XHRcdGNvbnN0IHZhbCA9IHBbIGZpZWxkIF07XG5cdFx0XHRtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XG5cdFx0XHRtYXggPSB2YWwgPiBtYXggPyB2YWwgOiBtYXg7XG5cblx0XHR9XG5cblx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHR0aGlzLm1heCA9IG1heDtcblxuXHR9XG5cblx0c2V0RnJvbVBvaW50cyggYXhpcywgcG9pbnRzICkge1xuXG5cdFx0bGV0IG1pbiA9IEluZmluaXR5O1xuXHRcdGxldCBtYXggPSAtIEluZmluaXR5O1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwID0gcG9pbnRzWyBpIF07XG5cdFx0XHRjb25zdCB2YWwgPSBheGlzLmRvdCggcCApO1xuXHRcdFx0bWluID0gdmFsIDwgbWluID8gdmFsIDogbWluO1xuXHRcdFx0bWF4ID0gdmFsID4gbWF4ID8gdmFsIDogbWF4O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0dGhpcy5tYXggPSBtYXg7XG5cblx0fVxuXG5cdGlzU2VwYXJhdGVkKCBvdGhlciApIHtcblxuXHRcdHJldHVybiB0aGlzLm1pbiA+IG90aGVyLm1heCB8fCBvdGhlci5taW4gPiB0aGlzLm1heDtcblxuXHR9XG5cbn1cblxuU2VwYXJhdGluZ0F4aXNCb3VuZHMucHJvdG90eXBlLnNldEZyb21Cb3ggPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRjb25zdCBwID0gbmV3IFZlY3RvcjMoKTtcblx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21Cb3goIGF4aXMsIGJveCApIHtcblxuXHRcdGNvbnN0IGJveE1pbiA9IGJveC5taW47XG5cdFx0Y29uc3QgYm94TWF4ID0gYm94Lm1heDtcblx0XHRsZXQgbWluID0gSW5maW5pdHk7XG5cdFx0bGV0IG1heCA9IC0gSW5maW5pdHk7XG5cdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IDE7IHggKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8PSAxOyB5ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCB6ID0gMDsgeiA8PSAxOyB6ICsrICkge1xuXG5cdFx0XHRcdFx0cC54ID0gYm94TWluLnggKiB4ICsgYm94TWF4LnggKiAoIDEgLSB4ICk7XG5cdFx0XHRcdFx0cC55ID0gYm94TWluLnkgKiB5ICsgYm94TWF4LnkgKiAoIDEgLSB5ICk7XG5cdFx0XHRcdFx0cC56ID0gYm94TWluLnogKiB6ICsgYm94TWF4LnogKiAoIDEgLSB6ICk7XG5cblx0XHRcdFx0XHRjb25zdCB2YWwgPSBheGlzLmRvdCggcCApO1xuXHRcdFx0XHRcdG1pbiA9IE1hdGgubWluKCB2YWwsIG1pbiApO1xuXHRcdFx0XHRcdG1heCA9IE1hdGgubWF4KCB2YWwsIG1heCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0dGhpcy5tYXggPSBtYXg7XG5cblx0fTtcblxufSApKCk7XG5cbmV4cG9ydCBjb25zdCBhcmVJbnRlcnNlY3RpbmcgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRjb25zdCBjYWNoZVNhdEJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRyZXR1cm4gZnVuY3Rpb24gYXJlSW50ZXJzZWN0aW5nKCBzaGFwZTEsIHNoYXBlMiApIHtcblxuXHRcdGNvbnN0IHBvaW50czEgPSBzaGFwZTEucG9pbnRzO1xuXHRcdGNvbnN0IHNhdEF4ZXMxID0gc2hhcGUxLnNhdEF4ZXM7XG5cdFx0Y29uc3Qgc2F0Qm91bmRzMSA9IHNoYXBlMS5zYXRCb3VuZHM7XG5cblx0XHRjb25zdCBwb2ludHMyID0gc2hhcGUyLnBvaW50cztcblx0XHRjb25zdCBzYXRBeGVzMiA9IHNoYXBlMi5zYXRBeGVzO1xuXHRcdGNvbnN0IHNhdEJvdW5kczIgPSBzaGFwZTIuc2F0Qm91bmRzO1xuXG5cdFx0Ly8gY2hlY2sgYXhlcyBvZiB0aGUgZmlyc3Qgc2hhcGVcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzYiA9IHNhdEJvdW5kczFbIGkgXTtcblx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczFbIGkgXTtcblx0XHRcdGNhY2hlU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBwb2ludHMyICk7XG5cdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZVNhdEJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgYXhlcyBvZiB0aGUgc2Vjb25kIHNoYXBlXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHMyWyBpIF07XG5cdFx0XHRjb25zdCBzYSA9IHNhdEF4ZXMyWyBpIF07XG5cdFx0XHRjYWNoZVNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBzYSwgcG9pbnRzMSApO1xuXHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHR9O1xuXG59ICkoKTtcbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiU2VwYXJhdGluZ0F4aXNCb3VuZHMiLCJzZXRGcm9tUG9pbnRzRmllbGQiLCJwb2ludHMiLCJmaWVsZCIsIm1pbiIsIkluZmluaXR5IiwibWF4IiwiaSIsImwiLCJsZW5ndGgiLCJwIiwidmFsIiwic2V0RnJvbVBvaW50cyIsImF4aXMiLCJkb3QiLCJpc1NlcGFyYXRlZCIsIm90aGVyIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJzZXRGcm9tQm94IiwiYm94IiwiYm94TWluIiwiYm94TWF4IiwieCIsInkiLCJ6IiwiTWF0aCIsImFyZUludGVyc2VjdGluZyIsImNhY2hlU2F0Qm91bmRzIiwic2hhcGUxIiwic2hhcGUyIiwicG9pbnRzMSIsInNhdEF4ZXMxIiwic2F0QXhlcyIsInNhdEJvdW5kczEiLCJzYXRCb3VuZHMiLCJwb2ludHMyIiwic2F0QXhlczIiLCJzYXRCb3VuZHMyIiwic2IiLCJzYSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js":
/*!********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayToBox: function() { return /* binding */ arrayToBox; },\n/* harmony export */   computeSurfaceArea: function() { return /* binding */ computeSurfaceArea; },\n/* harmony export */   copyBounds: function() { return /* binding */ copyBounds; },\n/* harmony export */   expandByTriangleBounds: function() { return /* binding */ expandByTriangleBounds; },\n/* harmony export */   getLongestEdgeIndex: function() { return /* binding */ getLongestEdgeIndex; },\n/* harmony export */   makeEmptyBounds: function() { return /* binding */ makeEmptyBounds; },\n/* harmony export */   unionBounds: function() { return /* binding */ unionBounds; }\n/* harmony export */ });\nfunction arrayToBox(nodeIndex32, array, target) {\n    target.min.x = array[nodeIndex32];\n    target.min.y = array[nodeIndex32 + 1];\n    target.min.z = array[nodeIndex32 + 2];\n    target.max.x = array[nodeIndex32 + 3];\n    target.max.y = array[nodeIndex32 + 4];\n    target.max.z = array[nodeIndex32 + 5];\n    return target;\n}\nfunction makeEmptyBounds(target) {\n    target[0] = target[1] = target[2] = Infinity;\n    target[3] = target[4] = target[5] = -Infinity;\n}\nfunction getLongestEdgeIndex(bounds) {\n    let splitDimIdx = -1;\n    let splitDist = -Infinity;\n    for(let i = 0; i < 3; i++){\n        const dist = bounds[i + 3] - bounds[i];\n        if (dist > splitDist) {\n            splitDist = dist;\n            splitDimIdx = i;\n        }\n    }\n    return splitDimIdx;\n}\n// copies bounds a into bounds b\nfunction copyBounds(source, target) {\n    target.set(source);\n}\n// sets bounds target to the union of bounds a and b\nfunction unionBounds(a, b, target) {\n    let aVal, bVal;\n    for(let d = 0; d < 3; d++){\n        const d3 = d + 3;\n        // set the minimum values\n        aVal = a[d];\n        bVal = b[d];\n        target[d] = aVal < bVal ? aVal : bVal;\n        // set the max values\n        aVal = a[d3];\n        bVal = b[d3];\n        target[d3] = aVal > bVal ? aVal : bVal;\n    }\n}\n// expands the given bounds by the provided triangle bounds\nfunction expandByTriangleBounds(startIndex, triangleBounds, bounds) {\n    for(let d = 0; d < 3; d++){\n        const tCenter = triangleBounds[startIndex + 2 * d];\n        const tHalf = triangleBounds[startIndex + 2 * d + 1];\n        const tMin = tCenter - tHalf;\n        const tMax = tCenter + tHalf;\n        if (tMin < bounds[d]) {\n            bounds[d] = tMin;\n        }\n        if (tMax > bounds[d + 3]) {\n            bounds[d + 3] = tMax;\n        }\n    }\n}\n// compute bounds surface area\nfunction computeSurfaceArea(bounds) {\n    const d0 = bounds[3] - bounds[0];\n    const d1 = bounds[4] - bounds[1];\n    const d2 = bounds[5] - bounds[2];\n    return 2 * (d0 * d1 + d1 * d2 + d2 * d0);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvQXJyYXlCb3hVdGlsaXRpZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFPLFNBQVNBLFdBQVlDLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxNQUFNO0lBRXJEQSxPQUFPQyxHQUFHLENBQUNDLENBQUMsR0FBR0gsS0FBSyxDQUFFRCxZQUFhO0lBQ25DRSxPQUFPQyxHQUFHLENBQUNFLENBQUMsR0FBR0osS0FBSyxDQUFFRCxjQUFjLEVBQUc7SUFDdkNFLE9BQU9DLEdBQUcsQ0FBQ0csQ0FBQyxHQUFHTCxLQUFLLENBQUVELGNBQWMsRUFBRztJQUV2Q0UsT0FBT0ssR0FBRyxDQUFDSCxDQUFDLEdBQUdILEtBQUssQ0FBRUQsY0FBYyxFQUFHO0lBQ3ZDRSxPQUFPSyxHQUFHLENBQUNGLENBQUMsR0FBR0osS0FBSyxDQUFFRCxjQUFjLEVBQUc7SUFDdkNFLE9BQU9LLEdBQUcsQ0FBQ0QsQ0FBQyxHQUFHTCxLQUFLLENBQUVELGNBQWMsRUFBRztJQUV2QyxPQUFPRTtBQUVSO0FBRU8sU0FBU00sZ0JBQWlCTixNQUFNO0lBRXRDQSxNQUFNLENBQUUsRUFBRyxHQUFHQSxNQUFNLENBQUUsRUFBRyxHQUFHQSxNQUFNLENBQUUsRUFBRyxHQUFHTztJQUMxQ1AsTUFBTSxDQUFFLEVBQUcsR0FBR0EsTUFBTSxDQUFFLEVBQUcsR0FBR0EsTUFBTSxDQUFFLEVBQUcsR0FBRyxDQUFFTztBQUU3QztBQUVPLFNBQVNDLG9CQUFxQkMsTUFBTTtJQUUxQyxJQUFJQyxjQUFjLENBQUU7SUFDcEIsSUFBSUMsWUFBWSxDQUFFSjtJQUVsQixJQUFNLElBQUlLLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFPO1FBRTlCLE1BQU1DLE9BQU9KLE1BQU0sQ0FBRUcsSUFBSSxFQUFHLEdBQUdILE1BQU0sQ0FBRUcsRUFBRztRQUMxQyxJQUFLQyxPQUFPRixXQUFZO1lBRXZCQSxZQUFZRTtZQUNaSCxjQUFjRTtRQUVmO0lBRUQ7SUFFQSxPQUFPRjtBQUVSO0FBRUEsZ0NBQWdDO0FBQ3pCLFNBQVNJLFdBQVlDLE1BQU0sRUFBRWYsTUFBTTtJQUV6Q0EsT0FBT2dCLEdBQUcsQ0FBRUQ7QUFFYjtBQUVBLG9EQUFvRDtBQUM3QyxTQUFTRSxZQUFhQyxDQUFDLEVBQUVDLENBQUMsRUFBRW5CLE1BQU07SUFFeEMsSUFBSW9CLE1BQU1DO0lBQ1YsSUFBTSxJQUFJQyxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBTztRQUU5QixNQUFNQyxLQUFLRCxJQUFJO1FBRWYseUJBQXlCO1FBQ3pCRixPQUFPRixDQUFDLENBQUVJLEVBQUc7UUFDYkQsT0FBT0YsQ0FBQyxDQUFFRyxFQUFHO1FBQ2J0QixNQUFNLENBQUVzQixFQUFHLEdBQUdGLE9BQU9DLE9BQU9ELE9BQU9DO1FBRW5DLHFCQUFxQjtRQUNyQkQsT0FBT0YsQ0FBQyxDQUFFSyxHQUFJO1FBQ2RGLE9BQU9GLENBQUMsQ0FBRUksR0FBSTtRQUNkdkIsTUFBTSxDQUFFdUIsR0FBSSxHQUFHSCxPQUFPQyxPQUFPRCxPQUFPQztJQUVyQztBQUVEO0FBRUEsMkRBQTJEO0FBQ3BELFNBQVNHLHVCQUF3QkMsVUFBVSxFQUFFQyxjQUFjLEVBQUVqQixNQUFNO0lBRXpFLElBQU0sSUFBSWEsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQU87UUFFOUIsTUFBTUssVUFBVUQsY0FBYyxDQUFFRCxhQUFhLElBQUlILEVBQUc7UUFDcEQsTUFBTU0sUUFBUUYsY0FBYyxDQUFFRCxhQUFhLElBQUlILElBQUksRUFBRztRQUV0RCxNQUFNTyxPQUFPRixVQUFVQztRQUN2QixNQUFNRSxPQUFPSCxVQUFVQztRQUV2QixJQUFLQyxPQUFPcEIsTUFBTSxDQUFFYSxFQUFHLEVBQUc7WUFFekJiLE1BQU0sQ0FBRWEsRUFBRyxHQUFHTztRQUVmO1FBRUEsSUFBS0MsT0FBT3JCLE1BQU0sQ0FBRWEsSUFBSSxFQUFHLEVBQUc7WUFFN0JiLE1BQU0sQ0FBRWEsSUFBSSxFQUFHLEdBQUdRO1FBRW5CO0lBRUQ7QUFFRDtBQUVBLDhCQUE4QjtBQUN2QixTQUFTQyxtQkFBb0J0QixNQUFNO0lBRXpDLE1BQU11QixLQUFLdkIsTUFBTSxDQUFFLEVBQUcsR0FBR0EsTUFBTSxDQUFFLEVBQUc7SUFDcEMsTUFBTXdCLEtBQUt4QixNQUFNLENBQUUsRUFBRyxHQUFHQSxNQUFNLENBQUUsRUFBRztJQUNwQyxNQUFNeUIsS0FBS3pCLE1BQU0sQ0FBRSxFQUFHLEdBQUdBLE1BQU0sQ0FBRSxFQUFHO0lBRXBDLE9BQU8sSUFBTXVCLENBQUFBLEtBQUtDLEtBQUtBLEtBQUtDLEtBQUtBLEtBQUtGLEVBQUM7QUFFeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9BcnJheUJveFV0aWxpdGllcy5qcz9jMTczIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBhcnJheVRvQm94KCBub2RlSW5kZXgzMiwgYXJyYXksIHRhcmdldCApIHtcblxuXHR0YXJnZXQubWluLnggPSBhcnJheVsgbm9kZUluZGV4MzIgXTtcblx0dGFyZ2V0Lm1pbi55ID0gYXJyYXlbIG5vZGVJbmRleDMyICsgMSBdO1xuXHR0YXJnZXQubWluLnogPSBhcnJheVsgbm9kZUluZGV4MzIgKyAyIF07XG5cblx0dGFyZ2V0Lm1heC54ID0gYXJyYXlbIG5vZGVJbmRleDMyICsgMyBdO1xuXHR0YXJnZXQubWF4LnkgPSBhcnJheVsgbm9kZUluZGV4MzIgKyA0IF07XG5cdHRhcmdldC5tYXgueiA9IGFycmF5WyBub2RlSW5kZXgzMiArIDUgXTtcblxuXHRyZXR1cm4gdGFyZ2V0O1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRW1wdHlCb3VuZHMoIHRhcmdldCApIHtcblxuXHR0YXJnZXRbIDAgXSA9IHRhcmdldFsgMSBdID0gdGFyZ2V0WyAyIF0gPSBJbmZpbml0eTtcblx0dGFyZ2V0WyAzIF0gPSB0YXJnZXRbIDQgXSA9IHRhcmdldFsgNSBdID0gLSBJbmZpbml0eTtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9uZ2VzdEVkZ2VJbmRleCggYm91bmRzICkge1xuXG5cdGxldCBzcGxpdERpbUlkeCA9IC0gMTtcblx0bGV0IHNwbGl0RGlzdCA9IC0gSW5maW5pdHk7XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdGNvbnN0IGRpc3QgPSBib3VuZHNbIGkgKyAzIF0gLSBib3VuZHNbIGkgXTtcblx0XHRpZiAoIGRpc3QgPiBzcGxpdERpc3QgKSB7XG5cblx0XHRcdHNwbGl0RGlzdCA9IGRpc3Q7XG5cdFx0XHRzcGxpdERpbUlkeCA9IGk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBzcGxpdERpbUlkeDtcblxufVxuXG4vLyBjb3BpZXMgYm91bmRzIGEgaW50byBib3VuZHMgYlxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlCb3VuZHMoIHNvdXJjZSwgdGFyZ2V0ICkge1xuXG5cdHRhcmdldC5zZXQoIHNvdXJjZSApO1xuXG59XG5cbi8vIHNldHMgYm91bmRzIHRhcmdldCB0byB0aGUgdW5pb24gb2YgYm91bmRzIGEgYW5kIGJcbmV4cG9ydCBmdW5jdGlvbiB1bmlvbkJvdW5kcyggYSwgYiwgdGFyZ2V0ICkge1xuXG5cdGxldCBhVmFsLCBiVmFsO1xuXHRmb3IgKCBsZXQgZCA9IDA7IGQgPCAzOyBkICsrICkge1xuXG5cdFx0Y29uc3QgZDMgPSBkICsgMztcblxuXHRcdC8vIHNldCB0aGUgbWluaW11bSB2YWx1ZXNcblx0XHRhVmFsID0gYVsgZCBdO1xuXHRcdGJWYWwgPSBiWyBkIF07XG5cdFx0dGFyZ2V0WyBkIF0gPSBhVmFsIDwgYlZhbCA/IGFWYWwgOiBiVmFsO1xuXG5cdFx0Ly8gc2V0IHRoZSBtYXggdmFsdWVzXG5cdFx0YVZhbCA9IGFbIGQzIF07XG5cdFx0YlZhbCA9IGJbIGQzIF07XG5cdFx0dGFyZ2V0WyBkMyBdID0gYVZhbCA+IGJWYWwgPyBhVmFsIDogYlZhbDtcblxuXHR9XG5cbn1cblxuLy8gZXhwYW5kcyB0aGUgZ2l2ZW4gYm91bmRzIGJ5IHRoZSBwcm92aWRlZCB0cmlhbmdsZSBib3VuZHNcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRCeVRyaWFuZ2xlQm91bmRzKCBzdGFydEluZGV4LCB0cmlhbmdsZUJvdW5kcywgYm91bmRzICkge1xuXG5cdGZvciAoIGxldCBkID0gMDsgZCA8IDM7IGQgKysgKSB7XG5cblx0XHRjb25zdCB0Q2VudGVyID0gdHJpYW5nbGVCb3VuZHNbIHN0YXJ0SW5kZXggKyAyICogZCBdO1xuXHRcdGNvbnN0IHRIYWxmID0gdHJpYW5nbGVCb3VuZHNbIHN0YXJ0SW5kZXggKyAyICogZCArIDEgXTtcblxuXHRcdGNvbnN0IHRNaW4gPSB0Q2VudGVyIC0gdEhhbGY7XG5cdFx0Y29uc3QgdE1heCA9IHRDZW50ZXIgKyB0SGFsZjtcblxuXHRcdGlmICggdE1pbiA8IGJvdW5kc1sgZCBdICkge1xuXG5cdFx0XHRib3VuZHNbIGQgXSA9IHRNaW47XG5cblx0XHR9XG5cblx0XHRpZiAoIHRNYXggPiBib3VuZHNbIGQgKyAzIF0gKSB7XG5cblx0XHRcdGJvdW5kc1sgZCArIDMgXSA9IHRNYXg7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8vIGNvbXB1dGUgYm91bmRzIHN1cmZhY2UgYXJlYVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTdXJmYWNlQXJlYSggYm91bmRzICkge1xuXG5cdGNvbnN0IGQwID0gYm91bmRzWyAzIF0gLSBib3VuZHNbIDAgXTtcblx0Y29uc3QgZDEgPSBib3VuZHNbIDQgXSAtIGJvdW5kc1sgMSBdO1xuXHRjb25zdCBkMiA9IGJvdW5kc1sgNSBdIC0gYm91bmRzWyAyIF07XG5cblx0cmV0dXJuIDIgKiAoIGQwICogZDEgKyBkMSAqIGQyICsgZDIgKiBkMCApO1xuXG59XG4iXSwibmFtZXMiOlsiYXJyYXlUb0JveCIsIm5vZGVJbmRleDMyIiwiYXJyYXkiLCJ0YXJnZXQiLCJtaW4iLCJ4IiwieSIsInoiLCJtYXgiLCJtYWtlRW1wdHlCb3VuZHMiLCJJbmZpbml0eSIsImdldExvbmdlc3RFZGdlSW5kZXgiLCJib3VuZHMiLCJzcGxpdERpbUlkeCIsInNwbGl0RGlzdCIsImkiLCJkaXN0IiwiY29weUJvdW5kcyIsInNvdXJjZSIsInNldCIsInVuaW9uQm91bmRzIiwiYSIsImIiLCJhVmFsIiwiYlZhbCIsImQiLCJkMyIsImV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMiLCJzdGFydEluZGV4IiwidHJpYW5nbGVCb3VuZHMiLCJ0Q2VudGVyIiwidEhhbGYiLCJ0TWluIiwidE1heCIsImNvbXB1dGVTdXJmYWNlQXJlYSIsImQwIiwiZDEiLCJkMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/BufferUtils.js":
/*!**************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/BufferUtils.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToBufferType: function() { return /* binding */ convertToBufferType; },\n/* harmony export */   isSharedArrayBufferSupported: function() { return /* binding */ isSharedArrayBufferSupported; }\n/* harmony export */ });\nfunction isSharedArrayBufferSupported() {\n    return typeof SharedArrayBuffer !== \"undefined\";\n}\nfunction convertToBufferType(array, BufferConstructor) {\n    if (array === null) {\n        return array;\n    } else if (array.buffer) {\n        const buffer = array.buffer;\n        if (buffer.constructor === BufferConstructor) {\n            return array;\n        }\n        const ArrayConstructor = array.constructor;\n        const result = new ArrayConstructor(new BufferConstructor(buffer.byteLength));\n        result.set(array);\n        return result;\n    } else {\n        if (array.constructor === BufferConstructor) {\n            return array;\n        }\n        const result = new BufferConstructor(array.byteLength);\n        new Uint8Array(result).set(new Uint8Array(array));\n        return result;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvQnVmZmVyVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQTtJQUVmLE9BQU8sT0FBT0Msc0JBQXNCO0FBRXJDO0FBRU8sU0FBU0Msb0JBQXFCQyxLQUFLLEVBQUVDLGlCQUFpQjtJQUU1RCxJQUFLRCxVQUFVLE1BQU87UUFFckIsT0FBT0E7SUFFUixPQUFPLElBQUtBLE1BQU1FLE1BQU0sRUFBRztRQUUxQixNQUFNQSxTQUFTRixNQUFNRSxNQUFNO1FBQzNCLElBQUtBLE9BQU9DLFdBQVcsS0FBS0YsbUJBQW9CO1lBRS9DLE9BQU9EO1FBRVI7UUFFQSxNQUFNSSxtQkFBbUJKLE1BQU1HLFdBQVc7UUFDMUMsTUFBTUUsU0FBUyxJQUFJRCxpQkFBa0IsSUFBSUgsa0JBQW1CQyxPQUFPSSxVQUFVO1FBQzdFRCxPQUFPRSxHQUFHLENBQUVQO1FBQ1osT0FBT0s7SUFFUixPQUFPO1FBRU4sSUFBS0wsTUFBTUcsV0FBVyxLQUFLRixtQkFBb0I7WUFFOUMsT0FBT0Q7UUFFUjtRQUVBLE1BQU1LLFNBQVMsSUFBSUosa0JBQW1CRCxNQUFNTSxVQUFVO1FBQ3RELElBQUlFLFdBQVlILFFBQVNFLEdBQUcsQ0FBRSxJQUFJQyxXQUFZUjtRQUM5QyxPQUFPSztJQUVSO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9CdWZmZXJVdGlscy5qcz9iYTVjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyU3VwcG9ydGVkKCkge1xuXG5cdHJldHVybiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9CdWZmZXJUeXBlKCBhcnJheSwgQnVmZmVyQ29uc3RydWN0b3IgKSB7XG5cblx0aWYgKCBhcnJheSA9PT0gbnVsbCApIHtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9IGVsc2UgaWYgKCBhcnJheS5idWZmZXIgKSB7XG5cblx0XHRjb25zdCBidWZmZXIgPSBhcnJheS5idWZmZXI7XG5cdFx0aWYgKCBidWZmZXIuY29uc3RydWN0b3IgPT09IEJ1ZmZlckNvbnN0cnVjdG9yICkge1xuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBBcnJheUNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3I7XG5cdFx0Y29uc3QgcmVzdWx0ID0gbmV3IEFycmF5Q29uc3RydWN0b3IoIG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggYnVmZmVyLmJ5dGVMZW5ndGggKSApO1xuXHRcdHJlc3VsdC5zZXQoIGFycmF5ICk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aWYgKCBhcnJheS5jb25zdHJ1Y3RvciA9PT0gQnVmZmVyQ29uc3RydWN0b3IgKSB7XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggYXJyYXkuYnl0ZUxlbmd0aCApO1xuXHRcdG5ldyBVaW50OEFycmF5KCByZXN1bHQgKS5zZXQoIG5ldyBVaW50OEFycmF5KCBhcnJheSApICk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn1cbiJdLCJuYW1lcyI6WyJpc1NoYXJlZEFycmF5QnVmZmVyU3VwcG9ydGVkIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJjb252ZXJ0VG9CdWZmZXJUeXBlIiwiYXJyYXkiLCJCdWZmZXJDb25zdHJ1Y3RvciIsImJ1ZmZlciIsImNvbnN0cnVjdG9yIiwiQXJyYXlDb25zdHJ1Y3RvciIsInJlc3VsdCIsImJ5dGVMZW5ndGgiLCJzZXQiLCJVaW50OEFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/BufferUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js":
/*!***********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtendedTrianglePool: function() { return /* binding */ ExtendedTrianglePool; }\n/* harmony export */ });\n/* harmony import */ var _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/ExtendedTriangle.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js\");\n/* harmony import */ var _PrimitivePool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PrimitivePool.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js\");\n\n\nclass ExtendedTrianglePoolBase extends _PrimitivePool_js__WEBPACK_IMPORTED_MODULE_0__.PrimitivePool {\n    constructor(){\n        super(()=>new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedTriangle());\n    }\n}\nconst ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvRXh0ZW5kZWRUcmlhbmdsZVBvb2wuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStEO0FBQ1o7QUFFbkQsTUFBTUUsaUNBQWlDRCw0REFBYUE7SUFFbkRFLGFBQWM7UUFFYixLQUFLLENBQUUsSUFBTSxJQUFJSCx1RUFBZ0JBO0lBRWxDO0FBRUQ7QUFFTyxNQUFNSSx1QkFBdUIsYUFBYSxHQUFHLElBQUlGLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL3V0aWxzL0V4dGVuZGVkVHJpYW5nbGVQb29sLmpzPzI2NzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5kZWRUcmlhbmdsZSB9IGZyb20gJy4uL21hdGgvRXh0ZW5kZWRUcmlhbmdsZS5qcyc7XG5pbXBvcnQgeyBQcmltaXRpdmVQb29sIH0gZnJvbSAnLi9QcmltaXRpdmVQb29sLmpzJztcblxuY2xhc3MgRXh0ZW5kZWRUcmlhbmdsZVBvb2xCYXNlIGV4dGVuZHMgUHJpbWl0aXZlUG9vbCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlciggKCkgPT4gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgY29uc3QgRXh0ZW5kZWRUcmlhbmdsZVBvb2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IEV4dGVuZGVkVHJpYW5nbGVQb29sQmFzZSgpO1xuIl0sIm5hbWVzIjpbIkV4dGVuZGVkVHJpYW5nbGUiLCJQcmltaXRpdmVQb29sIiwiRXh0ZW5kZWRUcmlhbmdsZVBvb2xCYXNlIiwiY29uc3RydWN0b3IiLCJFeHRlbmRlZFRyaWFuZ2xlUG9vbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js":
/*!*********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   acceleratedRaycast: function() { return /* binding */ acceleratedRaycast; },\n/* harmony export */   computeBoundsTree: function() { return /* binding */ computeBoundsTree; },\n/* harmony export */   disposeBoundsTree: function() { return /* binding */ disposeBoundsTree; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryRayIntersectUtilities.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js\");\n/* harmony import */ var _core_MeshBVH_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/MeshBVH.js */ \"(app-pages-browser)/./node_modules/three-mesh-bvh/src/core/MeshBVH.js\");\n\n\n\nconst ray = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Ray();\nconst tmpInverseMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst origMeshRaycastFunc = three__WEBPACK_IMPORTED_MODULE_0__.Mesh.prototype.raycast;\nfunction acceleratedRaycast(raycaster, intersects) {\n    if (this.geometry.boundsTree) {\n        if (this.material === undefined) return;\n        tmpInverseMatrix.copy(this.matrixWorld).invert();\n        ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n        const bvh = this.geometry.boundsTree;\n        if (raycaster.firstHitOnly === true) {\n            const hit = (0,_GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_1__.convertRaycastIntersect)(bvh.raycastFirst(ray, this.material), this, raycaster);\n            if (hit) {\n                intersects.push(hit);\n            }\n        } else {\n            const hits = bvh.raycast(ray, this.material);\n            for(let i = 0, l = hits.length; i < l; i++){\n                const hit = (0,_GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_1__.convertRaycastIntersect)(hits[i], this, raycaster);\n                if (hit) {\n                    intersects.push(hit);\n                }\n            }\n        }\n    } else {\n        origMeshRaycastFunc.call(this, raycaster, intersects);\n    }\n}\nfunction computeBoundsTree(options) {\n    this.boundsTree = new _core_MeshBVH_js__WEBPACK_IMPORTED_MODULE_2__.MeshBVH(this, options);\n    return this.boundsTree;\n}\nfunction disposeBoundsTree() {\n    this.boundsTree = null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvRXh0ZW5zaW9uVXRpbGl0aWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEyQztBQUNrQztBQUNoQztBQUU3QyxNQUFNSyxNQUFNLGFBQWEsR0FBRyxJQUFJTCxzQ0FBR0E7QUFDbkMsTUFBTU0sbUJBQW1CLGFBQWEsR0FBRyxJQUFJTCwwQ0FBT0E7QUFDcEQsTUFBTU0sc0JBQXNCTCx1Q0FBSUEsQ0FBQ00sU0FBUyxDQUFDQyxPQUFPO0FBRTNDLFNBQVNDLG1CQUFvQkMsU0FBUyxFQUFFQyxVQUFVO0lBRXhELElBQUssSUFBSSxDQUFDQyxRQUFRLENBQUNDLFVBQVUsRUFBRztRQUUvQixJQUFLLElBQUksQ0FBQ0MsUUFBUSxLQUFLQyxXQUFZO1FBRW5DVixpQkFBaUJXLElBQUksQ0FBRSxJQUFJLENBQUNDLFdBQVcsRUFBR0MsTUFBTTtRQUNoRGQsSUFBSVksSUFBSSxDQUFFTixVQUFVTixHQUFHLEVBQUdlLFlBQVksQ0FBRWQ7UUFFeEMsTUFBTWUsTUFBTSxJQUFJLENBQUNSLFFBQVEsQ0FBQ0MsVUFBVTtRQUNwQyxJQUFLSCxVQUFVVyxZQUFZLEtBQUssTUFBTztZQUV0QyxNQUFNQyxNQUFNcEIsMEZBQXVCQSxDQUFFa0IsSUFBSUcsWUFBWSxDQUFFbkIsS0FBSyxJQUFJLENBQUNVLFFBQVEsR0FBSSxJQUFJLEVBQUVKO1lBQ25GLElBQUtZLEtBQU07Z0JBRVZYLFdBQVdhLElBQUksQ0FBRUY7WUFFbEI7UUFFRCxPQUFPO1lBRU4sTUFBTUcsT0FBT0wsSUFBSVosT0FBTyxDQUFFSixLQUFLLElBQUksQ0FBQ1UsUUFBUTtZQUM1QyxJQUFNLElBQUlZLElBQUksR0FBR0MsSUFBSUYsS0FBS0csTUFBTSxFQUFFRixJQUFJQyxHQUFHRCxJQUFPO2dCQUUvQyxNQUFNSixNQUFNcEIsMEZBQXVCQSxDQUFFdUIsSUFBSSxDQUFFQyxFQUFHLEVBQUUsSUFBSSxFQUFFaEI7Z0JBQ3RELElBQUtZLEtBQU07b0JBRVZYLFdBQVdhLElBQUksQ0FBRUY7Z0JBRWxCO1lBRUQ7UUFFRDtJQUVELE9BQU87UUFFTmhCLG9CQUFvQnVCLElBQUksQ0FBRSxJQUFJLEVBQUVuQixXQUFXQztJQUU1QztBQUVEO0FBRU8sU0FBU21CLGtCQUFtQkMsT0FBTztJQUV6QyxJQUFJLENBQUNsQixVQUFVLEdBQUcsSUFBSVYscURBQU9BLENBQUUsSUFBSSxFQUFFNEI7SUFDckMsT0FBTyxJQUFJLENBQUNsQixVQUFVO0FBRXZCO0FBRU8sU0FBU21CO0lBRWYsSUFBSSxDQUFDbkIsVUFBVSxHQUFHO0FBRW5CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvRXh0ZW5zaW9uVXRpbGl0aWVzLmpzPzQwYjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmF5LCBNYXRyaXg0LCBNZXNoIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgY29udmVydFJheWNhc3RJbnRlcnNlY3QgfSBmcm9tICcuL0dlb21ldHJ5UmF5SW50ZXJzZWN0VXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IE1lc2hCVkggfSBmcm9tICcuLi9jb3JlL01lc2hCVkguanMnO1xuXG5jb25zdCByYXkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJheSgpO1xuY29uc3QgdG1wSW52ZXJzZU1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWF0cml4NCgpO1xuY29uc3Qgb3JpZ01lc2hSYXljYXN0RnVuYyA9IE1lc2gucHJvdG90eXBlLnJheWNhc3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY2NlbGVyYXRlZFJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdGlmICggdGhpcy5tYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0dG1wSW52ZXJzZU1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIHRtcEludmVyc2VNYXRyaXggKTtcblxuXHRcdGNvbnN0IGJ2aCA9IHRoaXMuZ2VvbWV0cnkuYm91bmRzVHJlZTtcblx0XHRpZiAoIHJheWNhc3Rlci5maXJzdEhpdE9ubHkgPT09IHRydWUgKSB7XG5cblx0XHRcdGNvbnN0IGhpdCA9IGNvbnZlcnRSYXljYXN0SW50ZXJzZWN0KCBidmgucmF5Y2FzdEZpcnN0KCByYXksIHRoaXMubWF0ZXJpYWwgKSwgdGhpcywgcmF5Y2FzdGVyICk7XG5cdFx0XHRpZiAoIGhpdCApIHtcblxuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGhpdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBoaXRzID0gYnZoLnJheWNhc3QoIHJheSwgdGhpcy5tYXRlcmlhbCApO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaGl0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGhpdCA9IGNvbnZlcnRSYXljYXN0SW50ZXJzZWN0KCBoaXRzWyBpIF0sIHRoaXMsIHJheWNhc3RlciApO1xuXHRcdFx0XHRpZiAoIGhpdCApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaGl0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdG9yaWdNZXNoUmF5Y2FzdEZ1bmMuY2FsbCggdGhpcywgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQm91bmRzVHJlZSggb3B0aW9ucyApIHtcblxuXHR0aGlzLmJvdW5kc1RyZWUgPSBuZXcgTWVzaEJWSCggdGhpcywgb3B0aW9ucyApO1xuXHRyZXR1cm4gdGhpcy5ib3VuZHNUcmVlO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlQm91bmRzVHJlZSgpIHtcblxuXHR0aGlzLmJvdW5kc1RyZWUgPSBudWxsO1xuXG59XG4iXSwibmFtZXMiOlsiUmF5IiwiTWF0cml4NCIsIk1lc2giLCJjb252ZXJ0UmF5Y2FzdEludGVyc2VjdCIsIk1lc2hCVkgiLCJyYXkiLCJ0bXBJbnZlcnNlTWF0cml4Iiwib3JpZ01lc2hSYXljYXN0RnVuYyIsInByb3RvdHlwZSIsInJheWNhc3QiLCJhY2NlbGVyYXRlZFJheWNhc3QiLCJyYXljYXN0ZXIiLCJpbnRlcnNlY3RzIiwiZ2VvbWV0cnkiLCJib3VuZHNUcmVlIiwibWF0ZXJpYWwiLCJ1bmRlZmluZWQiLCJjb3B5IiwibWF0cml4V29ybGQiLCJpbnZlcnQiLCJhcHBseU1hdHJpeDQiLCJidmgiLCJmaXJzdEhpdE9ubHkiLCJoaXQiLCJyYXljYXN0Rmlyc3QiLCJwdXNoIiwiaGl0cyIsImkiLCJsIiwibGVuZ3RoIiwiY2FsbCIsImNvbXB1dGVCb3VuZHNUcmVlIiwib3B0aW9ucyIsImRpc3Bvc2VCb3VuZHNUcmVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js":
/*!********************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertRaycastIntersect: function() { return /* binding */ convertRaycastIntersect; }\n/* harmony export */ });\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nfunction convertRaycastIntersect(hit, object, raycaster) {\n    if (hit === null) {\n        return null;\n    }\n    hit.point.applyMatrix4(object.matrixWorld);\n    hit.distance = hit.point.distanceTo(raycaster.ray.origin);\n    hit.object = object;\n    if (hit.distance < raycaster.near || hit.distance > raycaster.far) {\n        return null;\n    } else {\n        return hit;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvR2VvbWV0cnlSYXlJbnRlcnNlY3RVdGlsaXRpZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlGQUFpRjtBQUNqRiw4REFBOEQ7QUFDdkQsU0FBU0Esd0JBQXlCQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsU0FBUztJQUU5RCxJQUFLRixRQUFRLE1BQU87UUFFbkIsT0FBTztJQUVSO0lBRUFBLElBQUlHLEtBQUssQ0FBQ0MsWUFBWSxDQUFFSCxPQUFPSSxXQUFXO0lBQzFDTCxJQUFJTSxRQUFRLEdBQUdOLElBQUlHLEtBQUssQ0FBQ0ksVUFBVSxDQUFFTCxVQUFVTSxHQUFHLENBQUNDLE1BQU07SUFDekRULElBQUlDLE1BQU0sR0FBR0E7SUFFYixJQUFLRCxJQUFJTSxRQUFRLEdBQUdKLFVBQVVRLElBQUksSUFBSVYsSUFBSU0sUUFBUSxHQUFHSixVQUFVUyxHQUFHLEVBQUc7UUFFcEUsT0FBTztJQUVSLE9BQU87UUFFTixPQUFPWDtJQUVSO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9HZW9tZXRyeVJheUludGVyc2VjdFV0aWxpdGllcy5qcz8zNzBkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnZlcnRzIHRoZSBnaXZlbiBCVkggcmF5Y2FzdCBpbnRlcnNlY3Rpb24gdG8gYWxpZ24gd2l0aCB0aGUgdGhyZWUuanMgcmF5Y2FzdFxuLy8gc3RydWN0dXJlIChpbmNsdWRlIG9iamVjdCwgd29ybGQgc3BhY2UgZGlzdGFuY2UgYW5kIHBvaW50KS5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UmF5Y2FzdEludGVyc2VjdCggaGl0LCBvYmplY3QsIHJheWNhc3RlciApIHtcblxuXHRpZiAoIGhpdCA9PT0gbnVsbCApIHtcblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHRoaXQucG9pbnQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblx0aGl0LmRpc3RhbmNlID0gaGl0LnBvaW50LmRpc3RhbmNlVG8oIHJheWNhc3Rlci5yYXkub3JpZ2luICk7XG5cdGhpdC5vYmplY3QgPSBvYmplY3Q7XG5cblx0aWYgKCBoaXQuZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBoaXQuZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkge1xuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fSBlbHNlIHtcblxuXHRcdHJldHVybiBoaXQ7XG5cblx0fVxuXG59XG4iXSwibmFtZXMiOlsiY29udmVydFJheWNhc3RJbnRlcnNlY3QiLCJoaXQiLCJvYmplY3QiLCJyYXljYXN0ZXIiLCJwb2ludCIsImFwcGx5TWF0cml4NCIsIm1hdHJpeFdvcmxkIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwicmF5Iiwib3JpZ2luIiwibmVhciIsImZhciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrimitivePool: function() { return /* binding */ PrimitivePool; }\n/* harmony export */ });\nclass PrimitivePool {\n    getPrimitive() {\n        const primitives = this._primitives;\n        if (primitives.length === 0) {\n            return this._getNewPrimitive();\n        } else {\n            return primitives.pop();\n        }\n    }\n    releasePrimitive(primitive) {\n        this._primitives.push(primitive);\n    }\n    constructor(getNewPrimitive){\n        this._getNewPrimitive = getNewPrimitive;\n        this._primitives = [];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvUHJpbWl0aXZlUG9vbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUE7SUFTWkMsZUFBZTtRQUVkLE1BQU1DLGFBQWEsSUFBSSxDQUFDQyxXQUFXO1FBQ25DLElBQUtELFdBQVdFLE1BQU0sS0FBSyxHQUFJO1lBRTlCLE9BQU8sSUFBSSxDQUFDQyxnQkFBZ0I7UUFFN0IsT0FBTztZQUVOLE9BQU9ILFdBQVdJLEdBQUc7UUFFdEI7SUFFRDtJQUVBQyxpQkFBa0JDLFNBQVMsRUFBRztRQUU3QixJQUFJLENBQUNMLFdBQVcsQ0FBQ00sSUFBSSxDQUFFRDtJQUV4QjtJQTFCQUUsWUFBYUMsZUFBZSxDQUFHO1FBRTlCLElBQUksQ0FBQ04sZ0JBQWdCLEdBQUdNO1FBQ3hCLElBQUksQ0FBQ1IsV0FBVyxHQUFHLEVBQUU7SUFFdEI7QUF1QkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9QcmltaXRpdmVQb29sLmpzPzQ4ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFByaW1pdGl2ZVBvb2wge1xuXG5cdGNvbnN0cnVjdG9yKCBnZXROZXdQcmltaXRpdmUgKSB7XG5cblx0XHR0aGlzLl9nZXROZXdQcmltaXRpdmUgPSBnZXROZXdQcmltaXRpdmU7XG5cdFx0dGhpcy5fcHJpbWl0aXZlcyA9IFtdO1xuXG5cdH1cblxuXHRnZXRQcmltaXRpdmUoKSB7XG5cblx0XHRjb25zdCBwcmltaXRpdmVzID0gdGhpcy5fcHJpbWl0aXZlcztcblx0XHRpZiAoIHByaW1pdGl2ZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5fZ2V0TmV3UHJpbWl0aXZlKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gcHJpbWl0aXZlcy5wb3AoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmVsZWFzZVByaW1pdGl2ZSggcHJpbWl0aXZlICkge1xuXG5cdFx0dGhpcy5fcHJpbWl0aXZlcy5wdXNoKCBwcmltaXRpdmUgKTtcblxuXHR9XG5cbn1cbiJdLCJuYW1lcyI6WyJQcmltaXRpdmVQb29sIiwiZ2V0UHJpbWl0aXZlIiwicHJpbWl0aXZlcyIsIl9wcmltaXRpdmVzIiwibGVuZ3RoIiwiX2dldE5ld1ByaW1pdGl2ZSIsInBvcCIsInJlbGVhc2VQcmltaXRpdmUiLCJwcmltaXRpdmUiLCJwdXNoIiwiY29uc3RydWN0b3IiLCJnZXROZXdQcmltaXRpdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectTri: function() { return /* binding */ intersectTri; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _vB = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _vC = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _uvA = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nconst _uvB = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nconst _uvC = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nconst _normalA = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _normalB = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _normalC = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _intersectionPoint = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction checkIntersection(ray, pA, pB, pC, point, side) {\n    let intersect;\n    if (side === three__WEBPACK_IMPORTED_MODULE_0__.BackSide) {\n        intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    } else {\n        intersect = ray.intersectTriangle(pA, pB, pC, side !== three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide, point);\n    }\n    if (intersect === null) return null;\n    const distance = ray.origin.distanceTo(point);\n    return {\n        distance: distance,\n        point: point.clone()\n    };\n}\nfunction checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side) {\n    _vA.fromBufferAttribute(position, a);\n    _vB.fromBufferAttribute(position, b);\n    _vC.fromBufferAttribute(position, c);\n    const intersection = checkIntersection(ray, _vA, _vB, _vC, _intersectionPoint, side);\n    if (intersection) {\n        if (uv) {\n            _uvA.fromBufferAttribute(uv, a);\n            _uvB.fromBufferAttribute(uv, b);\n            _uvC.fromBufferAttribute(uv, c);\n            intersection.uv = three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        }\n        if (uv1) {\n            _uvA.fromBufferAttribute(uv1, a);\n            _uvB.fromBufferAttribute(uv1, b);\n            _uvC.fromBufferAttribute(uv1, c);\n            intersection.uv1 = three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        }\n        if (normal) {\n            _normalA.fromBufferAttribute(normal, a);\n            _normalB.fromBufferAttribute(normal, b);\n            _normalC.fromBufferAttribute(normal, c);\n            intersection.normal = three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n            if (intersection.normal.dot(ray.direction) > 0) {\n                intersection.normal.multiplyScalar(-1);\n            }\n        }\n        const face = {\n            a: a,\n            b: b,\n            c: c,\n            normal: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            materialIndex: 0\n        };\n        three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getNormal(_vA, _vB, _vC, face.normal);\n        intersection.face = face;\n        intersection.faceIndex = a;\n    }\n    return intersection;\n}\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri(geo, side, ray, tri, intersections) {\n    const triOffset = tri * 3;\n    let a = triOffset + 0;\n    let b = triOffset + 1;\n    let c = triOffset + 2;\n    const index = geo.index;\n    if (geo.index) {\n        a = index.getX(a);\n        b = index.getX(b);\n        c = index.getX(c);\n    }\n    const { position, normal, uv, uv1 } = geo.attributes;\n    const intersection = checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side);\n    if (intersection) {\n        intersection.faceIndex = tri;\n        if (intersections) intersections.push(intersection);\n        return intersection;\n    }\n    return null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvVGhyZWVSYXlJbnRlcnNlY3RVdGlsaXRpZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUU7QUFFekUsaURBQWlEO0FBQ2pELDRHQUE0RztBQUM1RyxNQUFNSyxNQUFNLGFBQWEsR0FBRyxJQUFJTCwwQ0FBT0E7QUFDdkMsTUFBTU0sTUFBTSxhQUFhLEdBQUcsSUFBSU4sMENBQU9BO0FBQ3ZDLE1BQU1PLE1BQU0sYUFBYSxHQUFHLElBQUlQLDBDQUFPQTtBQUV2QyxNQUFNUSxPQUFPLGFBQWEsR0FBRyxJQUFJUCwwQ0FBT0E7QUFDeEMsTUFBTVEsT0FBTyxhQUFhLEdBQUcsSUFBSVIsMENBQU9BO0FBQ3hDLE1BQU1TLE9BQU8sYUFBYSxHQUFHLElBQUlULDBDQUFPQTtBQUV4QyxNQUFNVSxXQUFXLGFBQWEsR0FBRyxJQUFJWCwwQ0FBT0E7QUFDNUMsTUFBTVksV0FBVyxhQUFhLEdBQUcsSUFBSVosMENBQU9BO0FBQzVDLE1BQU1hLFdBQVcsYUFBYSxHQUFHLElBQUliLDBDQUFPQTtBQUU1QyxNQUFNYyxxQkFBcUIsYUFBYSxHQUFHLElBQUlkLDBDQUFPQTtBQUN0RCxTQUFTZSxrQkFBbUJDLEdBQUcsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsS0FBSyxFQUFFQyxJQUFJO0lBRXZELElBQUlDO0lBQ0osSUFBS0QsU0FBU2pCLDJDQUFRQSxFQUFHO1FBRXhCa0IsWUFBWU4sSUFBSU8saUJBQWlCLENBQUVKLElBQUlELElBQUlELElBQUksTUFBTUc7SUFFdEQsT0FBTztRQUVORSxZQUFZTixJQUFJTyxpQkFBaUIsQ0FBRU4sSUFBSUMsSUFBSUMsSUFBSUUsU0FBU2xCLDZDQUFVQSxFQUFFaUI7SUFFckU7SUFFQSxJQUFLRSxjQUFjLE1BQU8sT0FBTztJQUVqQyxNQUFNRSxXQUFXUixJQUFJUyxNQUFNLENBQUNDLFVBQVUsQ0FBRU47SUFFeEMsT0FBTztRQUVOSSxVQUFVQTtRQUNWSixPQUFPQSxNQUFNTyxLQUFLO0lBRW5CO0FBRUQ7QUFFQSxTQUFTQyxnQ0FBaUNaLEdBQUcsRUFBRWEsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsR0FBRyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFZCxJQUFJO0lBRXRGaEIsSUFBSStCLG1CQUFtQixDQUFFUCxVQUFVSTtJQUNuQzNCLElBQUk4QixtQkFBbUIsQ0FBRVAsVUFBVUs7SUFDbkMzQixJQUFJNkIsbUJBQW1CLENBQUVQLFVBQVVNO0lBRW5DLE1BQU1FLGVBQWV0QixrQkFBbUJDLEtBQUtYLEtBQUtDLEtBQUtDLEtBQUtPLG9CQUFvQk87SUFFaEYsSUFBS2dCLGNBQWU7UUFFbkIsSUFBS04sSUFBSztZQUVUdkIsS0FBSzRCLG1CQUFtQixDQUFFTCxJQUFJRTtZQUM5QnhCLEtBQUsyQixtQkFBbUIsQ0FBRUwsSUFBSUc7WUFDOUJ4QixLQUFLMEIsbUJBQW1CLENBQUVMLElBQUlJO1lBRTlCRSxhQUFhTixFQUFFLEdBQUc3QiwyQ0FBUUEsQ0FBQ29DLGdCQUFnQixDQUFFeEIsb0JBQW9CVCxLQUFLQyxLQUFLQyxLQUFLQyxNQUFNQyxNQUFNQyxNQUFNLElBQUlULDBDQUFPQTtRQUU5RztRQUVBLElBQUsrQixLQUFNO1lBRVZ4QixLQUFLNEIsbUJBQW1CLENBQUVKLEtBQUtDO1lBQy9CeEIsS0FBSzJCLG1CQUFtQixDQUFFSixLQUFLRTtZQUMvQnhCLEtBQUswQixtQkFBbUIsQ0FBRUosS0FBS0c7WUFFL0JFLGFBQWFMLEdBQUcsR0FBRzlCLDJDQUFRQSxDQUFDb0MsZ0JBQWdCLENBQUV4QixvQkFBb0JULEtBQUtDLEtBQUtDLEtBQUtDLE1BQU1DLE1BQU1DLE1BQU0sSUFBSVQsMENBQU9BO1FBRS9HO1FBRUEsSUFBSzZCLFFBQVM7WUFFYm5CLFNBQVN5QixtQkFBbUIsQ0FBRU4sUUFBUUc7WUFDdENyQixTQUFTd0IsbUJBQW1CLENBQUVOLFFBQVFJO1lBQ3RDckIsU0FBU3VCLG1CQUFtQixDQUFFTixRQUFRSztZQUV0Q0UsYUFBYVAsTUFBTSxHQUFHNUIsMkNBQVFBLENBQUNvQyxnQkFBZ0IsQ0FBRXhCLG9CQUFvQlQsS0FBS0MsS0FBS0MsS0FBS0ksVUFBVUMsVUFBVUMsVUFBVSxJQUFJYiwwQ0FBT0E7WUFDN0gsSUFBS3FDLGFBQWFQLE1BQU0sQ0FBQ1MsR0FBRyxDQUFFdkIsSUFBSXdCLFNBQVMsSUFBSyxHQUFJO2dCQUVuREgsYUFBYVAsTUFBTSxDQUFDVyxjQUFjLENBQUUsQ0FBRTtZQUV2QztRQUVEO1FBRUEsTUFBTUMsT0FBTztZQUNaVCxHQUFHQTtZQUNIQyxHQUFHQTtZQUNIQyxHQUFHQTtZQUNITCxRQUFRLElBQUk5QiwwQ0FBT0E7WUFDbkIyQyxlQUFlO1FBQ2hCO1FBRUF6QywyQ0FBUUEsQ0FBQzBDLFNBQVMsQ0FBRXZDLEtBQUtDLEtBQUtDLEtBQUttQyxLQUFLWixNQUFNO1FBRTlDTyxhQUFhSyxJQUFJLEdBQUdBO1FBQ3BCTCxhQUFhUSxTQUFTLEdBQUdaO0lBRTFCO0lBRUEsT0FBT0k7QUFFUjtBQUVBLDRHQUE0RztBQUM1RyxTQUFTUyxhQUFjQyxHQUFHLEVBQUUxQixJQUFJLEVBQUVMLEdBQUcsRUFBRWdDLEdBQUcsRUFBRUMsYUFBYTtJQUV4RCxNQUFNQyxZQUFZRixNQUFNO0lBQ3hCLElBQUlmLElBQUlpQixZQUFZO0lBQ3BCLElBQUloQixJQUFJZ0IsWUFBWTtJQUNwQixJQUFJZixJQUFJZSxZQUFZO0lBRXBCLE1BQU1DLFFBQVFKLElBQUlJLEtBQUs7SUFDdkIsSUFBS0osSUFBSUksS0FBSyxFQUFHO1FBRWhCbEIsSUFBSWtCLE1BQU1DLElBQUksQ0FBRW5CO1FBQ2hCQyxJQUFJaUIsTUFBTUMsSUFBSSxDQUFFbEI7UUFDaEJDLElBQUlnQixNQUFNQyxJQUFJLENBQUVqQjtJQUVqQjtJQUVBLE1BQU0sRUFBRU4sUUFBUSxFQUFFQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsR0FBRyxFQUFFLEdBQUdlLElBQUlNLFVBQVU7SUFDcEQsTUFBTWhCLGVBQWVULGdDQUFpQ1osS0FBS2EsVUFBVUMsUUFBUUMsSUFBSUMsS0FBS0MsR0FBR0MsR0FBR0MsR0FBR2Q7SUFFL0YsSUFBS2dCLGNBQWU7UUFFbkJBLGFBQWFRLFNBQVMsR0FBR0c7UUFDekIsSUFBS0MsZUFBZ0JBLGNBQWNLLElBQUksQ0FBRWpCO1FBQ3pDLE9BQU9BO0lBRVI7SUFFQSxPQUFPO0FBRVI7QUFFd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9UaHJlZVJheUludGVyc2VjdFV0aWxpdGllcy5qcz8xNmU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMsIFZlY3RvcjIsIFRyaWFuZ2xlLCBEb3VibGVTaWRlLCBCYWNrU2lkZSB9IGZyb20gJ3RocmVlJztcblxuLy8gUmlwcGVkIGFuZCBtb2RpZmllZCBGcm9tIFRIUkVFLmpzIE1lc2ggcmF5Y2FzdFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iLzBhYTg3Yzk5OWZlNjFlMjE2YzExMzNmYmE3YTk1NzcyYjUwM2VkZGYvc3JjL29iamVjdHMvTWVzaC5qcyNMMTE1XG5jb25zdCBfdkEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92QiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZDID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF91dkEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF91dkIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IF91dkMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjIoKTtcblxuY29uc3QgX25vcm1hbEEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ub3JtYWxCID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbm9ybWFsQyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfaW50ZXJzZWN0aW9uUG9pbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKCByYXksIHBBLCBwQiwgcEMsIHBvaW50LCBzaWRlICkge1xuXG5cdGxldCBpbnRlcnNlY3Q7XG5cdGlmICggc2lkZSA9PT0gQmFja1NpZGUgKSB7XG5cblx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBDLCBwQiwgcEEsIHRydWUsIHBvaW50ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEEsIHBCLCBwQywgc2lkZSAhPT0gRG91YmxlU2lkZSwgcG9pbnQgKTtcblxuXHR9XG5cblx0aWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcblxuXHRjb25zdCBkaXN0YW5jZSA9IHJheS5vcmlnaW4uZGlzdGFuY2VUbyggcG9pbnQgKTtcblxuXHRyZXR1cm4ge1xuXG5cdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdHBvaW50OiBwb2ludC5jbG9uZSgpLFxuXG5cdH07XG5cbn1cblxuZnVuY3Rpb24gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggcmF5LCBwb3NpdGlvbiwgbm9ybWFsLCB1diwgdXYxLCBhLCBiLCBjLCBzaWRlICkge1xuXG5cdF92QS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYSApO1xuXHRfdkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGIgKTtcblx0X3ZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBjICk7XG5cblx0Y29uc3QgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIHJheSwgX3ZBLCBfdkIsIF92QywgX2ludGVyc2VjdGlvblBvaW50LCBzaWRlICk7XG5cblx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRpZiAoIHV2ICkge1xuXG5cdFx0XHRfdXZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBhICk7XG5cdFx0XHRfdXZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBiICk7XG5cdFx0XHRfdXZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBjICk7XG5cblx0XHRcdGludGVyc2VjdGlvbi51diA9IFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFZlY3RvcjIoKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1djEgKSB7XG5cblx0XHRcdF91dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBhICk7XG5cdFx0XHRfdXZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2MSwgYiApO1xuXHRcdFx0X3V2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1djEsIGMgKTtcblxuXHRcdFx0aW50ZXJzZWN0aW9uLnV2MSA9IFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFZlY3RvcjIoKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBub3JtYWwgKSB7XG5cblx0XHRcdF9ub3JtYWxBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgYSApO1xuXHRcdFx0X25vcm1hbEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLCBiICk7XG5cdFx0XHRfbm9ybWFsQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGMgKTtcblxuXHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbCA9IFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX25vcm1hbEEsIF9ub3JtYWxCLCBfbm9ybWFsQywgbmV3IFZlY3RvcjMoKSApO1xuXHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubm9ybWFsLmRvdCggcmF5LmRpcmVjdGlvbiApID4gMCApIHtcblxuXHRcdFx0XHRpbnRlcnNlY3Rpb24ubm9ybWFsLm11bHRpcGx5U2NhbGFyKCAtIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZmFjZSA9IHtcblx0XHRcdGE6IGEsXG5cdFx0XHRiOiBiLFxuXHRcdFx0YzogYyxcblx0XHRcdG5vcm1hbDogbmV3IFZlY3RvcjMoKSxcblx0XHRcdG1hdGVyaWFsSW5kZXg6IDBcblx0XHR9O1xuXG5cdFx0VHJpYW5nbGUuZ2V0Tm9ybWFsKCBfdkEsIF92QiwgX3ZDLCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBmYWNlO1xuXHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBhO1xuXG5cdH1cblxuXHRyZXR1cm4gaW50ZXJzZWN0aW9uO1xuXG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi8wYWE4N2M5OTlmZTYxZTIxNmMxMTMzZmJhN2E5NTc3MmI1MDNlZGRmL3NyYy9vYmplY3RzL01lc2guanMjTDI1OFxuZnVuY3Rpb24gaW50ZXJzZWN0VHJpKCBnZW8sIHNpZGUsIHJheSwgdHJpLCBpbnRlcnNlY3Rpb25zICkge1xuXG5cdGNvbnN0IHRyaU9mZnNldCA9IHRyaSAqIDM7XG5cdGxldCBhID0gdHJpT2Zmc2V0ICsgMDtcblx0bGV0IGIgPSB0cmlPZmZzZXQgKyAxO1xuXHRsZXQgYyA9IHRyaU9mZnNldCArIDI7XG5cblx0Y29uc3QgaW5kZXggPSBnZW8uaW5kZXg7XG5cdGlmICggZ2VvLmluZGV4ICkge1xuXG5cdFx0YSA9IGluZGV4LmdldFgoIGEgKTtcblx0XHRiID0gaW5kZXguZ2V0WCggYiApO1xuXHRcdGMgPSBpbmRleC5nZXRYKCBjICk7XG5cblx0fVxuXG5cdGNvbnN0IHsgcG9zaXRpb24sIG5vcm1hbCwgdXYsIHV2MSB9ID0gZ2VvLmF0dHJpYnV0ZXM7XG5cdGNvbnN0IGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHJheSwgcG9zaXRpb24sIG5vcm1hbCwgdXYsIHV2MSwgYSwgYiwgYywgc2lkZSApO1xuXG5cdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IHRyaTtcblx0XHRpZiAoIGludGVyc2VjdGlvbnMgKSBpbnRlcnNlY3Rpb25zLnB1c2goIGludGVyc2VjdGlvbiApO1xuXHRcdHJldHVybiBpbnRlcnNlY3Rpb247XG5cblx0fVxuXG5cdHJldHVybiBudWxsO1xuXG59XG5cbmV4cG9ydCB7IGludGVyc2VjdFRyaSB9O1xuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJWZWN0b3IyIiwiVHJpYW5nbGUiLCJEb3VibGVTaWRlIiwiQmFja1NpZGUiLCJfdkEiLCJfdkIiLCJfdkMiLCJfdXZBIiwiX3V2QiIsIl91dkMiLCJfbm9ybWFsQSIsIl9ub3JtYWxCIiwiX25vcm1hbEMiLCJfaW50ZXJzZWN0aW9uUG9pbnQiLCJjaGVja0ludGVyc2VjdGlvbiIsInJheSIsInBBIiwicEIiLCJwQyIsInBvaW50Iiwic2lkZSIsImludGVyc2VjdCIsImludGVyc2VjdFRyaWFuZ2xlIiwiZGlzdGFuY2UiLCJvcmlnaW4iLCJkaXN0YW5jZVRvIiwiY2xvbmUiLCJjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uIiwicG9zaXRpb24iLCJub3JtYWwiLCJ1diIsInV2MSIsImEiLCJiIiwiYyIsImZyb21CdWZmZXJBdHRyaWJ1dGUiLCJpbnRlcnNlY3Rpb24iLCJnZXRJbnRlcnBvbGF0aW9uIiwiZG90IiwiZGlyZWN0aW9uIiwibXVsdGlwbHlTY2FsYXIiLCJmYWNlIiwibWF0ZXJpYWxJbmRleCIsImdldE5vcm1hbCIsImZhY2VJbmRleCIsImludGVyc2VjdFRyaSIsImdlbyIsInRyaSIsImludGVyc2VjdGlvbnMiLCJ0cmlPZmZzZXQiLCJpbmRleCIsImdldFgiLCJhdHRyaWJ1dGVzIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js":
/*!********************************************************************!*\
  !*** ./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTriangleHitPointInfo: function() { return /* binding */ getTriangleHitPointInfo; },\n/* harmony export */   setTriangle: function() { return /* binding */ setTriangle; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nfunction setTriangle(tri, i, index, pos) {\n    const ta = tri.a;\n    const tb = tri.b;\n    const tc = tri.c;\n    let i0 = i;\n    let i1 = i + 1;\n    let i2 = i + 2;\n    if (index) {\n        i0 = index.getX(i0);\n        i1 = index.getX(i1);\n        i2 = index.getX(i2);\n    }\n    ta.x = pos.getX(i0);\n    ta.y = pos.getY(i0);\n    ta.z = pos.getZ(i0);\n    tb.x = pos.getX(i1);\n    tb.y = pos.getY(i1);\n    tb.z = pos.getZ(i1);\n    tc.x = pos.getX(i2);\n    tc.y = pos.getY(i2);\n    tc.z = pos.getZ(i2);\n}\nconst tempV1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst tempV2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst tempV3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst tempUV1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nconst tempUV2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nconst tempUV3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nfunction getTriangleHitPointInfo(point, geometry, triangleIndex, target) {\n    const indices = geometry.getIndex().array;\n    const positions = geometry.getAttribute(\"position\");\n    const uvs = geometry.getAttribute(\"uv\");\n    const a = indices[triangleIndex * 3];\n    const b = indices[triangleIndex * 3 + 1];\n    const c = indices[triangleIndex * 3 + 2];\n    tempV1.fromBufferAttribute(positions, a);\n    tempV2.fromBufferAttribute(positions, b);\n    tempV3.fromBufferAttribute(positions, c);\n    // find the associated material index\n    let materialIndex = 0;\n    const groups = geometry.groups;\n    const firstVertexIndex = triangleIndex * 3;\n    for(let i = 0, l = groups.length; i < l; i++){\n        const group = groups[i];\n        const { start, count } = group;\n        if (firstVertexIndex >= start && firstVertexIndex < start + count) {\n            materialIndex = group.materialIndex;\n            break;\n        }\n    }\n    // extract uvs\n    let uv = null;\n    if (uvs) {\n        tempUV1.fromBufferAttribute(uvs, a);\n        tempUV2.fromBufferAttribute(uvs, b);\n        tempUV3.fromBufferAttribute(uvs, c);\n        if (target && target.uv) uv = target.uv;\n        else uv = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getInterpolation(point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv);\n    }\n    // adjust the provided target or create a new one\n    if (target) {\n        if (!target.face) target.face = {};\n        target.face.a = a;\n        target.face.b = b;\n        target.face.c = c;\n        target.face.materialIndex = materialIndex;\n        if (!target.face.normal) target.face.normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getNormal(tempV1, tempV2, tempV3, target.face.normal);\n        if (uv) target.uv = uv;\n        return target;\n    } else {\n        return {\n            face: {\n                a: a,\n                b: b,\n                c: c,\n                materialIndex: materialIndex,\n                normal: three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getNormal(tempV1, tempV2, tempV3, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())\n            },\n            uv: uv\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvVHJpYW5nbGVVdGlsaXRpZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ21EO0FBRW5ELGtFQUFrRTtBQUMzRCxTQUFTRyxZQUFhQyxHQUFHLEVBQUVDLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxHQUFHO0lBRTlDLE1BQU1DLEtBQUtKLElBQUlLLENBQUM7SUFDaEIsTUFBTUMsS0FBS04sSUFBSU8sQ0FBQztJQUNoQixNQUFNQyxLQUFLUixJQUFJUyxDQUFDO0lBRWhCLElBQUlDLEtBQUtUO0lBQ1QsSUFBSVUsS0FBS1YsSUFBSTtJQUNiLElBQUlXLEtBQUtYLElBQUk7SUFDYixJQUFLQyxPQUFRO1FBRVpRLEtBQUtSLE1BQU1XLElBQUksQ0FBRUg7UUFDakJDLEtBQUtULE1BQU1XLElBQUksQ0FBRUY7UUFDakJDLEtBQUtWLE1BQU1XLElBQUksQ0FBRUQ7SUFFbEI7SUFFQVIsR0FBR1UsQ0FBQyxHQUFHWCxJQUFJVSxJQUFJLENBQUVIO0lBQ2pCTixHQUFHVyxDQUFDLEdBQUdaLElBQUlhLElBQUksQ0FBRU47SUFDakJOLEdBQUdhLENBQUMsR0FBR2QsSUFBSWUsSUFBSSxDQUFFUjtJQUVqQkosR0FBR1EsQ0FBQyxHQUFHWCxJQUFJVSxJQUFJLENBQUVGO0lBQ2pCTCxHQUFHUyxDQUFDLEdBQUdaLElBQUlhLElBQUksQ0FBRUw7SUFDakJMLEdBQUdXLENBQUMsR0FBR2QsSUFBSWUsSUFBSSxDQUFFUDtJQUVqQkgsR0FBR00sQ0FBQyxHQUFHWCxJQUFJVSxJQUFJLENBQUVEO0lBQ2pCSixHQUFHTyxDQUFDLEdBQUdaLElBQUlhLElBQUksQ0FBRUo7SUFDakJKLEdBQUdTLENBQUMsR0FBR2QsSUFBSWUsSUFBSSxDQUFFTjtBQUVsQjtBQUVBLE1BQU1PLFNBQVMsYUFBYSxHQUFHLElBQUl0QiwwQ0FBT0E7QUFDMUMsTUFBTXVCLFNBQVMsYUFBYSxHQUFHLElB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QixRQUFRQyxRQUFRQyxRQUFRLElBQUl4QiwwQ0FBT0E7WUFDaEU7WUFDQWdELElBQUlBO1FBQ0w7SUFFRDtBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvVHJpYW5nbGVVdGlsaXRpZXMuanM/YmI1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IFZlY3RvcjIsIFZlY3RvcjMsIFRyaWFuZ2xlIH0gZnJvbSAndGhyZWUnO1xuXG4vLyBzZXRzIHRoZSB2ZXJ0aWNlcyBvZiB0cmlhbmdsZSBgdHJpYCB3aXRoIHRoZSAzIHZlcnRpY2VzIGFmdGVyIGlcbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmlhbmdsZSggdHJpLCBpLCBpbmRleCwgcG9zICkge1xuXG5cdGNvbnN0IHRhID0gdHJpLmE7XG5cdGNvbnN0IHRiID0gdHJpLmI7XG5cdGNvbnN0IHRjID0gdHJpLmM7XG5cblx0bGV0IGkwID0gaTtcblx0bGV0IGkxID0gaSArIDE7XG5cdGxldCBpMiA9IGkgKyAyO1xuXHRpZiAoIGluZGV4ICkge1xuXG5cdFx0aTAgPSBpbmRleC5nZXRYKCBpMCApO1xuXHRcdGkxID0gaW5kZXguZ2V0WCggaTEgKTtcblx0XHRpMiA9IGluZGV4LmdldFgoIGkyICk7XG5cblx0fVxuXG5cdHRhLnggPSBwb3MuZ2V0WCggaTAgKTtcblx0dGEueSA9IHBvcy5nZXRZKCBpMCApO1xuXHR0YS56ID0gcG9zLmdldFooIGkwICk7XG5cblx0dGIueCA9IHBvcy5nZXRYKCBpMSApO1xuXHR0Yi55ID0gcG9zLmdldFkoIGkxICk7XG5cdHRiLnogPSBwb3MuZ2V0WiggaTEgKTtcblxuXHR0Yy54ID0gcG9zLmdldFgoIGkyICk7XG5cdHRjLnkgPSBwb3MuZ2V0WSggaTIgKTtcblx0dGMueiA9IHBvcy5nZXRaKCBpMiApO1xuXG59XG5cbmNvbnN0IHRlbXBWMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgdGVtcFYyID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wVjMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXBVVjEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IHRlbXBVVjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjIoKTtcbmNvbnN0IHRlbXBVVjMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjIoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyaWFuZ2xlSGl0UG9pbnRJbmZvKCBwb2ludCwgZ2VvbWV0cnksIHRyaWFuZ2xlSW5kZXgsIHRhcmdldCApIHtcblxuXHRjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKS5hcnJheTtcblx0Y29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cdGNvbnN0IHV2cyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3V2JyApO1xuXG5cdGNvbnN0IGEgPSBpbmRpY2VzWyB0cmlhbmdsZUluZGV4ICogMyBdO1xuXHRjb25zdCBiID0gaW5kaWNlc1sgdHJpYW5nbGVJbmRleCAqIDMgKyAxIF07XG5cdGNvbnN0IGMgPSBpbmRpY2VzWyB0cmlhbmdsZUluZGV4ICogMyArIDIgXTtcblxuXHR0ZW1wVjEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCBhICk7XG5cdHRlbXBWMi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIGIgKTtcblx0dGVtcFYzLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgYyApO1xuXG5cdC8vIGZpbmQgdGhlIGFzc29jaWF0ZWQgbWF0ZXJpYWwgaW5kZXhcblx0bGV0IG1hdGVyaWFsSW5kZXggPSAwO1xuXHRjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cdGNvbnN0IGZpcnN0VmVydGV4SW5kZXggPSB0cmlhbmdsZUluZGV4ICogMztcblx0Zm9yICggbGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdGNvbnN0IHsgc3RhcnQsIGNvdW50IH0gPSBncm91cDtcblx0XHRpZiAoIGZpcnN0VmVydGV4SW5kZXggPj0gc3RhcnQgJiYgZmlyc3RWZXJ0ZXhJbmRleCA8IHN0YXJ0ICsgY291bnQgKSB7XG5cblx0XHRcdG1hdGVyaWFsSW5kZXggPSBncm91cC5tYXRlcmlhbEluZGV4O1xuXHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIGV4dHJhY3QgdXZzXG5cdGxldCB1diA9IG51bGw7XG5cdGlmICggdXZzICkge1xuXG5cdFx0dGVtcFVWMS5mcm9tQnVmZmVyQXR0cmlidXRlKCB1dnMsIGEgKTtcblx0XHR0ZW1wVVYyLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2cywgYiApO1xuXHRcdHRlbXBVVjMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXZzLCBjICk7XG5cblx0XHRpZiAoIHRhcmdldCAmJiB0YXJnZXQudXYgKSB1diA9IHRhcmdldC51djtcblx0XHRlbHNlIHV2ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIHBvaW50LCB0ZW1wVjEsIHRlbXBWMiwgdGVtcFYzLCB0ZW1wVVYxLCB0ZW1wVVYyLCB0ZW1wVVYzLCB1diApO1xuXG5cdH1cblxuXHQvLyBhZGp1c3QgdGhlIHByb3ZpZGVkIHRhcmdldCBvciBjcmVhdGUgYSBuZXcgb25lXG5cdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCAhIHRhcmdldC5mYWNlICkgdGFyZ2V0LmZhY2UgPSB7IH07XG5cdFx0dGFyZ2V0LmZhY2UuYSA9IGE7XG5cdFx0dGFyZ2V0LmZhY2UuYiA9IGI7XG5cdFx0dGFyZ2V0LmZhY2UuYyA9IGM7XG5cdFx0dGFyZ2V0LmZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cdFx0aWYgKCAhIHRhcmdldC5mYWNlLm5vcm1hbCApIHRhcmdldC5mYWNlLm5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0VHJpYW5nbGUuZ2V0Tm9ybWFsKCB0ZW1wVjEsIHRlbXBWMiwgdGVtcFYzLCB0YXJnZXQuZmFjZS5ub3JtYWwgKTtcblxuXHRcdGlmICggdXYgKSB0YXJnZXQudXYgPSB1djtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fSBlbHNlIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRmYWNlOiB7XG5cdFx0XHRcdGE6IGEsXG5cdFx0XHRcdGI6IGIsXG5cdFx0XHRcdGM6IGMsXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXgsXG5cdFx0XHRcdG5vcm1hbDogVHJpYW5nbGUuZ2V0Tm9ybWFsKCB0ZW1wVjEsIHRlbXBWMiwgdGVtcFYzLCBuZXcgVmVjdG9yMygpIClcblx0XHRcdH0sXG5cdFx0XHR1djogdXZcblx0XHR9O1xuXG5cdH1cblxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjIiLCJWZWN0b3IzIiwiVHJpYW5nbGUiLCJzZXRUcmlhbmdsZSIsInRyaSIsImkiLCJpbmRleCIsInBvcyIsInRhIiwiYSIsInRiIiwiYiIsInRjIiwiYyIsImkwIiwiaTEiLCJpMiIsImdldFgiLCJ4IiwieSIsImdldFkiLCJ6IiwiZ2V0WiIsInRlbXBWMSIsInRlbXBWMiIsInRlbXBWMyIsInRlbXBVVjEiLCJ0ZW1wVVYyIiwidGVtcFVWMyIsImdldFRyaWFuZ2xlSGl0UG9pbnRJbmZvIiwicG9pbnQiLCJnZW9tZXRyeSIsInRyaWFuZ2xlSW5kZXgiLCJ0YXJnZXQiLCJpbmRpY2VzIiwiZ2V0SW5kZXgiLCJhcnJheSIsInBvc2l0aW9ucyIsImdldEF0dHJpYnV0ZSIsInV2cyIsImZyb21CdWZmZXJBdHRyaWJ1dGUiLCJtYXRlcmlhbEluZGV4IiwiZ3JvdXBzIiwiZmlyc3RWZXJ0ZXhJbmRleCIsImwiLCJsZW5ndGgiLCJncm91cCIsInN0YXJ0IiwiY291bnQiLCJ1diIsImdldEludGVycG9sYXRpb24iLCJmYWNlIiwibm9ybWFsIiwiZ2V0Tm9ybWFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three/examples/jsm/controls/OrbitControls.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three/examples/jsm/controls/OrbitControls.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrbitControls: function() { return /* binding */ OrbitControls; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\nconst _changeEvent = {\n    type: \"change\"\n};\nconst _startEvent = {\n    type: \"start\"\n};\nconst _endEvent = {\n    type: \"end\"\n};\nconst _ray = new three__WEBPACK_IMPORTED_MODULE_0__.Ray();\nconst _plane = new three__WEBPACK_IMPORTED_MODULE_0__.Plane();\nconst TILT_LIMIT = Math.cos(70 * three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.DEG2RAD);\nclass OrbitControls extends three__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {\n    constructor(object, domElement){\n        super();\n        this.object = object;\n        this.domElement = domElement;\n        this.domElement.style.touchAction = \"none\"; // disable touch scroll\n        // Set to false to disable this control\n        this.enabled = true;\n        // \"target\" sets the location of focus, where the object orbits around\n        this.target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        // Sets the 3D cursor (similar to Blender), from which the maxTargetRadius takes effect\n        this.cursor = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        this.minDistance = 0;\n        this.maxDistance = Infinity;\n        // How far you can zoom in and out ( OrthographicCamera only )\n        this.minZoom = 0;\n        this.maxZoom = Infinity;\n        // Limit camera target within a spherical area around the cursor\n        this.minTargetRadius = 0;\n        this.maxTargetRadius = Infinity;\n        // How far you can orbit vertically, upper and lower limits.\n        // Range is 0 to Math.PI radians.\n        this.minPolarAngle = 0; // radians\n        this.maxPolarAngle = Math.PI; // radians\n        // How far you can orbit horizontally, upper and lower limits.\n        // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n        this.minAzimuthAngle = -Infinity; // radians\n        this.maxAzimuthAngle = Infinity; // radians\n        // Set to true to enable damping (inertia)\n        // If damping is enabled, you must call controls.update() in your animation loop\n        this.enableDamping = false;\n        this.dampingFactor = 0.05;\n        // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n        // Set to false to disable zooming\n        this.enableZoom = true;\n        this.zoomSpeed = 1.0;\n        // Set to false to disable rotating\n        this.enableRotate = true;\n        this.rotateSpeed = 1.0;\n        // Set to false to disable panning\n        this.enablePan = true;\n        this.panSpeed = 1.0;\n        this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n        this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n        this.zoomToCursor = false;\n        // Set to true to automatically rotate around the target\n        // If auto-rotate is enabled, you must call controls.update() in your animation loop\n        this.autoRotate = false;\n        this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n        // The four arrow keys\n        this.keys = {\n            LEFT: \"ArrowLeft\",\n            UP: \"ArrowUp\",\n            RIGHT: \"ArrowRight\",\n            BOTTOM: \"ArrowDown\"\n        };\n        // Mouse buttons\n        this.mouseButtons = {\n            LEFT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE,\n            MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY,\n            RIGHT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN\n        };\n        // Touch fingers\n        this.touches = {\n            ONE: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE,\n            TWO: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN\n        };\n        // for reset\n        this.target0 = this.target.clone();\n        this.position0 = this.object.position.clone();\n        this.zoom0 = this.object.zoom;\n        // the target DOM element for key events\n        this._domElementKeyEvents = null;\n        //\n        // public methods\n        //\n        this.getPolarAngle = function() {\n            return spherical.phi;\n        };\n        this.getAzimuthalAngle = function() {\n            return spherical.theta;\n        };\n        this.getDistance = function() {\n            return this.object.position.distanceTo(this.target);\n        };\n        this.listenToKeyEvents = function(domElement) {\n            domElement.addEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = domElement;\n        };\n        this.stopListenToKeyEvents = function() {\n            this._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = null;\n        };\n        this.saveState = function() {\n            scope.target0.copy(scope.target);\n            scope.position0.copy(scope.object.position);\n            scope.zoom0 = scope.object.zoom;\n        };\n        this.reset = function() {\n            scope.target.copy(scope.target0);\n            scope.object.position.copy(scope.position0);\n            scope.object.zoom = scope.zoom0;\n            scope.object.updateProjectionMatrix();\n            scope.dispatchEvent(_changeEvent);\n            scope.update();\n            state = STATE.NONE;\n        };\n        // this method is exposed, but perhaps it would be better if we can make it private...\n        this.update = function() {\n            const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            // so camera.up is the orbit axis\n            const quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromUnitVectors(object.up, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0));\n            const quatInverse = quat.clone().invert();\n            const lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            const lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n            const lastTargetPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            const twoPI = 2 * Math.PI;\n            return function update() {\n                let deltaTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n                const position = scope.object.position;\n                offset.copy(position).sub(scope.target);\n                // rotate offset to \"y-axis-is-up\" space\n                offset.applyQuaternion(quat);\n                // angle from z-axis around y-axis\n                spherical.setFromVector3(offset);\n                if (scope.autoRotate && state === STATE.NONE) {\n                    rotateLeft(getAutoRotationAngle(deltaTime));\n                }\n                if (scope.enableDamping) {\n                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n                } else {\n                    spherical.theta += sphericalDelta.theta;\n                    spherical.phi += sphericalDelta.phi;\n                }\n                // restrict theta to be between desired limits\n                let min = scope.minAzimuthAngle;\n                let max = scope.maxAzimuthAngle;\n                if (isFinite(min) && isFinite(max)) {\n                    if (min < -Math.PI) min += twoPI;\n                    else if (min > Math.PI) min -= twoPI;\n                    if (max < -Math.PI) max += twoPI;\n                    else if (max > Math.PI) max -= twoPI;\n                    if (min <= max) {\n                        spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n                    } else {\n                        spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n                    }\n                }\n                // restrict phi to be between desired limits\n                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n                spherical.makeSafe();\n                // move target to panned location\n                if (scope.enableDamping === true) {\n                    scope.target.addScaledVector(panOffset, scope.dampingFactor);\n                } else {\n                    scope.target.add(panOffset);\n                }\n                // Limit the target distance from the cursor to create a sphere around the center of interest\n                scope.target.sub(scope.cursor);\n                scope.target.clampLength(scope.minTargetRadius, scope.maxTargetRadius);\n                scope.target.add(scope.cursor);\n                // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n                // we adjust zoom later in these cases\n                if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {\n                    spherical.radius = clampDistance(spherical.radius);\n                } else {\n                    spherical.radius = clampDistance(spherical.radius * scale);\n                }\n                offset.setFromSpherical(spherical);\n                // rotate offset back to \"camera-up-vector-is-up\" space\n                offset.applyQuaternion(quatInverse);\n                position.copy(scope.target).add(offset);\n                scope.object.lookAt(scope.target);\n                if (scope.enableDamping === true) {\n                    sphericalDelta.theta *= 1 - scope.dampingFactor;\n                    sphericalDelta.phi *= 1 - scope.dampingFactor;\n                    panOffset.multiplyScalar(1 - scope.dampingFactor);\n                } else {\n                    sphericalDelta.set(0, 0, 0);\n                    panOffset.set(0, 0, 0);\n                }\n                // adjust camera position\n                let zoomChanged = false;\n                if (scope.zoomToCursor && performCursorZoom) {\n                    let newRadius = null;\n                    if (scope.object.isPerspectiveCamera) {\n                        // move the camera down the pointer ray\n                        // this method avoids floating point error\n                        const prevRadius = offset.length();\n                        newRadius = clampDistance(prevRadius * scale);\n                        const radiusDelta = prevRadius - newRadius;\n                        scope.object.position.addScaledVector(dollyDirection, radiusDelta);\n                        scope.object.updateMatrixWorld();\n                    } else if (scope.object.isOrthographicCamera) {\n                        // adjust the ortho camera position based on zoom changes\n                        const mouseBefore = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n                        mouseBefore.unproject(scope.object);\n                        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n                        scope.object.updateProjectionMatrix();\n                        zoomChanged = true;\n                        const mouseAfter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n                        mouseAfter.unproject(scope.object);\n                        scope.object.position.sub(mouseAfter).add(mouseBefore);\n                        scope.object.updateMatrixWorld();\n                        newRadius = offset.length();\n                    } else {\n                        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\");\n                        scope.zoomToCursor = false;\n                    }\n                    // handle the placement of the target\n                    if (newRadius !== null) {\n                        if (this.screenSpacePanning) {\n                            // position the orbit target in front of the new camera position\n                            scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);\n                        } else {\n                            // get the ray and translation plane to compute target\n                            _ray.origin.copy(scope.object.position);\n                            _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);\n                            // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n                            // extremely large values\n                            if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                                object.lookAt(scope.target);\n                            } else {\n                                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);\n                                _ray.intersectPlane(_plane, scope.target);\n                            }\n                        }\n                    }\n                } else if (scope.object.isOrthographicCamera) {\n                    zoomChanged = scale !== 1;\n                    if (zoomChanged) {\n                        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n                        scope.object.updateProjectionMatrix();\n                    }\n                }\n                scale = 1;\n                performCursorZoom = false;\n                // update condition is:\n                // min(camera displacement, camera rotation in radians)^2 > EPS\n                // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n                if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS || lastTargetPosition.distanceToSquared(scope.target) > 0) {\n                    scope.dispatchEvent(_changeEvent);\n                    lastPosition.copy(scope.object.position);\n                    lastQuaternion.copy(scope.object.quaternion);\n                    lastTargetPosition.copy(scope.target);\n                    return true;\n                }\n                return false;\n            };\n        }();\n        this.dispose = function() {\n            scope.domElement.removeEventListener(\"contextmenu\", onContextMenu);\n            scope.domElement.removeEventListener(\"pointerdown\", onPointerDown);\n            scope.domElement.removeEventListener(\"pointercancel\", onPointerUp);\n            scope.domElement.removeEventListener(\"wheel\", onMouseWheel);\n            scope.domElement.removeEventListener(\"pointermove\", onPointerMove);\n            scope.domElement.removeEventListener(\"pointerup\", onPointerUp);\n            if (scope._domElementKeyEvents !== null) {\n                scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n                scope._domElementKeyEvents = null;\n            }\n        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n        };\n        //\n        // internals\n        //\n        const scope = this;\n        const STATE = {\n            NONE: -1,\n            ROTATE: 0,\n            DOLLY: 1,\n            PAN: 2,\n            TOUCH_ROTATE: 3,\n            TOUCH_PAN: 4,\n            TOUCH_DOLLY_PAN: 5,\n            TOUCH_DOLLY_ROTATE: 6\n        };\n        let state = STATE.NONE;\n        const EPS = 0.000001;\n        // current position in spherical coordinates\n        const spherical = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n        const sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n        let scale = 1;\n        const panOffset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const panStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const panEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const panDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyDirection = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const mouse = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        let performCursorZoom = false;\n        const pointers = [];\n        const pointerPositions = {};\n        let controlActive = false;\n        function getAutoRotationAngle(deltaTime) {\n            if (deltaTime !== null) {\n                return 2 * Math.PI / 60 * scope.autoRotateSpeed * deltaTime;\n            } else {\n                return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n            }\n        }\n        function getZoomScale(delta) {\n            const normalizedDelta = Math.abs(delta * 0.01);\n            return Math.pow(0.95, scope.zoomSpeed * normalizedDelta);\n        }\n        function rotateLeft(angle) {\n            sphericalDelta.theta -= angle;\n        }\n        function rotateUp(angle) {\n            sphericalDelta.phi -= angle;\n        }\n        const panLeft = function() {\n            const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            return function panLeft(distance, objectMatrix) {\n                v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n                v.multiplyScalar(-distance);\n                panOffset.add(v);\n            };\n        }();\n        const panUp = function() {\n            const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            return function panUp(distance, objectMatrix) {\n                if (scope.screenSpacePanning === true) {\n                    v.setFromMatrixColumn(objectMatrix, 1);\n                } else {\n                    v.setFromMatrixColumn(objectMatrix, 0);\n                    v.crossVectors(scope.object.up, v);\n                }\n                v.multiplyScalar(distance);\n                panOffset.add(v);\n            };\n        }();\n        // deltaX and deltaY are in pixels; right and down are positive\n        const pan = function() {\n            const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            return function pan(deltaX, deltaY) {\n                const element = scope.domElement;\n                if (scope.object.isPerspectiveCamera) {\n                    // perspective\n                    const position = scope.object.position;\n                    offset.copy(position).sub(scope.target);\n                    let targetDistance = offset.length();\n                    // half of the fov is center to top of screen\n                    targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n                    // we use only clientHeight here so aspect ratio does not distort speed\n                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n                } else if (scope.object.isOrthographicCamera) {\n                    // orthographic\n                    panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n                    panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n                } else {\n                    // camera neither orthographic nor perspective\n                    console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n                    scope.enablePan = false;\n                }\n            };\n        }();\n        function dollyOut(dollyScale) {\n            if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {\n                scale /= dollyScale;\n            } else {\n                console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n                scope.enableZoom = false;\n            }\n        }\n        function dollyIn(dollyScale) {\n            if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {\n                scale *= dollyScale;\n            } else {\n                console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n                scope.enableZoom = false;\n            }\n        }\n        function updateZoomParameters(x, y) {\n            if (!scope.zoomToCursor) {\n                return;\n            }\n            performCursorZoom = true;\n            const rect = scope.domElement.getBoundingClientRect();\n            const dx = x - rect.left;\n            const dy = y - rect.top;\n            const w = rect.width;\n            const h = rect.height;\n            mouse.x = dx / w * 2 - 1;\n            mouse.y = -(dy / h) * 2 + 1;\n            dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();\n        }\n        function clampDistance(dist) {\n            return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));\n        }\n        //\n        // event callbacks - update the object state\n        //\n        function handleMouseDownRotate(event) {\n            rotateStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownDolly(event) {\n            updateZoomParameters(event.clientX, event.clientX);\n            dollyStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownPan(event) {\n            panStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseMoveRotate(event) {\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            rotateStart.copy(rotateEnd);\n            scope.update();\n        }\n        function handleMouseMoveDolly(event) {\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n            if (dollyDelta.y > 0) {\n                dollyOut(getZoomScale(dollyDelta.y));\n            } else if (dollyDelta.y < 0) {\n                dollyIn(getZoomScale(dollyDelta.y));\n            }\n            dollyStart.copy(dollyEnd);\n            scope.update();\n        }\n        function handleMouseMovePan(event) {\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n            scope.update();\n        }\n        function handleMouseWheel(event) {\n            updateZoomParameters(event.clientX, event.clientY);\n            if (event.deltaY < 0) {\n                dollyIn(getZoomScale(event.deltaY));\n            } else if (event.deltaY > 0) {\n                dollyOut(getZoomScale(event.deltaY));\n            }\n            scope.update();\n        }\n        function handleKeyDown(event) {\n            let needsUpdate = false;\n            switch(event.code){\n                case scope.keys.UP:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    } else {\n                        pan(0, scope.keyPanSpeed);\n                    }\n                    needsUpdate = true;\n                    break;\n                case scope.keys.BOTTOM:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    } else {\n                        pan(0, -scope.keyPanSpeed);\n                    }\n                    needsUpdate = true;\n                    break;\n                case scope.keys.LEFT:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    } else {\n                        pan(scope.keyPanSpeed, 0);\n                    }\n                    needsUpdate = true;\n                    break;\n                case scope.keys.RIGHT:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);\n                    } else {\n                        pan(-scope.keyPanSpeed, 0);\n                    }\n                    needsUpdate = true;\n                    break;\n            }\n            if (needsUpdate) {\n                // prevent the browser from scrolling on cursor keys\n                event.preventDefault();\n                scope.update();\n            }\n        }\n        function handleTouchStartRotate(event) {\n            if (pointers.length === 1) {\n                rotateStart.set(event.pageX, event.pageY);\n            } else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                rotateStart.set(x, y);\n            }\n        }\n        function handleTouchStartPan(event) {\n            if (pointers.length === 1) {\n                panStart.set(event.pageX, event.pageY);\n            } else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                panStart.set(x, y);\n            }\n        }\n        function handleTouchStartDolly(event) {\n            const position = getSecondPointerPosition(event);\n            const dx = event.pageX - position.x;\n            const dy = event.pageY - position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyStart.set(0, distance);\n        }\n        function handleTouchStartDollyPan(event) {\n            if (scope.enableZoom) handleTouchStartDolly(event);\n            if (scope.enablePan) handleTouchStartPan(event);\n        }\n        function handleTouchStartDollyRotate(event) {\n            if (scope.enableZoom) handleTouchStartDolly(event);\n            if (scope.enableRotate) handleTouchStartRotate(event);\n        }\n        function handleTouchMoveRotate(event) {\n            if (pointers.length == 1) {\n                rotateEnd.set(event.pageX, event.pageY);\n            } else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                rotateEnd.set(x, y);\n            }\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            rotateStart.copy(rotateEnd);\n        }\n        function handleTouchMovePan(event) {\n            if (pointers.length === 1) {\n                panEnd.set(event.pageX, event.pageY);\n            } else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                panEnd.set(x, y);\n            }\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n        }\n        function handleTouchMoveDolly(event) {\n            const position = getSecondPointerPosition(event);\n            const dx = event.pageX - position.x;\n            const dy = event.pageY - position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyEnd.set(0, distance);\n            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n            dollyOut(dollyDelta.y);\n            dollyStart.copy(dollyEnd);\n            const centerX = (event.pageX + position.x) * 0.5;\n            const centerY = (event.pageY + position.y) * 0.5;\n            updateZoomParameters(centerX, centerY);\n        }\n        function handleTouchMoveDollyPan(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enablePan) handleTouchMovePan(event);\n        }\n        function handleTouchMoveDollyRotate(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enableRotate) handleTouchMoveRotate(event);\n        }\n        //\n        // event handlers - FSM: listen for events and reset state\n        //\n        function onPointerDown(event) {\n            if (scope.enabled === false) return;\n            if (pointers.length === 0) {\n                scope.domElement.setPointerCapture(event.pointerId);\n                scope.domElement.addEventListener(\"pointermove\", onPointerMove);\n                scope.domElement.addEventListener(\"pointerup\", onPointerUp);\n            }\n            //\n            addPointer(event);\n            if (event.pointerType === \"touch\") {\n                onTouchStart(event);\n            } else {\n                onMouseDown(event);\n            }\n        }\n        function onPointerMove(event) {\n            if (scope.enabled === false) return;\n            if (event.pointerType === \"touch\") {\n                onTouchMove(event);\n            } else {\n                onMouseMove(event);\n            }\n        }\n        function onPointerUp(event) {\n            removePointer(event);\n            switch(pointers.length){\n                case 0:\n                    scope.domElement.releasePointerCapture(event.pointerId);\n                    scope.domElement.removeEventListener(\"pointermove\", onPointerMove);\n                    scope.domElement.removeEventListener(\"pointerup\", onPointerUp);\n                    scope.dispatchEvent(_endEvent);\n                    state = STATE.NONE;\n                    break;\n                case 1:\n                    const pointerId = pointers[0];\n                    const position = pointerPositions[pointerId];\n                    // minimal placeholder event - allows state correction on pointer-up\n                    onTouchStart({\n                        pointerId: pointerId,\n                        pageX: position.x,\n                        pageY: position.y\n                    });\n                    break;\n            }\n        }\n        function onMouseDown(event) {\n            let mouseAction;\n            switch(event.button){\n                case 0:\n                    mouseAction = scope.mouseButtons.LEFT;\n                    break;\n                case 1:\n                    mouseAction = scope.mouseButtons.MIDDLE;\n                    break;\n                case 2:\n                    mouseAction = scope.mouseButtons.RIGHT;\n                    break;\n                default:\n                    mouseAction = -1;\n            }\n            switch(mouseAction){\n                case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseDownDolly(event);\n                    state = STATE.DOLLY;\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    } else {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    }\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    } else {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) {\n                scope.dispatchEvent(_startEvent);\n            }\n        }\n        function onMouseMove(event) {\n            switch(state){\n                case STATE.ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleMouseMoveRotate(event);\n                    break;\n                case STATE.DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseMoveDolly(event);\n                    break;\n                case STATE.PAN:\n                    if (scope.enablePan === false) return;\n                    handleMouseMovePan(event);\n                    break;\n            }\n        }\n        function onMouseWheel(event) {\n            if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;\n            event.preventDefault();\n            scope.dispatchEvent(_startEvent);\n            handleMouseWheel(customWheelEvent(event));\n            scope.dispatchEvent(_endEvent);\n        }\n        function customWheelEvent(event) {\n            const mode = event.deltaMode;\n            // minimal wheel event altered to meet delta-zoom demand\n            const newEvent = {\n                clientX: event.clientX,\n                clientY: event.clientY,\n                deltaY: event.deltaY\n            };\n            switch(mode){\n                case 1:\n                    newEvent.deltaY *= 16;\n                    break;\n                case 2:\n                    newEvent.deltaY *= 100;\n                    break;\n            }\n            // detect if event was triggered by pinching\n            if (event.ctrlKey && !controlActive) {\n                newEvent.deltaY *= 10;\n            }\n            return newEvent;\n        }\n        function interceptControlDown(event) {\n            if (event.key === \"Control\") {\n                controlActive = true;\n                const document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n                document.addEventListener(\"keyup\", interceptControlUp, {\n                    passive: true,\n                    capture: true\n                });\n            }\n        }\n        function interceptControlUp(event) {\n            if (event.key === \"Control\") {\n                controlActive = false;\n                const document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n                document.removeEventListener(\"keyup\", interceptControlUp, {\n                    passive: true,\n                    capture: true\n                });\n            }\n        }\n        function onKeyDown(event) {\n            if (scope.enabled === false || scope.enablePan === false) return;\n            handleKeyDown(event);\n        }\n        function onTouchStart(event) {\n            trackPointer(event);\n            switch(pointers.length){\n                case 1:\n                    switch(scope.touches.ONE){\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE:\n                            if (scope.enableRotate === false) return;\n                            handleTouchStartRotate(event);\n                            state = STATE.TOUCH_ROTATE;\n                            break;\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN:\n                            if (scope.enablePan === false) return;\n                            handleTouchStartPan(event);\n                            state = STATE.TOUCH_PAN;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                case 2:\n                    switch(scope.touches.TWO){\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN:\n                            if (scope.enableZoom === false && scope.enablePan === false) return;\n                            handleTouchStartDollyPan(event);\n                            state = STATE.TOUCH_DOLLY_PAN;\n                            break;\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE:\n                            if (scope.enableZoom === false && scope.enableRotate === false) return;\n                            handleTouchStartDollyRotate(event);\n                            state = STATE.TOUCH_DOLLY_ROTATE;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) {\n                scope.dispatchEvent(_startEvent);\n            }\n        }\n        function onTouchMove(event) {\n            trackPointer(event);\n            switch(state){\n                case STATE.TOUCH_ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleTouchMoveRotate(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_PAN:\n                    if (scope.enablePan === false) return;\n                    handleTouchMovePan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_PAN:\n                    if (scope.enableZoom === false && scope.enablePan === false) return;\n                    handleTouchMoveDollyPan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_ROTATE:\n                    if (scope.enableZoom === false && scope.enableRotate === false) return;\n                    handleTouchMoveDollyRotate(event);\n                    scope.update();\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n        }\n        function onContextMenu(event) {\n            if (scope.enabled === false) return;\n            event.preventDefault();\n        }\n        function addPointer(event) {\n            pointers.push(event.pointerId);\n        }\n        function removePointer(event) {\n            delete pointerPositions[event.pointerId];\n            for(let i = 0; i < pointers.length; i++){\n                if (pointers[i] == event.pointerId) {\n                    pointers.splice(i, 1);\n                    return;\n                }\n            }\n        }\n        function trackPointer(event) {\n            let position = pointerPositions[event.pointerId];\n            if (position === undefined) {\n                position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n                pointerPositions[event.pointerId] = position;\n            }\n            position.set(event.pageX, event.pageY);\n        }\n        function getSecondPointerPosition(event) {\n            const pointerId = event.pointerId === pointers[0] ? pointers[1] : pointers[0];\n            return pointerPositions[pointerId];\n        }\n        //\n        scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n        scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n        scope.domElement.addEventListener(\"pointercancel\", onPointerUp);\n        scope.domElement.addEventListener(\"wheel\", onMouseWheel, {\n            passive: false\n        });\n        const document = scope.domElement.getRootNode(); // offscreen canvas compatibility\n        document.addEventListener(\"keydown\", interceptControlDown, {\n            passive: true,\n            capture: true\n        });\n        // force an update at start\n        this.update();\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9scy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQVdlO0FBRWYsb0VBQW9FO0FBQ3BFLHVGQUF1RjtBQUN2RixFQUFFO0FBQ0YsaURBQWlEO0FBQ2pELDZFQUE2RTtBQUM3RSxtR0FBbUc7QUFFbkcsTUFBTVUsZUFBZTtJQUFFQyxNQUFNO0FBQVM7QUFDdEMsTUFBTUMsY0FBYztJQUFFRCxNQUFNO0FBQVE7QUFDcEMsTUFBTUUsWUFBWTtJQUFFRixNQUFNO0FBQU07QUFDaEMsTUFBTUcsT0FBTyxJQUFJTixzQ0FBR0E7QUFDcEIsTUFBTU8sU0FBUyxJQUFJUix3Q0FBS0E7QUFDeEIsTUFBTVMsYUFBYUMsS0FBS0MsR0FBRyxDQUFFLEtBQUtULDRDQUFTQSxDQUFDVSxPQUFPO0FBRW5ELE1BQU1DLHNCQUFzQnBCLGtEQUFlQTtJQUUxQ3FCLFlBQWFDLE1BQU0sRUFBRUMsVUFBVSxDQUFHO1FBRWpDLEtBQUs7UUFFTCxJQUFJLENBQUNELE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQSxVQUFVLENBQUNDLEtBQUssQ0FBQ0MsV0FBVyxHQUFHLFFBQVEsdUJBQXVCO1FBRW5FLHVDQUF1QztRQUN2QyxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUVmLHNFQUFzRTtRQUN0RSxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJckIsMENBQU9BO1FBRXpCLHVGQUF1RjtRQUN2RixJQUFJLENBQUNzQixNQUFNLEdBQUcsSUFBSXRCLDBDQUFPQTtRQUV6Qiw4REFBOEQ7UUFDOUQsSUFBSSxDQUFDdUIsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsV0FBVyxHQUFHQztRQUVuQiw4REFBOEQ7UUFDOUQsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBR0Y7UUFFZixnRUFBZ0U7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c0JBQXNCO1lBQUVLLFNBQVM7WUFBTUMsU0FBUztRQUFLO1FBRTNGLDJCQUEyQjtRQUUzQixJQUFJLENBQUN2TCxNQUFNO0lBRVo7QUFFRDtBQUV5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHMuanM/ZDFmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRFdmVudERpc3BhdGNoZXIsXG5cdE1PVVNFLFxuXHRRdWF0ZXJuaW9uLFxuXHRTcGhlcmljYWwsXG5cdFRPVUNILFxuXHRWZWN0b3IyLFxuXHRWZWN0b3IzLFxuXHRQbGFuZSxcblx0UmF5LFxuXHRNYXRoVXRpbHNcbn0gZnJvbSAndGhyZWUnO1xuXG4vLyBPcmJpdENvbnRyb2xzIHBlcmZvcm1zIG9yYml0aW5nLCBkb2xseWluZyAoem9vbWluZyksIGFuZCBwYW5uaW5nLlxuLy8gVW5saWtlIFRyYWNrYmFsbENvbnRyb2xzLCBpdCBtYWludGFpbnMgdGhlIFwidXBcIiBkaXJlY3Rpb24gb2JqZWN0LnVwICgrWSBieSBkZWZhdWx0KS5cbi8vXG4vLyAgICBPcmJpdCAtIGxlZnQgbW91c2UgLyB0b3VjaDogb25lLWZpbmdlciBtb3ZlXG4vLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3by1maW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxuLy8gICAgUGFuIC0gcmlnaHQgbW91c2UsIG9yIGxlZnQgbW91c2UgKyBjdHJsL21ldGEvc2hpZnRLZXksIG9yIGFycm93IGtleXMgLyB0b3VjaDogdHdvLWZpbmdlciBtb3ZlXG5cbmNvbnN0IF9jaGFuZ2VFdmVudCA9IHsgdHlwZTogJ2NoYW5nZScgfTtcbmNvbnN0IF9zdGFydEV2ZW50ID0geyB0eXBlOiAnc3RhcnQnIH07XG5jb25zdCBfZW5kRXZlbnQgPSB7IHR5cGU6ICdlbmQnIH07XG5jb25zdCBfcmF5ID0gbmV3IFJheSgpO1xuY29uc3QgX3BsYW5lID0gbmV3IFBsYW5lKCk7XG5jb25zdCBUSUxUX0xJTUlUID0gTWF0aC5jb3MoIDcwICogTWF0aFV0aWxzLkRFRzJSQUQgKTtcblxuY2xhc3MgT3JiaXRDb250cm9scyBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoIG9iamVjdCwgZG9tRWxlbWVudCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuXHRcdHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJzsgLy8gZGlzYWJsZSB0b3VjaCBzY3JvbGxcblxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cblx0XHQvLyBcInRhcmdldFwiIHNldHMgdGhlIGxvY2F0aW9uIG9mIGZvY3VzLCB3aGVyZSB0aGUgb2JqZWN0IG9yYml0cyBhcm91bmRcblx0XHR0aGlzLnRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBTZXRzIHRoZSAzRCBjdXJzb3IgKHNpbWlsYXIgdG8gQmxlbmRlciksIGZyb20gd2hpY2ggdGhlIG1heFRhcmdldFJhZGl1cyB0YWtlcyBlZmZlY3Rcblx0XHR0aGlzLmN1cnNvciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBIb3cgZmFyIHlvdSBjYW4gZG9sbHkgaW4gYW5kIG91dCAoIFBlcnNwZWN0aXZlQ2FtZXJhIG9ubHkgKVxuXHRcdHRoaXMubWluRGlzdGFuY2UgPSAwO1xuXHRcdHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcblxuXHRcdC8vIEhvdyBmYXIgeW91IGNhbiB6b29tIGluIGFuZCBvdXQgKCBPcnRob2dyYXBoaWNDYW1lcmEgb25seSApXG5cdFx0dGhpcy5taW5ab29tID0gMDtcblx0XHR0aGlzLm1heFpvb20gPSBJbmZpbml0eTtcblxuXHRcdC8vIExpbWl0IGNhbWVyYSB0YXJnZXQgd2l0aGluIGEgc3BoZXJpY2FsIGFyZWEgYXJvdW5kIHRoZSBjdXJzb3Jcblx0XHR0aGlzLm1pblRhcmdldFJhZGl1cyA9IDA7XG5cdFx0dGhpcy5tYXhUYXJnZXRSYWRpdXMgPSBJbmZpbml0eTtcblxuXHRcdC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCB2ZXJ0aWNhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuXHRcdC8vIFJhbmdlIGlzIDAgdG8gTWF0aC5QSSByYWRpYW5zLlxuXHRcdHRoaXMubWluUG9sYXJBbmdsZSA9IDA7IC8vIHJhZGlhbnNcblx0XHR0aGlzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJOyAvLyByYWRpYW5zXG5cblx0XHQvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgaG9yaXpvbnRhbGx5LCB1cHBlciBhbmQgbG93ZXIgbGltaXRzLlxuXHRcdC8vIElmIHNldCwgdGhlIGludGVydmFsIFsgbWluLCBtYXggXSBtdXN0IGJlIGEgc3ViLWludGVydmFsIG9mIFsgLSAyIFBJLCAyIFBJIF0sIHdpdGggKCBtYXggLSBtaW4gPCAyIFBJIClcblx0XHR0aGlzLm1pbkF6aW11dGhBbmdsZSA9IC0gSW5maW5pdHk7IC8vIHJhZGlhbnNcblx0XHR0aGlzLm1heEF6aW11dGhBbmdsZSA9IEluZmluaXR5OyAvLyByYWRpYW5zXG5cblx0XHQvLyBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgZGFtcGluZyAoaW5lcnRpYSlcblx0XHQvLyBJZiBkYW1waW5nIGlzIGVuYWJsZWQsIHlvdSBtdXN0IGNhbGwgY29udHJvbHMudXBkYXRlKCkgaW4geW91ciBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuZW5hYmxlRGFtcGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuZGFtcGluZ0ZhY3RvciA9IDAuMDU7XG5cblx0XHQvLyBUaGlzIG9wdGlvbiBhY3R1YWxseSBlbmFibGVzIGRvbGx5aW5nIGluIGFuZCBvdXQ7IGxlZnQgYXMgXCJ6b29tXCIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHpvb21pbmdcblx0XHR0aGlzLmVuYWJsZVpvb20gPSB0cnVlO1xuXHRcdHRoaXMuem9vbVNwZWVkID0gMS4wO1xuXG5cdFx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcm90YXRpbmdcblx0XHR0aGlzLmVuYWJsZVJvdGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5yb3RhdGVTcGVlZCA9IDEuMDtcblxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHBhbm5pbmdcblx0XHR0aGlzLmVuYWJsZVBhbiA9IHRydWU7XG5cdFx0dGhpcy5wYW5TcGVlZCA9IDEuMDtcblx0XHR0aGlzLnNjcmVlblNwYWNlUGFubmluZyA9IHRydWU7IC8vIGlmIGZhbHNlLCBwYW4gb3J0aG9nb25hbCB0byB3b3JsZC1zcGFjZSBkaXJlY3Rpb24gY2FtZXJhLnVwXG5cdFx0dGhpcy5rZXlQYW5TcGVlZCA9IDcuMDtcdC8vIHBpeGVscyBtb3ZlZCBwZXIgYXJyb3cga2V5IHB1c2hcblx0XHR0aGlzLnpvb21Ub0N1cnNvciA9IGZhbHNlO1xuXG5cdFx0Ly8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcblx0XHQvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgb3JiaXQgd2hlbiBmcHMgaXMgNjBcblxuXHRcdC8vIFRoZSBmb3VyIGFycm93IGtleXNcblx0XHR0aGlzLmtleXMgPSB7IExFRlQ6ICdBcnJvd0xlZnQnLCBVUDogJ0Fycm93VXAnLCBSSUdIVDogJ0Fycm93UmlnaHQnLCBCT1RUT006ICdBcnJvd0Rvd24nIH07XG5cblx0XHQvLyBNb3VzZSBidXR0b25zXG5cdFx0dGhpcy5tb3VzZUJ1dHRvbnMgPSB7IExFRlQ6IE1PVVNFLlJPVEFURSwgTUlERExFOiBNT1VTRS5ET0xMWSwgUklHSFQ6IE1PVVNFLlBBTiB9O1xuXG5cdFx0Ly8gVG91Y2ggZmluZ2Vyc1xuXHRcdHRoaXMudG91Y2hlcyA9IHsgT05FOiBUT1VDSC5ST1RBVEUsIFRXTzogVE9VQ0guRE9MTFlfUEFOIH07XG5cblx0XHQvLyBmb3IgcmVzZXRcblx0XHR0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXHRcdHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcblx0XHR0aGlzLnpvb20wID0gdGhpcy5vYmplY3Quem9vbTtcblxuXHRcdC8vIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnQgZm9yIGtleSBldmVudHNcblx0XHR0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzID0gbnVsbDtcblxuXHRcdC8vXG5cdFx0Ly8gcHVibGljIG1ldGhvZHNcblx0XHQvL1xuXG5cdFx0dGhpcy5nZXRQb2xhckFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gc3BoZXJpY2FsLnBoaTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldEF6aW11dGhhbEFuZ2xlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gc3BoZXJpY2FsLnRoZXRhO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm9iamVjdC5wb3NpdGlvbi5kaXN0YW5jZVRvKCB0aGlzLnRhcmdldCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMubGlzdGVuVG9LZXlFdmVudHMgPSBmdW5jdGlvbiAoIGRvbUVsZW1lbnQgKSB7XG5cblx0XHRcdGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24gKTtcblx0XHRcdHRoaXMuX2RvbUVsZW1lbnRLZXlFdmVudHMgPSBkb21FbGVtZW50O1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc3RvcExpc3RlblRvS2V5RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duICk7XG5cdFx0XHR0aGlzLl9kb21FbGVtZW50S2V5RXZlbnRzID0gbnVsbDtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0c2NvcGUudGFyZ2V0MC5jb3B5KCBzY29wZS50YXJnZXQgKTtcblx0XHRcdHNjb3BlLnBvc2l0aW9uMC5jb3B5KCBzY29wZS5vYmplY3QucG9zaXRpb24gKTtcblx0XHRcdHNjb3BlLnpvb20wID0gc2NvcGUub2JqZWN0Lnpvb207XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0c2NvcGUudGFyZ2V0LmNvcHkoIHNjb3BlLnRhcmdldDAgKTtcblx0XHRcdHNjb3BlLm9iamVjdC5wb3NpdGlvbi5jb3B5KCBzY29wZS5wb3NpdGlvbjAgKTtcblx0XHRcdHNjb3BlLm9iamVjdC56b29tID0gc2NvcGUuem9vbTA7XG5cblx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfY2hhbmdlRXZlbnQgKTtcblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdH07XG5cblx0XHQvLyB0aGlzIG1ldGhvZCBpcyBleHBvc2VkLCBidXQgcGVyaGFwcyBpdCB3b3VsZCBiZSBiZXR0ZXIgaWYgd2UgY2FuIG1ha2UgaXQgcHJpdmF0ZS4uLlxuXHRcdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBzbyBjYW1lcmEudXAgaXMgdGhlIG9yYml0IGF4aXNcblx0XHRcdGNvbnN0IHF1YXQgPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21Vbml0VmVjdG9ycyggb2JqZWN0LnVwLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApICk7XG5cdFx0XHRjb25zdCBxdWF0SW52ZXJzZSA9IHF1YXQuY2xvbmUoKS5pbnZlcnQoKTtcblxuXHRcdFx0Y29uc3QgbGFzdFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdGNvbnN0IGxhc3RRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRcdGNvbnN0IGxhc3RUYXJnZXRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGNvbnN0IHR3b1BJID0gMiAqIE1hdGguUEk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGRlbHRhVGltZSA9IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG5cblx0XHRcdFx0b2Zmc2V0LmNvcHkoIHBvc2l0aW9uICkuc3ViKCBzY29wZS50YXJnZXQgKTtcblxuXHRcdFx0XHQvLyByb3RhdGUgb2Zmc2V0IHRvIFwieS1heGlzLWlzLXVwXCIgc3BhY2Vcblx0XHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdCApO1xuXG5cdFx0XHRcdC8vIGFuZ2xlIGZyb20gei1heGlzIGFyb3VuZCB5LWF4aXNcblx0XHRcdFx0c3BoZXJpY2FsLnNldEZyb21WZWN0b3IzKCBvZmZzZXQgKTtcblxuXHRcdFx0XHRpZiAoIHNjb3BlLmF1dG9Sb3RhdGUgJiYgc3RhdGUgPT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdFx0XHRyb3RhdGVMZWZ0KCBnZXRBdXRvUm90YXRpb25BbmdsZSggZGVsdGFUaW1lICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVEYW1waW5nICkge1xuXG5cdFx0XHRcdFx0c3BoZXJpY2FsLnRoZXRhICs9IHNwaGVyaWNhbERlbHRhLnRoZXRhICogc2NvcGUuZGFtcGluZ0ZhY3Rvcjtcblx0XHRcdFx0XHRzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaSAqIHNjb3BlLmRhbXBpbmdGYWN0b3I7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHNwaGVyaWNhbC50aGV0YSArPSBzcGhlcmljYWxEZWx0YS50aGV0YTtcblx0XHRcdFx0XHRzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzdHJpY3QgdGhldGEgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuXG5cdFx0XHRcdGxldCBtaW4gPSBzY29wZS5taW5BemltdXRoQW5nbGU7XG5cdFx0XHRcdGxldCBtYXggPSBzY29wZS5tYXhBemltdXRoQW5nbGU7XG5cblx0XHRcdFx0aWYgKCBpc0Zpbml0ZSggbWluICkgJiYgaXNGaW5pdGUoIG1heCApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBtaW4gPCAtIE1hdGguUEkgKSBtaW4gKz0gdHdvUEk7IGVsc2UgaWYgKCBtaW4gPiBNYXRoLlBJICkgbWluIC09IHR3b1BJO1xuXG5cdFx0XHRcdFx0aWYgKCBtYXggPCAtIE1hdGguUEkgKSBtYXggKz0gdHdvUEk7IGVsc2UgaWYgKCBtYXggPiBNYXRoLlBJICkgbWF4IC09IHR3b1BJO1xuXG5cdFx0XHRcdFx0aWYgKCBtaW4gPD0gbWF4ICkge1xuXG5cdFx0XHRcdFx0XHRzcGhlcmljYWwudGhldGEgPSBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBzcGhlcmljYWwudGhldGEgKSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c3BoZXJpY2FsLnRoZXRhID0gKCBzcGhlcmljYWwudGhldGEgPiAoIG1pbiArIG1heCApIC8gMiApID9cblx0XHRcdFx0XHRcdFx0TWF0aC5tYXgoIG1pbiwgc3BoZXJpY2FsLnRoZXRhICkgOlxuXHRcdFx0XHRcdFx0XHRNYXRoLm1pbiggbWF4LCBzcGhlcmljYWwudGhldGEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcblx0XHRcdFx0c3BoZXJpY2FsLnBoaSA9IE1hdGgubWF4KCBzY29wZS5taW5Qb2xhckFuZ2xlLCBNYXRoLm1pbiggc2NvcGUubWF4UG9sYXJBbmdsZSwgc3BoZXJpY2FsLnBoaSApICk7XG5cblx0XHRcdFx0c3BoZXJpY2FsLm1ha2VTYWZlKCk7XG5cblxuXHRcdFx0XHQvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cblxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRzY29wZS50YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBwYW5PZmZzZXQsIHNjb3BlLmRhbXBpbmdGYWN0b3IgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2NvcGUudGFyZ2V0LmFkZCggcGFuT2Zmc2V0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExpbWl0IHRoZSB0YXJnZXQgZGlzdGFuY2UgZnJvbSB0aGUgY3Vyc29yIHRvIGNyZWF0ZSBhIHNwaGVyZSBhcm91bmQgdGhlIGNlbnRlciBvZiBpbnRlcmVzdFxuXHRcdFx0XHRzY29wZS50YXJnZXQuc3ViKCBzY29wZS5jdXJzb3IgKTtcblx0XHRcdFx0c2NvcGUudGFyZ2V0LmNsYW1wTGVuZ3RoKCBzY29wZS5taW5UYXJnZXRSYWRpdXMsIHNjb3BlLm1heFRhcmdldFJhZGl1cyApO1xuXHRcdFx0XHRzY29wZS50YXJnZXQuYWRkKCBzY29wZS5jdXJzb3IgKTtcblxuXHRcdFx0XHQvLyBhZGp1c3QgdGhlIGNhbWVyYSBwb3NpdGlvbiBiYXNlZCBvbiB6b29tIG9ubHkgaWYgd2UncmUgbm90IHpvb21pbmcgdG8gdGhlIGN1cnNvciBvciBpZiBpdCdzIGFuIG9ydGhvIGNhbWVyYVxuXHRcdFx0XHQvLyB3ZSBhZGp1c3Qgem9vbSBsYXRlciBpbiB0aGVzZSBjYXNlc1xuXHRcdFx0XHRpZiAoIHNjb3BlLnpvb21Ub0N1cnNvciAmJiBwZXJmb3JtQ3Vyc29yWm9vbSB8fCBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHRzcGhlcmljYWwucmFkaXVzID0gY2xhbXBEaXN0YW5jZSggc3BoZXJpY2FsLnJhZGl1cyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzcGhlcmljYWwucmFkaXVzID0gY2xhbXBEaXN0YW5jZSggc3BoZXJpY2FsLnJhZGl1cyAqIHNjYWxlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9mZnNldC5zZXRGcm9tU3BoZXJpY2FsKCBzcGhlcmljYWwgKTtcblxuXHRcdFx0XHQvLyByb3RhdGUgb2Zmc2V0IGJhY2sgdG8gXCJjYW1lcmEtdXAtdmVjdG9yLWlzLXVwXCIgc3BhY2Vcblx0XHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdEludmVyc2UgKTtcblxuXHRcdFx0XHRwb3NpdGlvbi5jb3B5KCBzY29wZS50YXJnZXQgKS5hZGQoIG9mZnNldCApO1xuXG5cdFx0XHRcdHNjb3BlLm9iamVjdC5sb29rQXQoIHNjb3BlLnRhcmdldCApO1xuXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlRGFtcGluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHNwaGVyaWNhbERlbHRhLnRoZXRhICo9ICggMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3IgKTtcblx0XHRcdFx0XHRzcGhlcmljYWxEZWx0YS5waGkgKj0gKCAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvciApO1xuXG5cdFx0XHRcdFx0cGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvciApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzcGhlcmljYWxEZWx0YS5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0XHRcdHBhbk9mZnNldC5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYWRqdXN0IGNhbWVyYSBwb3NpdGlvblxuXHRcdFx0XHRsZXQgem9vbUNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCBzY29wZS56b29tVG9DdXJzb3IgJiYgcGVyZm9ybUN1cnNvclpvb20gKSB7XG5cblx0XHRcdFx0XHRsZXQgbmV3UmFkaXVzID0gbnVsbDtcblx0XHRcdFx0XHRpZiAoIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0XHQvLyBtb3ZlIHRoZSBjYW1lcmEgZG93biB0aGUgcG9pbnRlciByYXlcblx0XHRcdFx0XHRcdC8vIHRoaXMgbWV0aG9kIGF2b2lkcyBmbG9hdGluZyBwb2ludCBlcnJvclxuXHRcdFx0XHRcdFx0Y29uc3QgcHJldlJhZGl1cyA9IG9mZnNldC5sZW5ndGgoKTtcblx0XHRcdFx0XHRcdG5ld1JhZGl1cyA9IGNsYW1wRGlzdGFuY2UoIHByZXZSYWRpdXMgKiBzY2FsZSApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCByYWRpdXNEZWx0YSA9IHByZXZSYWRpdXMgLSBuZXdSYWRpdXM7XG5cdFx0XHRcdFx0XHRzY29wZS5vYmplY3QucG9zaXRpb24uYWRkU2NhbGVkVmVjdG9yKCBkb2xseURpcmVjdGlvbiwgcmFkaXVzRGVsdGEgKTtcblx0XHRcdFx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0XHQvLyBhZGp1c3QgdGhlIG9ydGhvIGNhbWVyYSBwb3NpdGlvbiBiYXNlZCBvbiB6b29tIGNoYW5nZXNcblx0XHRcdFx0XHRcdGNvbnN0IG1vdXNlQmVmb3JlID0gbmV3IFZlY3RvcjMoIG1vdXNlLngsIG1vdXNlLnksIDAgKTtcblx0XHRcdFx0XHRcdG1vdXNlQmVmb3JlLnVucHJvamVjdCggc2NvcGUub2JqZWN0ICk7XG5cblx0XHRcdFx0XHRcdHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoIHNjb3BlLm1pblpvb20sIE1hdGgubWluKCBzY29wZS5tYXhab29tLCBzY29wZS5vYmplY3Quem9vbSAvIHNjYWxlICkgKTtcblx0XHRcdFx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cdFx0XHRcdFx0XHR6b29tQ2hhbmdlZCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGNvbnN0IG1vdXNlQWZ0ZXIgPSBuZXcgVmVjdG9yMyggbW91c2UueCwgbW91c2UueSwgMCApO1xuXHRcdFx0XHRcdFx0bW91c2VBZnRlci51bnByb2plY3QoIHNjb3BlLm9iamVjdCApO1xuXG5cdFx0XHRcdFx0XHRzY29wZS5vYmplY3QucG9zaXRpb24uc3ViKCBtb3VzZUFmdGVyICkuYWRkKCBtb3VzZUJlZm9yZSApO1xuXHRcdFx0XHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRcdFx0XHRcdG5ld1JhZGl1cyA9IG9mZnNldC5sZW5ndGgoKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHpvb20gdG8gY3Vyc29yIGRpc2FibGVkLicgKTtcblx0XHRcdFx0XHRcdHNjb3BlLnpvb21Ub0N1cnNvciA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHRhcmdldFxuXHRcdFx0XHRcdGlmICggbmV3UmFkaXVzICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuc2NyZWVuU3BhY2VQYW5uaW5nICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHBvc2l0aW9uIHRoZSBvcmJpdCB0YXJnZXQgaW4gZnJvbnQgb2YgdGhlIG5ldyBjYW1lcmEgcG9zaXRpb25cblx0XHRcdFx0XHRcdFx0c2NvcGUudGFyZ2V0LnNldCggMCwgMCwgLSAxIClcblx0XHRcdFx0XHRcdFx0XHQudHJhbnNmb3JtRGlyZWN0aW9uKCBzY29wZS5vYmplY3QubWF0cml4IClcblx0XHRcdFx0XHRcdFx0XHQubXVsdGlwbHlTY2FsYXIoIG5ld1JhZGl1cyApXG5cdFx0XHRcdFx0XHRcdFx0LmFkZCggc2NvcGUub2JqZWN0LnBvc2l0aW9uICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gZ2V0IHRoZSByYXkgYW5kIHRyYW5zbGF0aW9uIHBsYW5lIHRvIGNvbXB1dGUgdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdF9yYXkub3JpZ2luLmNvcHkoIHNjb3BlLm9iamVjdC5wb3NpdGlvbiApO1xuXHRcdFx0XHRcdFx0XHRfcmF5LmRpcmVjdGlvbi5zZXQoIDAsIDAsIC0gMSApLnRyYW5zZm9ybURpcmVjdGlvbiggc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjYW1lcmEgaXMgMjAgZGVncmVlcyBhYm92ZSB0aGUgaG9yaXpvbiB0aGVuIGRvbid0IGFkanVzdCB0aGUgZm9jdXMgdGFyZ2V0IHRvIGF2b2lkXG5cdFx0XHRcdFx0XHRcdC8vIGV4dHJlbWVseSBsYXJnZSB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggc2NvcGUub2JqZWN0LnVwLmRvdCggX3JheS5kaXJlY3Rpb24gKSApIDwgVElMVF9MSU1JVCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdC5sb29rQXQoIHNjb3BlLnRhcmdldCApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRfcGxhbmUuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIHNjb3BlLm9iamVjdC51cCwgc2NvcGUudGFyZ2V0ICk7XG5cdFx0XHRcdFx0XHRcdFx0X3JheS5pbnRlcnNlY3RQbGFuZSggX3BsYW5lLCBzY29wZS50YXJnZXQgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHR6b29tQ2hhbmdlZCA9IHNjYWxlICE9PSAxO1xuXG5cdFx0XHRcdFx0aWYgKCB6b29tQ2hhbmdlZCApIHtcblxuXHRcdFx0XHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heCggc2NvcGUubWluWm9vbSwgTWF0aC5taW4oIHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tIC8gc2NhbGUgKSApO1xuXHRcdFx0XHRcdFx0c2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NhbGUgPSAxO1xuXHRcdFx0XHRwZXJmb3JtQ3Vyc29yWm9vbSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIHVwZGF0ZSBjb25kaXRpb24gaXM6XG5cdFx0XHRcdC8vIG1pbihjYW1lcmEgZGlzcGxhY2VtZW50LCBjYW1lcmEgcm90YXRpb24gaW4gcmFkaWFucyleMiA+IEVQU1xuXHRcdFx0XHQvLyB1c2luZyBzbWFsbC1hbmdsZSBhcHByb3hpbWF0aW9uIGNvcyh4LzIpID0gMSAtIHheMiAvIDhcblxuXHRcdFx0XHRpZiAoIHpvb21DaGFuZ2VkIHx8XG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKCBzY29wZS5vYmplY3QucG9zaXRpb24gKSA+IEVQUyB8fFxuXHRcdFx0XHRcdDggKiAoIDEgLSBsYXN0UXVhdGVybmlvbi5kb3QoIHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uICkgKSA+IEVQUyB8fFxuXHRcdFx0XHRcdGxhc3RUYXJnZXRQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggc2NvcGUudGFyZ2V0ICkgPiAwICkge1xuXG5cdFx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX2NoYW5nZUV2ZW50ICk7XG5cblx0XHRcdFx0XHRsYXN0UG9zaXRpb24uY29weSggc2NvcGUub2JqZWN0LnBvc2l0aW9uICk7XG5cdFx0XHRcdFx0bGFzdFF1YXRlcm5pb24uY29weSggc2NvcGUub2JqZWN0LnF1YXRlcm5pb24gKTtcblx0XHRcdFx0XHRsYXN0VGFyZ2V0UG9zaXRpb24uY29weSggc2NvcGUudGFyZ2V0ICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpO1xuXG5cdFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUgKTtcblxuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duICk7XG5cdFx0XHRzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVyY2FuY2VsJywgb25Qb2ludGVyVXAgKTtcblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgb25Nb3VzZVdoZWVsICk7XG5cblx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSApO1xuXHRcdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcnVwJywgb25Qb2ludGVyVXAgKTtcblxuXG5cdFx0XHRpZiAoIHNjb3BlLl9kb21FbGVtZW50S2V5RXZlbnRzICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHNjb3BlLl9kb21FbGVtZW50S2V5RXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgb25LZXlEb3duICk7XG5cdFx0XHRcdHNjb3BlLl9kb21FbGVtZW50S2V5RXZlbnRzID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL3Njb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTsgLy8gc2hvdWxkIHRoaXMgYmUgYWRkZWQgaGVyZT9cblxuXHRcdH07XG5cblx0XHQvL1xuXHRcdC8vIGludGVybmFsc1xuXHRcdC8vXG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRjb25zdCBTVEFURSA9IHtcblx0XHRcdE5PTkU6IC0gMSxcblx0XHRcdFJPVEFURTogMCxcblx0XHRcdERPTExZOiAxLFxuXHRcdFx0UEFOOiAyLFxuXHRcdFx0VE9VQ0hfUk9UQVRFOiAzLFxuXHRcdFx0VE9VQ0hfUEFOOiA0LFxuXHRcdFx0VE9VQ0hfRE9MTFlfUEFOOiA1LFxuXHRcdFx0VE9VQ0hfRE9MTFlfUk9UQVRFOiA2XG5cdFx0fTtcblxuXHRcdGxldCBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRjb25zdCBFUFMgPSAwLjAwMDAwMTtcblxuXHRcdC8vIGN1cnJlbnQgcG9zaXRpb24gaW4gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG5cdFx0Y29uc3Qgc3BoZXJpY2FsID0gbmV3IFNwaGVyaWNhbCgpO1xuXHRcdGNvbnN0IHNwaGVyaWNhbERlbHRhID0gbmV3IFNwaGVyaWNhbCgpO1xuXG5cdFx0bGV0IHNjYWxlID0gMTtcblx0XHRjb25zdCBwYW5PZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Y29uc3Qgcm90YXRlU3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IHJvdGF0ZUVuZCA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0Y29uc3Qgcm90YXRlRGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Y29uc3QgcGFuU3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IHBhbkVuZCA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0Y29uc3QgcGFuRGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Y29uc3QgZG9sbHlTdGFydCA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0Y29uc3QgZG9sbHlFbmQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGNvbnN0IGRvbGx5RGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0Y29uc3QgZG9sbHlEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG1vdXNlID0gbmV3IFZlY3RvcjIoKTtcblx0XHRsZXQgcGVyZm9ybUN1cnNvclpvb20gPSBmYWxzZTtcblxuXHRcdGNvbnN0IHBvaW50ZXJzID0gW107XG5cdFx0Y29uc3QgcG9pbnRlclBvc2l0aW9ucyA9IHt9O1xuXG5cdFx0bGV0IGNvbnRyb2xBY3RpdmUgPSBmYWxzZTtcblxuXHRcdGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCBkZWx0YVRpbWUgKSB7XG5cblx0XHRcdGlmICggZGVsdGFUaW1lICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHJldHVybiAoIDIgKiBNYXRoLlBJIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQgKSAqIGRlbHRhVGltZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gMiAqIE1hdGguUEkgLyA2MCAvIDYwICogc2NvcGUuYXV0b1JvdGF0ZVNwZWVkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRab29tU2NhbGUoIGRlbHRhICkge1xuXG5cdFx0XHRjb25zdCBub3JtYWxpemVkRGVsdGEgPSBNYXRoLmFicyggZGVsdGEgKiAwLjAxICk7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIDAuOTUsIHNjb3BlLnpvb21TcGVlZCAqIG5vcm1hbGl6ZWREZWx0YSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcm90YXRlTGVmdCggYW5nbGUgKSB7XG5cblx0XHRcdHNwaGVyaWNhbERlbHRhLnRoZXRhIC09IGFuZ2xlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcm90YXRlVXAoIGFuZ2xlICkge1xuXG5cdFx0XHRzcGhlcmljYWxEZWx0YS5waGkgLT0gYW5nbGU7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYW5MZWZ0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zdCB2ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHBhbkxlZnQoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XG5cblx0XHRcdFx0di5zZXRGcm9tTWF0cml4Q29sdW1uKCBvYmplY3RNYXRyaXgsIDAgKTsgLy8gZ2V0IFggY29sdW1uIG9mIG9iamVjdE1hdHJpeFxuXHRcdFx0XHR2Lm11bHRpcGx5U2NhbGFyKCAtIGRpc3RhbmNlICk7XG5cblx0XHRcdFx0cGFuT2Zmc2V0LmFkZCggdiApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpO1xuXG5cdFx0Y29uc3QgcGFuVXAgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnN0IHYgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuVXAoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5zY3JlZW5TcGFjZVBhbm5pbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMCApO1xuXHRcdFx0XHRcdHYuY3Jvc3NWZWN0b3JzKCBzY29wZS5vYmplY3QudXAsIHYgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0di5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKTtcblxuXHRcdFx0XHRwYW5PZmZzZXQuYWRkKCB2ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCk7XG5cblx0XHQvLyBkZWx0YVggYW5kIGRlbHRhWSBhcmUgaW4gcGl4ZWxzOyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcblx0XHRjb25zdCBwYW4gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBwYW4oIGRlbHRhWCwgZGVsdGFZICkge1xuXG5cdFx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50O1xuXG5cdFx0XHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgKSB7XG5cblx0XHRcdFx0XHQvLyBwZXJzcGVjdGl2ZVxuXHRcdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuXHRcdFx0XHRcdG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG5cdFx0XHRcdFx0bGV0IHRhcmdldERpc3RhbmNlID0gb2Zmc2V0Lmxlbmd0aCgpO1xuXG5cdFx0XHRcdFx0Ly8gaGFsZiBvZiB0aGUgZm92IGlzIGNlbnRlciB0byB0b3Agb2Ygc2NyZWVuXG5cdFx0XHRcdFx0dGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oICggc2NvcGUub2JqZWN0LmZvdiAvIDIgKSAqIE1hdGguUEkgLyAxODAuMCApO1xuXG5cdFx0XHRcdFx0Ly8gd2UgdXNlIG9ubHkgY2xpZW50SGVpZ2h0IGhlcmUgc28gYXNwZWN0IHJhdGlvIGRvZXMgbm90IGRpc3RvcnQgc3BlZWRcblx0XHRcdFx0XHRwYW5MZWZ0KCAyICogZGVsdGFYICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXHRcdFx0XHRcdHBhblVwKCAyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRcdC8vIG9ydGhvZ3JhcGhpY1xuXHRcdFx0XHRcdHBhbkxlZnQoIGRlbHRhWCAqICggc2NvcGUub2JqZWN0LnJpZ2h0IC0gc2NvcGUub2JqZWN0LmxlZnQgKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRXaWR0aCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xuXHRcdFx0XHRcdHBhblVwKCBkZWx0YVkgKiAoIHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tICkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGNhbWVyYSBuZWl0aGVyIG9ydGhvZ3JhcGhpYyBub3IgcGVyc3BlY3RpdmVcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRcdHNjb3BlLmVuYWJsZVBhbiA9IGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH0oKTtcblxuXHRcdGZ1bmN0aW9uIGRvbGx5T3V0KCBkb2xseVNjYWxlICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhIHx8IHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSApIHtcblxuXHRcdFx0XHRzY2FsZSAvPSBkb2xseVNjYWxlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1dBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyApO1xuXHRcdFx0XHRzY29wZS5lbmFibGVab29tID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRvbGx5SW4oIGRvbGx5U2NhbGUgKSB7XG5cblx0XHRcdGlmICggc2NvcGUub2JqZWN0LmlzUGVyc3BlY3RpdmVDYW1lcmEgfHwgc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdHNjYWxlICo9IGRvbGx5U2NhbGU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC4nICk7XG5cdFx0XHRcdHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlWm9vbVBhcmFtZXRlcnMoIHgsIHkgKSB7XG5cblx0XHRcdGlmICggISBzY29wZS56b29tVG9DdXJzb3IgKSB7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBlcmZvcm1DdXJzb3Jab29tID0gdHJ1ZTtcblxuXHRcdFx0Y29uc3QgcmVjdCA9IHNjb3BlLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRjb25zdCBkeCA9IHggLSByZWN0LmxlZnQ7XG5cdFx0XHRjb25zdCBkeSA9IHkgLSByZWN0LnRvcDtcblx0XHRcdGNvbnN0IHcgPSByZWN0LndpZHRoO1xuXHRcdFx0Y29uc3QgaCA9IHJlY3QuaGVpZ2h0O1xuXG5cdFx0XHRtb3VzZS54ID0gKCBkeCAvIHcgKSAqIDIgLSAxO1xuXHRcdFx0bW91c2UueSA9IC0gKCBkeSAvIGggKSAqIDIgKyAxO1xuXG5cdFx0XHRkb2xseURpcmVjdGlvbi5zZXQoIG1vdXNlLngsIG1vdXNlLnksIDEgKS51bnByb2plY3QoIHNjb3BlLm9iamVjdCApLnN1Yiggc2NvcGUub2JqZWN0LnBvc2l0aW9uICkubm9ybWFsaXplKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjbGFtcERpc3RhbmNlKCBkaXN0ICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoIHNjb3BlLm1pbkRpc3RhbmNlLCBNYXRoLm1pbiggc2NvcGUubWF4RGlzdGFuY2UsIGRpc3QgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblx0XHQvLyBldmVudCBjYWxsYmFja3MgLSB1cGRhdGUgdGhlIG9iamVjdCBzdGF0ZVxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Sb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0XHRyb3RhdGVTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bkRvbGx5KCBldmVudCApIHtcblxuXHRcdFx0dXBkYXRlWm9vbVBhcmFtZXRlcnMoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFggKTtcblx0XHRcdGRvbGx5U3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICkge1xuXG5cdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSggZXZlbnQgKSB7XG5cblx0XHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuXHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApLm11bHRpcGx5U2NhbGFyKCBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0XHRjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTsgLy8geWVzLCBoZWlnaHRcblxuXHRcdFx0cm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdFx0ZG9sbHlFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHRcdGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcblxuXHRcdFx0aWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoIGRvbGx5RGVsdGEueSApICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGRvbGx5RGVsdGEueSA8IDAgKSB7XG5cblx0XHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCBkb2xseURlbHRhLnkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVQYW4oIGV2ZW50ICkge1xuXG5cdFx0XHRwYW5FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKS5tdWx0aXBseVNjYWxhciggc2NvcGUucGFuU3BlZWQgKTtcblxuXHRcdFx0cGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cblx0XHRcdHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG5cdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZU1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG5cdFx0XHR1cGRhdGVab29tUGFyYW1ldGVycyggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0XHRpZiAoIGV2ZW50LmRlbHRhWSA8IDAgKSB7XG5cblx0XHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCBldmVudC5kZWx0YVkgKSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBldmVudC5kZWx0YVkgPiAwICkge1xuXG5cdFx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoIGV2ZW50LmRlbHRhWSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVLZXlEb3duKCBldmVudCApIHtcblxuXHRcdFx0bGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdHN3aXRjaCAoIGV2ZW50LmNvZGUgKSB7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLlVQOlxuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgKSB7XG5cblx0XHRcdFx0XHRcdHJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHNjb3BlLnJvdGF0ZVNwZWVkIC8gc2NvcGUuZG9tRWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgKSB7XG5cblx0XHRcdFx0XHRcdHJvdGF0ZVVwKCAtIDIgKiBNYXRoLlBJICogc2NvcGUucm90YXRlU3BlZWQgLyBzY29wZS5kb21FbGVtZW50LmNsaWVudEhlaWdodCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0cGFuKCAwLCAtIHNjb3BlLmtleVBhblNwZWVkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLkxFRlQ6XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSApIHtcblxuXHRcdFx0XHRcdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiBzY29wZS5yb3RhdGVTcGVlZCAvIHNjb3BlLmRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwYW4oIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBzY29wZS5rZXlzLlJJR0hUOlxuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgKSB7XG5cblx0XHRcdFx0XHRcdHJvdGF0ZUxlZnQoIC0gMiAqIE1hdGguUEkgKiBzY29wZS5yb3RhdGVTcGVlZCAvIHNjb3BlLmRvbUVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwYW4oIC0gc2NvcGUua2V5UGFuU3BlZWQsIDAgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdC8vIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBzY3JvbGxpbmcgb24gY3Vyc29yIGtleXNcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRzY29wZS51cGRhdGUoKTtcblxuXHRcdFx0fVxuXG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBwb2ludGVycy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC5wYWdlWCwgZXZlbnQucGFnZVkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbiggZXZlbnQgKTtcblxuXHRcdFx0XHRjb25zdCB4ID0gMC41ICogKCBldmVudC5wYWdlWCArIHBvc2l0aW9uLnggKTtcblx0XHRcdFx0Y29uc3QgeSA9IDAuNSAqICggZXZlbnQucGFnZVkgKyBwb3NpdGlvbi55ICk7XG5cblx0XHRcdFx0cm90YXRlU3RhcnQuc2V0KCB4LCB5ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnRQYW4oIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHBvaW50ZXJzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRwYW5TdGFydC5zZXQoIGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKCBldmVudCApO1xuXG5cdFx0XHRcdGNvbnN0IHggPSAwLjUgKiAoIGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueCApO1xuXHRcdFx0XHRjb25zdCB5ID0gMC41ICogKCBldmVudC5wYWdlWSArIHBvc2l0aW9uLnkgKTtcblxuXHRcdFx0XHRwYW5TdGFydC5zZXQoIHgsIHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5KCBldmVudCApIHtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oIGV2ZW50ICk7XG5cblx0XHRcdGNvbnN0IGR4ID0gZXZlbnQucGFnZVggLSBwb3NpdGlvbi54O1xuXHRcdFx0Y29uc3QgZHkgPSBldmVudC5wYWdlWSAtIHBvc2l0aW9uLnk7XG5cblx0XHRcdGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG5cdFx0XHRkb2xseVN0YXJ0LnNldCggMCwgZGlzdGFuY2UgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseVBhbiggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSApIGhhbmRsZVRvdWNoU3RhcnREb2xseSggZXZlbnQgKTtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gKSBoYW5kbGVUb3VjaFN0YXJ0UGFuKCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5Um90YXRlKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tICkgaGFuZGxlVG91Y2hTdGFydERvbGx5KCBldmVudCApO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSApIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHBvaW50ZXJzLmxlbmd0aCA9PSAxICkge1xuXG5cdFx0XHRcdHJvdGF0ZUVuZC5zZXQoIGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKCBldmVudCApO1xuXG5cdFx0XHRcdGNvbnN0IHggPSAwLjUgKiAoIGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueCApO1xuXHRcdFx0XHRjb25zdCB5ID0gMC41ICogKCBldmVudC5wYWdlWSArIHBvc2l0aW9uLnkgKTtcblxuXHRcdFx0XHRyb3RhdGVFbmQuc2V0KCB4LCB5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApLm11bHRpcGx5U2NhbGFyKCBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG5cdFx0XHRjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcblxuXHRcdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTsgLy8geWVzLCBoZWlnaHRcblxuXHRcdFx0cm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlUGFuKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBwb2ludGVycy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0cGFuRW5kLnNldCggZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oIGV2ZW50ICk7XG5cblx0XHRcdFx0Y29uc3QgeCA9IDAuNSAqICggZXZlbnQucGFnZVggKyBwb3NpdGlvbi54ICk7XG5cdFx0XHRcdGNvbnN0IHkgPSAwLjUgKiAoIGV2ZW50LnBhZ2VZICsgcG9zaXRpb24ueSApO1xuXG5cdFx0XHRcdHBhbkVuZC5zZXQoIHgsIHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICkubXVsdGlwbHlTY2FsYXIoIHNjb3BlLnBhblNwZWVkICk7XG5cblx0XHRcdHBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG5cdFx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApIHtcblxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oIGV2ZW50ICk7XG5cblx0XHRcdGNvbnN0IGR4ID0gZXZlbnQucGFnZVggLSBwb3NpdGlvbi54O1xuXHRcdFx0Y29uc3QgZHkgPSBldmVudC5wYWdlWSAtIHBvc2l0aW9uLnk7XG5cblx0XHRcdGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG5cdFx0XHRkb2xseUVuZC5zZXQoIDAsIGRpc3RhbmNlICk7XG5cblx0XHRcdGRvbGx5RGVsdGEuc2V0KCAwLCBNYXRoLnBvdyggZG9sbHlFbmQueSAvIGRvbGx5U3RhcnQueSwgc2NvcGUuem9vbVNwZWVkICkgKTtcblxuXHRcdFx0ZG9sbHlPdXQoIGRvbGx5RGVsdGEueSApO1xuXG5cdFx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cblx0XHRcdGNvbnN0IGNlbnRlclggPSAoIGV2ZW50LnBhZ2VYICsgcG9zaXRpb24ueCApICogMC41O1xuXHRcdFx0Y29uc3QgY2VudGVyWSA9ICggZXZlbnQucGFnZVkgKyBwb3NpdGlvbi55ICkgKiAwLjU7XG5cblx0XHRcdHVwZGF0ZVpvb21QYXJhbWV0ZXJzKCBjZW50ZXJYLCBjZW50ZXJZICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseVBhbiggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSApIGhhbmRsZVRvdWNoTW92ZURvbGx5KCBldmVudCApO1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiApIGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZURvbGx5Um90YXRlKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tICkgaGFuZGxlVG91Y2hNb3ZlRG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlICkgaGFuZGxlVG91Y2hNb3ZlUm90YXRlKCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblx0XHQvLyBldmVudCBoYW5kbGVycyAtIEZTTTogbGlzdGVuIGZvciBldmVudHMgYW5kIHJlc2V0IHN0YXRlXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oIGV2ZW50ICkge1xuXG5cdFx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIHBvaW50ZXJzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRzY29wZS5kb21FbGVtZW50LnNldFBvaW50ZXJDYXB0dXJlKCBldmVudC5wb2ludGVySWQgKTtcblxuXHRcdFx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUgKTtcblx0XHRcdFx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcnVwJywgb25Qb2ludGVyVXAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRhZGRQb2ludGVyKCBldmVudCApO1xuXG5cdFx0XHRpZiAoIGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnICkge1xuXG5cdFx0XHRcdG9uVG91Y2hTdGFydCggZXZlbnQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvbk1vdXNlRG93biggZXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Qb2ludGVyTW92ZSggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGlmICggZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgKSB7XG5cblx0XHRcdFx0b25Ub3VjaE1vdmUoIGV2ZW50ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0b25Nb3VzZU1vdmUoIGV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uUG9pbnRlclVwKCBldmVudCApIHtcblxuXHRcdFx0cmVtb3ZlUG9pbnRlciggZXZlbnQgKTtcblxuXHRcdFx0c3dpdGNoICggcG9pbnRlcnMubGVuZ3RoICkge1xuXG5cdFx0XHRcdGNhc2UgMDpcblxuXHRcdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKCBldmVudC5wb2ludGVySWQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSApO1xuXHRcdFx0XHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwICk7XG5cblx0XHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfZW5kRXZlbnQgKTtcblxuXHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgMTpcblxuXHRcdFx0XHRcdGNvbnN0IHBvaW50ZXJJZCA9IHBvaW50ZXJzWyAwIF07XG5cdFx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBwb2ludGVyUG9zaXRpb25zWyBwb2ludGVySWQgXTtcblxuXHRcdFx0XHRcdC8vIG1pbmltYWwgcGxhY2Vob2xkZXIgZXZlbnQgLSBhbGxvd3Mgc3RhdGUgY29ycmVjdGlvbiBvbiBwb2ludGVyLXVwXG5cdFx0XHRcdFx0b25Ub3VjaFN0YXJ0KCB7IHBvaW50ZXJJZDogcG9pbnRlcklkLCBwYWdlWDogcG9zaXRpb24ueCwgcGFnZVk6IHBvc2l0aW9uLnkgfSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VEb3duKCBldmVudCApIHtcblxuXHRcdFx0bGV0IG1vdXNlQWN0aW9uO1xuXG5cdFx0XHRzd2l0Y2ggKCBldmVudC5idXR0b24gKSB7XG5cblx0XHRcdFx0Y2FzZSAwOlxuXG5cdFx0XHRcdFx0bW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuTEVGVDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDE6XG5cblx0XHRcdFx0XHRtb3VzZUFjdGlvbiA9IHNjb3BlLm1vdXNlQnV0dG9ucy5NSURETEU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAyOlxuXG5cdFx0XHRcdFx0bW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuUklHSFQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdG1vdXNlQWN0aW9uID0gLSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAoIG1vdXNlQWN0aW9uICkge1xuXG5cdFx0XHRcdGNhc2UgTU9VU0UuRE9MTFk6XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0aGFuZGxlTW91c2VEb3duRG9sbHkoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLkRPTExZO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNT1VTRS5ST1RBVEU6XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuUEFOO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRoYW5kbGVNb3VzZURvd25Sb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNT1VTRS5QQU46XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRoYW5kbGVNb3VzZURvd25Sb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRoYW5kbGVNb3VzZURvd25QYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuUEFOO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5OT05FICkge1xuXG5cdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIF9zdGFydEV2ZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCBldmVudCApIHtcblxuXHRcdFx0c3dpdGNoICggc3RhdGUgKSB7XG5cblx0XHRcdFx0Y2FzZSBTVEFURS5ST1RBVEU6XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVNb3VzZU1vdmVSb3RhdGUoIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFNUQVRFLkRPTExZOlxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBTVEFURS5QQU46XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVNb3VzZU1vdmVQYW4oIGV2ZW50ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZVdoZWVsKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSB8fCBzdGF0ZSAhPT0gU1RBVEUuTk9ORSApIHJldHVybjtcblxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX3N0YXJ0RXZlbnQgKTtcblxuXHRcdFx0aGFuZGxlTW91c2VXaGVlbCggY3VzdG9tV2hlZWxFdmVudCggZXZlbnQgKSApO1xuXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfZW5kRXZlbnQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGN1c3RvbVdoZWVsRXZlbnQoIGV2ZW50ICkge1xuXG5cdFx0XHRjb25zdCBtb2RlID0gZXZlbnQuZGVsdGFNb2RlO1xuXG5cdFx0XHQvLyBtaW5pbWFsIHdoZWVsIGV2ZW50IGFsdGVyZWQgdG8gbWVldCBkZWx0YS16b29tIGRlbWFuZFxuXHRcdFx0Y29uc3QgbmV3RXZlbnQgPSB7XG5cdFx0XHRcdGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG5cdFx0XHRcdGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG5cdFx0XHRcdGRlbHRhWTogZXZlbnQuZGVsdGFZLFxuXHRcdFx0fTtcblxuXHRcdFx0c3dpdGNoICggbW9kZSApIHtcblxuXHRcdFx0XHRjYXNlIDE6IC8vIExJTkVfTU9ERVxuXHRcdFx0XHRcdG5ld0V2ZW50LmRlbHRhWSAqPSAxNjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDI6IC8vIFBBR0VfTU9ERVxuXHRcdFx0XHRcdG5ld0V2ZW50LmRlbHRhWSAqPSAxMDA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZGV0ZWN0IGlmIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgcGluY2hpbmdcblx0XHRcdGlmICggZXZlbnQuY3RybEtleSAmJiAhIGNvbnRyb2xBY3RpdmUgKSB7XG5cblx0XHRcdFx0bmV3RXZlbnQuZGVsdGFZICo9IDEwO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXdFdmVudDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGludGVyY2VwdENvbnRyb2xEb3duKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBldmVudC5rZXkgPT09ICdDb250cm9sJyApIHtcblxuXHRcdFx0XHRjb250cm9sQWN0aXZlID0gdHJ1ZTtcblxuXG5cdFx0XHRcdGNvbnN0IGRvY3VtZW50ID0gc2NvcGUuZG9tRWxlbWVudC5nZXRSb290Tm9kZSgpOyAvLyBvZmZzY3JlZW4gY2FudmFzIGNvbXBhdGliaWxpdHlcblxuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCBpbnRlcmNlcHRDb250cm9sVXAsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGludGVyY2VwdENvbnRyb2xVcCggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggZXZlbnQua2V5ID09PSAnQ29udHJvbCcgKSB7XG5cblx0XHRcdFx0Y29udHJvbEFjdGl2ZSA9IGZhbHNlO1xuXG5cblx0XHRcdFx0Y29uc3QgZG9jdW1lbnQgPSBzY29wZS5kb21FbGVtZW50LmdldFJvb3ROb2RlKCk7IC8vIG9mZnNjcmVlbiBjYW52YXMgY29tcGF0aWJpbGl0eVxuXG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGludGVyY2VwdENvbnRyb2xVcCwgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25LZXlEb3duKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRoYW5kbGVLZXlEb3duKCBldmVudCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KCBldmVudCApIHtcblxuXHRcdFx0dHJhY2tQb2ludGVyKCBldmVudCApO1xuXG5cdFx0XHRzd2l0Y2ggKCBwb2ludGVycy5sZW5ndGggKSB7XG5cblx0XHRcdFx0Y2FzZSAxOlxuXG5cdFx0XHRcdFx0c3dpdGNoICggc2NvcGUudG91Y2hlcy5PTkUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgVE9VQ0guUk9UQVRFOlxuXG5cdFx0XHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfUk9UQVRFO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIFRPVUNILlBBTjpcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydFBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIDI6XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBzY29wZS50b3VjaGVzLlRXTyApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSBUT1VDSC5ET0xMWV9QQU46XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnREb2xseVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZX1BBTjtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBUT1VDSC5ET0xMWV9ST1RBVEU6XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdGhhbmRsZVRvdWNoU3RhcnREb2xseVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZX1JPVEFURTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLk5PTkUgKSB7XG5cblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggX3N0YXJ0RXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaE1vdmUoIGV2ZW50ICkge1xuXG5cdFx0XHR0cmFja1BvaW50ZXIoIGV2ZW50ICk7XG5cblx0XHRcdHN3aXRjaCAoIHN0YXRlICkge1xuXG5cdFx0XHRcdGNhc2UgU1RBVEUuVE9VQ0hfUk9UQVRFOlxuXG5cdFx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0aGFuZGxlVG91Y2hNb3ZlUm90YXRlKCBldmVudCApO1xuXG5cdFx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFNUQVRFLlRPVUNIX1BBTjpcblxuXHRcdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHRcdGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBTVEFURS5UT1VDSF9ET0xMWV9QQU46XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseVBhbiggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBTVEFURS5UT1VDSF9ET0xMWV9ST1RBVEU6XG5cblx0XHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZSggZXZlbnQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0TWVudSggZXZlbnQgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRQb2ludGVyKCBldmVudCApIHtcblxuXHRcdFx0cG9pbnRlcnMucHVzaCggZXZlbnQucG9pbnRlcklkICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVQb2ludGVyKCBldmVudCApIHtcblxuXHRcdFx0ZGVsZXRlIHBvaW50ZXJQb3NpdGlvbnNbIGV2ZW50LnBvaW50ZXJJZCBdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBwb2ludGVyc1sgaSBdID09IGV2ZW50LnBvaW50ZXJJZCApIHtcblxuXHRcdFx0XHRcdHBvaW50ZXJzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyYWNrUG9pbnRlciggZXZlbnQgKSB7XG5cblx0XHRcdGxldCBwb3NpdGlvbiA9IHBvaW50ZXJQb3NpdGlvbnNbIGV2ZW50LnBvaW50ZXJJZCBdO1xuXG5cdFx0XHRpZiAoIHBvc2l0aW9uID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cG9zaXRpb24gPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0XHRwb2ludGVyUG9zaXRpb25zWyBldmVudC5wb2ludGVySWQgXSA9IHBvc2l0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBvc2l0aW9uLnNldCggZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRTZWNvbmRQb2ludGVyUG9zaXRpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRjb25zdCBwb2ludGVySWQgPSAoIGV2ZW50LnBvaW50ZXJJZCA9PT0gcG9pbnRlcnNbIDAgXSApID8gcG9pbnRlcnNbIDEgXSA6IHBvaW50ZXJzWyAwIF07XG5cblx0XHRcdHJldHVybiBwb2ludGVyUG9zaXRpb25zWyBwb2ludGVySWQgXTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUgKTtcblxuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93biApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJjYW5jZWwnLCBvblBvaW50ZXJVcCApO1xuXHRcdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3doZWVsJywgb25Nb3VzZVdoZWVsLCB7IHBhc3NpdmU6IGZhbHNlIH0gKTtcblxuXHRcdGNvbnN0IGRvY3VtZW50ID0gc2NvcGUuZG9tRWxlbWVudC5nZXRSb290Tm9kZSgpOyAvLyBvZmZzY3JlZW4gY2FudmFzIGNvbXBhdGliaWxpdHlcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgaW50ZXJjZXB0Q29udHJvbERvd24sIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9ICk7XG5cblx0XHQvLyBmb3JjZSBhbiB1cGRhdGUgYXQgc3RhcnRcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IE9yYml0Q29udHJvbHMgfTtcbiJdLCJuYW1lcyI6WyJFdmVudERpc3BhdGNoZXIiLCJNT1VTRSIsIlF1YXRlcm5pb24iLCJTcGhlcmljYWwiLCJUT1VDSCIsIlZlY3RvcjIiLCJWZWN0b3IzIiwiUGxhbmUiLCJSYXkiLCJNYXRoVXRpbHMiLCJfY2hhbmdlRXZlbnQiLCJ0eXBlIiwiX3N0YXJ0RXZlbnQiLCJfZW5kRXZlbnQiLCJfcmF5IiwiX3BsYW5lIiwiVElMVF9MSU1JVCIsIk1hdGgiLCJjb3MiLCJERUcyUkFEIiwiT3JiaXRDb250cm9scyIsImNvbnN0cnVjdG9yIiwib2JqZWN0IiwiZG9tRWxlbWVudCIsInN0eWxlIiwidG91Y2hBY3Rpb24iLCJlbmFibGVkIiwidGFyZ2V0IiwiY3Vyc29yIiwibWluRGlzdGFuY2UiLCJtYXhEaXN0YW5jZSIsIkluZmluaXR5IiwibWluWm9vbSIsIm1heFpvb20iLCJtaW5UYXJnZXRSYWRpdXMiLCJtYXhUYXJnZXRSYWRpdXMiLCJtaW5Qb2xhckFuZ2xlIiwibWF4UG9sYXJBbmdsZSIsIlBJIiwibWluQXppbXV0aEFuZ2xlIiwibWF4QXppbXV0aEFuZ2xlIiwiZW5hYmxlRGFtcGluZyIsImRhbXBpbmdGYWN0b3IiLCJlbmFibGVab29tIiwiem9vbVNwZWVkIiwiZW5hYmxlUm90YXRlIiwicm90YXRlU3BlZWQiLCJlbmFibGVQYW4iLCJwYW5TcGVlZCIsInNjcmVlblNwYWNlUGFubmluZyIsImtleVBhblNwZWVkIiwiem9vbVRvQ3Vyc29yIiwiYXV0b1JvdGF0ZSIsImF1dG9Sb3RhdGVTcGVlZCIsImtleXMiLCJMRUZUIiwiVVAiLCJSSUdIVCIsIkJPVFRPTSIsIm1vdXNlQnV0dG9ucyIsIlJPVEFURSIsIk1JRERMRSIsIkRPTExZIiwiUEFOIiwidG91Y2hlcyIsIk9ORSIsIlRXTyIsIkRPTExZX1BBTiIsInRhcmdldDAiLCJjbG9uZSIsInBvc2l0aW9uMCIsInBvc2l0aW9uIiwiem9vbTAiLCJ6b29tIiwiX2RvbUVsZW1lbnRLZXlFdmVudHMiLCJnZXRQb2xhckFuZ2xlIiwic3BoZXJpY2FsIiwicGhpIiwiZ2V0QXppbXV0aGFsQW5nbGUiLCJ0aGV0YSIsImdldERpc3RhbmNlIiwiZGlzdGFuY2VUbyIsImxpc3RlblRvS2V5RXZlbnRzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uS2V5RG93biIsInN0b3BMaXN0ZW5Ub0tleUV2ZW50cyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzYXZlU3RhdGUiLCJzY29wZSIsImNvcHkiLCJyZXNldCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJkaXNwYXRjaEV2ZW50IiwidXBkYXRlIiwic3RhdGUiLCJTVEFURSIsIk5PTkUiLCJvZmZzZXQiLCJxdWF0Iiwic2V0RnJvbVVuaXRWZWN0b3JzIiwidXAiLCJxdWF0SW52ZXJzZSIsImludmVydCIsImxhc3RQb3NpdGlvbiIsImxhc3RRdWF0ZXJuaW9uIiwibGFzdFRhcmdldFBvc2l0aW9uIiwidHdvUEkiLCJkZWx0YVRpbWUiLCJzdWIiLCJhcHBseVF1YXRlcm5pb24iLCJzZXRGcm9tVmVjdG9yMyIsInJvdGF0ZUxlZnQiLCJnZXRBdXRvUm90YXRpb25BbmdsZSIsInNwaGVyaWNhbERlbHRhIiwibWluIiwibWF4IiwiaXNGaW5pdGUiLCJtYWtlU2FmZSIsImFkZFNjYWxlZFZlY3RvciIsInBhbk9mZnNldCIsImFkZCIsImNsYW1wTGVuZ3RoIiwicGVyZm9ybUN1cnNvclpvb20iLCJpc09ydGhvZ3JhcGhpY0NhbWVyYSIsInJhZGl1cyIsImNsYW1wRGlzdGFuY2UiLCJzY2FsZSIsInNldEZyb21TcGhlcmljYWwiLCJsb29rQXQiLCJtdWx0aXBseVNjYWxhciIsInNldCIsInpvb21DaGFuZ2VkIiwibmV3UmFkaXVzIiwiaXNQZXJzcGVjdGl2ZUNhbWVyYSIsInByZXZSYWRpdXMiLCJsZW5ndGgiLCJyYWRpdXNEZWx0YSIsImRvbGx5RGlyZWN0aW9uIiwidXBkYXRlTWF0cml4V29ybGQiLCJtb3VzZUJlZm9yZSIsIm1vdXNlIiwieCIsInkiLCJ1bnByb2plY3QiLCJtb3VzZUFmdGVyIiwiY29uc29sZSIsIndhcm4iLCJ0cmFuc2Zvcm1EaXJlY3Rpb24iLCJtYXRyaXgiLCJvcmlnaW4iLCJkaXJlY3Rpb24iLCJhYnMiLCJkb3QiLCJzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCIsImludGVyc2VjdFBsYW5lIiwiZGlzdGFuY2VUb1NxdWFyZWQiLCJFUFMiLCJxdWF0ZXJuaW9uIiwiZGlzcG9zZSIsIm9uQ29udGV4dE1lbnUiLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyVXAiLCJvbk1vdXNlV2hlZWwiLCJvblBvaW50ZXJNb3ZlIiwiVE9VQ0hfUk9UQVRFIiwiVE9VQ0hfUEFOIiwiVE9VQ0hfRE9MTFlfUEFOIiwiVE9VQ0hfRE9MTFlfUk9UQVRFIiwicm90YXRlU3RhcnQiLCJyb3RhdGVFbmQiLCJyb3RhdGVEZWx0YSIsInBhblN0YXJ0IiwicGFuRW5kIiwicGFuRGVsdGEiLCJkb2xseVN0YXJ0IiwiZG9sbHlFbmQiLCJkb2xseURlbHRhIiwicG9pbnRlcnMiLCJwb2ludGVyUG9zaXRpb25zIiwiY29udHJvbEFjdGl2ZSIsImdldFpvb21TY2FsZSIsImRlbHRhIiwibm9ybWFsaXplZERlbHRhIiwicG93IiwiYW5nbGUiLCJyb3RhdGVVcCIsInBhbkxlZnQiLCJ2IiwiZGlzdGFuY2UiLCJvYmplY3RNYXRyaXgiLCJzZXRGcm9tTWF0cml4Q29sdW1uIiwicGFuVXAiLCJjcm9zc1ZlY3RvcnMiLCJwYW4iLCJkZWx0YVgiLCJkZWx0YVkiLCJlbGVtZW50IiwidGFyZ2V0RGlzdGFuY2UiLCJ0YW4iLCJmb3YiLCJjbGllbnRIZWlnaHQiLCJyaWdodCIsImxlZnQiLCJjbGllbnRXaWR0aCIsInRvcCIsImJvdHRvbSIsImRvbGx5T3V0IiwiZG9sbHlTY2FsZSIsImRvbGx5SW4iLCJ1cGRhdGVab29tUGFyYW1ldGVycyIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJkeCIsImR5IiwidyIsIndpZHRoIiwiaCIsImhlaWdodCIsIm5vcm1hbGl6ZSIsImRpc3QiLCJoYW5kbGVNb3VzZURvd25Sb3RhdGUiLCJldmVudCIsImNsaWVudFgiLCJjbGllbnRZIiwiaGFuZGxlTW91c2VEb3duRG9sbHkiLCJoYW5kbGVNb3VzZURvd25QYW4iLCJoYW5kbGVNb3VzZU1vdmVSb3RhdGUiLCJzdWJWZWN0b3JzIiwiaGFuZGxlTW91c2VNb3ZlRG9sbHkiLCJoYW5kbGVNb3VzZU1vdmVQYW4iLCJoYW5kbGVNb3VzZVdoZWVsIiwiaGFuZGxlS2V5RG93biIsIm5lZWRzVXBkYXRlIiwiY29kZSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZVRvdWNoU3RhcnRSb3RhdGUiLCJwYWdlWCIsInBhZ2VZIiwiZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uIiwiaGFuZGxlVG91Y2hTdGFydFBhbiIsImhhbmRsZVRvdWNoU3RhcnREb2xseSIsInNxcnQiLCJoYW5kbGVUb3VjaFN0YXJ0RG9sbHlQYW4iLCJoYW5kbGVUb3VjaFN0YXJ0RG9sbHlSb3RhdGUiLCJoYW5kbGVUb3VjaE1vdmVSb3RhdGUiLCJoYW5kbGVUb3VjaE1vdmVQYW4iLCJoYW5kbGVUb3VjaE1vdmVEb2xseSIsImNlbnRlclgiLCJjZW50ZXJZIiwiaGFuZGxlVG91Y2hNb3ZlRG9sbHlQYW4iLCJoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZSIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwiYWRkUG9pbnRlciIsInBvaW50ZXJUeXBlIiwib25Ub3VjaFN0YXJ0Iiwib25Nb3VzZURvd24iLCJvblRvdWNoTW92ZSIsIm9uTW91c2VNb3ZlIiwicmVtb3ZlUG9pbnRlciIsInJlbGVhc2VQb2ludGVyQ2FwdHVyZSIsIm1vdXNlQWN0aW9uIiwiYnV0dG9uIiwiY3VzdG9tV2hlZWxFdmVudCIsIm1vZGUiLCJkZWx0YU1vZGUiLCJuZXdFdmVudCIsImludGVyY2VwdENvbnRyb2xEb3duIiwia2V5IiwiZG9jdW1lbnQiLCJnZXRSb290Tm9kZSIsImludGVyY2VwdENvbnRyb2xVcCIsInBhc3NpdmUiLCJjYXB0dXJlIiwidHJhY2tQb2ludGVyIiwiRE9MTFlfUk9UQVRFIiwicHVzaCIsImkiLCJzcGxpY2UiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three/examples/jsm/controls/OrbitControls.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three/examples/jsm/controls/TransformControls.js":
/*!***********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/controls/TransformControls.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransformControls: function() { return /* binding */ TransformControls; },\n/* harmony export */   TransformControlsGizmo: function() { return /* binding */ TransformControlsGizmo; },\n/* harmony export */   TransformControlsPlane: function() { return /* binding */ TransformControlsPlane; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nconst _raycaster = new three__WEBPACK_IMPORTED_MODULE_0__.Raycaster();\nconst _tempVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _tempVector2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _tempQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nconst _unit = {\n    X: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0),\n    Y: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0),\n    Z: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1)\n};\nconst _changeEvent = {\n    type: \"change\"\n};\nconst _mouseDownEvent = {\n    type: \"mouseDown\"\n};\nconst _mouseUpEvent = {\n    type: \"mouseUp\",\n    mode: null\n};\nconst _objectChangeEvent = {\n    type: \"objectChange\"\n};\nclass TransformControls extends three__WEBPACK_IMPORTED_MODULE_0__.Object3D {\n    // updateMatrixWorld  updates key transformation variables\n    updateMatrixWorld() {\n        if (this.object !== undefined) {\n            this.object.updateMatrixWorld();\n            if (this.object.parent === null) {\n                console.error(\"TransformControls: The attached 3D object must be a part of the scene graph.\");\n            } else {\n                this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale);\n            }\n            this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale);\n            this._parentQuaternionInv.copy(this._parentQuaternion).invert();\n            this._worldQuaternionInv.copy(this.worldQuaternion).invert();\n        }\n        this.camera.updateMatrixWorld();\n        this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale);\n        if (this.camera.isOrthographicCamera) {\n            this.camera.getWorldDirection(this.eye).negate();\n        } else {\n            this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();\n        }\n        super.updateMatrixWorld(this);\n    }\n    pointerHover(pointer) {\n        if (this.object === undefined || this.dragging === true) return;\n        _raycaster.setFromCamera(pointer, this.camera);\n        const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);\n        if (intersect) {\n            this.axis = intersect.object.name;\n        } else {\n            this.axis = null;\n        }\n    }\n    pointerDown(pointer) {\n        if (this.object === undefined || this.dragging === true || pointer.button !== 0) return;\n        if (this.axis !== null) {\n            _raycaster.setFromCamera(pointer, this.camera);\n            const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);\n            if (planeIntersect) {\n                this.object.updateMatrixWorld();\n                this.object.parent.updateMatrixWorld();\n                this._positionStart.copy(this.object.position);\n                this._quaternionStart.copy(this.object.quaternion);\n                this._scaleStart.copy(this.object.scale);\n                this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);\n                this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);\n            }\n            this.dragging = true;\n            _mouseDownEvent.mode = this.mode;\n            this.dispatchEvent(_mouseDownEvent);\n        }\n    }\n    pointerMove(pointer) {\n        const axis = this.axis;\n        const mode = this.mode;\n        const object = this.object;\n        let space = this.space;\n        if (mode === \"scale\") {\n            space = \"local\";\n        } else if (axis === \"E\" || axis === \"XYZE\" || axis === \"XYZ\") {\n            space = \"world\";\n        }\n        if (object === undefined || axis === null || this.dragging === false || pointer.button !== -1) return;\n        _raycaster.setFromCamera(pointer, this.camera);\n        const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);\n        if (!planeIntersect) return;\n        this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);\n        if (mode === \"translate\") {\n            // Apply translate\n            this._offset.copy(this.pointEnd).sub(this.pointStart);\n            if (space === \"local\" && axis !== \"XYZ\") {\n                this._offset.applyQuaternion(this._worldQuaternionInv);\n            }\n            if (axis.indexOf(\"X\") === -1) this._offset.x = 0;\n            if (axis.indexOf(\"Y\") === -1) this._offset.y = 0;\n            if (axis.indexOf(\"Z\") === -1) this._offset.z = 0;\n            if (space === \"local\" && axis !== \"XYZ\") {\n                this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);\n            } else {\n                this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);\n            }\n            object.position.copy(this._offset).add(this._positionStart);\n            // Apply translation snap\n            if (this.translationSnap) {\n                if (space === \"local\") {\n                    object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());\n                    if (axis.search(\"X\") !== -1) {\n                        object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;\n                    }\n                    if (axis.search(\"Y\") !== -1) {\n                        object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;\n                    }\n                    if (axis.search(\"Z\") !== -1) {\n                        object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;\n                    }\n                    object.position.applyQuaternion(this._quaternionStart);\n                }\n                if (space === \"world\") {\n                    if (object.parent) {\n                        object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));\n                    }\n                    if (axis.search(\"X\") !== -1) {\n                        object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;\n                    }\n                    if (axis.search(\"Y\") !== -1) {\n                        object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;\n                    }\n                    if (axis.search(\"Z\") !== -1) {\n                        object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;\n                    }\n                    if (object.parent) {\n                        object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));\n                    }\n                }\n            }\n        } else if (mode === \"scale\") {\n            if (axis.search(\"XYZ\") !== -1) {\n                let d = this.pointEnd.length() / this.pointStart.length();\n                if (this.pointEnd.dot(this.pointStart) < 0) d *= -1;\n                _tempVector2.set(d, d, d);\n            } else {\n                _tempVector.copy(this.pointStart);\n                _tempVector2.copy(this.pointEnd);\n                _tempVector.applyQuaternion(this._worldQuaternionInv);\n                _tempVector2.applyQuaternion(this._worldQuaternionInv);\n                _tempVector2.divide(_tempVector);\n                if (axis.search(\"X\") === -1) {\n                    _tempVector2.x = 1;\n                }\n                if (axis.search(\"Y\") === -1) {\n                    _tempVector2.y = 1;\n                }\n                if (axis.search(\"Z\") === -1) {\n                    _tempVector2.z = 1;\n                }\n            }\n            // Apply scale\n            object.scale.copy(this._scaleStart).multiply(_tempVector2);\n            if (this.scaleSnap) {\n                if (axis.search(\"X\") !== -1) {\n                    object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;\n                }\n                if (axis.search(\"Y\") !== -1) {\n                    object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;\n                }\n                if (axis.search(\"Z\") !== -1) {\n                    object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;\n                }\n            }\n        } else if (mode === \"rotate\") {\n            this._offset.copy(this.pointEnd).sub(this.pointStart);\n            const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));\n            let _inPlaneRotation = false;\n            if (axis === \"XYZE\") {\n                this.rotationAxis.copy(this._offset).cross(this.eye).normalize();\n                this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;\n            } else if (axis === \"X\" || axis === \"Y\" || axis === \"Z\") {\n                this.rotationAxis.copy(_unit[axis]);\n                _tempVector.copy(_unit[axis]);\n                if (space === \"local\") {\n                    _tempVector.applyQuaternion(this.worldQuaternion);\n                }\n                _tempVector.cross(this.eye);\n                // When _tempVector is 0 after cross with this.eye the vectors are parallel and should use in-plane rotation logic.\n                if (_tempVector.length() === 0) {\n                    _inPlaneRotation = true;\n                } else {\n                    this.rotationAngle = this._offset.dot(_tempVector.normalize()) * ROTATION_SPEED;\n                }\n            }\n            if (axis === \"E\" || _inPlaneRotation) {\n                this.rotationAxis.copy(this.eye);\n                this.rotationAngle = this.pointEnd.angleTo(this.pointStart);\n                this._startNorm.copy(this.pointStart).normalize();\n                this._endNorm.copy(this.pointEnd).normalize();\n                this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;\n            }\n            // Apply rotation snap\n            if (this.rotationSnap) this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;\n            // Apply rotate\n            if (space === \"local\" && axis !== \"E\" && axis !== \"XYZE\") {\n                object.quaternion.copy(this._quaternionStart);\n                object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();\n            } else {\n                this.rotationAxis.applyQuaternion(this._parentQuaternionInv);\n                object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));\n                object.quaternion.multiply(this._quaternionStart).normalize();\n            }\n        }\n        this.dispatchEvent(_changeEvent);\n        this.dispatchEvent(_objectChangeEvent);\n    }\n    pointerUp(pointer) {\n        if (pointer.button !== 0) return;\n        if (this.dragging && this.axis !== null) {\n            _mouseUpEvent.mode = this.mode;\n            this.dispatchEvent(_mouseUpEvent);\n        }\n        this.dragging = false;\n        this.axis = null;\n    }\n    dispose() {\n        this.domElement.removeEventListener(\"pointerdown\", this._onPointerDown);\n        this.domElement.removeEventListener(\"pointermove\", this._onPointerHover);\n        this.domElement.removeEventListener(\"pointermove\", this._onPointerMove);\n        this.domElement.removeEventListener(\"pointerup\", this._onPointerUp);\n        this.traverse(function(child) {\n            if (child.geometry) child.geometry.dispose();\n            if (child.material) child.material.dispose();\n        });\n    }\n    // Set current object\n    attach(object) {\n        this.object = object;\n        this.visible = true;\n        return this;\n    }\n    // Detach from object\n    detach() {\n        this.object = undefined;\n        this.visible = false;\n        this.axis = null;\n        return this;\n    }\n    reset() {\n        if (!this.enabled) return;\n        if (this.dragging) {\n            this.object.position.copy(this._positionStart);\n            this.object.quaternion.copy(this._quaternionStart);\n            this.object.scale.copy(this._scaleStart);\n            this.dispatchEvent(_changeEvent);\n            this.dispatchEvent(_objectChangeEvent);\n            this.pointStart.copy(this.pointEnd);\n        }\n    }\n    getRaycaster() {\n        return _raycaster;\n    }\n    // TODO: deprecate\n    getMode() {\n        return this.mode;\n    }\n    setMode(mode) {\n        this.mode = mode;\n    }\n    setTranslationSnap(translationSnap) {\n        this.translationSnap = translationSnap;\n    }\n    setRotationSnap(rotationSnap) {\n        this.rotationSnap = rotationSnap;\n    }\n    setScaleSnap(scaleSnap) {\n        this.scaleSnap = scaleSnap;\n    }\n    setSize(size) {\n        this.size = size;\n    }\n    setSpace(space) {\n        this.space = space;\n    }\n    constructor(camera, domElement){\n        super();\n        if (domElement === undefined) {\n            console.warn('THREE.TransformControls: The second parameter \"domElement\" is now mandatory.');\n            domElement = document;\n        }\n        this.isTransformControls = true;\n        this.visible = false;\n        this.domElement = domElement;\n        this.domElement.style.touchAction = \"none\"; // disable touch scroll\n        const _gizmo = new TransformControlsGizmo();\n        this._gizmo = _gizmo;\n        this.add(_gizmo);\n        const _plane = new TransformControlsPlane();\n        this._plane = _plane;\n        this.add(_plane);\n        const scope = this;\n        // Defined getter, setter and store for a property\n        function defineProperty(propName, defaultValue) {\n            let propValue = defaultValue;\n            Object.defineProperty(scope, propName, {\n                get: function() {\n                    return propValue !== undefined ? propValue : defaultValue;\n                },\n                set: function(value) {\n                    if (propValue !== value) {\n                        propValue = value;\n                        _plane[propName] = value;\n                        _gizmo[propName] = value;\n                        scope.dispatchEvent({\n                            type: propName + \"-changed\",\n                            value: value\n                        });\n                        scope.dispatchEvent(_changeEvent);\n                    }\n                }\n            });\n            scope[propName] = defaultValue;\n            _plane[propName] = defaultValue;\n            _gizmo[propName] = defaultValue;\n        }\n        // Define properties with getters/setter\n        // Setting the defined property will automatically trigger change event\n        // Defined properties are passed down to gizmo and plane\n        defineProperty(\"camera\", camera);\n        defineProperty(\"object\", undefined);\n        defineProperty(\"enabled\", true);\n        defineProperty(\"axis\", null);\n        defineProperty(\"mode\", \"translate\");\n        defineProperty(\"translationSnap\", null);\n        defineProperty(\"rotationSnap\", null);\n        defineProperty(\"scaleSnap\", null);\n        defineProperty(\"space\", \"world\");\n        defineProperty(\"size\", 1);\n        defineProperty(\"dragging\", false);\n        defineProperty(\"showX\", true);\n        defineProperty(\"showY\", true);\n        defineProperty(\"showZ\", true);\n        // Reusable utility variables\n        const worldPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const worldPositionStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const worldQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        const worldQuaternionStart = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        const cameraPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const cameraQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        const pointStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const pointEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const rotationAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const rotationAngle = 0;\n        const eye = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        // TODO: remove properties unused in plane and gizmo\n        defineProperty(\"worldPosition\", worldPosition);\n        defineProperty(\"worldPositionStart\", worldPositionStart);\n        defineProperty(\"worldQuaternion\", worldQuaternion);\n        defineProperty(\"worldQuaternionStart\", worldQuaternionStart);\n        defineProperty(\"cameraPosition\", cameraPosition);\n        defineProperty(\"cameraQuaternion\", cameraQuaternion);\n        defineProperty(\"pointStart\", pointStart);\n        defineProperty(\"pointEnd\", pointEnd);\n        defineProperty(\"rotationAxis\", rotationAxis);\n        defineProperty(\"rotationAngle\", rotationAngle);\n        defineProperty(\"eye\", eye);\n        this._offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this._startNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this._endNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this._cameraScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this._parentPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this._parentQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this._parentQuaternionInv = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this._parentScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this._worldScaleStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this._worldQuaternionInv = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this._worldScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this._positionStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this._quaternionStart = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this._scaleStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this._getPointer = getPointer.bind(this);\n        this._onPointerDown = onPointerDown.bind(this);\n        this._onPointerHover = onPointerHover.bind(this);\n        this._onPointerMove = onPointerMove.bind(this);\n        this._onPointerUp = onPointerUp.bind(this);\n        this.domElement.addEventListener(\"pointerdown\", this._onPointerDown);\n        this.domElement.addEventListener(\"pointermove\", this._onPointerHover);\n        this.domElement.addEventListener(\"pointerup\", this._onPointerUp);\n    }\n}\n// mouse / touch event handlers\nfunction getPointer(event) {\n    if (this.domElement.ownerDocument.pointerLockElement) {\n        return {\n            x: 0,\n            y: 0,\n            button: event.button\n        };\n    } else {\n        const rect = this.domElement.getBoundingClientRect();\n        return {\n            x: (event.clientX - rect.left) / rect.width * 2 - 1,\n            y: -(event.clientY - rect.top) / rect.height * 2 + 1,\n            button: event.button\n        };\n    }\n}\nfunction onPointerHover(event) {\n    if (!this.enabled) return;\n    switch(event.pointerType){\n        case \"mouse\":\n        case \"pen\":\n            this.pointerHover(this._getPointer(event));\n            break;\n    }\n}\nfunction onPointerDown(event) {\n    if (!this.enabled) return;\n    if (!document.pointerLockElement) {\n        this.domElement.setPointerCapture(event.pointerId);\n    }\n    this.domElement.addEventListener(\"pointermove\", this._onPointerMove);\n    this.pointerHover(this._getPointer(event));\n    this.pointerDown(this._getPointer(event));\n}\nfunction onPointerMove(event) {\n    if (!this.enabled) return;\n    this.pointerMove(this._getPointer(event));\n}\nfunction onPointerUp(event) {\n    if (!this.enabled) return;\n    this.domElement.releasePointerCapture(event.pointerId);\n    this.domElement.removeEventListener(\"pointermove\", this._onPointerMove);\n    this.pointerUp(this._getPointer(event));\n}\nfunction intersectObjectWithRay(object, raycaster, includeInvisible) {\n    const allIntersections = raycaster.intersectObject(object, true);\n    for(let i = 0; i < allIntersections.length; i++){\n        if (allIntersections[i].object.visible || includeInvisible) {\n            return allIntersections[i];\n        }\n    }\n    return false;\n}\n//\n// Reusable utility variables\nconst _tempEuler = new three__WEBPACK_IMPORTED_MODULE_0__.Euler();\nconst _alignVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\nconst _zeroVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\nconst _lookAtMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst _tempQuaternion2 = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nconst _identityQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nconst _dirVector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _tempMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst _unitX = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);\nconst _unitY = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\nconst _unitZ = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);\nconst _v1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _v2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _v3 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nclass TransformControlsGizmo extends three__WEBPACK_IMPORTED_MODULE_0__.Object3D {\n    // updateMatrixWorld will update transformations and appearance of individual handles\n    updateMatrixWorld(force) {\n        const space = this.mode === \"scale\" ? \"local\" : this.space; // scale always oriented to local rotation\n        const quaternion = space === \"local\" ? this.worldQuaternion : _identityQuaternion;\n        // Show only gizmos for current transform mode\n        this.gizmo[\"translate\"].visible = this.mode === \"translate\";\n        this.gizmo[\"rotate\"].visible = this.mode === \"rotate\";\n        this.gizmo[\"scale\"].visible = this.mode === \"scale\";\n        this.helper[\"translate\"].visible = this.mode === \"translate\";\n        this.helper[\"rotate\"].visible = this.mode === \"rotate\";\n        this.helper[\"scale\"].visible = this.mode === \"scale\";\n        let handles = [];\n        handles = handles.concat(this.picker[this.mode].children);\n        handles = handles.concat(this.gizmo[this.mode].children);\n        handles = handles.concat(this.helper[this.mode].children);\n        for(let i = 0; i < handles.length; i++){\n            const handle = handles[i];\n            // hide aligned to camera\n            handle.visible = true;\n            handle.rotation.set(0, 0, 0);\n            handle.position.copy(this.worldPosition);\n            let factor;\n            if (this.camera.isOrthographicCamera) {\n                factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;\n            } else {\n                factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);\n            }\n            handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);\n            // TODO: simplify helpers and consider decoupling from gizmo\n            if (handle.tag === \"helper\") {\n                handle.visible = false;\n                if (handle.name === \"AXIS\") {\n                    handle.visible = !!this.axis;\n                    if (this.axis === \"X\") {\n                        _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));\n                        handle.quaternion.copy(quaternion).multiply(_tempQuaternion);\n                        if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {\n                            handle.visible = false;\n                        }\n                    }\n                    if (this.axis === \"Y\") {\n                        _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));\n                        handle.quaternion.copy(quaternion).multiply(_tempQuaternion);\n                        if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {\n                            handle.visible = false;\n                        }\n                    }\n                    if (this.axis === \"Z\") {\n                        _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));\n                        handle.quaternion.copy(quaternion).multiply(_tempQuaternion);\n                        if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {\n                            handle.visible = false;\n                        }\n                    }\n                    if (this.axis === \"XYZE\") {\n                        _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));\n                        _alignVector.copy(this.rotationAxis);\n                        handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));\n                        handle.quaternion.multiply(_tempQuaternion);\n                        handle.visible = this.dragging;\n                    }\n                    if (this.axis === \"E\") {\n                        handle.visible = false;\n                    }\n                } else if (handle.name === \"START\") {\n                    handle.position.copy(this.worldPositionStart);\n                    handle.visible = this.dragging;\n                } else if (handle.name === \"END\") {\n                    handle.position.copy(this.worldPosition);\n                    handle.visible = this.dragging;\n                } else if (handle.name === \"DELTA\") {\n                    handle.position.copy(this.worldPositionStart);\n                    handle.quaternion.copy(this.worldQuaternionStart);\n                    _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);\n                    _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());\n                    handle.scale.copy(_tempVector);\n                    handle.visible = this.dragging;\n                } else {\n                    handle.quaternion.copy(quaternion);\n                    if (this.dragging) {\n                        handle.position.copy(this.worldPositionStart);\n                    } else {\n                        handle.position.copy(this.worldPosition);\n                    }\n                    if (this.axis) {\n                        handle.visible = this.axis.search(handle.name) !== -1;\n                    }\n                }\n                continue;\n            }\n            // Align handles to current local or world rotation\n            handle.quaternion.copy(quaternion);\n            if (this.mode === \"translate\" || this.mode === \"scale\") {\n                // Hide translate and scale axis facing the camera\n                const AXIS_HIDE_THRESHOLD = 0.99;\n                const PLANE_HIDE_THRESHOLD = 0.2;\n                if (handle.name === \"X\") {\n                    if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {\n                        handle.scale.set(1e-10, 1e-10, 1e-10);\n                        handle.visible = false;\n                    }\n                }\n                if (handle.name === \"Y\") {\n                    if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {\n                        handle.scale.set(1e-10, 1e-10, 1e-10);\n                        handle.visible = false;\n                    }\n                }\n                if (handle.name === \"Z\") {\n                    if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {\n                        handle.scale.set(1e-10, 1e-10, 1e-10);\n                        handle.visible = false;\n                    }\n                }\n                if (handle.name === \"XY\") {\n                    if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {\n                        handle.scale.set(1e-10, 1e-10, 1e-10);\n                        handle.visible = false;\n                    }\n                }\n                if (handle.name === \"YZ\") {\n                    if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {\n                        handle.scale.set(1e-10, 1e-10, 1e-10);\n                        handle.visible = false;\n                    }\n                }\n                if (handle.name === \"XZ\") {\n                    if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {\n                        handle.scale.set(1e-10, 1e-10, 1e-10);\n                        handle.visible = false;\n                    }\n                }\n            } else if (this.mode === \"rotate\") {\n                // Align handles to current local or world rotation\n                _tempQuaternion2.copy(quaternion);\n                _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());\n                if (handle.name.search(\"E\") !== -1) {\n                    handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));\n                }\n                if (handle.name === \"X\") {\n                    _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));\n                    _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);\n                    handle.quaternion.copy(_tempQuaternion);\n                }\n                if (handle.name === \"Y\") {\n                    _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));\n                    _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);\n                    handle.quaternion.copy(_tempQuaternion);\n                }\n                if (handle.name === \"Z\") {\n                    _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));\n                    _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);\n                    handle.quaternion.copy(_tempQuaternion);\n                }\n            }\n            // Hide disabled axes\n            handle.visible = handle.visible && (handle.name.indexOf(\"X\") === -1 || this.showX);\n            handle.visible = handle.visible && (handle.name.indexOf(\"Y\") === -1 || this.showY);\n            handle.visible = handle.visible && (handle.name.indexOf(\"Z\") === -1 || this.showZ);\n            handle.visible = handle.visible && (handle.name.indexOf(\"E\") === -1 || this.showX && this.showY && this.showZ);\n            // highlight selected axis\n            handle.material._color = handle.material._color || handle.material.color.clone();\n            handle.material._opacity = handle.material._opacity || handle.material.opacity;\n            handle.material.color.copy(handle.material._color);\n            handle.material.opacity = handle.material._opacity;\n            if (this.enabled && this.axis) {\n                if (handle.name === this.axis) {\n                    handle.material.color.setHex(0xffff00);\n                    handle.material.opacity = 1.0;\n                } else if (this.axis.split(\"\").some(function(a) {\n                    return handle.name === a;\n                })) {\n                    handle.material.color.setHex(0xffff00);\n                    handle.material.opacity = 1.0;\n                }\n            }\n        }\n        super.updateMatrixWorld(force);\n    }\n    constructor(){\n        super();\n        this.isTransformControlsGizmo = true;\n        this.type = \"TransformControlsGizmo\";\n        // shared materials\n        const gizmoMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            depthTest: false,\n            depthWrite: false,\n            fog: false,\n            toneMapped: false,\n            transparent: true\n        });\n        const gizmoLineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({\n            depthTest: false,\n            depthWrite: false,\n            fog: false,\n            toneMapped: false,\n            transparent: true\n        });\n        // Make unique material for each axis/color\n        const matInvisible = gizmoMaterial.clone();\n        matInvisible.opacity = 0.15;\n        const matHelper = gizmoLineMaterial.clone();\n        matHelper.opacity = 0.5;\n        const matRed = gizmoMaterial.clone();\n        matRed.color.setHex(0xff0000);\n        const matGreen = gizmoMaterial.clone();\n        matGreen.color.setHex(0x00ff00);\n        const matBlue = gizmoMaterial.clone();\n        matBlue.color.setHex(0x0000ff);\n        const matRedTransparent = gizmoMaterial.clone();\n        matRedTransparent.color.setHex(0xff0000);\n        matRedTransparent.opacity = 0.5;\n        const matGreenTransparent = gizmoMaterial.clone();\n        matGreenTransparent.color.setHex(0x00ff00);\n        matGreenTransparent.opacity = 0.5;\n        const matBlueTransparent = gizmoMaterial.clone();\n        matBlueTransparent.color.setHex(0x0000ff);\n        matBlueTransparent.opacity = 0.5;\n        const matWhiteTransparent = gizmoMaterial.clone();\n        matWhiteTransparent.opacity = 0.25;\n        const matYellowTransparent = gizmoMaterial.clone();\n        matYellowTransparent.color.setHex(0xffff00);\n        matYellowTransparent.opacity = 0.25;\n        const matYellow = gizmoMaterial.clone();\n        matYellow.color.setHex(0xffff00);\n        const matGray = gizmoMaterial.clone();\n        matGray.color.setHex(0x787878);\n        // reusable geometry\n        const arrowGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0, 0.04, 0.1, 12);\n        arrowGeometry.translate(0, 0.05, 0);\n        const scaleHandleGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.08, 0.08, 0.08);\n        scaleHandleGeometry.translate(0, 0.04, 0);\n        const lineGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        lineGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute([\n            0,\n            0,\n            0,\n            1,\n            0,\n            0\n        ], 3));\n        const lineGeometry2 = new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.0075, 0.0075, 0.5, 3);\n        lineGeometry2.translate(0, 0.25, 0);\n        function CircleGeometry(radius, arc) {\n            const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry(radius, 0.0075, 3, 64, arc * Math.PI * 2);\n            geometry.rotateY(Math.PI / 2);\n            geometry.rotateX(Math.PI / 2);\n            return geometry;\n        }\n        // Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position\n        function TranslateHelperGeometry() {\n            const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n            geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute([\n                0,\n                0,\n                0,\n                1,\n                1,\n                1\n            ], 3));\n            return geometry;\n        }\n        // Gizmo definitions - custom hierarchy definitions for setupGizmo() function\n        const gizmoTranslate = {\n            X: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(arrowGeometry, matRed),\n                    [\n                        0.5,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        -Math.PI / 2\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(arrowGeometry, matRed),\n                    [\n                        -0.5,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        Math.PI / 2\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(lineGeometry2, matRed),\n                    [\n                        0,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        -Math.PI / 2\n                    ]\n                ]\n            ],\n            Y: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(arrowGeometry, matGreen),\n                    [\n                        0,\n                        0.5,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(arrowGeometry, matGreen),\n                    [\n                        0,\n                        -0.5,\n                        0\n                    ],\n                    [\n                        Math.PI,\n                        0,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(lineGeometry2, matGreen)\n                ]\n            ],\n            Z: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(arrowGeometry, matBlue),\n                    [\n                        0,\n                        0,\n                        0.5\n                    ],\n                    [\n                        Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(arrowGeometry, matBlue),\n                    [\n                        0,\n                        0,\n                        -0.5\n                    ],\n                    [\n                        -Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(lineGeometry2, matBlue),\n                    null,\n                    [\n                        Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ]\n            ],\n            XYZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()),\n                    [\n                        0,\n                        0,\n                        0\n                    ]\n                ]\n            ],\n            XY: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()),\n                    [\n                        0.15,\n                        0.15,\n                        0\n                    ]\n                ]\n            ],\n            YZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()),\n                    [\n                        0,\n                        0.15,\n                        0.15\n                    ],\n                    [\n                        0,\n                        Math.PI / 2,\n                        0\n                    ]\n                ]\n            ],\n            XZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()),\n                    [\n                        0.15,\n                        0,\n                        0.15\n                    ],\n                    [\n                        -Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ]\n            ]\n        };\n        const pickerTranslate = {\n            X: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        0.3,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        -Math.PI / 2\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        -0.3,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        Math.PI / 2\n                    ]\n                ]\n            ],\n            Y: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        0,\n                        0.3,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        0,\n                        -0.3,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        Math.PI\n                    ]\n                ]\n            ],\n            Z: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        0,\n                        0,\n                        0.3\n                    ],\n                    [\n                        Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        0,\n                        0,\n                        -0.3\n                    ],\n                    [\n                        -Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ]\n            ],\n            XYZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry(0.2, 0), matInvisible)\n                ]\n            ],\n            XY: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.2, 0.2, 0.01), matInvisible),\n                    [\n                        0.15,\n                        0.15,\n                        0\n                    ]\n                ]\n            ],\n            YZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.2, 0.2, 0.01), matInvisible),\n                    [\n                        0,\n                        0.15,\n                        0.15\n                    ],\n                    [\n                        0,\n                        Math.PI / 2,\n                        0\n                    ]\n                ]\n            ],\n            XZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.2, 0.2, 0.01), matInvisible),\n                    [\n                        0.15,\n                        0,\n                        0.15\n                    ],\n                    [\n                        -Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ]\n            ]\n        };\n        const helperTranslate = {\n            START: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry(0.01, 2), matHelper),\n                    null,\n                    null,\n                    null,\n                    \"helper\"\n                ]\n            ],\n            END: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry(0.01, 2), matHelper),\n                    null,\n                    null,\n                    null,\n                    \"helper\"\n                ]\n            ],\n            DELTA: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Line(TranslateHelperGeometry(), matHelper),\n                    null,\n                    null,\n                    null,\n                    \"helper\"\n                ]\n            ],\n            X: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Line(lineGeometry, matHelper.clone()),\n                    [\n                        -1e3,\n                        0,\n                        0\n                    ],\n                    null,\n                    [\n                        1e6,\n                        1,\n                        1\n                    ],\n                    \"helper\"\n                ]\n            ],\n            Y: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Line(lineGeometry, matHelper.clone()),\n                    [\n                        0,\n                        -1e3,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        Math.PI / 2\n                    ],\n                    [\n                        1e6,\n                        1,\n                        1\n                    ],\n                    \"helper\"\n                ]\n            ],\n            Z: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Line(lineGeometry, matHelper.clone()),\n                    [\n                        0,\n                        0,\n                        -1e3\n                    ],\n                    [\n                        0,\n                        -Math.PI / 2,\n                        0\n                    ],\n                    [\n                        1e6,\n                        1,\n                        1\n                    ],\n                    \"helper\"\n                ]\n            ]\n        };\n        const gizmoRotate = {\n            XYZE: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(CircleGeometry(0.5, 1), matGray),\n                    null,\n                    [\n                        0,\n                        Math.PI / 2,\n                        0\n                    ]\n                ]\n            ],\n            X: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(CircleGeometry(0.5, 0.5), matRed)\n                ]\n            ],\n            Y: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(CircleGeometry(0.5, 0.5), matGreen),\n                    null,\n                    [\n                        0,\n                        0,\n                        -Math.PI / 2\n                    ]\n                ]\n            ],\n            Z: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(CircleGeometry(0.5, 0.5), matBlue),\n                    null,\n                    [\n                        0,\n                        Math.PI / 2,\n                        0\n                    ]\n                ]\n            ],\n            E: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(CircleGeometry(0.75, 1), matYellowTransparent),\n                    null,\n                    [\n                        0,\n                        Math.PI / 2,\n                        0\n                    ]\n                ]\n            ]\n        };\n        const helperRotate = {\n            AXIS: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Line(lineGeometry, matHelper.clone()),\n                    [\n                        -1e3,\n                        0,\n                        0\n                    ],\n                    null,\n                    [\n                        1e6,\n                        1,\n                        1\n                    ],\n                    \"helper\"\n                ]\n            ]\n        };\n        const pickerRotate = {\n            XYZE: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.25, 10, 8), matInvisible)\n                ]\n            ],\n            X: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry(0.5, 0.1, 4, 24), matInvisible),\n                    [\n                        0,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        -Math.PI / 2,\n                        -Math.PI / 2\n                    ]\n                ]\n            ],\n            Y: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry(0.5, 0.1, 4, 24), matInvisible),\n                    [\n                        0,\n                        0,\n                        0\n                    ],\n                    [\n                        Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ]\n            ],\n            Z: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry(0.5, 0.1, 4, 24), matInvisible),\n                    [\n                        0,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        -Math.PI / 2\n                    ]\n                ]\n            ],\n            E: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry(0.75, 0.1, 2, 24), matInvisible)\n                ]\n            ]\n        };\n        const gizmoScale = {\n            X: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(scaleHandleGeometry, matRed),\n                    [\n                        0.5,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        -Math.PI / 2\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(lineGeometry2, matRed),\n                    [\n                        0,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        -Math.PI / 2\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(scaleHandleGeometry, matRed),\n                    [\n                        -0.5,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        Math.PI / 2\n                    ]\n                ]\n            ],\n            Y: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(scaleHandleGeometry, matGreen),\n                    [\n                        0,\n                        0.5,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(lineGeometry2, matGreen)\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(scaleHandleGeometry, matGreen),\n                    [\n                        0,\n                        -0.5,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        Math.PI\n                    ]\n                ]\n            ],\n            Z: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(scaleHandleGeometry, matBlue),\n                    [\n                        0,\n                        0,\n                        0.5\n                    ],\n                    [\n                        Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(lineGeometry2, matBlue),\n                    [\n                        0,\n                        0,\n                        0\n                    ],\n                    [\n                        Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(scaleHandleGeometry, matBlue),\n                    [\n                        0,\n                        0,\n                        -0.5\n                    ],\n                    [\n                        -Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ]\n            ],\n            XY: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent),\n                    [\n                        0.15,\n                        0.15,\n                        0\n                    ]\n                ]\n            ],\n            YZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.15, 0.15, 0.01), matRedTransparent),\n                    [\n                        0,\n                        0.15,\n                        0.15\n                    ],\n                    [\n                        0,\n                        Math.PI / 2,\n                        0\n                    ]\n                ]\n            ],\n            XZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent),\n                    [\n                        0.15,\n                        0,\n                        0.15\n                    ],\n                    [\n                        -Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ]\n            ],\n            XYZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())\n                ]\n            ]\n        };\n        const pickerScale = {\n            X: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        0.3,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        -Math.PI / 2\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        -0.3,\n                        0,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        Math.PI / 2\n                    ]\n                ]\n            ],\n            Y: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        0,\n                        0.3,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        0,\n                        -0.3,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        Math.PI\n                    ]\n                ]\n            ],\n            Z: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        0,\n                        0,\n                        0.3\n                    ],\n                    [\n                        Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ],\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(0.2, 0, 0.6, 4), matInvisible),\n                    [\n                        0,\n                        0,\n                        -0.3\n                    ],\n                    [\n                        -Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ]\n            ],\n            XY: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.2, 0.2, 0.01), matInvisible),\n                    [\n                        0.15,\n                        0.15,\n                        0\n                    ]\n                ]\n            ],\n            YZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.2, 0.2, 0.01), matInvisible),\n                    [\n                        0,\n                        0.15,\n                        0.15\n                    ],\n                    [\n                        0,\n                        Math.PI / 2,\n                        0\n                    ]\n                ]\n            ],\n            XZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.2, 0.2, 0.01), matInvisible),\n                    [\n                        0.15,\n                        0,\n                        0.15\n                    ],\n                    [\n                        -Math.PI / 2,\n                        0,\n                        0\n                    ]\n                ]\n            ],\n            XYZ: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(0.2, 0.2, 0.2), matInvisible),\n                    [\n                        0,\n                        0,\n                        0\n                    ]\n                ]\n            ]\n        };\n        const helperScale = {\n            X: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Line(lineGeometry, matHelper.clone()),\n                    [\n                        -1e3,\n                        0,\n                        0\n                    ],\n                    null,\n                    [\n                        1e6,\n                        1,\n                        1\n                    ],\n                    \"helper\"\n                ]\n            ],\n            Y: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Line(lineGeometry, matHelper.clone()),\n                    [\n                        0,\n                        -1e3,\n                        0\n                    ],\n                    [\n                        0,\n                        0,\n                        Math.PI / 2\n                    ],\n                    [\n                        1e6,\n                        1,\n                        1\n                    ],\n                    \"helper\"\n                ]\n            ],\n            Z: [\n                [\n                    new three__WEBPACK_IMPORTED_MODULE_0__.Line(lineGeometry, matHelper.clone()),\n                    [\n                        0,\n                        0,\n                        -1e3\n                    ],\n                    [\n                        0,\n                        -Math.PI / 2,\n                        0\n                    ],\n                    [\n                        1e6,\n                        1,\n                        1\n                    ],\n                    \"helper\"\n                ]\n            ]\n        };\n        // Creates an Object3D with gizmos described in custom hierarchy definition.\n        function setupGizmo(gizmoMap) {\n            const gizmo = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n            for(const name in gizmoMap){\n                for(let i = gizmoMap[name].length; i--;){\n                    const object = gizmoMap[name][i][0].clone();\n                    const position = gizmoMap[name][i][1];\n                    const rotation = gizmoMap[name][i][2];\n                    const scale = gizmoMap[name][i][3];\n                    const tag = gizmoMap[name][i][4];\n                    // name and tag properties are essential for picking and updating logic.\n                    object.name = name;\n                    object.tag = tag;\n                    if (position) {\n                        object.position.set(position[0], position[1], position[2]);\n                    }\n                    if (rotation) {\n                        object.rotation.set(rotation[0], rotation[1], rotation[2]);\n                    }\n                    if (scale) {\n                        object.scale.set(scale[0], scale[1], scale[2]);\n                    }\n                    object.updateMatrix();\n                    const tempGeometry = object.geometry.clone();\n                    tempGeometry.applyMatrix4(object.matrix);\n                    object.geometry = tempGeometry;\n                    object.renderOrder = Infinity;\n                    object.position.set(0, 0, 0);\n                    object.rotation.set(0, 0, 0);\n                    object.scale.set(1, 1, 1);\n                    gizmo.add(object);\n                }\n            }\n            return gizmo;\n        }\n        // Gizmo creation\n        this.gizmo = {};\n        this.picker = {};\n        this.helper = {};\n        this.add(this.gizmo[\"translate\"] = setupGizmo(gizmoTranslate));\n        this.add(this.gizmo[\"rotate\"] = setupGizmo(gizmoRotate));\n        this.add(this.gizmo[\"scale\"] = setupGizmo(gizmoScale));\n        this.add(this.picker[\"translate\"] = setupGizmo(pickerTranslate));\n        this.add(this.picker[\"rotate\"] = setupGizmo(pickerRotate));\n        this.add(this.picker[\"scale\"] = setupGizmo(pickerScale));\n        this.add(this.helper[\"translate\"] = setupGizmo(helperTranslate));\n        this.add(this.helper[\"rotate\"] = setupGizmo(helperRotate));\n        this.add(this.helper[\"scale\"] = setupGizmo(helperScale));\n        // Pickers should be hidden always\n        this.picker[\"translate\"].visible = false;\n        this.picker[\"rotate\"].visible = false;\n        this.picker[\"scale\"].visible = false;\n    }\n}\n//\nclass TransformControlsPlane extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n    updateMatrixWorld(force) {\n        let space = this.space;\n        this.position.copy(this.worldPosition);\n        if (this.mode === \"scale\") space = \"local\"; // scale always oriented to local rotation\n        _v1.copy(_unitX).applyQuaternion(space === \"local\" ? this.worldQuaternion : _identityQuaternion);\n        _v2.copy(_unitY).applyQuaternion(space === \"local\" ? this.worldQuaternion : _identityQuaternion);\n        _v3.copy(_unitZ).applyQuaternion(space === \"local\" ? this.worldQuaternion : _identityQuaternion);\n        // Align the plane for current transform mode, axis and space.\n        _alignVector.copy(_v2);\n        switch(this.mode){\n            case \"translate\":\n            case \"scale\":\n                switch(this.axis){\n                    case \"X\":\n                        _alignVector.copy(this.eye).cross(_v1);\n                        _dirVector.copy(_v1).cross(_alignVector);\n                        break;\n                    case \"Y\":\n                        _alignVector.copy(this.eye).cross(_v2);\n                        _dirVector.copy(_v2).cross(_alignVector);\n                        break;\n                    case \"Z\":\n                        _alignVector.copy(this.eye).cross(_v3);\n                        _dirVector.copy(_v3).cross(_alignVector);\n                        break;\n                    case \"XY\":\n                        _dirVector.copy(_v3);\n                        break;\n                    case \"YZ\":\n                        _dirVector.copy(_v1);\n                        break;\n                    case \"XZ\":\n                        _alignVector.copy(_v3);\n                        _dirVector.copy(_v2);\n                        break;\n                    case \"XYZ\":\n                    case \"E\":\n                        _dirVector.set(0, 0, 0);\n                        break;\n                }\n                break;\n            case \"rotate\":\n            default:\n                // special case for rotate\n                _dirVector.set(0, 0, 0);\n        }\n        if (_dirVector.length() === 0) {\n            // If in rotate mode, make the plane parallel to camera\n            this.quaternion.copy(this.cameraQuaternion);\n        } else {\n            _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);\n            this.quaternion.setFromRotationMatrix(_tempMatrix);\n        }\n        super.updateMatrixWorld(force);\n    }\n    constructor(){\n        super(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(100000, 100000, 2, 2), new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            visible: false,\n            wireframe: true,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide,\n            transparent: true,\n            opacity: 0.1,\n            toneMapped: false\n        }));\n        this.isTransformControlsPlane = true;\n        this.type = \"TransformControlsPlane\";\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvVHJhbnNmb3JtQ29udHJvbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQW9CZTtBQUVmLE1BQU1tQixhQUFhLElBQUlKLDRDQUFTQTtBQUVoQyxNQUFNSyxjQUFjLElBQUlGLDBDQUFPQTtBQUMvQixNQUFNRyxlQUFlLElBQUlILDBDQUFPQTtBQUNoQyxNQUFNSSxrQkFBa0IsSUFBSVIsNkNBQVVBO0FBQ3RDLE1BQU1TLFFBQVE7SUFDYkMsR0FBRyxJQUFJTiwwQ0FBT0EsQ0FBRSxHQUFHLEdBQUc7SUFDdEJPLEdBQUcsSUFBSVAsMENBQU9BLENBQUUsR0FBRyxHQUFHO0lBQ3RCUSxHQUFHLElBQUlSLDBDQUFPQSxDQUFFLEdBQUcsR0FBRztBQUN2QjtBQUVBLE1BQU1TLGVBQWU7SUFBRUMsTUFBTTtBQUFTO0FBQ3RDLE1BQU1DLGtCQUFrQjtJQUFFRCxNQUFNO0FBQVk7QUFDNUMsTUFBTUUsZ0JBQWdCO0lBQUVGLE1BQU07SUFBV0csTUFBTTtBQUFLO0FBQ3BELE1BQU1DLHFCQUFxQjtJQUFFSixNQUFNO0FBQWU7QUFFbEQsTUFBTUssMEJBQTBCdEIsMkNBQVFBO0lBOEl2QywwREFBMEQ7SUFDMUR1QixvQkFBb0I7UUFFbkIsSUFBSyxJQUFJLENBQUNDLE1BQU0sS0FBS0MsV0FBWTtZQUVoQyxJQUFJLENBQUNELE1BQU0sQ0FBQ0QsaUJBQWlCO1lBRTdCLElBQUssSUFBSSxDQUFDQyxNQUFNLENBQUNFLE1BQU0sS0FBSyxNQUFPO2dCQUVsQ0MsUUFBUUMsS0FBSyxDQUFFO1lBRWhCLE9BQU87Z0JBRU4sSUFBSSxDQUFDSixNQUFNLENBQUNFLE1BQU0sQ0FBQ0csV0FBVyxDQUFDQyxTQUFTLENBQUUsSUFBSSxDQUFDQyxlQUFlLEVBQUUsSUFBSSxDQUFDQyxpQkFBaUIsRUFBRSxJQUFJLENBQUNDLFlBQVk7WUFFMUc7WUFFQSxJQUFJLENBQUNULE1B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QUksQ0FBRXlKO3dCQUNqQjtvQkFDRCxLQUFLO3dCQUNKVixhQUFhL0ksSUFBSSxDQUFFMko7d0JBQ25CUCxXQUFXcEosSUFBSSxDQUFFMEo7d0JBQ2pCO29CQUNELEtBQUs7b0JBQ0wsS0FBSzt3QkFDSk4sV0FBVzFGLEdBQUcsQ0FBRSxHQUFHLEdBQUc7d0JBQ3RCO2dCQUVGO2dCQUVBO1lBQ0QsS0FBSztZQUNMO2dCQUNDLDBCQUEwQjtnQkFDMUIwRixXQUFXMUYsR0FBRyxDQUFFLEdBQUcsR0FBRztRQUV4QjtRQUVBLElBQUswRixXQUFXNUYsTUFBTSxPQUFPLEdBQUk7WUFFaEMsdURBQXVEO1lBQ3ZELElBQUksQ0FBQzFCLFVBQVUsQ0FBQzlCLElBQUksQ0FBRSxJQUFJLENBQUNLLGdCQUFnQjtRQUU1QyxPQUFPO1lBRU5nSixZQUFZMkIsTUFBTSxDQUFFN00sWUFBWXVGLEdBQUcsQ0FBRSxHQUFHLEdBQUcsSUFBSzBGLFlBQVlMO1lBRTVELElBQUksQ0FBQ2pILFVBQVUsQ0FBQ2lKLHFCQUFxQixDQUFFMUI7UUFFeEM7UUFFQSxLQUFLLENBQUNwSyxrQkFBbUIySztJQUUxQjtJQXZGQTFELGFBQWM7UUFFYixLQUFLLENBQ0osSUFBSXRJLGdEQUFhQSxDQUFFLFFBQVEsUUFBUSxHQUFHLElBQ3RDLElBQUlILG9EQUFpQkEsQ0FBRTtZQUFFNEgsU0FBUztZQUFPdUssV0FBVztZQUFNQyxNQUFNM1MsNkNBQVVBO1lBQUVxUCxhQUFhO1lBQU1YLFNBQVM7WUFBS1UsWUFBWTtRQUFNO1FBR2hJLElBQUksQ0FBQ3dELHdCQUF3QixHQUFHO1FBRWhDLElBQUksQ0FBQ25SLElBQUksR0FBRztJQUViO0FBOEVEO0FBRTZFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvVHJhbnNmb3JtQ29udHJvbHMuanM/MTNjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRCb3hHZW9tZXRyeSxcblx0QnVmZmVyR2VvbWV0cnksXG5cdEN5bGluZGVyR2VvbWV0cnksXG5cdERvdWJsZVNpZGUsXG5cdEV1bGVyLFxuXHRGbG9hdDMyQnVmZmVyQXR0cmlidXRlLFxuXHRMaW5lLFxuXHRMaW5lQmFzaWNNYXRlcmlhbCxcblx0TWF0cml4NCxcblx0TWVzaCxcblx0TWVzaEJhc2ljTWF0ZXJpYWwsXG5cdE9iamVjdDNELFxuXHRPY3RhaGVkcm9uR2VvbWV0cnksXG5cdFBsYW5lR2VvbWV0cnksXG5cdFF1YXRlcm5pb24sXG5cdFJheWNhc3Rlcixcblx0U3BoZXJlR2VvbWV0cnksXG5cdFRvcnVzR2VvbWV0cnksXG5cdFZlY3RvcjNcbn0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCBfcmF5Y2FzdGVyID0gbmV3IFJheWNhc3RlcigpO1xuXG5jb25zdCBfdGVtcFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdGVtcFZlY3RvcjIgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3RlbXBRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF91bml0ID0ge1xuXHRYOiBuZXcgVmVjdG9yMyggMSwgMCwgMCApLFxuXHRZOiBuZXcgVmVjdG9yMyggMCwgMSwgMCApLFxuXHRaOiBuZXcgVmVjdG9yMyggMCwgMCwgMSApXG59O1xuXG5jb25zdCBfY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XG5jb25zdCBfbW91c2VEb3duRXZlbnQgPSB7IHR5cGU6ICdtb3VzZURvd24nIH07XG5jb25zdCBfbW91c2VVcEV2ZW50ID0geyB0eXBlOiAnbW91c2VVcCcsIG1vZGU6IG51bGwgfTtcbmNvbnN0IF9vYmplY3RDaGFuZ2VFdmVudCA9IHsgdHlwZTogJ29iamVjdENoYW5nZScgfTtcblxuY2xhc3MgVHJhbnNmb3JtQ29udHJvbHMgZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoIGNhbWVyYSwgZG9tRWxlbWVudCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHRpZiAoIGRvbUVsZW1lbnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVHJhbnNmb3JtQ29udHJvbHM6IFRoZSBzZWNvbmQgcGFyYW1ldGVyIFwiZG9tRWxlbWVudFwiIGlzIG5vdyBtYW5kYXRvcnkuJyApO1xuXHRcdFx0ZG9tRWxlbWVudCA9IGRvY3VtZW50O1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5pc1RyYW5zZm9ybUNvbnRyb2xzID0gdHJ1ZTtcblxuXHRcdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuXHRcdHRoaXMuZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQ7XG5cdFx0dGhpcy5kb21FbGVtZW50LnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnOyAvLyBkaXNhYmxlIHRvdWNoIHNjcm9sbFxuXG5cdFx0Y29uc3QgX2dpem1vID0gbmV3IFRyYW5zZm9ybUNvbnRyb2xzR2l6bW8oKTtcblx0XHR0aGlzLl9naXptbyA9IF9naXptbztcblx0XHR0aGlzLmFkZCggX2dpem1vICk7XG5cblx0XHRjb25zdCBfcGxhbmUgPSBuZXcgVHJhbnNmb3JtQ29udHJvbHNQbGFuZSgpO1xuXHRcdHRoaXMuX3BsYW5lID0gX3BsYW5lO1xuXHRcdHRoaXMuYWRkKCBfcGxhbmUgKTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdC8vIERlZmluZWQgZ2V0dGVyLCBzZXR0ZXIgYW5kIHN0b3JlIGZvciBhIHByb3BlcnR5XG5cdFx0ZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoIHByb3BOYW1lLCBkZWZhdWx0VmFsdWUgKSB7XG5cblx0XHRcdGxldCBwcm9wVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG5cblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggc2NvcGUsIHByb3BOYW1lLCB7XG5cblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gcHJvcFZhbHVlICE9PSB1bmRlZmluZWQgPyBwcm9wVmFsdWUgOiBkZWZhdWx0VmFsdWU7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHByb3BWYWx1ZSAhPT0gdmFsdWUgKSB7XG5cblx0XHRcdFx0XHRcdHByb3BWYWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0X3BsYW5lWyBwcm9wTmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRfZ2l6bW9bIHByb3BOYW1lIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiBwcm9wTmFtZSArICctY2hhbmdlZCcsIHZhbHVlOiB2YWx1ZSB9ICk7XG5cdFx0XHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBfY2hhbmdlRXZlbnQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0c2NvcGVbIHByb3BOYW1lIF0gPSBkZWZhdWx0VmFsdWU7XG5cdFx0XHRfcGxhbmVbIHByb3BOYW1lIF0gPSBkZWZhdWx0VmFsdWU7XG5cdFx0XHRfZ2l6bW9bIHByb3BOYW1lIF0gPSBkZWZhdWx0VmFsdWU7XG5cblx0XHR9XG5cblx0XHQvLyBEZWZpbmUgcHJvcGVydGllcyB3aXRoIGdldHRlcnMvc2V0dGVyXG5cdFx0Ly8gU2V0dGluZyB0aGUgZGVmaW5lZCBwcm9wZXJ0eSB3aWxsIGF1dG9tYXRpY2FsbHkgdHJpZ2dlciBjaGFuZ2UgZXZlbnRcblx0XHQvLyBEZWZpbmVkIHByb3BlcnRpZXMgYXJlIHBhc3NlZCBkb3duIHRvIGdpem1vIGFuZCBwbGFuZVxuXG5cdFx0ZGVmaW5lUHJvcGVydHkoICdjYW1lcmEnLCBjYW1lcmEgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ29iamVjdCcsIHVuZGVmaW5lZCApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAnZW5hYmxlZCcsIHRydWUgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ2F4aXMnLCBudWxsICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdtb2RlJywgJ3RyYW5zbGF0ZScgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3RyYW5zbGF0aW9uU25hcCcsIG51bGwgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3JvdGF0aW9uU25hcCcsIG51bGwgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3NjYWxlU25hcCcsIG51bGwgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3NwYWNlJywgJ3dvcmxkJyApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAnc2l6ZScsIDEgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ2RyYWdnaW5nJywgZmFsc2UgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3Nob3dYJywgdHJ1ZSApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAnc2hvd1knLCB0cnVlICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdzaG93WicsIHRydWUgKTtcblxuXHRcdC8vIFJldXNhYmxlIHV0aWxpdHkgdmFyaWFibGVzXG5cblx0XHRjb25zdCB3b3JsZFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCB3b3JsZFBvc2l0aW9uU3RhcnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHdvcmxkUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0Y29uc3Qgd29ybGRRdWF0ZXJuaW9uU3RhcnQgPSBuZXcgUXVhdGVybmlvbigpO1xuXHRcdGNvbnN0IGNhbWVyYVBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBjYW1lcmFRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRjb25zdCBwb2ludFN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBwb2ludEVuZCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgcm90YXRpb25BeGlzID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCByb3RhdGlvbkFuZ2xlID0gMDtcblx0XHRjb25zdCBleWUgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gVE9ETzogcmVtb3ZlIHByb3BlcnRpZXMgdW51c2VkIGluIHBsYW5lIGFuZCBnaXptb1xuXG5cdFx0ZGVmaW5lUHJvcGVydHkoICd3b3JsZFBvc2l0aW9uJywgd29ybGRQb3NpdGlvbiApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAnd29ybGRQb3NpdGlvblN0YXJ0Jywgd29ybGRQb3NpdGlvblN0YXJ0ICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICd3b3JsZFF1YXRlcm5pb24nLCB3b3JsZFF1YXRlcm5pb24gKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ3dvcmxkUXVhdGVybmlvblN0YXJ0Jywgd29ybGRRdWF0ZXJuaW9uU3RhcnQgKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ2NhbWVyYVBvc2l0aW9uJywgY2FtZXJhUG9zaXRpb24gKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSggJ2NhbWVyYVF1YXRlcm5pb24nLCBjYW1lcmFRdWF0ZXJuaW9uICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdwb2ludFN0YXJ0JywgcG9pbnRTdGFydCApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAncG9pbnRFbmQnLCBwb2ludEVuZCApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAncm90YXRpb25BeGlzJywgcm90YXRpb25BeGlzICk7XG5cdFx0ZGVmaW5lUHJvcGVydHkoICdyb3RhdGlvbkFuZ2xlJywgcm90YXRpb25BbmdsZSApO1xuXHRcdGRlZmluZVByb3BlcnR5KCAnZXllJywgZXllICk7XG5cblx0XHR0aGlzLl9vZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMuX3N0YXJ0Tm9ybSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dGhpcy5fZW5kTm9ybSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dGhpcy5fY2FtZXJhU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dGhpcy5fcGFyZW50UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMuX3BhcmVudFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXHRcdHRoaXMuX3BhcmVudFF1YXRlcm5pb25JbnYgPSBuZXcgUXVhdGVybmlvbigpO1xuXHRcdHRoaXMuX3BhcmVudFNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHRoaXMuX3dvcmxkU2NhbGVTdGFydCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dGhpcy5fd29ybGRRdWF0ZXJuaW9uSW52ID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHR0aGlzLl93b3JsZFNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHRoaXMuX3Bvc2l0aW9uU3RhcnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMuX3F1YXRlcm5pb25TdGFydCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0dGhpcy5fc2NhbGVTdGFydCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR0aGlzLl9nZXRQb2ludGVyID0gZ2V0UG9pbnRlci5iaW5kKCB0aGlzICk7XG5cdFx0dGhpcy5fb25Qb2ludGVyRG93biA9IG9uUG9pbnRlckRvd24uYmluZCggdGhpcyApO1xuXHRcdHRoaXMuX29uUG9pbnRlckhvdmVyID0gb25Qb2ludGVySG92ZXIuYmluZCggdGhpcyApO1xuXHRcdHRoaXMuX29uUG9pbnRlck1vdmUgPSBvblBvaW50ZXJNb3ZlLmJpbmQoIHRoaXMgKTtcblx0XHR0aGlzLl9vblBvaW50ZXJVcCA9IG9uUG9pbnRlclVwLmJpbmQoIHRoaXMgKTtcblxuXHRcdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblBvaW50ZXJEb3duICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVybW92ZScsIHRoaXMuX29uUG9pbnRlckhvdmVyICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVydXAnLCB0aGlzLl9vblBvaW50ZXJVcCApO1xuXG5cdH1cblxuXHQvLyB1cGRhdGVNYXRyaXhXb3JsZCAgdXBkYXRlcyBrZXkgdHJhbnNmb3JtYXRpb24gdmFyaWFibGVzXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCkge1xuXG5cdFx0aWYgKCB0aGlzLm9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHRpZiAoIHRoaXMub2JqZWN0LnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVHJhbnNmb3JtQ29udHJvbHM6IFRoZSBhdHRhY2hlZCAzRCBvYmplY3QgbXVzdCBiZSBhIHBhcnQgb2YgdGhlIHNjZW5lIGdyYXBoLicgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLm9iamVjdC5wYXJlbnQubWF0cml4V29ybGQuZGVjb21wb3NlKCB0aGlzLl9wYXJlbnRQb3NpdGlvbiwgdGhpcy5fcGFyZW50UXVhdGVybmlvbiwgdGhpcy5fcGFyZW50U2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9iamVjdC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHRoaXMud29ybGRQb3NpdGlvbiwgdGhpcy53b3JsZFF1YXRlcm5pb24sIHRoaXMuX3dvcmxkU2NhbGUgKTtcblxuXHRcdFx0dGhpcy5fcGFyZW50UXVhdGVybmlvbkludi5jb3B5KCB0aGlzLl9wYXJlbnRRdWF0ZXJuaW9uICkuaW52ZXJ0KCk7XG5cdFx0XHR0aGlzLl93b3JsZFF1YXRlcm5pb25JbnYuY29weSggdGhpcy53b3JsZFF1YXRlcm5pb24gKS5pbnZlcnQoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cdFx0dGhpcy5jYW1lcmEubWF0cml4V29ybGQuZGVjb21wb3NlKCB0aGlzLmNhbWVyYVBvc2l0aW9uLCB0aGlzLmNhbWVyYVF1YXRlcm5pb24sIHRoaXMuX2NhbWVyYVNjYWxlICk7XG5cblx0XHRpZiAoIHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHR0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbiggdGhpcy5leWUgKS5uZWdhdGUoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZXllLmNvcHkoIHRoaXMuY2FtZXJhUG9zaXRpb24gKS5zdWIoIHRoaXMud29ybGRQb3NpdGlvbiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fVxuXG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIHRoaXMgKTtcblxuXHR9XG5cblx0cG9pbnRlckhvdmVyKCBwb2ludGVyICkge1xuXG5cdFx0aWYgKCB0aGlzLm9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuZHJhZ2dpbmcgPT09IHRydWUgKSByZXR1cm47XG5cblx0XHRfcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoIHBvaW50ZXIsIHRoaXMuY2FtZXJhICk7XG5cblx0XHRjb25zdCBpbnRlcnNlY3QgPSBpbnRlcnNlY3RPYmplY3RXaXRoUmF5KCB0aGlzLl9naXptby5waWNrZXJbIHRoaXMubW9kZSBdLCBfcmF5Y2FzdGVyICk7XG5cblx0XHRpZiAoIGludGVyc2VjdCApIHtcblxuXHRcdFx0dGhpcy5heGlzID0gaW50ZXJzZWN0Lm9iamVjdC5uYW1lO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5heGlzID0gbnVsbDtcblxuXHRcdH1cblxuXHR9XG5cblx0cG9pbnRlckRvd24oIHBvaW50ZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMub2JqZWN0ID09PSB1bmRlZmluZWQgfHwgdGhpcy5kcmFnZ2luZyA9PT0gdHJ1ZSB8fCBwb2ludGVyLmJ1dHRvbiAhPT0gMCApIHJldHVybjtcblxuXHRcdGlmICggdGhpcy5heGlzICE9PSBudWxsICkge1xuXG5cdFx0XHRfcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoIHBvaW50ZXIsIHRoaXMuY2FtZXJhICk7XG5cblx0XHRcdGNvbnN0IHBsYW5lSW50ZXJzZWN0ID0gaW50ZXJzZWN0T2JqZWN0V2l0aFJheSggdGhpcy5fcGxhbmUsIF9yYXljYXN0ZXIsIHRydWUgKTtcblxuXHRcdFx0aWYgKCBwbGFuZUludGVyc2VjdCApIHtcblxuXHRcdFx0XHR0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdFx0XHR0aGlzLm9iamVjdC5wYXJlbnQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0XHR0aGlzLl9wb3NpdGlvblN0YXJ0LmNvcHkoIHRoaXMub2JqZWN0LnBvc2l0aW9uICk7XG5cdFx0XHRcdHRoaXMuX3F1YXRlcm5pb25TdGFydC5jb3B5KCB0aGlzLm9iamVjdC5xdWF0ZXJuaW9uICk7XG5cdFx0XHRcdHRoaXMuX3NjYWxlU3RhcnQuY29weSggdGhpcy5vYmplY3Quc2NhbGUgKTtcblxuXHRcdFx0XHR0aGlzLm9iamVjdC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHRoaXMud29ybGRQb3NpdGlvblN0YXJ0LCB0aGlzLndvcmxkUXVhdGVybmlvblN0YXJ0LCB0aGlzLl93b3JsZFNjYWxlU3RhcnQgKTtcblxuXHRcdFx0XHR0aGlzLnBvaW50U3RhcnQuY29weSggcGxhbmVJbnRlcnNlY3QucG9pbnQgKS5zdWIoIHRoaXMud29ybGRQb3NpdGlvblN0YXJ0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cdFx0XHRfbW91c2VEb3duRXZlbnQubW9kZSA9IHRoaXMubW9kZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggX21vdXNlRG93bkV2ZW50ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHBvaW50ZXJNb3ZlKCBwb2ludGVyICkge1xuXG5cdFx0Y29uc3QgYXhpcyA9IHRoaXMuYXhpcztcblx0XHRjb25zdCBtb2RlID0gdGhpcy5tb2RlO1xuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMub2JqZWN0O1xuXHRcdGxldCBzcGFjZSA9IHRoaXMuc3BhY2U7XG5cblx0XHRpZiAoIG1vZGUgPT09ICdzY2FsZScgKSB7XG5cblx0XHRcdHNwYWNlID0gJ2xvY2FsJztcblxuXHRcdH0gZWxzZSBpZiAoIGF4aXMgPT09ICdFJyB8fCBheGlzID09PSAnWFlaRScgfHwgYXhpcyA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdHNwYWNlID0gJ3dvcmxkJztcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgfHwgYXhpcyA9PT0gbnVsbCB8fCB0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCBwb2ludGVyLmJ1dHRvbiAhPT0gLSAxICkgcmV0dXJuO1xuXG5cdFx0X3JheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCBwb2ludGVyLCB0aGlzLmNhbWVyYSApO1xuXG5cdFx0Y29uc3QgcGxhbmVJbnRlcnNlY3QgPSBpbnRlcnNlY3RPYmplY3RXaXRoUmF5KCB0aGlzLl9wbGFuZSwgX3JheWNhc3RlciwgdHJ1ZSApO1xuXG5cdFx0aWYgKCAhIHBsYW5lSW50ZXJzZWN0ICkgcmV0dXJuO1xuXG5cdFx0dGhpcy5wb2ludEVuZC5jb3B5KCBwbGFuZUludGVyc2VjdC5wb2ludCApLnN1YiggdGhpcy53b3JsZFBvc2l0aW9uU3RhcnQgKTtcblxuXHRcdGlmICggbW9kZSA9PT0gJ3RyYW5zbGF0ZScgKSB7XG5cblx0XHRcdC8vIEFwcGx5IHRyYW5zbGF0ZVxuXG5cdFx0XHR0aGlzLl9vZmZzZXQuY29weSggdGhpcy5wb2ludEVuZCApLnN1YiggdGhpcy5wb2ludFN0YXJ0ICk7XG5cblx0XHRcdGlmICggc3BhY2UgPT09ICdsb2NhbCcgJiYgYXhpcyAhPT0gJ1hZWicgKSB7XG5cblx0XHRcdFx0dGhpcy5fb2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggdGhpcy5fd29ybGRRdWF0ZXJuaW9uSW52ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBheGlzLmluZGV4T2YoICdYJyApID09PSAtIDEgKSB0aGlzLl9vZmZzZXQueCA9IDA7XG5cdFx0XHRpZiAoIGF4aXMuaW5kZXhPZiggJ1knICkgPT09IC0gMSApIHRoaXMuX29mZnNldC55ID0gMDtcblx0XHRcdGlmICggYXhpcy5pbmRleE9mKCAnWicgKSA9PT0gLSAxICkgdGhpcy5fb2Zmc2V0LnogPSAwO1xuXG5cdFx0XHRpZiAoIHNwYWNlID09PSAnbG9jYWwnICYmIGF4aXMgIT09ICdYWVonICkge1xuXG5cdFx0XHRcdHRoaXMuX29mZnNldC5hcHBseVF1YXRlcm5pb24oIHRoaXMuX3F1YXRlcm5pb25TdGFydCApLmRpdmlkZSggdGhpcy5fcGFyZW50U2NhbGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl9vZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzLl9wYXJlbnRRdWF0ZXJuaW9uSW52ICkuZGl2aWRlKCB0aGlzLl9wYXJlbnRTY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5wb3NpdGlvbi5jb3B5KCB0aGlzLl9vZmZzZXQgKS5hZGQoIHRoaXMuX3Bvc2l0aW9uU3RhcnQgKTtcblxuXHRcdFx0Ly8gQXBwbHkgdHJhbnNsYXRpb24gc25hcFxuXG5cdFx0XHRpZiAoIHRoaXMudHJhbnNsYXRpb25TbmFwICkge1xuXG5cdFx0XHRcdGlmICggc3BhY2UgPT09ICdsb2NhbCcgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uYXBwbHlRdWF0ZXJuaW9uKCBfdGVtcFF1YXRlcm5pb24uY29weSggdGhpcy5fcXVhdGVybmlvblN0YXJ0ICkuaW52ZXJ0KCkgKTtcblxuXHRcdFx0XHRcdGlmICggYXhpcy5zZWFyY2goICdYJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi54ID0gTWF0aC5yb3VuZCggb2JqZWN0LnBvc2l0aW9uLnggLyB0aGlzLnRyYW5zbGF0aW9uU25hcCApICogdGhpcy50cmFuc2xhdGlvblNuYXA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGF4aXMuc2VhcmNoKCAnWScgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24ueSA9IE1hdGgucm91bmQoIG9iamVjdC5wb3NpdGlvbi55IC8gdGhpcy50cmFuc2xhdGlvblNuYXAgKSAqIHRoaXMudHJhbnNsYXRpb25TbmFwO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBheGlzLnNlYXJjaCggJ1onICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLnogPSBNYXRoLnJvdW5kKCBvYmplY3QucG9zaXRpb24ueiAvIHRoaXMudHJhbnNsYXRpb25TbmFwICkgKiB0aGlzLnRyYW5zbGF0aW9uU25hcDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi5hcHBseVF1YXRlcm5pb24oIHRoaXMuX3F1YXRlcm5pb25TdGFydCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNwYWNlID09PSAnd29ybGQnICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QucGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uYWRkKCBfdGVtcFZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5wYXJlbnQubWF0cml4V29ybGQgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBheGlzLnNlYXJjaCggJ1gnICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLnggPSBNYXRoLnJvdW5kKCBvYmplY3QucG9zaXRpb24ueCAvIHRoaXMudHJhbnNsYXRpb25TbmFwICkgKiB0aGlzLnRyYW5zbGF0aW9uU25hcDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYXhpcy5zZWFyY2goICdZJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi55ID0gTWF0aC5yb3VuZCggb2JqZWN0LnBvc2l0aW9uLnkgLyB0aGlzLnRyYW5zbGF0aW9uU25hcCApICogdGhpcy50cmFuc2xhdGlvblNuYXA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGF4aXMuc2VhcmNoKCAnWicgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24ueiA9IE1hdGgucm91bmQoIG9iamVjdC5wb3NpdGlvbi56IC8gdGhpcy50cmFuc2xhdGlvblNuYXAgKSAqIHRoaXMudHJhbnNsYXRpb25TbmFwO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QucGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uc3ViKCBfdGVtcFZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5wYXJlbnQubWF0cml4V29ybGQgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggbW9kZSA9PT0gJ3NjYWxlJyApIHtcblxuXHRcdFx0aWYgKCBheGlzLnNlYXJjaCggJ1hZWicgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdGxldCBkID0gdGhpcy5wb2ludEVuZC5sZW5ndGgoKSAvIHRoaXMucG9pbnRTdGFydC5sZW5ndGgoKTtcblxuXHRcdFx0XHRpZiAoIHRoaXMucG9pbnRFbmQuZG90KCB0aGlzLnBvaW50U3RhcnQgKSA8IDAgKSBkICo9IC0gMTtcblxuXHRcdFx0XHRfdGVtcFZlY3RvcjIuc2V0KCBkLCBkLCBkICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3RlbXBWZWN0b3IuY29weSggdGhpcy5wb2ludFN0YXJ0ICk7XG5cdFx0XHRcdF90ZW1wVmVjdG9yMi5jb3B5KCB0aGlzLnBvaW50RW5kICk7XG5cblx0XHRcdFx0X3RlbXBWZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzLl93b3JsZFF1YXRlcm5pb25JbnYgKTtcblx0XHRcdFx0X3RlbXBWZWN0b3IyLmFwcGx5UXVhdGVybmlvbiggdGhpcy5fd29ybGRRdWF0ZXJuaW9uSW52ICk7XG5cblx0XHRcdFx0X3RlbXBWZWN0b3IyLmRpdmlkZSggX3RlbXBWZWN0b3IgKTtcblxuXHRcdFx0XHRpZiAoIGF4aXMuc2VhcmNoKCAnWCcgKSA9PT0gLSAxICkge1xuXG5cdFx0XHRcdFx0X3RlbXBWZWN0b3IyLnggPSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGF4aXMuc2VhcmNoKCAnWScgKSA9PT0gLSAxICkge1xuXG5cdFx0XHRcdFx0X3RlbXBWZWN0b3IyLnkgPSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGF4aXMuc2VhcmNoKCAnWicgKSA9PT0gLSAxICkge1xuXG5cdFx0XHRcdFx0X3RlbXBWZWN0b3IyLnogPSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBzY2FsZVxuXG5cdFx0XHRvYmplY3Quc2NhbGUuY29weSggdGhpcy5fc2NhbGVTdGFydCApLm11bHRpcGx5KCBfdGVtcFZlY3RvcjIgKTtcblxuXHRcdFx0aWYgKCB0aGlzLnNjYWxlU25hcCApIHtcblxuXHRcdFx0XHRpZiAoIGF4aXMuc2VhcmNoKCAnWCcgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LnNjYWxlLnggPSBNYXRoLnJvdW5kKCBvYmplY3Quc2NhbGUueCAvIHRoaXMuc2NhbGVTbmFwICkgKiB0aGlzLnNjYWxlU25hcCB8fCB0aGlzLnNjYWxlU25hcDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBheGlzLnNlYXJjaCggJ1knICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5zY2FsZS55ID0gTWF0aC5yb3VuZCggb2JqZWN0LnNjYWxlLnkgLyB0aGlzLnNjYWxlU25hcCApICogdGhpcy5zY2FsZVNuYXAgfHwgdGhpcy5zY2FsZVNuYXA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggYXhpcy5zZWFyY2goICdaJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRvYmplY3Quc2NhbGUueiA9IE1hdGgucm91bmQoIG9iamVjdC5zY2FsZS56IC8gdGhpcy5zY2FsZVNuYXAgKSAqIHRoaXMuc2NhbGVTbmFwIHx8IHRoaXMuc2NhbGVTbmFwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggbW9kZSA9PT0gJ3JvdGF0ZScgKSB7XG5cblx0XHRcdHRoaXMuX29mZnNldC5jb3B5KCB0aGlzLnBvaW50RW5kICkuc3ViKCB0aGlzLnBvaW50U3RhcnQgKTtcblxuXHRcdFx0Y29uc3QgUk9UQVRJT05fU1BFRUQgPSAyMCAvIHRoaXMud29ybGRQb3NpdGlvbi5kaXN0YW5jZVRvKCBfdGVtcFZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcblxuXHRcdFx0bGV0IF9pblBsYW5lUm90YXRpb24gPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBheGlzID09PSAnWFlaRScgKSB7XG5cblx0XHRcdFx0dGhpcy5yb3RhdGlvbkF4aXMuY29weSggdGhpcy5fb2Zmc2V0ICkuY3Jvc3MoIHRoaXMuZXllICkubm9ybWFsaXplKCk7XG5cdFx0XHRcdHRoaXMucm90YXRpb25BbmdsZSA9IHRoaXMuX29mZnNldC5kb3QoIF90ZW1wVmVjdG9yLmNvcHkoIHRoaXMucm90YXRpb25BeGlzICkuY3Jvc3MoIHRoaXMuZXllICkgKSAqIFJPVEFUSU9OX1NQRUVEO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBheGlzID09PSAnWCcgfHwgYXhpcyA9PT0gJ1knIHx8IGF4aXMgPT09ICdaJyApIHtcblxuXHRcdFx0XHR0aGlzLnJvdGF0aW9uQXhpcy5jb3B5KCBfdW5pdFsgYXhpcyBdICk7XG5cblx0XHRcdFx0X3RlbXBWZWN0b3IuY29weSggX3VuaXRbIGF4aXMgXSApO1xuXG5cdFx0XHRcdGlmICggc3BhY2UgPT09ICdsb2NhbCcgKSB7XG5cblx0XHRcdFx0XHRfdGVtcFZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHRoaXMud29ybGRRdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF90ZW1wVmVjdG9yLmNyb3NzKCB0aGlzLmV5ZSApO1xuXG5cdFx0XHRcdC8vIFdoZW4gX3RlbXBWZWN0b3IgaXMgMCBhZnRlciBjcm9zcyB3aXRoIHRoaXMuZXllIHRoZSB2ZWN0b3JzIGFyZSBwYXJhbGxlbCBhbmQgc2hvdWxkIHVzZSBpbi1wbGFuZSByb3RhdGlvbiBsb2dpYy5cblx0XHRcdFx0aWYgKCBfdGVtcFZlY3Rvci5sZW5ndGgoKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdF9pblBsYW5lUm90YXRpb24gPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLnJvdGF0aW9uQW5nbGUgPSB0aGlzLl9vZmZzZXQuZG90KCBfdGVtcFZlY3Rvci5ub3JtYWxpemUoKSApICogUk9UQVRJT05fU1BFRUQ7XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBheGlzID09PSAnRScgfHwgX2luUGxhbmVSb3RhdGlvbiApIHtcblxuXHRcdFx0XHR0aGlzLnJvdGF0aW9uQXhpcy5jb3B5KCB0aGlzLmV5ZSApO1xuXHRcdFx0XHR0aGlzLnJvdGF0aW9uQW5nbGUgPSB0aGlzLnBvaW50RW5kLmFuZ2xlVG8oIHRoaXMucG9pbnRTdGFydCApO1xuXG5cdFx0XHRcdHRoaXMuX3N0YXJ0Tm9ybS5jb3B5KCB0aGlzLnBvaW50U3RhcnQgKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0dGhpcy5fZW5kTm9ybS5jb3B5KCB0aGlzLnBvaW50RW5kICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0dGhpcy5yb3RhdGlvbkFuZ2xlICo9ICggdGhpcy5fZW5kTm9ybS5jcm9zcyggdGhpcy5fc3RhcnROb3JtICkuZG90KCB0aGlzLmV5ZSApIDwgMCA/IDEgOiAtIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSByb3RhdGlvbiBzbmFwXG5cblx0XHRcdGlmICggdGhpcy5yb3RhdGlvblNuYXAgKSB0aGlzLnJvdGF0aW9uQW5nbGUgPSBNYXRoLnJvdW5kKCB0aGlzLnJvdGF0aW9uQW5nbGUgLyB0aGlzLnJvdGF0aW9uU25hcCApICogdGhpcy5yb3RhdGlvblNuYXA7XG5cblx0XHRcdC8vIEFwcGx5IHJvdGF0ZVxuXHRcdFx0aWYgKCBzcGFjZSA9PT0gJ2xvY2FsJyAmJiBheGlzICE9PSAnRScgJiYgYXhpcyAhPT0gJ1hZWkUnICkge1xuXG5cdFx0XHRcdG9iamVjdC5xdWF0ZXJuaW9uLmNvcHkoIHRoaXMuX3F1YXRlcm5pb25TdGFydCApO1xuXHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5tdWx0aXBseSggX3RlbXBRdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIHRoaXMucm90YXRpb25BeGlzLCB0aGlzLnJvdGF0aW9uQW5nbGUgKSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMucm90YXRpb25BeGlzLmFwcGx5UXVhdGVybmlvbiggdGhpcy5fcGFyZW50UXVhdGVybmlvbkludiApO1xuXHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5jb3B5KCBfdGVtcFF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggdGhpcy5yb3RhdGlvbkF4aXMsIHRoaXMucm90YXRpb25BbmdsZSApICk7XG5cdFx0XHRcdG9iamVjdC5xdWF0ZXJuaW9uLm11bHRpcGx5KCB0aGlzLl9xdWF0ZXJuaW9uU3RhcnQgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBfY2hhbmdlRXZlbnQgKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIF9vYmplY3RDaGFuZ2VFdmVudCApO1xuXG5cdH1cblxuXHRwb2ludGVyVXAoIHBvaW50ZXIgKSB7XG5cblx0XHRpZiAoIHBvaW50ZXIuYnV0dG9uICE9PSAwICkgcmV0dXJuO1xuXG5cdFx0aWYgKCB0aGlzLmRyYWdnaW5nICYmICggdGhpcy5heGlzICE9PSBudWxsICkgKSB7XG5cblx0XHRcdF9tb3VzZVVwRXZlbnQubW9kZSA9IHRoaXMubW9kZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggX21vdXNlVXBFdmVudCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHRoaXMuYXhpcyA9IG51bGw7XG5cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJkb3duJywgdGhpcy5fb25Qb2ludGVyRG93biApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblBvaW50ZXJIb3ZlciApO1xuXHRcdHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblBvaW50ZXJNb3ZlICk7XG5cdFx0dGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdwb2ludGVydXAnLCB0aGlzLl9vblBvaW50ZXJVcCApO1xuXG5cdFx0dGhpcy50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0aWYgKCBjaGlsZC5nZW9tZXRyeSApIGNoaWxkLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdGlmICggY2hpbGQubWF0ZXJpYWwgKSBjaGlsZC5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8vIFNldCBjdXJyZW50IG9iamVjdFxuXHRhdHRhY2goIG9iamVjdCApIHtcblxuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly8gRGV0YWNoIGZyb20gb2JqZWN0XG5cdGRldGFjaCgpIHtcblxuXHRcdHRoaXMub2JqZWN0ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuXHRcdHRoaXMuYXhpcyA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVzZXQoKSB7XG5cblx0XHRpZiAoICEgdGhpcy5lbmFibGVkICkgcmV0dXJuO1xuXG5cdFx0aWYgKCB0aGlzLmRyYWdnaW5nICkge1xuXG5cdFx0XHR0aGlzLm9iamVjdC5wb3NpdGlvbi5jb3B5KCB0aGlzLl9wb3NpdGlvblN0YXJ0ICk7XG5cdFx0XHR0aGlzLm9iamVjdC5xdWF0ZXJuaW9uLmNvcHkoIHRoaXMuX3F1YXRlcm5pb25TdGFydCApO1xuXHRcdFx0dGhpcy5vYmplY3Quc2NhbGUuY29weSggdGhpcy5fc2NhbGVTdGFydCApO1xuXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIF9jaGFuZ2VFdmVudCApO1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCBfb2JqZWN0Q2hhbmdlRXZlbnQgKTtcblxuXHRcdFx0dGhpcy5wb2ludFN0YXJ0LmNvcHkoIHRoaXMucG9pbnRFbmQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2V0UmF5Y2FzdGVyKCkge1xuXG5cdFx0cmV0dXJuIF9yYXljYXN0ZXI7XG5cblx0fVxuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZVxuXG5cdGdldE1vZGUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tb2RlO1xuXG5cdH1cblxuXHRzZXRNb2RlKCBtb2RlICkge1xuXG5cdFx0dGhpcy5tb2RlID0gbW9kZTtcblxuXHR9XG5cblx0c2V0VHJhbnNsYXRpb25TbmFwKCB0cmFuc2xhdGlvblNuYXAgKSB7XG5cblx0XHR0aGlzLnRyYW5zbGF0aW9uU25hcCA9IHRyYW5zbGF0aW9uU25hcDtcblxuXHR9XG5cblx0c2V0Um90YXRpb25TbmFwKCByb3RhdGlvblNuYXAgKSB7XG5cblx0XHR0aGlzLnJvdGF0aW9uU25hcCA9IHJvdGF0aW9uU25hcDtcblxuXHR9XG5cblx0c2V0U2NhbGVTbmFwKCBzY2FsZVNuYXAgKSB7XG5cblx0XHR0aGlzLnNjYWxlU25hcCA9IHNjYWxlU25hcDtcblxuXHR9XG5cblx0c2V0U2l6ZSggc2l6ZSApIHtcblxuXHRcdHRoaXMuc2l6ZSA9IHNpemU7XG5cblx0fVxuXG5cdHNldFNwYWNlKCBzcGFjZSApIHtcblxuXHRcdHRoaXMuc3BhY2UgPSBzcGFjZTtcblxuXHR9XG5cbn1cblxuLy8gbW91c2UgLyB0b3VjaCBldmVudCBoYW5kbGVyc1xuXG5mdW5jdGlvbiBnZXRQb2ludGVyKCBldmVudCApIHtcblxuXHRpZiAoIHRoaXMuZG9tRWxlbWVudC5vd25lckRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiAwLFxuXHRcdFx0eTogMCxcblx0XHRcdGJ1dHRvbjogZXZlbnQuYnV0dG9uXG5cdFx0fTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc3QgcmVjdCA9IHRoaXMuZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiAoIGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgKSAvIHJlY3Qud2lkdGggKiAyIC0gMSxcblx0XHRcdHk6IC0gKCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgKSAvIHJlY3QuaGVpZ2h0ICogMiArIDEsXG5cdFx0XHRidXR0b246IGV2ZW50LmJ1dHRvblxuXHRcdH07XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIG9uUG9pbnRlckhvdmVyKCBldmVudCApIHtcblxuXHRpZiAoICEgdGhpcy5lbmFibGVkICkgcmV0dXJuO1xuXG5cdHN3aXRjaCAoIGV2ZW50LnBvaW50ZXJUeXBlICkge1xuXG5cdFx0Y2FzZSAnbW91c2UnOlxuXHRcdGNhc2UgJ3Blbic6XG5cdFx0XHR0aGlzLnBvaW50ZXJIb3ZlciggdGhpcy5fZ2V0UG9pbnRlciggZXZlbnQgKSApO1xuXHRcdFx0YnJlYWs7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIG9uUG9pbnRlckRvd24oIGV2ZW50ICkge1xuXG5cdGlmICggISB0aGlzLmVuYWJsZWQgKSByZXR1cm47XG5cblx0aWYgKCAhIGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCApIHtcblxuXHRcdHRoaXMuZG9tRWxlbWVudC5zZXRQb2ludGVyQ2FwdHVyZSggZXZlbnQucG9pbnRlcklkICk7XG5cblx0fVxuXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblBvaW50ZXJNb3ZlICk7XG5cblx0dGhpcy5wb2ludGVySG92ZXIoIHRoaXMuX2dldFBvaW50ZXIoIGV2ZW50ICkgKTtcblx0dGhpcy5wb2ludGVyRG93biggdGhpcy5fZ2V0UG9pbnRlciggZXZlbnQgKSApO1xuXG59XG5cbmZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoIGV2ZW50ICkge1xuXG5cdGlmICggISB0aGlzLmVuYWJsZWQgKSByZXR1cm47XG5cblx0dGhpcy5wb2ludGVyTW92ZSggdGhpcy5fZ2V0UG9pbnRlciggZXZlbnQgKSApO1xuXG59XG5cbmZ1bmN0aW9uIG9uUG9pbnRlclVwKCBldmVudCApIHtcblxuXHRpZiAoICEgdGhpcy5lbmFibGVkICkgcmV0dXJuO1xuXG5cdHRoaXMuZG9tRWxlbWVudC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoIGV2ZW50LnBvaW50ZXJJZCApO1xuXG5cdHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAncG9pbnRlcm1vdmUnLCB0aGlzLl9vblBvaW50ZXJNb3ZlICk7XG5cblx0dGhpcy5wb2ludGVyVXAoIHRoaXMuX2dldFBvaW50ZXIoIGV2ZW50ICkgKTtcblxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RPYmplY3RXaXRoUmF5KCBvYmplY3QsIHJheWNhc3RlciwgaW5jbHVkZUludmlzaWJsZSApIHtcblxuXHRjb25zdCBhbGxJbnRlcnNlY3Rpb25zID0gcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0cnVlICk7XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYWxsSW50ZXJzZWN0aW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRpZiAoIGFsbEludGVyc2VjdGlvbnNbIGkgXS5vYmplY3QudmlzaWJsZSB8fCBpbmNsdWRlSW52aXNpYmxlICkge1xuXG5cdFx0XHRyZXR1cm4gYWxsSW50ZXJzZWN0aW9uc1sgaSBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG5cbn1cblxuLy9cblxuLy8gUmV1c2FibGUgdXRpbGl0eSB2YXJpYWJsZXNcblxuY29uc3QgX3RlbXBFdWxlciA9IG5ldyBFdWxlcigpO1xuY29uc3QgX2FsaWduVmVjdG9yID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcbmNvbnN0IF96ZXJvVmVjdG9yID0gbmV3IFZlY3RvcjMoIDAsIDAsIDAgKTtcbmNvbnN0IF9sb29rQXRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3RlbXBRdWF0ZXJuaW9uMiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5jb25zdCBfaWRlbnRpdHlRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IF9kaXJWZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3RlbXBNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5jb25zdCBfdW5pdFggPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xuY29uc3QgX3VuaXRZID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcbmNvbnN0IF91bml0WiA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XG5cbmNvbnN0IF92MSA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdjIgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YzID0gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgVHJhbnNmb3JtQ29udHJvbHNHaXptbyBleHRlbmRzIE9iamVjdDNEIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzVHJhbnNmb3JtQ29udHJvbHNHaXptbyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnVHJhbnNmb3JtQ29udHJvbHNHaXptbyc7XG5cblx0XHQvLyBzaGFyZWQgbWF0ZXJpYWxzXG5cblx0XHRjb25zdCBnaXptb01hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7XG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHRmb2c6IGZhbHNlLFxuXHRcdFx0dG9uZU1hcHBlZDogZmFsc2UsXG5cdFx0XHR0cmFuc3BhcmVudDogdHJ1ZVxuXHRcdH0gKTtcblxuXHRcdGNvbnN0IGdpem1vTGluZU1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7XG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHRmb2c6IGZhbHNlLFxuXHRcdFx0dG9uZU1hcHBlZDogZmFsc2UsXG5cdFx0XHR0cmFuc3BhcmVudDogdHJ1ZVxuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdW5pcXVlIG1hdGVyaWFsIGZvciBlYWNoIGF4aXMvY29sb3JcblxuXHRcdGNvbnN0IG1hdEludmlzaWJsZSA9IGdpem1vTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRJbnZpc2libGUub3BhY2l0eSA9IDAuMTU7XG5cblx0XHRjb25zdCBtYXRIZWxwZXIgPSBnaXptb0xpbmVNYXRlcmlhbC5jbG9uZSgpO1xuXHRcdG1hdEhlbHBlci5vcGFjaXR5ID0gMC41O1xuXG5cdFx0Y29uc3QgbWF0UmVkID0gZ2l6bW9NYXRlcmlhbC5jbG9uZSgpO1xuXHRcdG1hdFJlZC5jb2xvci5zZXRIZXgoIDB4ZmYwMDAwICk7XG5cblx0XHRjb25zdCBtYXRHcmVlbiA9IGdpem1vTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRHcmVlbi5jb2xvci5zZXRIZXgoIDB4MDBmZjAwICk7XG5cblx0XHRjb25zdCBtYXRCbHVlID0gZ2l6bW9NYXRlcmlhbC5jbG9uZSgpO1xuXHRcdG1hdEJsdWUuY29sb3Iuc2V0SGV4KCAweDAwMDBmZiApO1xuXG5cdFx0Y29uc3QgbWF0UmVkVHJhbnNwYXJlbnQgPSBnaXptb01hdGVyaWFsLmNsb25lKCk7XG5cdFx0bWF0UmVkVHJhbnNwYXJlbnQuY29sb3Iuc2V0SGV4KCAweGZmMDAwMCApO1xuXHRcdG1hdFJlZFRyYW5zcGFyZW50Lm9wYWNpdHkgPSAwLjU7XG5cblx0XHRjb25zdCBtYXRHcmVlblRyYW5zcGFyZW50ID0gZ2l6bW9NYXRlcmlhbC5jbG9uZSgpO1xuXHRcdG1hdEdyZWVuVHJhbnNwYXJlbnQuY29sb3Iuc2V0SGV4KCAweDAwZmYwMCApO1xuXHRcdG1hdEdyZWVuVHJhbnNwYXJlbnQub3BhY2l0eSA9IDAuNTtcblxuXHRcdGNvbnN0IG1hdEJsdWVUcmFuc3BhcmVudCA9IGdpem1vTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRCbHVlVHJhbnNwYXJlbnQuY29sb3Iuc2V0SGV4KCAweDAwMDBmZiApO1xuXHRcdG1hdEJsdWVUcmFuc3BhcmVudC5vcGFjaXR5ID0gMC41O1xuXG5cdFx0Y29uc3QgbWF0V2hpdGVUcmFuc3BhcmVudCA9IGdpem1vTWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRtYXRXaGl0ZVRyYW5zcGFyZW50Lm9wYWNpdHkgPSAwLjI1O1xuXG5cdFx0Y29uc3QgbWF0WWVsbG93VHJhbnNwYXJlbnQgPSBnaXptb01hdGVyaWFsLmNsb25lKCk7XG5cdFx0bWF0WWVsbG93VHJhbnNwYXJlbnQuY29sb3Iuc2V0SGV4KCAweGZmZmYwMCApO1xuXHRcdG1hdFllbGxvd1RyYW5zcGFyZW50Lm9wYWNpdHkgPSAwLjI1O1xuXG5cdFx0Y29uc3QgbWF0WWVsbG93ID0gZ2l6bW9NYXRlcmlhbC5jbG9uZSgpO1xuXHRcdG1hdFllbGxvdy5jb2xvci5zZXRIZXgoIDB4ZmZmZjAwICk7XG5cblx0XHRjb25zdCBtYXRHcmF5ID0gZ2l6bW9NYXRlcmlhbC5jbG9uZSgpO1xuXHRcdG1hdEdyYXkuY29sb3Iuc2V0SGV4KCAweDc4Nzg3OCApO1xuXG5cdFx0Ly8gcmV1c2FibGUgZ2VvbWV0cnlcblxuXHRcdGNvbnN0IGFycm93R2VvbWV0cnkgPSBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggMCwgMC4wNCwgMC4xLCAxMiApO1xuXHRcdGFycm93R2VvbWV0cnkudHJhbnNsYXRlKCAwLCAwLjA1LCAwICk7XG5cblx0XHRjb25zdCBzY2FsZUhhbmRsZUdlb21ldHJ5ID0gbmV3IEJveEdlb21ldHJ5KCAwLjA4LCAwLjA4LCAwLjA4ICk7XG5cdFx0c2NhbGVIYW5kbGVHZW9tZXRyeS50cmFuc2xhdGUoIDAsIDAuMDQsIDAgKTtcblxuXHRcdGNvbnN0IGxpbmVHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGxpbmVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbIDAsIDAsIDAsXHQxLCAwLCAwIF0sIDMgKSApO1xuXG5cdFx0Y29uc3QgbGluZUdlb21ldHJ5MiA9IG5ldyBDeWxpbmRlckdlb21ldHJ5KCAwLjAwNzUsIDAuMDA3NSwgMC41LCAzICk7XG5cdFx0bGluZUdlb21ldHJ5Mi50cmFuc2xhdGUoIDAsIDAuMjUsIDAgKTtcblxuXHRcdGZ1bmN0aW9uIENpcmNsZUdlb21ldHJ5KCByYWRpdXMsIGFyYyApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgVG9ydXNHZW9tZXRyeSggcmFkaXVzLCAwLjAwNzUsIDMsIDY0LCBhcmMgKiBNYXRoLlBJICogMiApO1xuXHRcdFx0Z2VvbWV0cnkucm90YXRlWSggTWF0aC5QSSAvIDIgKTtcblx0XHRcdGdlb21ldHJ5LnJvdGF0ZVgoIE1hdGguUEkgLyAyICk7XG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHQvLyBTcGVjaWFsIGdlb21ldHJ5IGZvciB0cmFuc2Zvcm0gaGVscGVyLiBJZiBzY2FsZWQgd2l0aCBwb3NpdGlvbiB2ZWN0b3IgaXQgc3BhbnMgZnJvbSBbMCwwLDBdIHRvIHBvc2l0aW9uXG5cblx0XHRmdW5jdGlvbiBUcmFuc2xhdGVIZWxwZXJHZW9tZXRyeSgpIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggWyAwLCAwLCAwLCAxLCAxLCAxIF0sIDMgKSApO1xuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHQvLyBHaXptbyBkZWZpbml0aW9ucyAtIGN1c3RvbSBoaWVyYXJjaHkgZGVmaW5pdGlvbnMgZm9yIHNldHVwR2l6bW8oKSBmdW5jdGlvblxuXG5cdFx0Y29uc3QgZ2l6bW9UcmFuc2xhdGUgPSB7XG5cdFx0XHRYOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIGFycm93R2VvbWV0cnksIG1hdFJlZCApLCBbIDAuNSwgMCwgMCBdLCBbIDAsIDAsIC0gTWF0aC5QSSAvIDIgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIGFycm93R2VvbWV0cnksIG1hdFJlZCApLCBbIC0gMC41LCAwLCAwIF0sIFsgMCwgMCwgTWF0aC5QSSAvIDIgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIGxpbmVHZW9tZXRyeTIsIG1hdFJlZCApLCBbIDAsIDAsIDAgXSwgWyAwLCAwLCAtIE1hdGguUEkgLyAyIF1dXG5cdFx0XHRdLFxuXHRcdFx0WTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBhcnJvd0dlb21ldHJ5LCBtYXRHcmVlbiApLCBbIDAsIDAuNSwgMCBdXSxcblx0XHRcdFx0WyBuZXcgTWVzaCggYXJyb3dHZW9tZXRyeSwgbWF0R3JlZW4gKSwgWyAwLCAtIDAuNSwgMCBdLCBbIE1hdGguUEksIDAsIDAgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIGxpbmVHZW9tZXRyeTIsIG1hdEdyZWVuICkgXVxuXHRcdFx0XSxcblx0XHRcdFo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggYXJyb3dHZW9tZXRyeSwgbWF0Qmx1ZSApLCBbIDAsIDAsIDAuNSBdLCBbIE1hdGguUEkgLyAyLCAwLCAwIF1dLFxuXHRcdFx0XHRbIG5ldyBNZXNoKCBhcnJvd0dlb21ldHJ5LCBtYXRCbHVlICksIFsgMCwgMCwgLSAwLjUgXSwgWyAtIE1hdGguUEkgLyAyLCAwLCAwIF1dLFxuXHRcdFx0XHRbIG5ldyBNZXNoKCBsaW5lR2VvbWV0cnkyLCBtYXRCbHVlICksIG51bGwsIFsgTWF0aC5QSSAvIDIsIDAsIDAgXV1cblx0XHRcdF0sXG5cdFx0XHRYWVo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IE9jdGFoZWRyb25HZW9tZXRyeSggMC4xLCAwICksIG1hdFdoaXRlVHJhbnNwYXJlbnQuY2xvbmUoKSApLCBbIDAsIDAsIDAgXV1cblx0XHRcdF0sXG5cdFx0XHRYWTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQm94R2VvbWV0cnkoIDAuMTUsIDAuMTUsIDAuMDEgKSwgbWF0Qmx1ZVRyYW5zcGFyZW50LmNsb25lKCkgKSwgWyAwLjE1LCAwLjE1LCAwIF1dXG5cdFx0XHRdLFxuXHRcdFx0WVo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEJveEdlb21ldHJ5KCAwLjE1LCAwLjE1LCAwLjAxICksIG1hdFJlZFRyYW5zcGFyZW50LmNsb25lKCkgKSwgWyAwLCAwLjE1LCAwLjE1IF0sIFsgMCwgTWF0aC5QSSAvIDIsIDAgXV1cblx0XHRcdF0sXG5cdFx0XHRYWjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQm94R2VvbWV0cnkoIDAuMTUsIDAuMTUsIDAuMDEgKSwgbWF0R3JlZW5UcmFuc3BhcmVudC5jbG9uZSgpICksIFsgMC4xNSwgMCwgMC4xNSBdLCBbIC0gTWF0aC5QSSAvIDIsIDAsIDAgXV1cblx0XHRcdF1cblx0XHR9O1xuXG5cdFx0Y29uc3QgcGlja2VyVHJhbnNsYXRlID0ge1xuXHRcdFx0WDogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggMC4yLCAwLCAwLjYsIDQgKSwgbWF0SW52aXNpYmxlICksIFsgMC4zLCAwLCAwIF0sIFsgMCwgMCwgLSBNYXRoLlBJIC8gMiBdXSxcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEN5bGluZGVyR2VvbWV0cnkoIDAuMiwgMCwgMC42LCA0ICksIG1hdEludmlzaWJsZSApLCBbIC0gMC4zLCAwLCAwIF0sIFsgMCwgMCwgTWF0aC5QSSAvIDIgXV1cblx0XHRcdF0sXG5cdFx0XHRZOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBDeWxpbmRlckdlb21ldHJ5KCAwLjIsIDAsIDAuNiwgNCApLCBtYXRJbnZpc2libGUgKSwgWyAwLCAwLjMsIDAgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBDeWxpbmRlckdlb21ldHJ5KCAwLjIsIDAsIDAuNiwgNCApLCBtYXRJbnZpc2libGUgKSwgWyAwLCAtIDAuMywgMCBdLCBbIDAsIDAsIE1hdGguUEkgXV1cblx0XHRcdF0sXG5cdFx0XHRaOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBDeWxpbmRlckdlb21ldHJ5KCAwLjIsIDAsIDAuNiwgNCApLCBtYXRJbnZpc2libGUgKSwgWyAwLCAwLCAwLjMgXSwgWyBNYXRoLlBJIC8gMiwgMCwgMCBdXSxcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEN5bGluZGVyR2VvbWV0cnkoIDAuMiwgMCwgMC42LCA0ICksIG1hdEludmlzaWJsZSApLCBbIDAsIDAsIC0gMC4zIF0sIFsgLSBNYXRoLlBJIC8gMiwgMCwgMCBdXVxuXHRcdFx0XSxcblx0XHRcdFhZWjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KCAwLjIsIDAgKSwgbWF0SW52aXNpYmxlICkgXVxuXHRcdFx0XSxcblx0XHRcdFhZOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBCb3hHZW9tZXRyeSggMC4yLCAwLjIsIDAuMDEgKSwgbWF0SW52aXNpYmxlICksIFsgMC4xNSwgMC4xNSwgMCBdXVxuXHRcdFx0XSxcblx0XHRcdFlaOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBCb3hHZW9tZXRyeSggMC4yLCAwLjIsIDAuMDEgKSwgbWF0SW52aXNpYmxlICksIFsgMCwgMC4xNSwgMC4xNSBdLCBbIDAsIE1hdGguUEkgLyAyLCAwIF1dXG5cdFx0XHRdLFxuXHRcdFx0WFo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEJveEdlb21ldHJ5KCAwLjIsIDAuMiwgMC4wMSApLCBtYXRJbnZpc2libGUgKSwgWyAwLjE1LCAwLCAwLjE1IF0sIFsgLSBNYXRoLlBJIC8gMiwgMCwgMCBdXVxuXHRcdFx0XVxuXHRcdH07XG5cblx0XHRjb25zdCBoZWxwZXJUcmFuc2xhdGUgPSB7XG5cdFx0XHRTVEFSVDogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KCAwLjAxLCAyICksIG1hdEhlbHBlciApLCBudWxsLCBudWxsLCBudWxsLCAnaGVscGVyJyBdXG5cdFx0XHRdLFxuXHRcdFx0RU5EOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBPY3RhaGVkcm9uR2VvbWV0cnkoIDAuMDEsIDIgKSwgbWF0SGVscGVyICksIG51bGwsIG51bGwsIG51bGwsICdoZWxwZXInIF1cblx0XHRcdF0sXG5cdFx0XHRERUxUQTogW1xuXHRcdFx0XHRbIG5ldyBMaW5lKCBUcmFuc2xhdGVIZWxwZXJHZW9tZXRyeSgpLCBtYXRIZWxwZXIgKSwgbnVsbCwgbnVsbCwgbnVsbCwgJ2hlbHBlcicgXVxuXHRcdFx0XSxcblx0XHRcdFg6IFtcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRIZWxwZXIuY2xvbmUoKSApLCBbIC0gMWUzLCAwLCAwIF0sIG51bGwsIFsgMWU2LCAxLCAxIF0sICdoZWxwZXInIF1cblx0XHRcdF0sXG5cdFx0XHRZOiBbXG5cdFx0XHRcdFsgbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbWF0SGVscGVyLmNsb25lKCkgKSwgWyAwLCAtIDFlMywgMCBdLCBbIDAsIDAsIE1hdGguUEkgLyAyIF0sIFsgMWU2LCAxLCAxIF0sICdoZWxwZXInIF1cblx0XHRcdF0sXG5cdFx0XHRaOiBbXG5cdFx0XHRcdFsgbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbWF0SGVscGVyLmNsb25lKCkgKSwgWyAwLCAwLCAtIDFlMyBdLCBbIDAsIC0gTWF0aC5QSSAvIDIsIDAgXSwgWyAxZTYsIDEsIDEgXSwgJ2hlbHBlcicgXVxuXHRcdFx0XVxuXHRcdH07XG5cblx0XHRjb25zdCBnaXptb1JvdGF0ZSA9IHtcblx0XHRcdFhZWkU6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggQ2lyY2xlR2VvbWV0cnkoIDAuNSwgMSApLCBtYXRHcmF5ICksIG51bGwsIFsgMCwgTWF0aC5QSSAvIDIsIDAgXV1cblx0XHRcdF0sXG5cdFx0XHRYOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIENpcmNsZUdlb21ldHJ5KCAwLjUsIDAuNSApLCBtYXRSZWQgKSBdXG5cdFx0XHRdLFxuXHRcdFx0WTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBDaXJjbGVHZW9tZXRyeSggMC41LCAwLjUgKSwgbWF0R3JlZW4gKSwgbnVsbCwgWyAwLCAwLCAtIE1hdGguUEkgLyAyIF1dXG5cdFx0XHRdLFxuXHRcdFx0WjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBDaXJjbGVHZW9tZXRyeSggMC41LCAwLjUgKSwgbWF0Qmx1ZSApLCBudWxsLCBbIDAsIE1hdGguUEkgLyAyLCAwIF1dXG5cdFx0XHRdLFxuXHRcdFx0RTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBDaXJjbGVHZW9tZXRyeSggMC43NSwgMSApLCBtYXRZZWxsb3dUcmFuc3BhcmVudCApLCBudWxsLCBbIDAsIE1hdGguUEkgLyAyLCAwIF1dXG5cdFx0XHRdXG5cdFx0fTtcblxuXHRcdGNvbnN0IGhlbHBlclJvdGF0ZSA9IHtcblx0XHRcdEFYSVM6IFtcblx0XHRcdFx0WyBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBtYXRIZWxwZXIuY2xvbmUoKSApLCBbIC0gMWUzLCAwLCAwIF0sIG51bGwsIFsgMWU2LCAxLCAxIF0sICdoZWxwZXInIF1cblx0XHRcdF1cblx0XHR9O1xuXG5cdFx0Y29uc3QgcGlja2VyUm90YXRlID0ge1xuXHRcdFx0WFlaRTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgU3BoZXJlR2VvbWV0cnkoIDAuMjUsIDEwLCA4ICksIG1hdEludmlzaWJsZSApIF1cblx0XHRcdF0sXG5cdFx0XHRYOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBUb3J1c0dlb21ldHJ5KCAwLjUsIDAuMSwgNCwgMjQgKSwgbWF0SW52aXNpYmxlICksIFsgMCwgMCwgMCBdLCBbIDAsIC0gTWF0aC5QSSAvIDIsIC0gTWF0aC5QSSAvIDIgXV0sXG5cdFx0XHRdLFxuXHRcdFx0WTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgVG9ydXNHZW9tZXRyeSggMC41LCAwLjEsIDQsIDI0ICksIG1hdEludmlzaWJsZSApLCBbIDAsIDAsIDAgXSwgWyBNYXRoLlBJIC8gMiwgMCwgMCBdXSxcblx0XHRcdF0sXG5cdFx0XHRaOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBUb3J1c0dlb21ldHJ5KCAwLjUsIDAuMSwgNCwgMjQgKSwgbWF0SW52aXNpYmxlICksIFsgMCwgMCwgMCBdLCBbIDAsIDAsIC0gTWF0aC5QSSAvIDIgXV0sXG5cdFx0XHRdLFxuXHRcdFx0RTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgVG9ydXNHZW9tZXRyeSggMC43NSwgMC4xLCAyLCAyNCApLCBtYXRJbnZpc2libGUgKSBdXG5cdFx0XHRdXG5cdFx0fTtcblxuXHRcdGNvbnN0IGdpem1vU2NhbGUgPSB7XG5cdFx0XHRYOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIHNjYWxlSGFuZGxlR2VvbWV0cnksIG1hdFJlZCApLCBbIDAuNSwgMCwgMCBdLCBbIDAsIDAsIC0gTWF0aC5QSSAvIDIgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIGxpbmVHZW9tZXRyeTIsIG1hdFJlZCApLCBbIDAsIDAsIDAgXSwgWyAwLCAwLCAtIE1hdGguUEkgLyAyIF1dLFxuXHRcdFx0XHRbIG5ldyBNZXNoKCBzY2FsZUhhbmRsZUdlb21ldHJ5LCBtYXRSZWQgKSwgWyAtIDAuNSwgMCwgMCBdLCBbIDAsIDAsIE1hdGguUEkgLyAyIF1dLFxuXHRcdFx0XSxcblx0XHRcdFk6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggc2NhbGVIYW5kbGVHZW9tZXRyeSwgbWF0R3JlZW4gKSwgWyAwLCAwLjUsIDAgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIGxpbmVHZW9tZXRyeTIsIG1hdEdyZWVuICkgXSxcblx0XHRcdFx0WyBuZXcgTWVzaCggc2NhbGVIYW5kbGVHZW9tZXRyeSwgbWF0R3JlZW4gKSwgWyAwLCAtIDAuNSwgMCBdLCBbIDAsIDAsIE1hdGguUEkgXV0sXG5cdFx0XHRdLFxuXHRcdFx0WjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBzY2FsZUhhbmRsZUdlb21ldHJ5LCBtYXRCbHVlICksIFsgMCwgMCwgMC41IF0sIFsgTWF0aC5QSSAvIDIsIDAsIDAgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIGxpbmVHZW9tZXRyeTIsIG1hdEJsdWUgKSwgWyAwLCAwLCAwIF0sIFsgTWF0aC5QSSAvIDIsIDAsIDAgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIHNjYWxlSGFuZGxlR2VvbWV0cnksIG1hdEJsdWUgKSwgWyAwLCAwLCAtIDAuNSBdLCBbIC0gTWF0aC5QSSAvIDIsIDAsIDAgXV1cblx0XHRcdF0sXG5cdFx0XHRYWTogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQm94R2VvbWV0cnkoIDAuMTUsIDAuMTUsIDAuMDEgKSwgbWF0Qmx1ZVRyYW5zcGFyZW50ICksIFsgMC4xNSwgMC4xNSwgMCBdXVxuXHRcdFx0XSxcblx0XHRcdFlaOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBCb3hHZW9tZXRyeSggMC4xNSwgMC4xNSwgMC4wMSApLCBtYXRSZWRUcmFuc3BhcmVudCApLCBbIDAsIDAuMTUsIDAuMTUgXSwgWyAwLCBNYXRoLlBJIC8gMiwgMCBdXVxuXHRcdFx0XSxcblx0XHRcdFhaOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBCb3hHZW9tZXRyeSggMC4xNSwgMC4xNSwgMC4wMSApLCBtYXRHcmVlblRyYW5zcGFyZW50ICksIFsgMC4xNSwgMCwgMC4xNSBdLCBbIC0gTWF0aC5QSSAvIDIsIDAsIDAgXV1cblx0XHRcdF0sXG5cdFx0XHRYWVo6IFtcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEJveEdlb21ldHJ5KCAwLjEsIDAuMSwgMC4xICksIG1hdFdoaXRlVHJhbnNwYXJlbnQuY2xvbmUoKSApIF0sXG5cdFx0XHRdXG5cdFx0fTtcblxuXHRcdGNvbnN0IHBpY2tlclNjYWxlID0ge1xuXHRcdFx0WDogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggMC4yLCAwLCAwLjYsIDQgKSwgbWF0SW52aXNpYmxlICksIFsgMC4zLCAwLCAwIF0sIFsgMCwgMCwgLSBNYXRoLlBJIC8gMiBdXSxcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEN5bGluZGVyR2VvbWV0cnkoIDAuMiwgMCwgMC42LCA0ICksIG1hdEludmlzaWJsZSApLCBbIC0gMC4zLCAwLCAwIF0sIFsgMCwgMCwgTWF0aC5QSSAvIDIgXV1cblx0XHRcdF0sXG5cdFx0XHRZOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBDeWxpbmRlckdlb21ldHJ5KCAwLjIsIDAsIDAuNiwgNCApLCBtYXRJbnZpc2libGUgKSwgWyAwLCAwLjMsIDAgXV0sXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBDeWxpbmRlckdlb21ldHJ5KCAwLjIsIDAsIDAuNiwgNCApLCBtYXRJbnZpc2libGUgKSwgWyAwLCAtIDAuMywgMCBdLCBbIDAsIDAsIE1hdGguUEkgXV1cblx0XHRcdF0sXG5cdFx0XHRaOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBDeWxpbmRlckdlb21ldHJ5KCAwLjIsIDAsIDAuNiwgNCApLCBtYXRJbnZpc2libGUgKSwgWyAwLCAwLCAwLjMgXSwgWyBNYXRoLlBJIC8gMiwgMCwgMCBdXSxcblx0XHRcdFx0WyBuZXcgTWVzaCggbmV3IEN5bGluZGVyR2VvbWV0cnkoIDAuMiwgMCwgMC42LCA0ICksIG1hdEludmlzaWJsZSApLCBbIDAsIDAsIC0gMC4zIF0sIFsgLSBNYXRoLlBJIC8gMiwgMCwgMCBdXVxuXHRcdFx0XSxcblx0XHRcdFhZOiBbXG5cdFx0XHRcdFsgbmV3IE1lc2goIG5ldyBCb3hHZW9tZXRyeSggMC4yLCAwLjIsIDAuMDEgKSwgbWF0SW52aXNpYmxlICksIFsgMC4xNSwgMC4xNSwgMCBdXSxcblx0XHRcdF0sXG5cdFx0XHRZWjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQm94R2VvbWV0cnkoIDAuMiwgMC4yLCAwLjAxICksIG1hdEludmlzaWJsZSApLCBbIDAsIDAuMTUsIDAuMTUgXSwgWyAwLCBNYXRoLlBJIC8gMiwgMCBdXSxcblx0XHRcdF0sXG5cdFx0XHRYWjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQm94R2VvbWV0cnkoIDAuMiwgMC4yLCAwLjAxICksIG1hdEludmlzaWJsZSApLCBbIDAuMTUsIDAsIDAuMTUgXSwgWyAtIE1hdGguUEkgLyAyLCAwLCAwIF1dLFxuXHRcdFx0XSxcblx0XHRcdFhZWjogW1xuXHRcdFx0XHRbIG5ldyBNZXNoKCBuZXcgQm94R2VvbWV0cnkoIDAuMiwgMC4yLCAwLjIgKSwgbWF0SW52aXNpYmxlICksIFsgMCwgMCwgMCBdXSxcblx0XHRcdF1cblx0XHR9O1xuXG5cdFx0Y29uc3QgaGVscGVyU2NhbGUgPSB7XG5cdFx0XHRYOiBbXG5cdFx0XHRcdFsgbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbWF0SGVscGVyLmNsb25lKCkgKSwgWyAtIDFlMywgMCwgMCBdLCBudWxsLCBbIDFlNiwgMSwgMSBdLCAnaGVscGVyJyBdXG5cdFx0XHRdLFxuXHRcdFx0WTogW1xuXHRcdFx0XHRbIG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG1hdEhlbHBlci5jbG9uZSgpICksIFsgMCwgLSAxZTMsIDAgXSwgWyAwLCAwLCBNYXRoLlBJIC8gMiBdLCBbIDFlNiwgMSwgMSBdLCAnaGVscGVyJyBdXG5cdFx0XHRdLFxuXHRcdFx0WjogW1xuXHRcdFx0XHRbIG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG1hdEhlbHBlci5jbG9uZSgpICksIFsgMCwgMCwgLSAxZTMgXSwgWyAwLCAtIE1hdGguUEkgLyAyLCAwIF0sIFsgMWU2LCAxLCAxIF0sICdoZWxwZXInIF1cblx0XHRcdF1cblx0XHR9O1xuXG5cdFx0Ly8gQ3JlYXRlcyBhbiBPYmplY3QzRCB3aXRoIGdpem1vcyBkZXNjcmliZWQgaW4gY3VzdG9tIGhpZXJhcmNoeSBkZWZpbml0aW9uLlxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBHaXptbyggZ2l6bW9NYXAgKSB7XG5cblx0XHRcdGNvbnN0IGdpem1vID0gbmV3IE9iamVjdDNEKCk7XG5cblx0XHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gZ2l6bW9NYXAgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSBnaXptb01hcFsgbmFtZSBdLmxlbmd0aDsgaSAtLTsgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBvYmplY3QgPSBnaXptb01hcFsgbmFtZSBdWyBpIF1bIDAgXS5jbG9uZSgpO1xuXHRcdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2l6bW9NYXBbIG5hbWUgXVsgaSBdWyAxIF07XG5cdFx0XHRcdFx0Y29uc3Qgcm90YXRpb24gPSBnaXptb01hcFsgbmFtZSBdWyBpIF1bIDIgXTtcblx0XHRcdFx0XHRjb25zdCBzY2FsZSA9IGdpem1vTWFwWyBuYW1lIF1bIGkgXVsgMyBdO1xuXHRcdFx0XHRcdGNvbnN0IHRhZyA9IGdpem1vTWFwWyBuYW1lIF1bIGkgXVsgNCBdO1xuXG5cdFx0XHRcdFx0Ly8gbmFtZSBhbmQgdGFnIHByb3BlcnRpZXMgYXJlIGVzc2VudGlhbCBmb3IgcGlja2luZyBhbmQgdXBkYXRpbmcgbG9naWMuXG5cdFx0XHRcdFx0b2JqZWN0Lm5hbWUgPSBuYW1lO1xuXHRcdFx0XHRcdG9iamVjdC50YWcgPSB0YWc7XG5cblx0XHRcdFx0XHRpZiAoIHBvc2l0aW9uICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uc2V0KCBwb3NpdGlvblsgMCBdLCBwb3NpdGlvblsgMSBdLCBwb3NpdGlvblsgMiBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHJvdGF0aW9uICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3Qucm90YXRpb24uc2V0KCByb3RhdGlvblsgMCBdLCByb3RhdGlvblsgMSBdLCByb3RhdGlvblsgMiBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHNjYWxlICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3Quc2NhbGUuc2V0KCBzY2FsZVsgMCBdLCBzY2FsZVsgMSBdLCBzY2FsZVsgMiBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvYmplY3QudXBkYXRlTWF0cml4KCk7XG5cblx0XHRcdFx0XHRjb25zdCB0ZW1wR2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnkuY2xvbmUoKTtcblx0XHRcdFx0XHR0ZW1wR2VvbWV0cnkuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4ICk7XG5cdFx0XHRcdFx0b2JqZWN0Lmdlb21ldHJ5ID0gdGVtcEdlb21ldHJ5O1xuXHRcdFx0XHRcdG9iamVjdC5yZW5kZXJPcmRlciA9IEluZmluaXR5O1xuXG5cdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdG9iamVjdC5yb3RhdGlvbi5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdFx0XHRvYmplY3Quc2NhbGUuc2V0KCAxLCAxLCAxICk7XG5cblx0XHRcdFx0XHRnaXptby5hZGQoIG9iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2l6bW87XG5cblx0XHR9XG5cblx0XHQvLyBHaXptbyBjcmVhdGlvblxuXG5cdFx0dGhpcy5naXptbyA9IHt9O1xuXHRcdHRoaXMucGlja2VyID0ge307XG5cdFx0dGhpcy5oZWxwZXIgPSB7fTtcblxuXHRcdHRoaXMuYWRkKCB0aGlzLmdpem1vWyAndHJhbnNsYXRlJyBdID0gc2V0dXBHaXptbyggZ2l6bW9UcmFuc2xhdGUgKSApO1xuXHRcdHRoaXMuYWRkKCB0aGlzLmdpem1vWyAncm90YXRlJyBdID0gc2V0dXBHaXptbyggZ2l6bW9Sb3RhdGUgKSApO1xuXHRcdHRoaXMuYWRkKCB0aGlzLmdpem1vWyAnc2NhbGUnIF0gPSBzZXR1cEdpem1vKCBnaXptb1NjYWxlICkgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5waWNrZXJbICd0cmFuc2xhdGUnIF0gPSBzZXR1cEdpem1vKCBwaWNrZXJUcmFuc2xhdGUgKSApO1xuXHRcdHRoaXMuYWRkKCB0aGlzLnBpY2tlclsgJ3JvdGF0ZScgXSA9IHNldHVwR2l6bW8oIHBpY2tlclJvdGF0ZSApICk7XG5cdFx0dGhpcy5hZGQoIHRoaXMucGlja2VyWyAnc2NhbGUnIF0gPSBzZXR1cEdpem1vKCBwaWNrZXJTY2FsZSApICk7XG5cdFx0dGhpcy5hZGQoIHRoaXMuaGVscGVyWyAndHJhbnNsYXRlJyBdID0gc2V0dXBHaXptbyggaGVscGVyVHJhbnNsYXRlICkgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5oZWxwZXJbICdyb3RhdGUnIF0gPSBzZXR1cEdpem1vKCBoZWxwZXJSb3RhdGUgKSApO1xuXHRcdHRoaXMuYWRkKCB0aGlzLmhlbHBlclsgJ3NjYWxlJyBdID0gc2V0dXBHaXptbyggaGVscGVyU2NhbGUgKSApO1xuXG5cdFx0Ly8gUGlja2VycyBzaG91bGQgYmUgaGlkZGVuIGFsd2F5c1xuXG5cdFx0dGhpcy5waWNrZXJbICd0cmFuc2xhdGUnIF0udmlzaWJsZSA9IGZhbHNlO1xuXHRcdHRoaXMucGlja2VyWyAncm90YXRlJyBdLnZpc2libGUgPSBmYWxzZTtcblx0XHR0aGlzLnBpY2tlclsgJ3NjYWxlJyBdLnZpc2libGUgPSBmYWxzZTtcblxuXHR9XG5cblx0Ly8gdXBkYXRlTWF0cml4V29ybGQgd2lsbCB1cGRhdGUgdHJhbnNmb3JtYXRpb25zIGFuZCBhcHBlYXJhbmNlIG9mIGluZGl2aWR1YWwgaGFuZGxlc1xuXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdGNvbnN0IHNwYWNlID0gKCB0aGlzLm1vZGUgPT09ICdzY2FsZScgKSA/ICdsb2NhbCcgOiB0aGlzLnNwYWNlOyAvLyBzY2FsZSBhbHdheXMgb3JpZW50ZWQgdG8gbG9jYWwgcm90YXRpb25cblxuXHRcdGNvbnN0IHF1YXRlcm5pb24gPSAoIHNwYWNlID09PSAnbG9jYWwnICkgPyB0aGlzLndvcmxkUXVhdGVybmlvbiA6IF9pZGVudGl0eVF1YXRlcm5pb247XG5cblx0XHQvLyBTaG93IG9ubHkgZ2l6bW9zIGZvciBjdXJyZW50IHRyYW5zZm9ybSBtb2RlXG5cblx0XHR0aGlzLmdpem1vWyAndHJhbnNsYXRlJyBdLnZpc2libGUgPSB0aGlzLm1vZGUgPT09ICd0cmFuc2xhdGUnO1xuXHRcdHRoaXMuZ2l6bW9bICdyb3RhdGUnIF0udmlzaWJsZSA9IHRoaXMubW9kZSA9PT0gJ3JvdGF0ZSc7XG5cdFx0dGhpcy5naXptb1sgJ3NjYWxlJyBdLnZpc2libGUgPSB0aGlzLm1vZGUgPT09ICdzY2FsZSc7XG5cblx0XHR0aGlzLmhlbHBlclsgJ3RyYW5zbGF0ZScgXS52aXNpYmxlID0gdGhpcy5tb2RlID09PSAndHJhbnNsYXRlJztcblx0XHR0aGlzLmhlbHBlclsgJ3JvdGF0ZScgXS52aXNpYmxlID0gdGhpcy5tb2RlID09PSAncm90YXRlJztcblx0XHR0aGlzLmhlbHBlclsgJ3NjYWxlJyBdLnZpc2libGUgPSB0aGlzLm1vZGUgPT09ICdzY2FsZSc7XG5cblxuXHRcdGxldCBoYW5kbGVzID0gW107XG5cdFx0aGFuZGxlcyA9IGhhbmRsZXMuY29uY2F0KCB0aGlzLnBpY2tlclsgdGhpcy5tb2RlIF0uY2hpbGRyZW4gKTtcblx0XHRoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQoIHRoaXMuZ2l6bW9bIHRoaXMubW9kZSBdLmNoaWxkcmVuICk7XG5cdFx0aGFuZGxlcyA9IGhhbmRsZXMuY29uY2F0KCB0aGlzLmhlbHBlclsgdGhpcy5tb2RlIF0uY2hpbGRyZW4gKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGhhbmRsZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBoYW5kbGUgPSBoYW5kbGVzWyBpIF07XG5cblx0XHRcdC8vIGhpZGUgYWxpZ25lZCB0byBjYW1lcmFcblxuXHRcdFx0aGFuZGxlLnZpc2libGUgPSB0cnVlO1xuXHRcdFx0aGFuZGxlLnJvdGF0aW9uLnNldCggMCwgMCwgMCApO1xuXHRcdFx0aGFuZGxlLnBvc2l0aW9uLmNvcHkoIHRoaXMud29ybGRQb3NpdGlvbiApO1xuXG5cdFx0XHRsZXQgZmFjdG9yO1xuXG5cdFx0XHRpZiAoIHRoaXMuY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdGZhY3RvciA9ICggdGhpcy5jYW1lcmEudG9wIC0gdGhpcy5jYW1lcmEuYm90dG9tICkgLyB0aGlzLmNhbWVyYS56b29tO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGZhY3RvciA9IHRoaXMud29ybGRQb3NpdGlvbi5kaXN0YW5jZVRvKCB0aGlzLmNhbWVyYVBvc2l0aW9uICkgKiBNYXRoLm1pbiggMS45ICogTWF0aC50YW4oIE1hdGguUEkgKiB0aGlzLmNhbWVyYS5mb3YgLyAzNjAgKSAvIHRoaXMuY2FtZXJhLnpvb20sIDcgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRoYW5kbGUuc2NhbGUuc2V0KCAxLCAxLCAxICkubXVsdGlwbHlTY2FsYXIoIGZhY3RvciAqIHRoaXMuc2l6ZSAvIDQgKTtcblxuXHRcdFx0Ly8gVE9ETzogc2ltcGxpZnkgaGVscGVycyBhbmQgY29uc2lkZXIgZGVjb3VwbGluZyBmcm9tIGdpem1vXG5cblx0XHRcdGlmICggaGFuZGxlLnRhZyA9PT0gJ2hlbHBlcicgKSB7XG5cblx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoIGhhbmRsZS5uYW1lID09PSAnQVhJUycgKSB7XG5cblx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9ICEhIHRoaXMuYXhpcztcblxuXHRcdFx0XHRcdGlmICggdGhpcy5heGlzID09PSAnWCcgKSB7XG5cblx0XHRcdFx0XHRcdF90ZW1wUXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIF90ZW1wRXVsZXIuc2V0KCAwLCAwLCAwICkgKTtcblx0XHRcdFx0XHRcdGhhbmRsZS5xdWF0ZXJuaW9uLmNvcHkoIHF1YXRlcm5pb24gKS5tdWx0aXBseSggX3RlbXBRdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIF9hbGlnblZlY3Rvci5jb3B5KCBfdW5pdFggKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKS5kb3QoIHRoaXMuZXllICkgKSA+IDAuOSApIHtcblxuXHRcdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuYXhpcyA9PT0gJ1knICkge1xuXG5cdFx0XHRcdFx0XHRfdGVtcFF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBfdGVtcEV1bGVyLnNldCggMCwgMCwgTWF0aC5QSSAvIDIgKSApO1xuXHRcdFx0XHRcdFx0aGFuZGxlLnF1YXRlcm5pb24uY29weSggcXVhdGVybmlvbiApLm11bHRpcGx5KCBfdGVtcFF1YXRlcm5pb24gKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggX2FsaWduVmVjdG9yLmNvcHkoIF91bml0WSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApLmRvdCggdGhpcy5leWUgKSApID4gMC45ICkge1xuXG5cdFx0XHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGhpcy5heGlzID09PSAnWicgKSB7XG5cblx0XHRcdFx0XHRcdF90ZW1wUXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIF90ZW1wRXVsZXIuc2V0KCAwLCBNYXRoLlBJIC8gMiwgMCApICk7XG5cdFx0XHRcdFx0XHRoYW5kbGUucXVhdGVybmlvbi5jb3B5KCBxdWF0ZXJuaW9uICkubXVsdGlwbHkoIF90ZW1wUXVhdGVybmlvbiApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBfYWxpZ25WZWN0b3IuY29weSggX3VuaXRaICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkuZG90KCB0aGlzLmV5ZSApICkgPiAwLjkgKSB7XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmF4aXMgPT09ICdYWVpFJyApIHtcblxuXHRcdFx0XHRcdFx0X3RlbXBRdWF0ZXJuaW9uLnNldEZyb21FdWxlciggX3RlbXBFdWxlci5zZXQoIDAsIE1hdGguUEkgLyAyLCAwICkgKTtcblx0XHRcdFx0XHRcdF9hbGlnblZlY3Rvci5jb3B5KCB0aGlzLnJvdGF0aW9uQXhpcyApO1xuXHRcdFx0XHRcdFx0aGFuZGxlLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbG9va0F0TWF0cml4Lmxvb2tBdCggX3plcm9WZWN0b3IsIF9hbGlnblZlY3RvciwgX3VuaXRZICkgKTtcblx0XHRcdFx0XHRcdGhhbmRsZS5xdWF0ZXJuaW9uLm11bHRpcGx5KCBfdGVtcFF1YXRlcm5pb24gKTtcblx0XHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gdGhpcy5kcmFnZ2luZztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGhpcy5heGlzID09PSAnRScgKSB7XG5cblx0XHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBoYW5kbGUubmFtZSA9PT0gJ1NUQVJUJyApIHtcblxuXHRcdFx0XHRcdGhhbmRsZS5wb3NpdGlvbi5jb3B5KCB0aGlzLndvcmxkUG9zaXRpb25TdGFydCApO1xuXHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gdGhpcy5kcmFnZ2luZztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBoYW5kbGUubmFtZSA9PT0gJ0VORCcgKSB7XG5cblx0XHRcdFx0XHRoYW5kbGUucG9zaXRpb24uY29weSggdGhpcy53b3JsZFBvc2l0aW9uICk7XG5cdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSB0aGlzLmRyYWdnaW5nO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGhhbmRsZS5uYW1lID09PSAnREVMVEEnICkge1xuXG5cdFx0XHRcdFx0aGFuZGxlLnBvc2l0aW9uLmNvcHkoIHRoaXMud29ybGRQb3NpdGlvblN0YXJ0ICk7XG5cdFx0XHRcdFx0aGFuZGxlLnF1YXRlcm5pb24uY29weSggdGhpcy53b3JsZFF1YXRlcm5pb25TdGFydCApO1xuXHRcdFx0XHRcdF90ZW1wVmVjdG9yLnNldCggMWUtMTAsIDFlLTEwLCAxZS0xMCApLmFkZCggdGhpcy53b3JsZFBvc2l0aW9uU3RhcnQgKS5zdWIoIHRoaXMud29ybGRQb3NpdGlvbiApLm11bHRpcGx5U2NhbGFyKCAtIDEgKTtcblx0XHRcdFx0XHRfdGVtcFZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHRoaXMud29ybGRRdWF0ZXJuaW9uU3RhcnQuY2xvbmUoKS5pbnZlcnQoKSApO1xuXHRcdFx0XHRcdGhhbmRsZS5zY2FsZS5jb3B5KCBfdGVtcFZlY3RvciApO1xuXHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gdGhpcy5kcmFnZ2luZztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aGFuZGxlLnF1YXRlcm5pb24uY29weSggcXVhdGVybmlvbiApO1xuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmRyYWdnaW5nICkge1xuXG5cdFx0XHRcdFx0XHRoYW5kbGUucG9zaXRpb24uY29weSggdGhpcy53b3JsZFBvc2l0aW9uU3RhcnQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGhhbmRsZS5wb3NpdGlvbi5jb3B5KCB0aGlzLndvcmxkUG9zaXRpb24gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGhpcy5heGlzICkge1xuXG5cdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IHRoaXMuYXhpcy5zZWFyY2goIGhhbmRsZS5uYW1lICkgIT09IC0gMTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdXBkYXRpbmcgaGVscGVyLCBza2lwIHJlc3Qgb2YgdGhlIGxvb3Bcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWxpZ24gaGFuZGxlcyB0byBjdXJyZW50IGxvY2FsIG9yIHdvcmxkIHJvdGF0aW9uXG5cblx0XHRcdGhhbmRsZS5xdWF0ZXJuaW9uLmNvcHkoIHF1YXRlcm5pb24gKTtcblxuXHRcdFx0aWYgKCB0aGlzLm1vZGUgPT09ICd0cmFuc2xhdGUnIHx8IHRoaXMubW9kZSA9PT0gJ3NjYWxlJyApIHtcblxuXHRcdFx0XHQvLyBIaWRlIHRyYW5zbGF0ZSBhbmQgc2NhbGUgYXhpcyBmYWNpbmcgdGhlIGNhbWVyYVxuXG5cdFx0XHRcdGNvbnN0IEFYSVNfSElERV9USFJFU0hPTEQgPSAwLjk5O1xuXHRcdFx0XHRjb25zdCBQTEFORV9ISURFX1RIUkVTSE9MRCA9IDAuMjtcblxuXHRcdFx0XHRpZiAoIGhhbmRsZS5uYW1lID09PSAnWCcgKSB7XG5cblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBfYWxpZ25WZWN0b3IuY29weSggX3VuaXRYICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkuZG90KCB0aGlzLmV5ZSApICkgPiBBWElTX0hJREVfVEhSRVNIT0xEICkge1xuXG5cdFx0XHRcdFx0XHRoYW5kbGUuc2NhbGUuc2V0KCAxZS0xMCwgMWUtMTAsIDFlLTEwICk7XG5cdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhbmRsZS5uYW1lID09PSAnWScgKSB7XG5cblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBfYWxpZ25WZWN0b3IuY29weSggX3VuaXRZICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkuZG90KCB0aGlzLmV5ZSApICkgPiBBWElTX0hJREVfVEhSRVNIT0xEICkge1xuXG5cdFx0XHRcdFx0XHRoYW5kbGUuc2NhbGUuc2V0KCAxZS0xMCwgMWUtMTAsIDFlLTEwICk7XG5cdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhbmRsZS5uYW1lID09PSAnWicgKSB7XG5cblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBfYWxpZ25WZWN0b3IuY29weSggX3VuaXRaICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkuZG90KCB0aGlzLmV5ZSApICkgPiBBWElTX0hJREVfVEhSRVNIT0xEICkge1xuXG5cdFx0XHRcdFx0XHRoYW5kbGUuc2NhbGUuc2V0KCAxZS0xMCwgMWUtMTAsIDFlLTEwICk7XG5cdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhbmRsZS5uYW1lID09PSAnWFknICkge1xuXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggX2FsaWduVmVjdG9yLmNvcHkoIF91bml0WiApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApLmRvdCggdGhpcy5leWUgKSApIDwgUExBTkVfSElERV9USFJFU0hPTEQgKSB7XG5cblx0XHRcdFx0XHRcdGhhbmRsZS5zY2FsZS5zZXQoIDFlLTEwLCAxZS0xMCwgMWUtMTAgKTtcblx0XHRcdFx0XHRcdGhhbmRsZS52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFuZGxlLm5hbWUgPT09ICdZWicgKSB7XG5cblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBfYWxpZ25WZWN0b3IuY29weSggX3VuaXRYICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkuZG90KCB0aGlzLmV5ZSApICkgPCBQTEFORV9ISURFX1RIUkVTSE9MRCApIHtcblxuXHRcdFx0XHRcdFx0aGFuZGxlLnNjYWxlLnNldCggMWUtMTAsIDFlLTEwLCAxZS0xMCApO1xuXHRcdFx0XHRcdFx0aGFuZGxlLnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBoYW5kbGUubmFtZSA9PT0gJ1haJyApIHtcblxuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIF9hbGlnblZlY3Rvci5jb3B5KCBfdW5pdFkgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKS5kb3QoIHRoaXMuZXllICkgKSA8IFBMQU5FX0hJREVfVEhSRVNIT0xEICkge1xuXG5cdFx0XHRcdFx0XHRoYW5kbGUuc2NhbGUuc2V0KCAxZS0xMCwgMWUtMTAsIDFlLTEwICk7XG5cdFx0XHRcdFx0XHRoYW5kbGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5tb2RlID09PSAncm90YXRlJyApIHtcblxuXHRcdFx0XHQvLyBBbGlnbiBoYW5kbGVzIHRvIGN1cnJlbnQgbG9jYWwgb3Igd29ybGQgcm90YXRpb25cblxuXHRcdFx0XHRfdGVtcFF1YXRlcm5pb24yLmNvcHkoIHF1YXRlcm5pb24gKTtcblx0XHRcdFx0X2FsaWduVmVjdG9yLmNvcHkoIHRoaXMuZXllICkuYXBwbHlRdWF0ZXJuaW9uKCBfdGVtcFF1YXRlcm5pb24uY29weSggcXVhdGVybmlvbiApLmludmVydCgpICk7XG5cblx0XHRcdFx0aWYgKCBoYW5kbGUubmFtZS5zZWFyY2goICdFJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRoYW5kbGUucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9sb29rQXRNYXRyaXgubG9va0F0KCB0aGlzLmV5ZSwgX3plcm9WZWN0b3IsIF91bml0WSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFuZGxlLm5hbWUgPT09ICdYJyApIHtcblxuXHRcdFx0XHRcdF90ZW1wUXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBfdW5pdFgsIE1hdGguYXRhbjIoIC0gX2FsaWduVmVjdG9yLnksIF9hbGlnblZlY3Rvci56ICkgKTtcblx0XHRcdFx0XHRfdGVtcFF1YXRlcm5pb24ubXVsdGlwbHlRdWF0ZXJuaW9ucyggX3RlbXBRdWF0ZXJuaW9uMiwgX3RlbXBRdWF0ZXJuaW9uICk7XG5cdFx0XHRcdFx0aGFuZGxlLnF1YXRlcm5pb24uY29weSggX3RlbXBRdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFuZGxlLm5hbWUgPT09ICdZJyApIHtcblxuXHRcdFx0XHRcdF90ZW1wUXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBfdW5pdFksIE1hdGguYXRhbjIoIF9hbGlnblZlY3Rvci54LCBfYWxpZ25WZWN0b3IueiApICk7XG5cdFx0XHRcdFx0X3RlbXBRdWF0ZXJuaW9uLm11bHRpcGx5UXVhdGVybmlvbnMoIF90ZW1wUXVhdGVybmlvbjIsIF90ZW1wUXVhdGVybmlvbiApO1xuXHRcdFx0XHRcdGhhbmRsZS5xdWF0ZXJuaW9uLmNvcHkoIF90ZW1wUXVhdGVybmlvbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhbmRsZS5uYW1lID09PSAnWicgKSB7XG5cblx0XHRcdFx0XHRfdGVtcFF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggX3VuaXRaLCBNYXRoLmF0YW4yKCBfYWxpZ25WZWN0b3IueSwgX2FsaWduVmVjdG9yLnggKSApO1xuXHRcdFx0XHRcdF90ZW1wUXVhdGVybmlvbi5tdWx0aXBseVF1YXRlcm5pb25zKCBfdGVtcFF1YXRlcm5pb24yLCBfdGVtcFF1YXRlcm5pb24gKTtcblx0XHRcdFx0XHRoYW5kbGUucXVhdGVybmlvbi5jb3B5KCBfdGVtcFF1YXRlcm5pb24gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gSGlkZSBkaXNhYmxlZCBheGVzXG5cdFx0XHRoYW5kbGUudmlzaWJsZSA9IGhhbmRsZS52aXNpYmxlICYmICggaGFuZGxlLm5hbWUuaW5kZXhPZiggJ1gnICkgPT09IC0gMSB8fCB0aGlzLnNob3dYICk7XG5cdFx0XHRoYW5kbGUudmlzaWJsZSA9IGhhbmRsZS52aXNpYmxlICYmICggaGFuZGxlLm5hbWUuaW5kZXhPZiggJ1knICkgPT09IC0gMSB8fCB0aGlzLnNob3dZICk7XG5cdFx0XHRoYW5kbGUudmlzaWJsZSA9IGhhbmRsZS52aXNpYmxlICYmICggaGFuZGxlLm5hbWUuaW5kZXhPZiggJ1onICkgPT09IC0gMSB8fCB0aGlzLnNob3daICk7XG5cdFx0XHRoYW5kbGUudmlzaWJsZSA9IGhhbmRsZS52aXNpYmxlICYmICggaGFuZGxlLm5hbWUuaW5kZXhPZiggJ0UnICkgPT09IC0gMSB8fCAoIHRoaXMuc2hvd1ggJiYgdGhpcy5zaG93WSAmJiB0aGlzLnNob3daICkgKTtcblxuXHRcdFx0Ly8gaGlnaGxpZ2h0IHNlbGVjdGVkIGF4aXNcblxuXHRcdFx0aGFuZGxlLm1hdGVyaWFsLl9jb2xvciA9IGhhbmRsZS5tYXRlcmlhbC5fY29sb3IgfHwgaGFuZGxlLm1hdGVyaWFsLmNvbG9yLmNsb25lKCk7XG5cdFx0XHRoYW5kbGUubWF0ZXJpYWwuX29wYWNpdHkgPSBoYW5kbGUubWF0ZXJpYWwuX29wYWNpdHkgfHwgaGFuZGxlLm1hdGVyaWFsLm9wYWNpdHk7XG5cblx0XHRcdGhhbmRsZS5tYXRlcmlhbC5jb2xvci5jb3B5KCBoYW5kbGUubWF0ZXJpYWwuX2NvbG9yICk7XG5cdFx0XHRoYW5kbGUubWF0ZXJpYWwub3BhY2l0eSA9IGhhbmRsZS5tYXRlcmlhbC5fb3BhY2l0eTtcblxuXHRcdFx0aWYgKCB0aGlzLmVuYWJsZWQgJiYgdGhpcy5heGlzICkge1xuXG5cdFx0XHRcdGlmICggaGFuZGxlLm5hbWUgPT09IHRoaXMuYXhpcyApIHtcblxuXHRcdFx0XHRcdGhhbmRsZS5tYXRlcmlhbC5jb2xvci5zZXRIZXgoIDB4ZmZmZjAwICk7XG5cdFx0XHRcdFx0aGFuZGxlLm1hdGVyaWFsLm9wYWNpdHkgPSAxLjA7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5heGlzLnNwbGl0KCAnJyApLnNvbWUoIGZ1bmN0aW9uICggYSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBoYW5kbGUubmFtZSA9PT0gYTtcblxuXHRcdFx0XHR9ICkgKSB7XG5cblx0XHRcdFx0XHRoYW5kbGUubWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCAweGZmZmYwMCApO1xuXHRcdFx0XHRcdGhhbmRsZS5tYXRlcmlhbC5vcGFjaXR5ID0gMS4wO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0fVxuXG59XG5cbi8vXG5cbmNsYXNzIFRyYW5zZm9ybUNvbnRyb2xzUGxhbmUgZXh0ZW5kcyBNZXNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKFxuXHRcdFx0bmV3IFBsYW5lR2VvbWV0cnkoIDEwMDAwMCwgMTAwMDAwLCAyLCAyICksXG5cdFx0XHRuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgdmlzaWJsZTogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgc2lkZTogRG91YmxlU2lkZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuMSwgdG9uZU1hcHBlZDogZmFsc2UgfSApXG5cdFx0KTtcblxuXHRcdHRoaXMuaXNUcmFuc2Zvcm1Db250cm9sc1BsYW5lID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdUcmFuc2Zvcm1Db250cm9sc1BsYW5lJztcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0bGV0IHNwYWNlID0gdGhpcy5zcGFjZTtcblxuXHRcdHRoaXMucG9zaXRpb24uY29weSggdGhpcy53b3JsZFBvc2l0aW9uICk7XG5cblx0XHRpZiAoIHRoaXMubW9kZSA9PT0gJ3NjYWxlJyApIHNwYWNlID0gJ2xvY2FsJzsgLy8gc2NhbGUgYWx3YXlzIG9yaWVudGVkIHRvIGxvY2FsIHJvdGF0aW9uXG5cblx0XHRfdjEuY29weSggX3VuaXRYICkuYXBwbHlRdWF0ZXJuaW9uKCBzcGFjZSA9PT0gJ2xvY2FsJyA/IHRoaXMud29ybGRRdWF0ZXJuaW9uIDogX2lkZW50aXR5UXVhdGVybmlvbiApO1xuXHRcdF92Mi5jb3B5KCBfdW5pdFkgKS5hcHBseVF1YXRlcm5pb24oIHNwYWNlID09PSAnbG9jYWwnID8gdGhpcy53b3JsZFF1YXRlcm5pb24gOiBfaWRlbnRpdHlRdWF0ZXJuaW9uICk7XG5cdFx0X3YzLmNvcHkoIF91bml0WiApLmFwcGx5UXVhdGVybmlvbiggc3BhY2UgPT09ICdsb2NhbCcgPyB0aGlzLndvcmxkUXVhdGVybmlvbiA6IF9pZGVudGl0eVF1YXRlcm5pb24gKTtcblxuXHRcdC8vIEFsaWduIHRoZSBwbGFuZSBmb3IgY3VycmVudCB0cmFuc2Zvcm0gbW9kZSwgYXhpcyBhbmQgc3BhY2UuXG5cblx0XHRfYWxpZ25WZWN0b3IuY29weSggX3YyICk7XG5cblx0XHRzd2l0Y2ggKCB0aGlzLm1vZGUgKSB7XG5cblx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdHN3aXRjaCAoIHRoaXMuYXhpcyApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ1gnOlxuXHRcdFx0XHRcdFx0X2FsaWduVmVjdG9yLmNvcHkoIHRoaXMuZXllICkuY3Jvc3MoIF92MSApO1xuXHRcdFx0XHRcdFx0X2RpclZlY3Rvci5jb3B5KCBfdjEgKS5jcm9zcyggX2FsaWduVmVjdG9yICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdZJzpcblx0XHRcdFx0XHRcdF9hbGlnblZlY3Rvci5jb3B5KCB0aGlzLmV5ZSApLmNyb3NzKCBfdjIgKTtcblx0XHRcdFx0XHRcdF9kaXJWZWN0b3IuY29weSggX3YyICkuY3Jvc3MoIF9hbGlnblZlY3RvciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnWic6XG5cdFx0XHRcdFx0XHRfYWxpZ25WZWN0b3IuY29weSggdGhpcy5leWUgKS5jcm9zcyggX3YzICk7XG5cdFx0XHRcdFx0XHRfZGlyVmVjdG9yLmNvcHkoIF92MyApLmNyb3NzKCBfYWxpZ25WZWN0b3IgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ1hZJzpcblx0XHRcdFx0XHRcdF9kaXJWZWN0b3IuY29weSggX3YzICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdZWic6XG5cdFx0XHRcdFx0XHRfZGlyVmVjdG9yLmNvcHkoIF92MSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnWFonOlxuXHRcdFx0XHRcdFx0X2FsaWduVmVjdG9yLmNvcHkoIF92MyApO1xuXHRcdFx0XHRcdFx0X2RpclZlY3Rvci5jb3B5KCBfdjIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ1hZWic6XG5cdFx0XHRcdFx0Y2FzZSAnRSc6XG5cdFx0XHRcdFx0XHRfZGlyVmVjdG9yLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSBmb3Igcm90YXRlXG5cdFx0XHRcdF9kaXJWZWN0b3Iuc2V0KCAwLCAwLCAwICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIF9kaXJWZWN0b3IubGVuZ3RoKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIElmIGluIHJvdGF0ZSBtb2RlLCBtYWtlIHRoZSBwbGFuZSBwYXJhbGxlbCB0byBjYW1lcmFcblx0XHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCB0aGlzLmNhbWVyYVF1YXRlcm5pb24gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF90ZW1wTWF0cml4Lmxvb2tBdCggX3RlbXBWZWN0b3Iuc2V0KCAwLCAwLCAwICksIF9kaXJWZWN0b3IsIF9hbGlnblZlY3RvciApO1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfdGVtcE1hdHJpeCApO1xuXG5cdFx0fVxuXG5cdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFRyYW5zZm9ybUNvbnRyb2xzLCBUcmFuc2Zvcm1Db250cm9sc0dpem1vLCBUcmFuc2Zvcm1Db250cm9sc1BsYW5lIH07XG4iXSwibmFtZXMiOlsiQm94R2VvbWV0cnkiLCJCdWZmZXJHZW9tZXRyeSIsIkN5bGluZGVyR2VvbWV0cnkiLCJEb3VibGVTaWRlIiwiRXVsZXIiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwiTGluZSIsIkxpbmVCYXNpY01hdGVyaWFsIiwiTWF0cml4NCIsIk1lc2giLCJNZXNoQmFzaWNNYXRlcmlhbCIsIk9iamVjdDNEIiwiT2N0YWhlZHJvbkdlb21ldHJ5IiwiUGxhbmVHZW9tZXRyeSIsIlF1YXRlcm5pb24iLCJSYXljYXN0ZXIiLCJTcGhlcmVHZW9tZXRyeSIsIlRvcnVzR2VvbWV0cnkiLCJWZWN0b3IzIiwiX3JheWNhc3RlciIsIl90ZW1wVmVjdG9yIiwiX3RlbXBWZWN0b3IyIiwiX3RlbXBRdWF0ZXJuaW9uIiwiX3VuaXQiLCJYIiwiWSIsIloiLCJfY2hhbmdlRXZlbnQiLCJ0eXBlIiwiX21vdXNlRG93bkV2ZW50IiwiX21vdXNlVXBFdmVudCIsIm1vZGUiLCJfb2JqZWN0Q2hhbmdlRXZlbnQiLCJUcmFuc2Zvcm1Db250cm9scyIsInVwZGF0ZU1hdHJpeFdvcmxkIiwib2JqZWN0IiwidW5kZWZpbmVkIiwicGFyZW50IiwiY29uc29sZSIsImVycm9yIiwibWF0cml4V29ybGQiLCJkZWNvbXBvc2UiLCJfcGFyZW50UG9zaXRpb24iLCJfcGFyZW50UXVhdGVybmlvbiIsIl9wYXJlbnRTY2FsZSIsIndvcmxkUG9zaXRpb24iLCJ3b3JsZFF1YXRlcm5pb24iLCJfd29ybGRTY2FsZSIsIl9wYXJlbnRRdWF0ZXJuaW9uSW52IiwiY29weSIsImludmVydCIsIl93b3JsZFF1YXRlcm5pb25JbnYiLCJjYW1lcmEiLCJjYW1lcmFQb3NpdGlvbiIsImNhbWVyYVF1YXRlcm5pb24iLCJfY2FtZXJhU2NhbGUiLCJpc09ydGhvZ3JhcGhpY0NhbWVyYSIsImdldFdvcmxkRGlyZWN0aW9uIiwiZXllIiwibmVnYXRlIiwic3ViIiwibm9ybWFsaXplIiwicG9pbnRlckhvdmVyIiwicG9pbnRlciIsImRyYWdnaW5nIiwic2V0RnJvbUNhbWVyYSIsImludGVyc2VjdCIsImludGVyc2VjdE9iamVjdFdpdGhSYXkiLCJfZ2l6bW8iLCJwaWNrZXIiLCJheGlzIiwibmFtZSIsInBvaW50ZXJEb3duIiwiYnV0dG9uIiwicGxhbmVJbnRlcnNlY3QiLCJfcGxhbmUiLCJfcG9zaXRpb25TdGFydCIsInBvc2l0aW9uIiwiX3F1YXRlcm5pb25TdGFydCIsInF1YXRlcm5pb24iLCJfc2NhbGVTdGFydCIsInNjYWxlIiwid29ybGRQb3NpdGlvblN0YXJ0Iiwid29ybGRRdWF0ZXJuaW9uU3RhcnQiLCJfd29ybGRTY2FsZVN0YXJ0IiwicG9pbnRTdGFydCIsInBvaW50IiwiZGlzcGF0Y2hFdmVudCIsInBvaW50ZXJNb3ZlIiwic3BhY2UiLCJwb2ludEVuZCIsIl9vZmZzZXQiLCJhcHBseVF1YXRlcm5pb24iLCJpbmRleE9mIiwieCIsInkiLCJ6IiwiZGl2aWRlIiwiYWRkIiwidHJhbnNsYXRpb25TbmFwIiwic2VhcmNoIiwiTWF0aCIsInJvdW5kIiwic2V0RnJvbU1hdHJpeFBvc2l0aW9uIiwiZCIsImxlbmd0aCIsImRvdCIsInNldCIsIm11bHRpcGx5Iiwic2NhbGVTbmFwIiwiUk9UQVRJT05fU1BFRUQiLCJkaXN0YW5jZVRvIiwiX2luUGxhbmVSb3RhdGlvbiIsInJvdGF0aW9uQXhpcyIsImNyb3NzIiwicm90YXRpb25BbmdsZSIsImFuZ2xlVG8iLCJfc3RhcnROb3JtIiwiX2VuZE5vcm0iLCJyb3RhdGlvblNuYXAiLCJzZXRGcm9tQXhpc0FuZ2xlIiwicG9pbnRlclVwIiwiZGlzcG9zZSIsImRvbUVsZW1lbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiX29uUG9pbnRlckRvd24iLCJfb25Qb2ludGVySG92ZXIiLCJfb25Qb2ludGVyTW92ZSIsIl9vblBvaW50ZXJVcCIsInRyYXZlcnNlIiwiY2hpbGQiLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiYXR0YWNoIiwidmlzaWJsZSIsImRldGFjaCIsInJlc2V0IiwiZW5hYmxlZCIsImdldFJheWNhc3RlciIsImdldE1vZGUiLCJzZXRNb2RlIiwic2V0VHJhbnNsYXRpb25TbmFwIiwic2V0Um90YXRpb25TbmFwIiwic2V0U2NhbGVTbmFwIiwic2V0U2l6ZSIsInNpemUiLCJzZXRTcGFjZSIsImNvbnN0cnVjdG9yIiwid2FybiIsImRvY3VtZW50IiwiaXNUcmFuc2Zvcm1Db250cm9scyIsInN0eWxlIiwidG91Y2hBY3Rpb24iLCJUcmFuc2Zvcm1Db250cm9sc0dpem1vIiwiVHJhbnNmb3JtQ29udHJvbHNQbGFuZSIsInNjb3BlIiwiZGVmaW5lUHJvcGVydHkiLCJwcm9wTmFtZSIsImRlZmF1bHRWYWx1ZSIsInByb3BWYWx1ZSIsIk9iamVjdCIsImdldCIsInZhbHVlIiwiX2dldFBvaW50ZXIiLCJnZXRQb2ludGVyIiwiYmluZCIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJIb3ZlciIsIm9uUG9pbnRlck1vdmUiLCJvblBvaW50ZXJVcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIm93bmVyRG9jdW1lbnQiLCJwb2ludGVyTG9ja0VsZW1lbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImxlZnQiLCJ3aWR0aCIsImNsaWVudFkiLCJ0b3AiLCJoZWlnaHQiLCJwb2ludGVyVHlwZSIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwicmF5Y2FzdGVyIiwiaW5jbHVkZUludmlzaWJsZSIsImFsbEludGVyc2VjdGlvbnMiLCJpbnRlcnNlY3RPYmplY3QiLCJpIiwiX3RlbXBFdWxlciIsIl9hbGlnblZlY3RvciIsIl96ZXJvVmVjdG9yIiwiX2xvb2tBdE1hdHJpeCIsIl90ZW1wUXVhdGVybmlvbjIiLCJfaWRlbnRpdHlRdWF0ZXJuaW9uIiwiX2RpclZlY3RvciIsIl90ZW1wTWF0cml4IiwiX3VuaXRYIiwiX3VuaXRZIiwiX3VuaXRaIiwiX3YxIiwiX3YyIiwiX3YzIiwiZm9yY2UiLCJnaXptbyIsImhlbHBlciIsImhhbmRsZXMiLCJjb25jYXQiLCJjaGlsZHJlbiIsImhhbmRsZSIsInJvdGF0aW9uIiwiZmFjdG9yIiwiYm90dG9tIiwiem9vbSIsIm1pbiIsInRhbiIsIlBJIiwiZm92IiwibXVsdGlwbHlTY2FsYXIiLCJ0YWciLCJzZXRGcm9tRXVsZXIiLCJhYnMiLCJzZXRGcm9tUm90YXRpb25NYXRyaXgiLCJsb29rQXQiLCJjbG9uZSIsIkFYSVNfSElERV9USFJFU0hPTEQiLCJQTEFORV9ISURFX1RIUkVTSE9MRCIsImF0YW4yIiwibXVsdGlwbHlRdWF0ZXJuaW9ucyIsInNob3dYIiwic2hvd1kiLCJzaG93WiIsIl9jb2xvciIsImNvbG9yIiwiX29wYWNpdHkiLCJvcGFjaXR5Iiwic2V0SGV4Iiwic3BsaXQiLCJzb21lIiwiYSIsImlzVHJhbnNmb3JtQ29udHJvbHNHaXptbyIsImdpem1vTWF0ZXJpYWwiLCJkZXB0aFRlc3QiLCJkZXB0aFdyaXRlIiwiZm9nIiwidG9uZU1hcHBlZCIsInRyYW5zcGFyZW50IiwiZ2l6bW9MaW5lTWF0ZXJpYWwiLCJtYXRJbnZpc2libGUiLCJtYXRIZWxwZXIiLCJtYXRSZWQiLCJtYXRHcmVlbiIsIm1hdEJsdWUiLCJtYXRSZWRUcmFuc3BhcmVudCIsIm1hdEdyZWVuVHJhbnNwYXJlbnQiLCJtYXRCbHVlVHJhbnNwYXJlbnQiLCJtYXRXaGl0ZVRyYW5zcGFyZW50IiwibWF0WWVsbG93VHJhbnNwYXJlbnQiLCJtYXRZZWxsb3ciLCJtYXRHcmF5IiwiYXJyb3dHZW9tZXRyeSIsInRyYW5zbGF0ZSIsInNjYWxlSGFuZGxlR2VvbWV0cnkiLCJsaW5lR2VvbWV0cnkiLCJzZXRBdHRyaWJ1dGUiLCJsaW5lR2VvbWV0cnkyIiwiQ2lyY2xlR2VvbWV0cnkiLCJyYWRpdXMiLCJhcmMiLCJyb3RhdGVZIiwicm90YXRlWCIsIlRyYW5zbGF0ZUhlbHBlckdlb21ldHJ5IiwiZ2l6bW9UcmFuc2xhdGUiLCJYWVoiLCJYWSIsIllaIiwiWFoiLCJwaWNrZXJUcmFuc2xhdGUiLCJoZWxwZXJUcmFuc2xhdGUiLCJTVEFSVCIsIkVORCIsIkRFTFRBIiwiZ2l6bW9Sb3RhdGUiLCJYWVpFIiwiRSIsImhlbHBlclJvdGF0ZSIsIkFYSVMiLCJwaWNrZXJSb3RhdGUiLCJnaXptb1NjYWxlIiwicGlja2VyU2NhbGUiLCJoZWxwZXJTY2FsZSIsInNldHVwR2l6bW8iLCJnaXptb01hcCIsInVwZGF0ZU1hdHJpeCIsInRlbXBHZW9tZXRyeSIsImFwcGx5TWF0cml4NCIsIm1hdHJpeCIsInJlbmRlck9yZGVyIiwiSW5maW5pdHkiLCJ3aXJlZnJhbWUiLCJzaWRlIiwiaXNUcmFuc2Zvcm1Db250cm9sc1BsYW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three/examples/jsm/controls/TransformControls.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three/examples/jsm/loaders/GLTFLoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/GLTFLoader.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: function() { return /* binding */ GLTFLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(app-pages-browser)/./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js\");\n\n\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        let resourcePath;\n        if (this.resourcePath !== \"\") {\n            resourcePath = this.resourcePath;\n        } else if (this.path !== \"\") {\n            // If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n            // Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n            // resourcePath = 'https://my-cnd-server.com/assets/models/'\n            // referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n            // referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n            const relativeUrl = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(relativeUrl, this.path);\n        } else {\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n        }\n        // Tells the LoadingManager to track an extra item, which resolves after\n        // the model is fully loaded. This means the count of items loaded will\n        // be incorrect, but ensures manager.onLoad() does not fire early.\n        this.manager.itemStart(url);\n        const _onError = function(e) {\n            if (onError) {\n                onError(e);\n            } else {\n                console.error(e);\n            }\n            scope.manager.itemError(url);\n            scope.manager.itemEnd(url);\n        };\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, function(data) {\n            try {\n                scope.parse(data, resourcePath, function(gltf) {\n                    onLoad(gltf);\n                    scope.manager.itemEnd(url);\n                }, _onError);\n            } catch (e) {\n                _onError(e);\n            }\n        }, onProgress, _onError);\n    }\n    setDRACOLoader(dracoLoader) {\n        this.dracoLoader = dracoLoader;\n        return this;\n    }\n    setDDSLoader() {\n        throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n    }\n    setKTX2Loader(ktx2Loader) {\n        this.ktx2Loader = ktx2Loader;\n        return this;\n    }\n    setMeshoptDecoder(meshoptDecoder) {\n        this.meshoptDecoder = meshoptDecoder;\n        return this;\n    }\n    register(callback) {\n        if (this.pluginCallbacks.indexOf(callback) === -1) {\n            this.pluginCallbacks.push(callback);\n        }\n        return this;\n    }\n    unregister(callback) {\n        if (this.pluginCallbacks.indexOf(callback) !== -1) {\n            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n        }\n        return this;\n    }\n    parse(data, path, onLoad, onError) {\n        let json;\n        const extensions = {};\n        const plugins = {};\n        const textDecoder = new TextDecoder();\n        if (typeof data === \"string\") {\n            json = JSON.parse(data);\n        } else if (data instanceof ArrayBuffer) {\n            const magic = textDecoder.decode(new Uint8Array(data, 0, 4));\n            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n                try {\n                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n                } catch (error) {\n                    if (onError) onError(error);\n                    return;\n                }\n                json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n            } else {\n                json = JSON.parse(textDecoder.decode(data));\n            }\n        } else {\n            json = data;\n        }\n        if (json.asset === undefined || json.asset.version[0] < 2) {\n            if (onError) onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n            return;\n        }\n        const parser = new GLTFParser(json, {\n            path: path || this.resourcePath || \"\",\n            crossOrigin: this.crossOrigin,\n            requestHeader: this.requestHeader,\n            manager: this.manager,\n            ktx2Loader: this.ktx2Loader,\n            meshoptDecoder: this.meshoptDecoder\n        });\n        parser.fileLoader.setRequestHeader(this.requestHeader);\n        for(let i = 0; i < this.pluginCallbacks.length; i++){\n            const plugin = this.pluginCallbacks[i](parser);\n            if (!plugin.name) console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n            plugins[plugin.name] = plugin;\n            // Workaround to avoid determining as unknown extension\n            // in addUnknownExtensionsToUserData().\n            // Remove this workaround if we move all the existing\n            // extension handlers to plugin system\n            extensions[plugin.name] = true;\n        }\n        if (json.extensionsUsed) {\n            for(let i = 0; i < json.extensionsUsed.length; ++i){\n                const extensionName = json.extensionsUsed[i];\n                const extensionsRequired = json.extensionsRequired || [];\n                switch(extensionName){\n                    case EXTENSIONS.KHR_MATERIALS_UNLIT:\n                        extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n                        break;\n                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n                        break;\n                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n                        extensions[extensionName] = new GLTFTextureTransformExtension();\n                        break;\n                    case EXTENSIONS.KHR_MESH_QUANTIZATION:\n                        extensions[extensionName] = new GLTFMeshQuantizationExtension();\n                        break;\n                    default:\n                        if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n                            console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n                        }\n                }\n            }\n        }\n        parser.setExtensions(extensions);\n        parser.setPlugins(plugins);\n        parser.parse(onLoad, onError);\n    }\n    parseAsync(data, path) {\n        const scope = this;\n        return new Promise(function(resolve, reject) {\n            scope.parse(data, path, resolve, reject);\n        });\n    }\n    constructor(manager){\n        super(manager);\n        this.dracoLoader = null;\n        this.ktx2Loader = null;\n        this.meshoptDecoder = null;\n        this.pluginCallbacks = [];\n        this.register(function(parser) {\n            return new GLTFMaterialsClearcoatExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureBasisUExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureWebPExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureAVIFExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSheenExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsTransmissionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsVolumeExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIorExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsEmissiveStrengthExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSpecularExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIridescenceExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsAnisotropyExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsBumpExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFLightsExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshoptCompression(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshGpuInstancing(parser);\n        });\n    }\n}\n/* GLTFREGISTRY */ function GLTFRegistry() {\n    let objects = {};\n    return {\n        get: function(key) {\n            return objects[key];\n        },\n        add: function(key, object) {\n            objects[key] = object;\n        },\n        remove: function(key) {\n            delete objects[key];\n        },\n        removeAll: function() {\n            objects = {};\n        }\n    };\n}\n_c = GLTFRegistry;\n/*********************************/ /********** EXTENSIONS ***********/ /*********************************/ const EXTENSIONS = {\n    KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n    KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n    KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n    KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n    KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n    KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n    KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n    KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n    KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n    KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n    KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n    KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n    KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n    KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n    KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n    KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n    EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n    EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n    EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n    EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n    EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */ class GLTFLightsExtension {\n    _markDefs() {\n        const parser = this.parser;\n        const nodeDefs = this.parser.json.nodes || [];\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n            }\n        }\n    }\n    _loadLight(lightIndex) {\n        const parser = this.parser;\n        const cacheKey = \"light:\" + lightIndex;\n        let dependency = parser.cache.get(cacheKey);\n        if (dependency) return dependency;\n        const json = parser.json;\n        const extensions = json.extensions && json.extensions[this.name] || {};\n        const lightDefs = extensions.lights || [];\n        const lightDef = lightDefs[lightIndex];\n        let lightNode;\n        const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0xffffff);\n        if (lightDef.color !== undefined) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        const range = lightDef.range !== undefined ? lightDef.range : 0;\n        switch(lightDef.type){\n            case \"directional\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            case \"point\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n                lightNode.distance = range;\n                break;\n            case \"spot\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n                lightNode.distance = range;\n                // Handle spotlight properties.\n                lightDef.spot = lightDef.spot || {};\n                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n                lightNode.angle = lightDef.spot.outerConeAngle;\n                lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            default:\n                throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n        }\n        // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n        // here, because node-level parsing will only override position if explicitly specified.\n        lightNode.position.set(0, 0, 0);\n        lightNode.decay = 2;\n        assignExtrasToUserData(lightNode, lightDef);\n        if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n        lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n        dependency = Promise.resolve(lightNode);\n        parser.cache.add(cacheKey, dependency);\n        return dependency;\n    }\n    getDependency(type, index) {\n        if (type !== \"light\") return;\n        return this._loadLight(index);\n    }\n    createNodeAttachment(nodeIndex) {\n        const self1 = this;\n        const parser = this.parser;\n        const json = parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n        const lightIndex = lightDef.light;\n        if (lightIndex === undefined) return null;\n        return this._loadLight(lightIndex).then(function(light) {\n            return parser._getNodeRef(self1.cache, lightIndex, light);\n        });\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n        // Object3D instance caches\n        this.cache = {\n            refs: {},\n            uses: {}\n        };\n    }\n}\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */ class GLTFMaterialsUnlitExtension {\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n    }\n    extendParams(materialParams, materialDef, parser) {\n        const pending = [];\n        materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0);\n        materialParams.opacity = 1.0;\n        const metallicRoughness = materialDef.pbrMetallicRoughness;\n        if (metallicRoughness) {\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.setRGB(array[0], array[1], array[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== undefined) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace));\n            }\n        }\n        return Promise.all(pending);\n    }\n    constructor(){\n        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n    }\n}\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */ class GLTFMaterialsEmissiveStrengthExtension {\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n        if (emissiveStrength !== undefined) {\n            materialParams.emissiveIntensity = emissiveStrength;\n        }\n        return Promise.resolve();\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n    }\n}\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */ class GLTFMaterialsClearcoatExtension {\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.clearcoatFactor !== undefined) {\n            materialParams.clearcoat = extension.clearcoatFactor;\n        }\n        if (extension.clearcoatTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n        }\n        if (extension.clearcoatRoughnessFactor !== undefined) {\n            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n        }\n        if (extension.clearcoatRoughnessTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n        }\n        if (extension.clearcoatNormalTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n            if (extension.clearcoatNormalTexture.scale !== undefined) {\n                const scale = extension.clearcoatNormalTexture.scale;\n                materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n            }\n        }\n        return Promise.all(pending);\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n    }\n}\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */ class GLTFMaterialsIridescenceExtension {\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.iridescenceFactor !== undefined) {\n            materialParams.iridescence = extension.iridescenceFactor;\n        }\n        if (extension.iridescenceTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n        }\n        if (extension.iridescenceIor !== undefined) {\n            materialParams.iridescenceIOR = extension.iridescenceIor;\n        }\n        if (materialParams.iridescenceThicknessRange === undefined) {\n            materialParams.iridescenceThicknessRange = [\n                100,\n                400\n            ];\n        }\n        if (extension.iridescenceThicknessMinimum !== undefined) {\n            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n        }\n        if (extension.iridescenceThicknessMaximum !== undefined) {\n            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n        }\n        if (extension.iridescenceThicknessTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture));\n        }\n        return Promise.all(pending);\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n    }\n}\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */ class GLTFMaterialsSheenExtension {\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n        materialParams.sheenRoughness = 0;\n        materialParams.sheen = 1;\n        const extension = materialDef.extensions[this.name];\n        if (extension.sheenColorFactor !== undefined) {\n            const colorFactor = extension.sheenColorFactor;\n            materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        }\n        if (extension.sheenRoughnessFactor !== undefined) {\n            materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n        }\n        if (extension.sheenColorTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace));\n        }\n        if (extension.sheenRoughnessTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n        }\n        return Promise.all(pending);\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n    }\n}\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */ class GLTFMaterialsTransmissionExtension {\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.transmissionFactor !== undefined) {\n            materialParams.transmission = extension.transmissionFactor;\n        }\n        if (extension.transmissionTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n        }\n        return Promise.all(pending);\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n    }\n}\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */ class GLTFMaterialsVolumeExtension {\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n        if (extension.thicknessTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n        }\n        materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n        const colorArray = extension.attenuationColor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        return Promise.all(pending);\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n    }\n}\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */ class GLTFMaterialsIorExtension {\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n        return Promise.resolve();\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n    }\n}\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */ class GLTFMaterialsSpecularExtension {\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n        if (extension.specularTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n        }\n        const colorArray = extension.specularColorFactor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        if (extension.specularColorTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace));\n        }\n        return Promise.all(pending);\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n    }\n}\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */ class GLTFMaterialsBumpExtension {\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;\n        if (extension.bumpTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n        }\n        return Promise.all(pending);\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n    }\n}\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */ class GLTFMaterialsAnisotropyExtension {\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.anisotropyStrength !== undefined) {\n            materialParams.anisotropy = extension.anisotropyStrength;\n        }\n        if (extension.anisotropyRotation !== undefined) {\n            materialParams.anisotropyRotation = extension.anisotropyRotation;\n        }\n        if (extension.anisotropyTexture !== undefined) {\n            pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n        }\n        return Promise.all(pending);\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n    }\n}\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */ class GLTFTextureBasisUExtension {\n    loadTexture(textureIndex) {\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[this.name];\n        const loader = parser.options.ktx2Loader;\n        if (!loader) {\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n            } else {\n                // Assumes that the extension is optional and that a fallback texture is present\n                return null;\n            }\n        }\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n    }\n}\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */ class GLTFTextureWebPExtension {\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n            }\n            // Fall back to PNG or JPEG.\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                // Lossy test image. Support for lossy images doesn't guarantee support for all\n                // WebP images, unfortunately.\n                image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n        this.isSupported = null;\n    }\n}\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */ class GLTFTextureAVIFExtension {\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n            }\n            // Fall back to PNG or JPEG.\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                // Lossy test image.\n                image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n        this.isSupported = null;\n    }\n}\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */ class GLTFMeshoptCompression {\n    loadBufferView(index) {\n        const json = this.parser.json;\n        const bufferView = json.bufferViews[index];\n        if (bufferView.extensions && bufferView.extensions[this.name]) {\n            const extensionDef = bufferView.extensions[this.name];\n            const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n            const decoder = this.parser.options.meshoptDecoder;\n            if (!decoder || !decoder.supported) {\n                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                    throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n                } else {\n                    // Assumes that the extension is optional and that fallback buffer data is present\n                    return null;\n                }\n            }\n            return buffer.then(function(res) {\n                const byteOffset = extensionDef.byteOffset || 0;\n                const byteLength = extensionDef.byteLength || 0;\n                const count = extensionDef.count;\n                const stride = extensionDef.byteStride;\n                const source = new Uint8Array(res, byteOffset, byteLength);\n                if (decoder.decodeGltfBufferAsync) {\n                    return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res) {\n                        return res.buffer;\n                    });\n                } else {\n                    // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n                    return decoder.ready.then(function() {\n                        const result = new ArrayBuffer(count * stride);\n                        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n                        return result;\n                    });\n                }\n            });\n        } else {\n            return null;\n        }\n    }\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n        this.parser = parser;\n    }\n}\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */ class GLTFMeshGpuInstancing {\n    createNodeMesh(nodeIndex) {\n        const json = this.parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {\n            return null;\n        }\n        const meshDef = json.meshes[nodeDef.mesh];\n        // No Points or Lines + Instancing support yet\n        for (const primitive of meshDef.primitives){\n            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== undefined) {\n                return null;\n            }\n        }\n        const extensionDef = nodeDef.extensions[this.name];\n        const attributesDef = extensionDef.attributes;\n        // @TODO: Can we support InstancedMesh + SkinnedMesh?\n        const pending = [];\n        const attributes = {};\n        for(const key in attributesDef){\n            pending.push(this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor)=>{\n                attributes[key] = accessor;\n                return attributes[key];\n            }));\n        }\n        if (pending.length < 1) {\n            return null;\n        }\n        pending.push(this.parser.createNodeMesh(nodeIndex));\n        return Promise.all(pending).then((results)=>{\n            const nodeObject = results.pop();\n            const meshes = nodeObject.isGroup ? nodeObject.children : [\n                nodeObject\n            ];\n            const count = results[0].count; // All attribute counts should be same\n            const instancedMeshes = [];\n            for (const mesh of meshes){\n                // Temporal variables\n                const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n                const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n                const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n                for(let i = 0; i < count; i++){\n                    if (attributes.TRANSLATION) {\n                        p.fromBufferAttribute(attributes.TRANSLATION, i);\n                    }\n                    if (attributes.ROTATION) {\n                        q.fromBufferAttribute(attributes.ROTATION, i);\n                    }\n                    if (attributes.SCALE) {\n                        s.fromBufferAttribute(attributes.SCALE, i);\n                    }\n                    instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n                }\n                // Add instance attributes to the geometry, excluding TRS.\n                for(const attributeName in attributes){\n                    if (attributeName === \"_COLOR_0\") {\n                        const attr = attributes[attributeName];\n                        instancedMesh.instanceColor = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n                    } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n                        mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n                    }\n                }\n                // Just in case\n                three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n                this.parser.assignFinalMaterial(instancedMesh);\n                instancedMeshes.push(instancedMesh);\n            }\n            if (nodeObject.isGroup) {\n                nodeObject.clear();\n                nodeObject.add(...instancedMeshes);\n                return nodeObject;\n            }\n            return instancedMeshes[0];\n        });\n    }\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n        this.parser = parser;\n    }\n}\n/* BINARY EXTENSION */ const BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 0x4E4F534A,\n    BIN: 0x004E4942\n};\nclass GLTFBinaryExtension {\n    constructor(data){\n        this.name = EXTENSIONS.KHR_BINARY_GLTF;\n        this.content = null;\n        this.body = null;\n        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n        const textDecoder = new TextDecoder();\n        this.header = {\n            magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),\n            version: headerView.getUint32(4, true),\n            length: headerView.getUint32(8, true)\n        };\n        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n            throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n        } else if (this.header.version < 2.0) {\n            throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n        }\n        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n        let chunkIndex = 0;\n        while(chunkIndex < chunkContentsLength){\n            const chunkLength = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            const chunkType = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n                const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n                this.content = textDecoder.decode(contentArray);\n            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n                const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n                this.body = data.slice(byteOffset, byteOffset + chunkLength);\n            }\n            // Clients must ignore chunks with unknown types.\n            chunkIndex += chunkLength;\n        }\n        if (this.content === null) {\n            throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n        }\n    }\n}\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */ class GLTFDracoMeshCompressionExtension {\n    decodePrimitive(primitive, parser) {\n        const json = this.json;\n        const dracoLoader = this.dracoLoader;\n        const bufferViewIndex = primitive.extensions[this.name].bufferView;\n        const gltfAttributeMap = primitive.extensions[this.name].attributes;\n        const threeAttributeMap = {};\n        const attributeNormalizedMap = {};\n        const attributeTypeMap = {};\n        for(const attributeName in gltfAttributeMap){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n        }\n        for(const attributeName in primitive.attributes){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            if (gltfAttributeMap[attributeName] !== undefined) {\n                const accessorDef = json.accessors[primitive.attributes[attributeName]];\n                const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n                attributeTypeMap[threeAttributeName] = componentType.name;\n                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n            }\n        }\n        return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n            return new Promise(function(resolve, reject) {\n                dracoLoader.decodeDracoFile(bufferView, function(geometry) {\n                    for(const attributeName in geometry.attributes){\n                        const attribute = geometry.attributes[attributeName];\n                        const normalized = attributeNormalizedMap[attributeName];\n                        if (normalized !== undefined) attribute.normalized = normalized;\n                    }\n                    resolve(geometry);\n                }, threeAttributeMap, attributeTypeMap, three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace, reject);\n            });\n        });\n    }\n    constructor(json, dracoLoader){\n        if (!dracoLoader) {\n            throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n        }\n        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n        this.json = json;\n        this.dracoLoader = dracoLoader;\n        this.dracoLoader.preload();\n    }\n}\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */ class GLTFTextureTransformExtension {\n    extendTexture(texture, transform) {\n        if ((transform.texCoord === undefined || transform.texCoord === texture.channel) && transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {\n            // See https://github.com/mrdoob/three.js/issues/21819.\n            return texture;\n        }\n        texture = texture.clone();\n        if (transform.texCoord !== undefined) {\n            texture.channel = transform.texCoord;\n        }\n        if (transform.offset !== undefined) {\n            texture.offset.fromArray(transform.offset);\n        }\n        if (transform.rotation !== undefined) {\n            texture.rotation = transform.rotation;\n        }\n        if (transform.scale !== undefined) {\n            texture.repeat.fromArray(transform.scale);\n        }\n        texture.needsUpdate = true;\n        return texture;\n    }\n    constructor(){\n        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n    }\n}\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */ class GLTFMeshQuantizationExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n    }\n}\n/*********************************/ /********** INTERPOLATION ********/ /*********************************/ // Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n    copySampleValue_(index) {\n        // Copies a sample value to the result buffer. See description of glTF\n        // CUBICSPLINE values layout in interpolate_() function below.\n        const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n        for(let i = 0; i !== valueSize; i++){\n            result[i] = values[offset + i];\n        }\n        return result;\n    }\n    interpolate_(i1, t0, t, t1) {\n        const result = this.resultBuffer;\n        const values = this.sampleValues;\n        const stride = this.valueSize;\n        const stride2 = stride * 2;\n        const stride3 = stride * 3;\n        const td = t1 - t0;\n        const p = (t - t0) / td;\n        const pp = p * p;\n        const ppp = pp * p;\n        const offset1 = i1 * stride3;\n        const offset0 = offset1 - stride3;\n        const s2 = -2 * ppp + 3 * pp;\n        const s3 = ppp - pp;\n        const s0 = 1 - s2;\n        const s1 = s3 - pp + p;\n        // Layout of keyframe output values for CUBICSPLINE animations:\n        //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n        for(let i = 0; i !== stride; i++){\n            const p0 = values[offset0 + i + stride]; // splineVertex_k\n            const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n            const p1 = values[offset1 + i + stride]; // splineVertex_k+1\n            const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n        }\n        return result;\n    }\n    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){\n        super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    }\n}\nconst _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n    interpolate_(i1, t0, t, t1) {\n        const result = super.interpolate_(i1, t0, t, t1);\n        _q.fromArray(result).normalize().toArray(result);\n        return result;\n    }\n}\n/*********************************/ /********** INTERNALS ************/ /*********************************/ /* CONSTANTS */ const WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n    9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n    9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n    9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n    9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n    9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n    9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n    33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n    33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n    10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n    \"SCALAR\": 1,\n    \"VEC2\": 2,\n    \"VEC3\": 3,\n    \"VEC4\": 4,\n    \"MAT2\": 4,\n    \"MAT3\": 9,\n    \"MAT4\": 16\n};\nconst ATTRIBUTES = {\n    POSITION: \"position\",\n    NORMAL: \"normal\",\n    TANGENT: \"tangent\",\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\",\n    COLOR_0: \"color\",\n    WEIGHTS_0: \"skinWeight\",\n    JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n    scale: \"scale\",\n    translation: \"position\",\n    rotation: \"quaternion\",\n    weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n    CUBICSPLINE: undefined,\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n    STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n    OPAQUE: \"OPAQUE\",\n    MASK: \"MASK\",\n    BLEND: \"BLEND\"\n};\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */ function createDefaultMaterial(cache) {\n    if (cache[\"DefaultMaterial\"] === undefined) {\n        cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: 0xFFFFFF,\n            emissive: 0x000000,\n            metalness: 1,\n            roughness: 1,\n            transparent: false,\n            depthTest: true,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n        });\n    }\n    return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    // Add unknown glTF extensions to an object's userData.\n    for(const name in objectDef.extensions){\n        if (knownExtensions[name] === undefined) {\n            object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n            object.userData.gltfExtensions[name] = objectDef.extensions[name];\n        }\n    }\n}\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */ function assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== undefined) {\n        if (typeof gltfDef.extras === \"object\") {\n            Object.assign(object.userData, gltfDef.extras);\n        } else {\n            console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n        }\n    }\n}\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */ function addMorphTargets(geometry, targets, parser) {\n    let hasMorphPosition = false;\n    let hasMorphNormal = false;\n    let hasMorphColor = false;\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (target.POSITION !== undefined) hasMorphPosition = true;\n        if (target.NORMAL !== undefined) hasMorphNormal = true;\n        if (target.COLOR_0 !== undefined) hasMorphColor = true;\n        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n    }\n    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n    const pendingPositionAccessors = [];\n    const pendingNormalAccessors = [];\n    const pendingColorAccessors = [];\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (hasMorphPosition) {\n            const pendingAccessor = target.POSITION !== undefined ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n            pendingPositionAccessors.push(pendingAccessor);\n        }\n        if (hasMorphNormal) {\n            const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n            pendingNormalAccessors.push(pendingAccessor);\n        }\n        if (hasMorphColor) {\n            const pendingAccessor = target.COLOR_0 !== undefined ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n            pendingColorAccessors.push(pendingAccessor);\n        }\n    }\n    return Promise.all([\n        Promise.all(pendingPositionAccessors),\n        Promise.all(pendingNormalAccessors),\n        Promise.all(pendingColorAccessors)\n    ]).then(function(accessors) {\n        const morphPositions = accessors[0];\n        const morphNormals = accessors[1];\n        const morphColors = accessors[2];\n        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n        if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n        geometry.morphTargetsRelative = true;\n        return geometry;\n    });\n}\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */ function updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n    if (meshDef.weights !== undefined) {\n        for(let i = 0, il = meshDef.weights.length; i < il; i++){\n            mesh.morphTargetInfluences[i] = meshDef.weights[i];\n        }\n    }\n    // .extras has user-defined data, so check that .extras.targetNames is an array.\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n        const targetNames = meshDef.extras.targetNames;\n        if (mesh.morphTargetInfluences.length === targetNames.length) {\n            mesh.morphTargetDictionary = {};\n            for(let i = 0, il = targetNames.length; i < il; i++){\n                mesh.morphTargetDictionary[targetNames[i]] = i;\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n        }\n    }\n}\nfunction createPrimitiveKey(primitiveDef) {\n    let geometryKey;\n    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    if (dracoExtension) {\n        geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n    } else {\n        geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n    }\n    if (primitiveDef.targets !== undefined) {\n        for(let i = 0, il = primitiveDef.targets.length; i < il; i++){\n            geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n        }\n    }\n    return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n    let attributesKey = \"\";\n    const keys = Object.keys(attributes).sort();\n    for(let i = 0, il = keys.length; i < il; i++){\n        attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n    }\n    return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n    // Reference:\n    // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n    switch(constructor){\n        case Int8Array:\n            return 1 / 127;\n        case Uint8Array:\n            return 1 / 255;\n        case Int16Array:\n            return 1 / 32767;\n        case Uint16Array:\n            return 1 / 65535;\n        default:\n            throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n    }\n}\nfunction getImageURIMimeType(uri) {\n    if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return \"image/jpeg\";\n    if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return \"image/webp\";\n    return \"image/png\";\n}\nconst _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n/* GLTF PARSER */ class GLTFParser {\n    setExtensions(extensions) {\n        this.extensions = extensions;\n    }\n    setPlugins(plugins) {\n        this.plugins = plugins;\n    }\n    parse(onLoad, onError) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        // Clear the loader cache\n        this.cache.removeAll();\n        this.nodeCache = {};\n        // Mark the special nodes/meshes in json for efficient parse\n        this._invokeAll(function(ext) {\n            return ext._markDefs && ext._markDefs();\n        });\n        Promise.all(this._invokeAll(function(ext) {\n            return ext.beforeRoot && ext.beforeRoot();\n        })).then(function() {\n            return Promise.all([\n                parser.getDependencies(\"scene\"),\n                parser.getDependencies(\"animation\"),\n                parser.getDependencies(\"camera\")\n            ]);\n        }).then(function(dependencies) {\n            const result = {\n                scene: dependencies[0][json.scene || 0],\n                scenes: dependencies[0],\n                animations: dependencies[1],\n                cameras: dependencies[2],\n                asset: json.asset,\n                parser: parser,\n                userData: {}\n            };\n            addUnknownExtensionsToUserData(extensions, result, json);\n            assignExtrasToUserData(result, json);\n            return Promise.all(parser._invokeAll(function(ext) {\n                return ext.afterRoot && ext.afterRoot(result);\n            })).then(function() {\n                onLoad(result);\n            });\n        }).catch(onError);\n    }\n    /**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */ _markDefs() {\n        const nodeDefs = this.json.nodes || [];\n        const skinDefs = this.json.skins || [];\n        const meshDefs = this.json.meshes || [];\n        // Nothing in the node definition indicates whether it is a Bone or an\n        // Object3D. Use the skins' joint references to mark bones.\n        for(let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){\n            const joints = skinDefs[skinIndex].joints;\n            for(let i = 0, il = joints.length; i < il; i++){\n                nodeDefs[joints[i]].isBone = true;\n            }\n        }\n        // Iterate over all nodes, marking references to shared resources,\n        // as well as skeleton joints.\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.mesh !== undefined) {\n                this._addNodeRef(this.meshCache, nodeDef.mesh);\n                // Nothing in the mesh definition indicates whether it is\n                // a SkinnedMesh or Mesh. Use the node's mesh reference\n                // to mark SkinnedMesh if node has skin.\n                if (nodeDef.skin !== undefined) {\n                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n                }\n            }\n            if (nodeDef.camera !== undefined) {\n                this._addNodeRef(this.cameraCache, nodeDef.camera);\n            }\n        }\n    }\n    /**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */ _addNodeRef(cache, index) {\n        if (index === undefined) return;\n        if (cache.refs[index] === undefined) {\n            cache.refs[index] = cache.uses[index] = 0;\n        }\n        cache.refs[index]++;\n    }\n    /** Returns a reference to a shared resource, cloning it if necessary. */ _getNodeRef(cache, index, object) {\n        if (cache.refs[index] <= 1) return object;\n        const ref = object.clone();\n        // Propagates mappings to the cloned object, prevents mappings on the\n        // original object from being lost.\n        const updateMappings = (original, clone)=>{\n            const mappings = this.associations.get(original);\n            if (mappings != null) {\n                this.associations.set(clone, mappings);\n            }\n            for (const [i, child] of original.children.entries()){\n                updateMappings(child, clone.children[i]);\n            }\n        };\n        updateMappings(object, ref);\n        ref.name += \"_instance_\" + cache.uses[index]++;\n        return ref;\n    }\n    _invokeOne(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.push(this);\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) return result;\n        }\n        return null;\n    }\n    _invokeAll(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.unshift(this);\n        const pending = [];\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) pending.push(result);\n        }\n        return pending;\n    }\n    /**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */ getDependency(type, index) {\n        const cacheKey = type + \":\" + index;\n        let dependency = this.cache.get(cacheKey);\n        if (!dependency) {\n            switch(type){\n                case \"scene\":\n                    dependency = this.loadScene(index);\n                    break;\n                case \"node\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadNode && ext.loadNode(index);\n                    });\n                    break;\n                case \"mesh\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMesh && ext.loadMesh(index);\n                    });\n                    break;\n                case \"accessor\":\n                    dependency = this.loadAccessor(index);\n                    break;\n                case \"bufferView\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadBufferView && ext.loadBufferView(index);\n                    });\n                    break;\n                case \"buffer\":\n                    dependency = this.loadBuffer(index);\n                    break;\n                case \"material\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMaterial && ext.loadMaterial(index);\n                    });\n                    break;\n                case \"texture\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadTexture && ext.loadTexture(index);\n                    });\n                    break;\n                case \"skin\":\n                    dependency = this.loadSkin(index);\n                    break;\n                case \"animation\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadAnimation && ext.loadAnimation(index);\n                    });\n                    break;\n                case \"camera\":\n                    dependency = this.loadCamera(index);\n                    break;\n                default:\n                    dependency = this._invokeOne(function(ext) {\n                        return ext != this && ext.getDependency && ext.getDependency(type, index);\n                    });\n                    if (!dependency) {\n                        throw new Error(\"Unknown type: \" + type);\n                    }\n                    break;\n            }\n            this.cache.add(cacheKey, dependency);\n        }\n        return dependency;\n    }\n    /**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */ getDependencies(type) {\n        let dependencies = this.cache.get(type);\n        if (!dependencies) {\n            const parser = this;\n            const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n            dependencies = Promise.all(defs.map(function(def, index) {\n                return parser.getDependency(type, index);\n            }));\n            this.cache.add(type, dependencies);\n        }\n        return dependencies;\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */ loadBuffer(bufferIndex) {\n        const bufferDef = this.json.buffers[bufferIndex];\n        const loader = this.fileLoader;\n        if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n            throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n        }\n        // If present, GLB container is required to be the first buffer.\n        if (bufferDef.uri === undefined && bufferIndex === 0) {\n            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n        }\n        const options = this.options;\n        return new Promise(function(resolve, reject) {\n            loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function() {\n                reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n            });\n        });\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */ loadBufferView(bufferViewIndex) {\n        const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n        return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n            const byteLength = bufferViewDef.byteLength || 0;\n            const byteOffset = bufferViewDef.byteOffset || 0;\n            return buffer.slice(byteOffset, byteOffset + byteLength);\n        });\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */ loadAccessor(accessorIndex) {\n        const parser = this;\n        const json = this.json;\n        const accessorDef = this.json.accessors[accessorIndex];\n        if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const normalized = accessorDef.normalized === true;\n            const array = new TypedArray(accessorDef.count * itemSize);\n            return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n        }\n        const pendingBufferViews = [];\n        if (accessorDef.bufferView !== undefined) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n        } else {\n            pendingBufferViews.push(null);\n        }\n        if (accessorDef.sparse !== undefined) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n        }\n        return Promise.all(pendingBufferViews).then(function(bufferViews) {\n            const bufferView = bufferViews[0];\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n            const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n            const itemBytes = elementBytes * itemSize;\n            const byteOffset = accessorDef.byteOffset || 0;\n            const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n            const normalized = accessorDef.normalized === true;\n            let array, bufferAttribute;\n            // The buffer is not interleaved if the stride is the item size in bytes.\n            if (byteStride && byteStride !== itemBytes) {\n                // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n                // This makes sure that IBA.count reflects accessor.count properly\n                const ibSlice = Math.floor(byteOffset / byteStride);\n                const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n                let ib = parser.cache.get(ibCacheKey);\n                if (!ib) {\n                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n                    // Integer parameters to IB/IBA are in array elements, not bytes.\n                    ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n                    parser.cache.add(ibCacheKey, ib);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n            } else {\n                if (bufferView === null) {\n                    array = new TypedArray(accessorDef.count * itemSize);\n                } else {\n                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n            }\n            // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n            if (accessorDef.sparse !== undefined) {\n                const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n                const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n                const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n                const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n                const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n                const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n                if (bufferView !== null) {\n                    // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n                    bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n                }\n                for(let i = 0, il = sparseIndices.length; i < il; i++){\n                    const index = sparseIndices[i];\n                    bufferAttribute.setX(index, sparseValues[i * itemSize]);\n                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n                    if (itemSize >= 5) throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n                }\n            }\n            return bufferAttribute;\n        });\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture|null>}\n\t */ loadTexture(textureIndex) {\n        const json = this.json;\n        const options = this.options;\n        const textureDef = json.textures[textureIndex];\n        const sourceIndex = textureDef.source;\n        const sourceDef = json.images[sourceIndex];\n        let loader = this.textureLoader;\n        if (sourceDef.uri) {\n            const handler = options.manager.getHandler(sourceDef.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.loadTextureImage(textureIndex, sourceIndex, loader);\n    }\n    loadTextureImage(textureIndex, sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const textureDef = json.textures[textureIndex];\n        const sourceDef = json.images[sourceIndex];\n        const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n        if (this.textureCache[cacheKey]) {\n            // See https://github.com/mrdoob/three.js/issues/21559.\n            return this.textureCache[cacheKey];\n        }\n        const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n            texture.flipY = false;\n            texture.name = textureDef.name || sourceDef.name || \"\";\n            if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n                texture.name = sourceDef.uri;\n            }\n            const samplers = json.samplers || {};\n            const sampler = samplers[textureDef.sampler] || {};\n            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            parser.associations.set(texture, {\n                textures: textureIndex\n            });\n            return texture;\n        }).catch(function() {\n            return null;\n        });\n        this.textureCache[cacheKey] = promise;\n        return promise;\n    }\n    loadImageSource(sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const options = this.options;\n        if (this.sourceCache[sourceIndex] !== undefined) {\n            return this.sourceCache[sourceIndex].then((texture)=>texture.clone());\n        }\n        const sourceDef = json.images[sourceIndex];\n        const URL = self.URL || self.webkitURL;\n        let sourceURI = sourceDef.uri || \"\";\n        let isObjectURL = false;\n        if (sourceDef.bufferView !== undefined) {\n            // Load binary image data from bufferView, if provided.\n            sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n                isObjectURL = true;\n                const blob = new Blob([\n                    bufferView\n                ], {\n                    type: sourceDef.mimeType\n                });\n                sourceURI = URL.createObjectURL(blob);\n                return sourceURI;\n            });\n        } else if (sourceDef.uri === undefined) {\n            throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n        }\n        const promise = Promise.resolve(sourceURI).then(function(sourceURI) {\n            return new Promise(function(resolve, reject) {\n                let onLoad = resolve;\n                if (loader.isImageBitmapLoader === true) {\n                    onLoad = function(imageBitmap) {\n                        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n                        texture.needsUpdate = true;\n                        resolve(texture);\n                    };\n                }\n                loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject);\n            });\n        }).then(function(texture) {\n            // Clean up resources and configure Texture.\n            if (isObjectURL === true) {\n                URL.revokeObjectURL(sourceURI);\n            }\n            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n            return texture;\n        }).catch(function(error) {\n            console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n            throw error;\n        });\n        this.sourceCache[sourceIndex] = promise;\n        return promise;\n    }\n    /**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise<Texture>}\n\t */ assignTexture(materialParams, mapName, mapDef, colorSpace) {\n        const parser = this;\n        return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n            if (!texture) return null;\n            if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {\n                texture = texture.clone();\n                texture.channel = mapDef.texCoord;\n            }\n            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n                const transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n                if (transform) {\n                    const gltfReference = parser.associations.get(texture);\n                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n                    parser.associations.set(texture, gltfReference);\n                }\n            }\n            if (colorSpace !== undefined) {\n                texture.colorSpace = colorSpace;\n            }\n            materialParams[mapName] = texture;\n            return texture;\n        });\n    }\n    /**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */ assignFinalMaterial(mesh) {\n        const geometry = mesh.geometry;\n        let material = mesh.material;\n        const useDerivativeTangents = geometry.attributes.tangent === undefined;\n        const useVertexColors = geometry.attributes.color !== undefined;\n        const useFlatShading = geometry.attributes.normal === undefined;\n        if (mesh.isPoints) {\n            const cacheKey = \"PointsMaterial:\" + material.uuid;\n            let pointsMaterial = this.cache.get(cacheKey);\n            if (!pointsMaterial) {\n                pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n                pointsMaterial.color.copy(material.color);\n                pointsMaterial.map = material.map;\n                pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n                this.cache.add(cacheKey, pointsMaterial);\n            }\n            material = pointsMaterial;\n        } else if (mesh.isLine) {\n            const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n            let lineMaterial = this.cache.get(cacheKey);\n            if (!lineMaterial) {\n                lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n                lineMaterial.color.copy(material.color);\n                lineMaterial.map = material.map;\n                this.cache.add(cacheKey, lineMaterial);\n            }\n            material = lineMaterial;\n        }\n        // Clone the material if it will be modified\n        if (useDerivativeTangents || useVertexColors || useFlatShading) {\n            let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n            if (useDerivativeTangents) cacheKey += \"derivative-tangents:\";\n            if (useVertexColors) cacheKey += \"vertex-colors:\";\n            if (useFlatShading) cacheKey += \"flat-shading:\";\n            let cachedMaterial = this.cache.get(cacheKey);\n            if (!cachedMaterial) {\n                cachedMaterial = material.clone();\n                if (useVertexColors) cachedMaterial.vertexColors = true;\n                if (useFlatShading) cachedMaterial.flatShading = true;\n                if (useDerivativeTangents) {\n                    // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n                    if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n                    if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n                }\n                this.cache.add(cacheKey, cachedMaterial);\n                this.associations.set(cachedMaterial, this.associations.get(material));\n            }\n            material = cachedMaterial;\n        }\n        mesh.material = material;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */ loadMaterial(materialIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const materialDef = json.materials[materialIndex];\n        let materialType;\n        const materialParams = {};\n        const materialExtensions = materialDef.extensions || {};\n        const pending = [];\n        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n            materialType = kmuExtension.getMaterialType();\n            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n        } else {\n            // Specification:\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n            const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n            materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0);\n            materialParams.opacity = 1.0;\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.setRGB(array[0], array[1], array[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== undefined) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace));\n            }\n            materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n            materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n            if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n                pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n                pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n            }\n            materialType = this._invokeOne(function(ext) {\n                return ext.getMaterialType && ext.getMaterialType(materialIndex);\n            });\n            pending.push(Promise.all(this._invokeAll(function(ext) {\n                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n            })));\n        }\n        if (materialDef.doubleSided === true) {\n            materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        }\n        const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n        if (alphaMode === ALPHA_MODES.BLEND) {\n            materialParams.transparent = true;\n            // See: https://github.com/mrdoob/three.js/issues/17706\n            materialParams.depthWrite = false;\n        } else {\n            materialParams.transparent = false;\n            if (alphaMode === ALPHA_MODES.MASK) {\n                materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n            }\n        }\n        if (materialDef.normalTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n            materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n            if (materialDef.normalTexture.scale !== undefined) {\n                const scale = materialDef.normalTexture.scale;\n                materialParams.normalScale.set(scale, scale);\n            }\n        }\n        if (materialDef.occlusionTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n            if (materialDef.occlusionTexture.strength !== undefined) {\n                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n            }\n        }\n        if (materialDef.emissiveFactor !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            const emissiveFactor = materialDef.emissiveFactor;\n            materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        }\n        if (materialDef.emissiveTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace));\n        }\n        return Promise.all(pending).then(function() {\n            const material = new materialType(materialParams);\n            if (materialDef.name) material.name = materialDef.name;\n            assignExtrasToUserData(material, materialDef);\n            parser.associations.set(material, {\n                materials: materialIndex\n            });\n            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n            return material;\n        });\n    }\n    /** When Object3D instances are targeted by animation, they need unique names. */ createUniqueName(originalName) {\n        const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n        if (sanitizedName in this.nodeNamesUsed) {\n            return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n        } else {\n            this.nodeNamesUsed[sanitizedName] = 0;\n            return sanitizedName;\n        }\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */ loadGeometries(primitives) {\n        const parser = this;\n        const extensions = this.extensions;\n        const cache = this.primitiveCache;\n        function createDracoPrimitive(primitive) {\n            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n                return addPrimitiveAttributes(geometry, primitive, parser);\n            });\n        }\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const primitive = primitives[i];\n            const cacheKey = createPrimitiveKey(primitive);\n            // See if we've already created this geometry\n            const cached = cache[cacheKey];\n            if (cached) {\n                // Use the cached geometry if it exists\n                pending.push(cached.promise);\n            } else {\n                let geometryPromise;\n                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n                    // Use DRACO geometry if available\n                    geometryPromise = createDracoPrimitive(primitive);\n                } else {\n                    // Otherwise create a new geometry\n                    geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n                }\n                // Cache this geometry\n                cache[cacheKey] = {\n                    primitive: primitive,\n                    promise: geometryPromise\n                };\n                pending.push(geometryPromise);\n            }\n        }\n        return Promise.all(pending);\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */ loadMesh(meshIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const meshDef = json.meshes[meshIndex];\n        const primitives = meshDef.primitives;\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n            pending.push(material);\n        }\n        pending.push(parser.loadGeometries(primitives));\n        return Promise.all(pending).then(function(results) {\n            const materials = results.slice(0, results.length - 1);\n            const geometries = results[results.length - 1];\n            const meshes = [];\n            for(let i = 0, il = geometries.length; i < il; i++){\n                const geometry = geometries[i];\n                const primitive = primitives[i];\n                // 1. create Mesh\n                let mesh;\n                const material = materials[i];\n                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n                    // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n                    mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n                    if (mesh.isSkinnedMesh === true) {\n                        // normalize skin weights to fix malformed assets (see #15319)\n                        mesh.normalizeSkinWeights();\n                    }\n                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n                    }\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n                } else {\n                    throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n                }\n                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n                    updateMorphTargets(mesh, meshDef);\n                }\n                mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n                assignExtrasToUserData(mesh, meshDef);\n                if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n                parser.assignFinalMaterial(mesh);\n                meshes.push(mesh);\n            }\n            for(let i = 0, il = meshes.length; i < il; i++){\n                parser.associations.set(meshes[i], {\n                    meshes: meshIndex,\n                    primitives: i\n                });\n            }\n            if (meshes.length === 1) {\n                if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n                return meshes[0];\n            }\n            const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);\n            parser.associations.set(group, {\n                meshes: meshIndex\n            });\n            for(let i = 0, il = meshes.length; i < il; i++){\n                group.add(meshes[i]);\n            }\n            return group;\n        });\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */ loadCamera(cameraIndex) {\n        let camera;\n        const cameraDef = this.json.cameras[cameraIndex];\n        const params = cameraDef[cameraDef.type];\n        if (!params) {\n            console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n            return;\n        }\n        if (cameraDef.type === \"perspective\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n        } else if (cameraDef.type === \"orthographic\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n        }\n        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n        assignExtrasToUserData(camera, cameraDef);\n        return Promise.resolve(camera);\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Skeleton>}\n\t */ loadSkin(skinIndex) {\n        const skinDef = this.json.skins[skinIndex];\n        const pending = [];\n        for(let i = 0, il = skinDef.joints.length; i < il; i++){\n            pending.push(this._loadNodeShallow(skinDef.joints[i]));\n        }\n        if (skinDef.inverseBindMatrices !== undefined) {\n            pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n        } else {\n            pending.push(null);\n        }\n        return Promise.all(pending).then(function(results) {\n            const inverseBindMatrices = results.pop();\n            const jointNodes = results;\n            // Note that bones (joint nodes) may or may not be in the\n            // scene graph at this time.\n            const bones = [];\n            const boneInverses = [];\n            for(let i = 0, il = jointNodes.length; i < il; i++){\n                const jointNode = jointNodes[i];\n                if (jointNode) {\n                    bones.push(jointNode);\n                    const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                    if (inverseBindMatrices !== null) {\n                        mat.fromArray(inverseBindMatrices.array, i * 16);\n                    }\n                    boneInverses.push(mat);\n                } else {\n                    console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n        });\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */ loadAnimation(animationIndex) {\n        const json = this.json;\n        const parser = this;\n        const animationDef = json.animations[animationIndex];\n        const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n        const pendingNodes = [];\n        const pendingInputAccessors = [];\n        const pendingOutputAccessors = [];\n        const pendingSamplers = [];\n        const pendingTargets = [];\n        for(let i = 0, il = animationDef.channels.length; i < il; i++){\n            const channel = animationDef.channels[i];\n            const sampler = animationDef.samplers[channel.sampler];\n            const target = channel.target;\n            const name = target.node;\n            const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n            const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n            if (target.node === undefined) continue;\n            pendingNodes.push(this.getDependency(\"node\", name));\n            pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n            pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n            pendingSamplers.push(sampler);\n            pendingTargets.push(target);\n        }\n        return Promise.all([\n            Promise.all(pendingNodes),\n            Promise.all(pendingInputAccessors),\n            Promise.all(pendingOutputAccessors),\n            Promise.all(pendingSamplers),\n            Promise.all(pendingTargets)\n        ]).then(function(dependencies) {\n            const nodes = dependencies[0];\n            const inputAccessors = dependencies[1];\n            const outputAccessors = dependencies[2];\n            const samplers = dependencies[3];\n            const targets = dependencies[4];\n            const tracks = [];\n            for(let i = 0, il = nodes.length; i < il; i++){\n                const node = nodes[i];\n                const inputAccessor = inputAccessors[i];\n                const outputAccessor = outputAccessors[i];\n                const sampler = samplers[i];\n                const target = targets[i];\n                if (node === undefined) continue;\n                if (node.updateMatrix) {\n                    node.updateMatrix();\n                }\n                const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n                if (createdTracks) {\n                    for(let k = 0; k < createdTracks.length; k++){\n                        tracks.push(createdTracks[k]);\n                    }\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, undefined, tracks);\n        });\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        if (nodeDef.mesh === undefined) return null;\n        return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n            // if weights are provided on the node, override weights on the mesh.\n            if (nodeDef.weights !== undefined) {\n                node.traverse(function(o) {\n                    if (!o.isMesh) return;\n                    for(let i = 0, il = nodeDef.weights.length; i < il; i++){\n                        o.morphTargetInfluences[i] = nodeDef.weights[i];\n                    }\n                });\n            }\n            return node;\n        });\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */ loadNode(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        const nodePending = parser._loadNodeShallow(nodeIndex);\n        const childPending = [];\n        const childrenDef = nodeDef.children || [];\n        for(let i = 0, il = childrenDef.length; i < il; i++){\n            childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n        }\n        const skeletonPending = nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n        return Promise.all([\n            nodePending,\n            Promise.all(childPending),\n            skeletonPending\n        ]).then(function(results) {\n            const node = results[0];\n            const children = results[1];\n            const skeleton = results[2];\n            if (skeleton !== null) {\n                // This full traverse should be fine because\n                // child glTF nodes have not been added to this node yet.\n                node.traverse(function(mesh) {\n                    if (!mesh.isSkinnedMesh) return;\n                    mesh.bind(skeleton, _identityMatrix);\n                });\n            }\n            for(let i = 0, il = children.length; i < il; i++){\n                node.add(children[i]);\n            }\n            return node;\n        });\n    }\n    // ._loadNodeShallow() parses a single node.\n    // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n    _loadNodeShallow(nodeIndex) {\n        const json = this.json;\n        const extensions = this.extensions;\n        const parser = this;\n        // This method is called from .loadNode() and .loadSkin().\n        // Cache a node to avoid duplication.\n        if (this.nodeCache[nodeIndex] !== undefined) {\n            return this.nodeCache[nodeIndex];\n        }\n        const nodeDef = json.nodes[nodeIndex];\n        // reserve node's name before its dependencies, so the root has the intended name.\n        const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n        const pending = [];\n        const meshPromise = parser._invokeOne(function(ext) {\n            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n        });\n        if (meshPromise) {\n            pending.push(meshPromise);\n        }\n        if (nodeDef.camera !== undefined) {\n            pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n            }));\n        }\n        parser._invokeAll(function(ext) {\n            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n        }).forEach(function(promise) {\n            pending.push(promise);\n        });\n        this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n            let node;\n            // .isBone isn't in glTF spec. See ._markDefs\n            if (nodeDef.isBone === true) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n            } else if (objects.length > 1) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            } else if (objects.length === 1) {\n                node = objects[0];\n            } else {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n            }\n            if (node !== objects[0]) {\n                for(let i = 0, il = objects.length; i < il; i++){\n                    node.add(objects[i]);\n                }\n            }\n            if (nodeDef.name) {\n                node.userData.name = nodeDef.name;\n                node.name = nodeName;\n            }\n            assignExtrasToUserData(node, nodeDef);\n            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n            if (nodeDef.matrix !== undefined) {\n                const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                matrix.fromArray(nodeDef.matrix);\n                node.applyMatrix4(matrix);\n            } else {\n                if (nodeDef.translation !== undefined) {\n                    node.position.fromArray(nodeDef.translation);\n                }\n                if (nodeDef.rotation !== undefined) {\n                    node.quaternion.fromArray(nodeDef.rotation);\n                }\n                if (nodeDef.scale !== undefined) {\n                    node.scale.fromArray(nodeDef.scale);\n                }\n            }\n            if (!parser.associations.has(node)) {\n                parser.associations.set(node, {});\n            }\n            parser.associations.get(node).nodes = nodeIndex;\n            return node;\n        });\n        return this.nodeCache[nodeIndex];\n    }\n    /**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */ loadScene(sceneIndex) {\n        const extensions = this.extensions;\n        const sceneDef = this.json.scenes[sceneIndex];\n        const parser = this;\n        // Loader returns Group, not Scene.\n        // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n        const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n        assignExtrasToUserData(scene, sceneDef);\n        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n        const nodeIds = sceneDef.nodes || [];\n        const pending = [];\n        for(let i = 0, il = nodeIds.length; i < il; i++){\n            pending.push(parser.getDependency(\"node\", nodeIds[i]));\n        }\n        return Promise.all(pending).then(function(nodes) {\n            for(let i = 0, il = nodes.length; i < il; i++){\n                scene.add(nodes[i]);\n            }\n            // Removes dangling associations, associations that reference a node that\n            // didn't make it into the scene.\n            const reduceAssociations = (node)=>{\n                const reducedAssociations = new Map();\n                for (const [key, value] of parser.associations){\n                    if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n                        reducedAssociations.set(key, value);\n                    }\n                }\n                node.traverse((node)=>{\n                    const mappings = parser.associations.get(node);\n                    if (mappings != null) {\n                        reducedAssociations.set(node, mappings);\n                    }\n                });\n                return reducedAssociations;\n            };\n            parser.associations = reduceAssociations(scene);\n            return scene;\n        });\n    }\n    _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n        const tracks = [];\n        const targetName = node.name ? node.name : node.uuid;\n        const targetNames = [];\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n            node.traverse(function(object) {\n                if (object.morphTargetInfluences) {\n                    targetNames.push(object.name ? object.name : object.uuid);\n                }\n            });\n        } else {\n            targetNames.push(targetName);\n        }\n        let TypedKeyframeTrack;\n        switch(PATH_PROPERTIES[target.path]){\n            case PATH_PROPERTIES.weights:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                break;\n            case PATH_PROPERTIES.rotation:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n                break;\n            case PATH_PROPERTIES.position:\n            case PATH_PROPERTIES.scale:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                break;\n            default:\n                switch(outputAccessor.itemSize){\n                    case 1:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                        break;\n                    case 2:\n                    case 3:\n                    default:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                        break;\n                }\n                break;\n        }\n        const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n        const outputArray = this._getArrayFromAccessor(outputAccessor);\n        for(let j = 0, jl = targetNames.length; j < jl; j++){\n            const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n            // Override interpolation with custom factory method.\n            if (sampler.interpolation === \"CUBICSPLINE\") {\n                this._createCubicSplineTrackInterpolant(track);\n            }\n            tracks.push(track);\n        }\n        return tracks;\n    }\n    _getArrayFromAccessor(accessor) {\n        let outputArray = accessor.array;\n        if (accessor.normalized) {\n            const scale = getNormalizedComponentScale(outputArray.constructor);\n            const scaled = new Float32Array(outputArray.length);\n            for(let j = 0, jl = outputArray.length; j < jl; j++){\n                scaled[j] = outputArray[j] * scale;\n            }\n            outputArray = scaled;\n        }\n        return outputArray;\n    }\n    _createCubicSplineTrackInterpolant(track) {\n        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n            // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n            // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n            // must be divided by three to get the interpolant's sampleSize argument.\n            const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n        };\n        // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n    }\n    constructor(json = {}, options = {}){\n        this.json = json;\n        this.extensions = {};\n        this.plugins = {};\n        this.options = options;\n        // loader object cache\n        this.cache = new GLTFRegistry();\n        // associations between Three.js objects and glTF elements\n        this.associations = new Map();\n        // BufferGeometry caching\n        this.primitiveCache = {};\n        // Node cache\n        this.nodeCache = {};\n        // Object3D instance caches\n        this.meshCache = {\n            refs: {},\n            uses: {}\n        };\n        this.cameraCache = {\n            refs: {},\n            uses: {}\n        };\n        this.lightCache = {\n            refs: {},\n            uses: {}\n        };\n        this.sourceCache = {};\n        this.textureCache = {};\n        // Track node names, to ensure no duplicates\n        this.nodeNamesUsed = {};\n        // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n        // expensive work of uploading a texture to the GPU off the main thread.\n        let isSafari = false;\n        let isFirefox = false;\n        let firefoxVersion = -1;\n        if (typeof navigator !== \"undefined\") {\n            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n            isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n        }\n        if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n        } else {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n        }\n        this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n        this.textureLoader.setRequestHeader(this.options.requestHeader);\n        this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n        this.fileLoader.setResponseType(\"arraybuffer\");\n        if (this.options.crossOrigin === \"use-credentials\") {\n            this.fileLoader.setWithCredentials(true);\n        }\n    }\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */ function computeBounds(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n    if (attributes.POSITION !== undefined) {\n        const accessor = parser.json.accessors[attributes.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n        if (min !== undefined && max !== undefined) {\n            box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n            if (accessor.normalized) {\n                const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                box.min.multiplyScalar(boxScale);\n                box.max.multiplyScalar(boxScale);\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n            return;\n        }\n    } else {\n        return;\n    }\n    const targets = primitiveDef.targets;\n    if (targets !== undefined) {\n        const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        for(let i = 0, il = targets.length; i < il; i++){\n            const target = targets[i];\n            if (target.POSITION !== undefined) {\n                const accessor = parser.json.accessors[target.POSITION];\n                const min = accessor.min;\n                const max = accessor.max;\n                // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n                if (min !== undefined && max !== undefined) {\n                    // we need to get max of absolute components because target weight is [-1,1]\n                    vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n                    vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n                    vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n                    if (accessor.normalized) {\n                        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                        vector.multiplyScalar(boxScale);\n                    }\n                    // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n                    // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n                    // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n                    // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n                    maxDisplacement.max(vector);\n                } else {\n                    console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n                }\n            }\n        }\n        // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n        box.expandByVector(maxDisplacement);\n    }\n    geometry.boundingBox = box;\n    const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */ function addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const pending = [];\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n        return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n            geometry.setAttribute(attributeName, accessor);\n        });\n    }\n    for(const gltfAttributeName in attributes){\n        const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n        // Skip attributes already provided by e.g. Draco extension.\n        if (threeAttributeName in geometry.attributes) continue;\n        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n    if (primitiveDef.indices !== undefined && !geometry.index) {\n        const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor) {\n            geometry.setIndex(accessor);\n        });\n        pending.push(accessor);\n    }\n    if (three__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.workingColorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace && \"COLOR_0\" in attributes) {\n        console.warn('THREE.GLTFLoader: Converting vertex colors from \"srgb-linear\" to \"'.concat(three__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.workingColorSpace, '\" not supported.'));\n    }\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function() {\n        return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n}\n\nvar _c;\n$RefreshReg$(_c, \"GLTFRegistry\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQWtFZTtBQUN1RDtBQUV0RSxNQUFNa0UsbUJBQW1CdEMseUNBQU1BO0lBOEc5QnVDLEtBQU1DLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRztRQUV4QyxNQUFNQyxRQUFRLElBQUk7UUFFbEIsSUFBSUM7UUFFSixJQUFLLElBQUksQ0FBQ0EsWUFBWSxLQUFLLElBQUs7WUFFL0JBLGVBQWUsSUFBSSxDQUFDQSxZQUFZO1FBRWpDLE9BQU8sSUFBSyxJQUFJLENBQUNDLElBQUksS0FBSyxJQUFLO1lBRTlCLDRHQUE0RztZQUM1RyxpRkFBaUY7WUFDakYsNERBQTREO1lBQzVELDBHQUEwRztZQUMxRyw0SEFBNEg7WUFDNUgsTUFBTUMsY0FBYzlDLDhDQUFXQSxDQUFDK0MsY0FBYyxDQUFFUjtZQUNoREssZUFBZTVDLDhDQUFXQSxDQUFDZ0QsVUFBVSxDQUFFRixhQUFhLElBQUksQ0FBQ0QsSUFBSTtRQUU5RCxPQUFPO1lBRU5ELGVBQWU1Qyw4Q0FBV0EsQ0FBQytDLGNBQWMsQ0FBRVI7UUFFNUM7UUFFQSx3RUFBd0U7UUFDeEUsdUVBQXVFO1FBQ3ZFLGtFQUFrRTtRQUNsRSxJQUFJLENBQUNVLE9BQU8sQ0FBQ0MsU0FBUyxDQUFFWDtRQUV4QixNQUFNWSxXQUFXLFNBQVdDLENBQUM7WUFFNUIsSUFBS1YsU0FBVTtnQkFFZEEsUUFBU1U7WUFFVixPQUFPO2dCQUVOQyxRQUFRQyxLQUFLLENBQUVGO1lBRWhCO1lBRUFULE1BQU1NLE9BQU8sQ0FBQ00sU0FBUyxDQUFFaEI7WUFDekJJLE1BQU1NLE9BQU8sQ0FBQ08sT0FBTyxDQUFFakI7UUFFeEI7UUFFQSxNQUFNa0IsU0FBUyxJQUFJNUUsNkNBQVVBLENBQUUsSUFBSSxDQUFDb0UsT0FBTztRQUUzQ1EsT0FBT0MsT0FBTyxDQUFFLElBQUksQ0FBQ2IsSUFBSTtRQUN6QlksT0FBT0UsZUFBZSxDQUFFO1FBQ3hCRixPQUFPRyxnQkFBZ0IsQ0FBRSxJQUFJLENBQUNDLGFBQWE7UUFDM0NKLE9BQU9LLGtCQUFrQixDQUFFLElBQUksQ0FBQ0MsZUFBZTtRQUUvQ04sT0FBT25CLElBQUksQ0FBRUMsS0FBSyxTQUFXeUIsSUFBSTtZQUVoQyxJQUFJO2dCQUVIckIsTUFBTXNCLEtBQUssQ0FBRUQsTUFBTXBCLGNBQWMsU0FBV3NCLElBQUk7b0JBRS9DMUIsT0FBUTBCO29CQUVSdkIsTUFBTU0sT0FBTyxDQUFDTyxPQUFPLENBQUVqQjtnQkFFeEIsR0FBR1k7WUFFSixFQUFFLE9BQVFDLEdBQUk7Z0JBRWJELFNBQVVDO1lBRVg7UUFFRCxHQUFHWCxZQUFZVTtJQUVoQjtJQUVBZ0IsZUFBZ0JDLFdBQVcsRUFBRztRQUU3QixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFDbkIsT0FBTyxJQUFJO0lBRVo7SUFFQUMsZUFBZTtRQUVkLE1BQU0sSUFBSUMsTUFFVDtJQUlGO0lBRUFDLGNBQWVDLFVBQVUsRUFBRztRQUUzQixJQUFJLENBQUNBLFVBQVUsR0FBR0E7UUFDbEIsT0FBTyxJQUFJO0lBRVo7SUFFQUMsa0JBQW1CQyxjQUFjLEVBQUc7UUFFbkMsSUFBSSxDQUFDQSxjQUFjLEdBQUdBO1FBQ3RCLE9BQU8sSUFBSTtJQUVaO0lBRUFDLFNBQVVDLFFBQVEsRUFBRztRQUVwQixJQUFLLElBQUksQ0FBQ0MsZUFBZSxDQUFDQyxPQUFPLENBQUVGLGNBQWUsQ0FBRSxHQUFJO1lBRXZELElBQUksQ0FBQ0MsZUFBZSxDQUFDRSxJQUFJLENBQUVIO1FBRTVCO1FBRUEsT0FBTyxJQUFJO0lBRVo7SUFFQUksV0FBWUosUUFBUSxFQUFHO1FBRXRCLElBQUssSUFBSSxDQUFDQyxlQUFlLENBQUNDLE9BQU8sQ0FBRUYsY0FBZSxDQUFFLEdBQUk7WUFFdkQsSUFBSSxDQUFDQyxlQUFlLENBQUNJLE1BQU0sQ0FBRSxJQUFJLENBQUNKLGVBQWUsQ0FBQ0MsT0FBTyxDQUFFRixXQUFZO1FBRXhFO1FBRUEsT0FBTyxJQUFJO0lBRVo7SUFFQVgsTUFBT0QsSUFBSSxFQUFFbkIsSUFBSSxFQUFFTCxNQUFNLEVBQUVFLE9BQU8sRUFBRztRQUVwQyxJQUFJd0M7UUFDSixNQUFNQyxhQUFhLENBQUM7UUFDcEIsTUFBTUMsVUFBVSxDQUFDO1FBQ2pCLE1BQU1DLGNBQWMsSUFBSUM7UUFFeEIsSUFBSyxPQUFPdEIsU0FBUyxVQUFXO1lBRS9Ca0IsT0FBT0ssS0FBS3RCLEtBQUssQ0FBRUQ7UUFFcEIsT0FBTyxJQUFLQSxnQkFBZ0J3QixhQUFjO1lBRXpDLE1BQU1DLFFBQVFKLFlBQVlLLE1BQU0sQ0FBRSxJQUFJQyxXQUFZM0IsTUFBTSxHQUFHO1lBRTNELElBQUt5QixVQUFVRywrQkFBZ0M7Z0JBRTlDLElBQUk7b0JBRUhULFVBQVUsQ0FBRVUsV0FBV0MsZUFBZSxDQUFFLEdBQUcsSUFBSUMsb0JBQXFCL0I7Z0JBRXJFLEVBQUUsT0FBUVYsT0FBUTtvQkFFakIsSUFBS1osU0FBVUEsUUFBU1k7b0JBQ3hCO2dCQUVEO2dCQUVBNEIsT0FBT0ssS0FBS3RCLEtBQUssQ0FBRWtCLFVBQVUsQ0FBRVUsV0FBV0MsZUFBZSxDQUFFLENBQUNFLE9BQU87WUFFcEUsT0FBTztnQkFFTmQsT0FBT0ssS0FBS3RCLEtBQUssQ0FBRW9CLFlBQVlLLE1BQU0sQ0FBRTFCO1lBRXhDO1FBRUQsT0FBTztZQUVOa0IsT0FBT2xCO1FBRVI7UUFFQSxJQUFLa0IsS0FBS2UsS0FBSyxLQUFLQyxhQUFhaEIsS0FBS2UsS0FBSyxDQUFDRSxPQUFPLENBQUUsRUFBRyxHQUFHLEdBQUk7WUFFOUQsSUFBS3pELFNBQVVBLFFBQVMsSUFBSTRCLE1BQU87WUFDbkM7UUFFRDtRQUVBLE1BQU04QixTQUFTLElBQUlDLFdBQVluQixNQUFNO1lBRXBDckMsTUFBTUEsUUFBUSxJQUFJLENBQUNELFlBQVksSUFBSTtZQUNuQzBELGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQzdCekMsZUFBZSxJQUFJLENBQUNBLGFBQWE7WUFDakNaLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCdUIsWUFBWSxJQUFJLENBQUNBLFVBQVU7WUFDM0JFLGdCQUFnQixJQUFJLENBQUNBLGNBQWM7UUFFcEM7UUFFQTBCLE9BQU9HLFVBQVUsQ0FBQzNDLGdCQUFnQixDQUFFLElBQUksQ0FBQ0MsYUFBYTtRQUV0RCxJQUFNLElBQUkyQyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDM0IsZUFBZSxDQUFDNEIsTUFBTSxFQUFFRCxJQUFPO1lBRXhELE1BQU1FLFNBQVMsSUFBSSxDQUFDN0IsZUFBZSxDQUFFMkIsRUFBRyxDQUFFSjtZQUUxQyxJQUFLLENBQUVNLE9BQU9DLElBQUksRUFBR3RELFFBQVFDLEtBQUssQ0FBRTtZQUVwQzhCLE9BQU8sQ0FBRXNCLE9BQU9DLElBQUksQ0FBRSxHQUFHRDtZQUV6Qix1REFBdUQ7WUFDdkQsdUNBQXVDO1lBQ3ZDLHFEQUFxRDtZQUNyRCxzQ0FBc0M7WUFDdEN2QixVQUFVLENBQUV1QixPQUFPQyxJQUFJLENBQUUsR0FBRztRQUU3QjtRQUVBLElBQUt6QixLQUFLMEIsY0FBYyxFQUFHO1lBRTFCLElBQU0sSUFBSUosSUFBSSxHQUFHQSxJQUFJdEIsS0FBSzBCLGNBQWMsQ0FBQ0gsTUFBTSxFQUFFLEVBQUdELEVBQUk7Z0JBRXZELE1BQU1LLGdCQUFnQjNCLEtBQUswQixjQUFjLENBQUVKLEVBQUc7Z0JBQzlDLE1BQU1NLHFCQUFxQjVCLEtBQUs0QixrQkFBa0IsSUFBSSxFQUFFO2dCQUV4RCxPQUFTRDtvQkFFUixLQUFLaEIsV0FBV2tCLG1CQUFtQjt3QkFDbEM1QixVQUFVLENBQUUwQixjQUFlLEdBQUcsSUFBSUc7d0JBQ2xDO29CQUVELEtBQUtuQixXQUFXb0IsMEJBQTBCO3dCQUN6QzlCLFVBQVUsQ0FBRTBCLGNBQWUsR0FBRyxJQUFJSyxrQ0FBbUNoQyxNQUFNLElBQUksQ0FBQ2QsV0FBVzt3QkFDM0Y7b0JBRUQsS0FBS3lCLFdBQVdzQixxQkFBcUI7d0JBQ3BDaEMsVUFBVSxDQUFFMEIsY0FBZSxHQUFHLElBQUlPO3dCQUNsQztvQkFFRCxLQUFLdkIsV0FBV3dCLHFCQUFxQjt3QkFDcENsQyxVQUFVLENBQUUwQixjQUFlLEdBQUcsSUFBSVM7d0JBQ2xDO29CQUVEO3dCQUVDLElBQUtSLG1CQUFtQmhDLE9BQU8sQ0FBRStCLGtCQUFtQixLQUFLekIsT0FBTyxDQUFFeUIsY0FBZSxLQUFLWCxXQUFZOzRCQUVqRzdDLFFBQVFrRSxJQUFJLENBQUUsMENBQTBDVixnQkFBZ0I7d0JBRXpFO2dCQUVGO1lBRUQ7UUFFRDtRQUVBVCxPQUFPb0IsYUFBYSxDQUFFckM7UUFDdEJpQixPQUFPcUIsVUFBVSxDQUFFckM7UUFDbkJnQixPQUFPbkMsS0FBSyxDQUFFekIsUUFBUUU7SUFFdkI7SUFFQWdGLFdBQVkxRCxJQUFJLEVBQUVuQixJQUFJLEVBQUc7UUFFeEIsTUFBTUYsUUFBUSxJQUFJO1FBRWxCLE9BQU8sSUFBSWdGLFFBQVMsU0FBV0MsT0FBTyxFQUFFQyxNQUFNO1lBRTdDbEYsTUFBTXNCLEtBQUssQ0FBRUQsTUFBTW5CLE1BQU0rRSxTQUFTQztRQUVuQztJQUVEO0lBclhBQyxZQUFhN0UsT0FBTyxDQUFHO1FBRXRCLEtBQUssQ0FBRUE7UUFFUCxJQUFJLENBQUNtQixXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDSSxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDRSxjQUFjLEdBQUc7UUFFdEIsSUFBSSxDQUFDRyxlQUFlLEdBQUcsRUFBRTtRQUV6QixJQUFJLENBQUNGLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUkyQixnQ0FBaUMzQjtRQUU3QztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUk0QiwyQkFBNEI1QjtRQUV4QztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUk2Qix5QkFBMEI3QjtRQUV0QztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUk4Qix5QkFBMEI5QjtRQUV0QztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUkrQiw0QkFBNkIvQjtRQUV6QztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUlnQyxtQ0FBb0NoQztRQUVoRDtRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUlpQyw2QkFBOEJqQztRQUUxQztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUlrQywwQkFBMkJsQztRQUV2QztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUltQyx1Q0FBd0NuQztRQUVwRDtRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUlvQywrQkFBZ0NwQztRQUU1QztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUlxQyxrQ0FBbUNyQztRQUUvQztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUlzQyxpQ0FBa0N0QztRQUU5QztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUl1QywyQkFBNEJ2QztRQUV4QztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUl3QyxvQkFBcUJ4QztRQUVqQztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUl5Qyx1QkFBd0J6QztRQUVwQztRQUVBLElBQUksQ0FBQ3pCLFFBQVEsQ0FBRSxTQUFXeUIsTUFBTTtZQUUvQixPQUFPLElBQUkwQyxzQkFBdUIxQztRQUVuQztJQUVEO0FBNlFEO0FBRUEsZ0JBQWdCLEdBRWhCLFNBQVMyQztJQUVSLElBQUlDLFVBQVUsQ0FBQztJQUVmLE9BQU87UUFFTkMsS0FBSyxTQUFXQyxHQUFHO1lBRWxCLE9BQU9GLE9BQU8sQ0FBRUUsSUFBSztRQUV0QjtRQUVBQyxLQUFLLFNBQVdELEdBQUcsRUFBRUUsTUFBTTtZQUUxQkosT0FBTyxDQUFFRSxJQUFLLEdBQUdFO1FBRWxCO1FBRUFDLFFBQVEsU0FBV0gsR0FBRztZQUVyQixPQUFPRixPQUFPLENBQUVFLElBQUs7UUFFdEI7UUFFQUksV0FBVztZQUVWTixVQUFVLENBQUM7UUFFWjtJQUVEO0FBRUQ7S0FoQ1NEO0FBa0NULGlDQUFpQyxHQUNqQyxpQ0FBaUMsR0FDakMsaUNBQWlDLEdBRWpDLE1BQU1sRCxhQUFhO0lBQ2xCQyxpQkFBaUI7SUFDakJtQiw0QkFBNEI7SUFDNUJzQyxxQkFBcUI7SUFDckJDLHlCQUF5QjtJQUN6QkMsbUJBQW1CO0lBQ25CQyxxQkFBcUI7SUFDckJDLHdCQUF3QjtJQUN4QkMsNEJBQTRCO0lBQzVCQywyQkFBMkI7SUFDM0JDLDBCQUEwQjtJQUMxQi9DLHFCQUFxQjtJQUNyQmdELHNCQUFzQjtJQUN0QkMsb0JBQW9CO0lBQ3BCN0MsdUJBQXVCO0lBQ3ZCRSx1QkFBdUI7SUFDdkI0QyxpQ0FBaUM7SUFDakNDLG9CQUFvQjtJQUNwQkMsa0JBQWtCO0lBQ2xCQyxrQkFBa0I7SUFDbEJDLHlCQUF5QjtJQUN6QkMseUJBQXlCO0FBQzFCO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU0xQjtJQVlMMkIsWUFBWTtRQUVYLE1BQU1uRSxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNb0UsV0FBVyxJQUFJLENBQUNwRSxNQUFNLENBQUNsQixJQUFJLENBQUN1RixLQUFLLElBQUksRUFBRTtRQUU3QyxJQUFNLElBQUlDLFlBQVksR0FBR0MsYUFBYUgsU0FBUy9ELE1BQU0sRUFBRWlFLFlBQVlDLFlBQVlELFlBQWU7WUFFN0YsTUFBTUUsVUFBVUosUUFBUSxDQUFFRSxVQUFXO1lBRXJDLElBQUtFLFFBQVF6RixVQUFVLElBQ2xCeUYsUUFBUXpGLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUUsSUFDL0JpRSxRQUFRekYsVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRSxDQUFDa0UsS0FBSyxLQUFLM0UsV0FBWTtnQkFFMURFLE9BQU8wRSxXQUFXLENBQUUsSUFBSSxDQUFDQyxLQUFLLEVBQUVILFFBQVF6RixVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLENBQUNrRSxLQUFLO1lBRXRFO1FBRUQ7SUFFRDtJQUVBRyxXQUFZQyxVQUFVLEVBQUc7UUFFeEIsTUFBTTdFLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU04RSxXQUFXLFdBQVdEO1FBQzVCLElBQUlFLGFBQWEvRSxPQUFPMkUsS0FBSyxDQUFDOUIsR0FBRyxDQUFFaUM7UUFFbkMsSUFBS0MsWUFBYSxPQUFPQTtRQUV6QixNQUFNakcsT0FBT2tCLE9BQU9sQixJQUFJO1FBQ3hCLE1BQU1DLGFBQWEsS0FBT0EsVUFBVSxJQUFJRCxLQUFLQyxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLElBQU0sQ0FBQztRQUMzRSxNQUFNeUUsWUFBWWpHLFdBQVdrRyxNQUFNLElBQUksRUFBRTtRQUN6QyxNQUFNQyxXQUFXRixTQUFTLENBQUVILFdBQVk7UUFDeEMsSUFBSU07UUFFSixNQUFNQyxRQUFRLElBQUkvTSx3Q0FBS0EsQ0FBRTtRQUV6QixJQUFLNk0sU0FBU0UsS0FBSyxLQUFLdEYsV0FBWXNGLE1BQU1DLE1BQU0sQ0FBRUgsU0FBU0UsS0FBSyxDQUFFLEVBQUcsRUFBRUYsU0FBU0UsS0FBSyxDQUFFLEVBQUcsRUFBRUYsU0FBU0UsS0FBSyxDQUFFLEVBQUcsRUFBRTFMLHVEQUFvQkE7UUFFckksTUFBTTRMLFFBQVFKLFNBQVNJLEtBQUssS0FBS3hGLFlBQVlvRixTQUFTSSxLQUFLLEdBQUc7UUFFOUQsT0FBU0osU0FBU0ssSUFBSTtZQUVyQixLQUFLO2dCQUNKSixZQUFZLElBQUk1TSxtREFBZ0JBLENBQUU2TTtnQkFDbENELFVBQVVLLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDQyxHQUFHLENBQUUsR0FBRyxHQUFHLENBQUU7Z0JBQ3ZDUCxVQUFVcEMsR0FBRyxDQUFFb0MsVUFBVUssTUFBTTtnQkFDL0I7WUFFRCxLQUFLO2dCQUNKTCxZQUFZLElBQUl2Syw2Q0FBVUEsQ0FBRXdLO2dCQUM1QkQsVUFBVVEsUUFBUSxHQUFHTDtnQkFDckI7WUFFRCxLQUFLO2dCQUNKSCxZQUFZLElBQUk3Siw0Q0FBU0EsQ0FBRThKO2dCQUMzQkQsVUFBVVEsUUFBUSxHQUFHTDtnQkFDckIsK0JBQStCO2dCQUMvQkosU0FBU1UsSUFBSSxHQUFHVixTQUFTVSxJQUFJLElBQUksQ0FBQztnQkFDbENWLFNBQVNVLElBQUksQ0FBQ0MsY0FBYyxHQUFHWCxTQUFTVSxJQUFJLENBQUNDLGNBQWMsS0FBSy9GLFlBQVlvRixTQUFTVSxJQUFJLENBQUNDLGNBQWMsR0FBRztnQkFDM0dYLFNBQVNVLElBQUksQ0FBQ0UsY0FBYyxHQUFHWixTQUFTVSxJQUFJLENBQUNFLGNBQWMsS0FBS2hHLFlBQVlvRixTQUFTVSxJQUFJLENBQUNFLGNBQWMsR0FBR0MsS0FBS0MsRUFBRSxHQUFHO2dCQUNySGIsVUFBVWMsS0FBSyxHQUFHZixTQUFTVSxJQUFJLENBQUNFLGNBQWM7Z0JBQzlDWCxVQUFVZSxRQUFRLEdBQUcsTUFBTWhCLFNBQVNVLElBQUksQ0FBQ0MsY0FBYyxHQUFHWCxTQUFTVSxJQUFJLENBQUNFLGNBQWM7Z0JBQ3RGWCxVQUFVSyxNQUFNLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFFLEdBQUcsR0FBRyxDQUFFO2dCQUN2Q1AsVUFBVXBDLEdBQUcsQ0FBRW9DLFVBQVVLLE1BQU07Z0JBQy9CO1lBRUQ7Z0JBQ0MsTUFBTSxJQUFJdEgsTUFBTyw4Q0FBOENnSCxTQUFTSyxJQUFJO1FBRTlFO1FBRUEsMEZBQTBGO1FBQzFGLHdGQUF3RjtRQUN4RkosVUFBVU0sUUFBUSxDQUFDQyxHQUFHLENBQUUsR0FBRyxHQUFHO1FBRTlCUCxVQUFVZ0IsS0FBSyxHQUFHO1FBRWxCQyx1QkFBd0JqQixXQUFXRDtRQUVuQyxJQUFLQSxTQUFTbUIsU0FBUyxLQUFLdkcsV0FBWXFGLFVBQVVrQixTQUFTLEdBQUduQixTQUFTbUIsU0FBUztRQUVoRmxCLFVBQVU1RSxJQUFJLEdBQUdQLE9BQU9zRyxnQkFBZ0IsQ0FBRXBCLFNBQVMzRSxJQUFJLElBQU0sV0FBV3NFO1FBRXhFRSxhQUFheEQsUUFBUUMsT0FBTyxDQUFFMkQ7UUFFOUJuRixPQUFPMkUsS0FBSyxDQUFDNUIsR0FBRyxDQUFFK0IsVUFBVUM7UUFFNUIsT0FBT0E7SUFFUjtJQUVBd0IsY0FBZWhCLElBQUksRUFBRWlCLEtBQUssRUFBRztRQUU1QixJQUFLakIsU0FBUyxTQUFVO1FBRXhCLE9BQU8sSUFBSSxDQUFDWCxVQUFVLENBQUU0QjtJQUV6QjtJQUVBQyxxQkFBc0JuQyxTQUFTLEVBQUc7UUFFakMsTUFBTW9DLFFBQU8sSUFBSTtRQUNqQixNQUFNMUcsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTWxCLE9BQU9rQixPQUFPbEIsSUFBSTtRQUN4QixNQUFNMEYsVUFBVTFGLEtBQUt1RixLQUFLLENBQUVDLFVBQVc7UUFDdkMsTUFBTVksV0FBVyxRQUFVbkcsVUFBVSxJQUFJeUYsUUFBUXpGLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUUsSUFBTSxDQUFDO1FBQy9FLE1BQU1zRSxhQUFhSyxTQUFTVCxLQUFLO1FBRWpDLElBQUtJLGVBQWUvRSxXQUFZLE9BQU87UUFFdkMsT0FBTyxJQUFJLENBQUM4RSxVQUFVLENBQUVDLFlBQWE4QixJQUFJLENBQUUsU0FBV2xDLEtBQUs7WUFFMUQsT0FBT3pFLE9BQU80RyxXQUFXLENBQUVGLE1BQUsvQixLQUFLLEVBQUVFLFlBQVlKO1FBRXBEO0lBRUQ7SUEvSEEvQyxZQUFhMUIsTUFBTSxDQUFHO1FBRXJCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ08sSUFBSSxHQUFHZCxXQUFXMEQsbUJBQW1CO1FBRTFDLDJCQUEyQjtRQUMzQixJQUFJLENBQUN3QixLQUFLLEdBQUc7WUFBRWtDLE1BQU0sQ0FBQztZQUFHQyxNQUFNLENBQUM7UUFBRTtJQUVuQztBQXlIRDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNbEc7SUFRTG1HLGtCQUFrQjtRQUVqQixPQUFPOU0sb0RBQWlCQTtJQUV6QjtJQUVBK00sYUFBY0MsY0FBYyxFQUFFQyxXQUFXLEVBQUVsSCxNQUFNLEVBQUc7UUFFbkQsTUFBTW1ILFVBQVUsRUFBRTtRQUVsQkYsZUFBZTdCLEtBQUssR0FBRyxJQUFJL00sd0NBQUtBLENBQUUsS0FBSyxLQUFLO1FBQzVDNE8sZUFBZUcsT0FBTyxHQUFHO1FBRXpCLE1BQU1DLG9CQUFvQkgsWUFBWUksb0JBQW9CO1FBRTFELElBQUtELG1CQUFvQjtZQUV4QixJQUFLRSxNQUFNQyxPQUFPLENBQUVILGtCQUFrQkksZUFBZSxHQUFLO2dCQUV6RCxNQUFNQyxRQUFRTCxrQkFBa0JJLGVBQWU7Z0JBRS9DUixlQUFlN0IsS0FBSyxDQUFDQyxNQUFNLENBQUVxQyxLQUFLLENBQUUsRUFBRyxFQUFFQSxLQUFLLENBQUUsRUFBRyxFQUFFQSxLQUFLLENBQUUsRUFBRyxFQUFFaE8sdURBQW9CQTtnQkFDckZ1TixlQUFlRyxPQUFPLEdBQUdNLEtBQUssQ0FBRSxFQUFHO1lBRXBDO1lBRUEsSUFBS0wsa0JBQWtCTSxnQkFBZ0IsS0FBSzdILFdBQVk7Z0JBRXZEcUgsUUFBUXhJLElBQUksQ0FBRXFCLE9BQU80SCxhQUFhLENBQUVYLGdCQUFnQixPQUFPSSxrQkFBa0JNLGdCQUFnQixFQUFFN0wsaURBQWNBO1lBRTlHO1FBRUQ7UUFFQSxPQUFPeUYsUUFBUXNHLEdBQUcsQ0FBRVY7SUFFckI7SUExQ0F6RixhQUFjO1FBRWIsSUFBSSxDQUFDbkIsSUFBSSxHQUFHZCxXQUFXa0IsbUJBQW1CO0lBRTNDO0FBd0NEO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU13QjtJQVNMMkYscUJBQXNCQyxhQUFhLEVBQUVkLGNBQWMsRUFBRztRQUVyRCxNQUFNakgsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTWtILGNBQWNsSCxPQUFPbEIsSUFBSSxDQUFDa0osU0FBUyxDQUFFRCxjQUFlO1FBRTFELElBQUssQ0FBRWIsWUFBWW5JLFVBQVUsSUFBSSxDQUFFbUksWUFBWW5JLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUUsRUFBRztZQUV4RSxPQUFPZ0IsUUFBUUMsT0FBTztRQUV2QjtRQUVBLE1BQU15RyxtQkFBbUJmLFlBQVluSSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLENBQUMwSCxnQkFBZ0I7UUFFN0UsSUFBS0EscUJBQXFCbkksV0FBWTtZQUVyQ21ILGVBQWVpQixpQkFBaUIsR0FBR0Q7UUFFcEM7UUFFQSxPQUFPMUcsUUFBUUMsT0FBTztJQUV2QjtJQTVCQUUsWUFBYTFCLE1BQU0sQ0FBRztRQUVyQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNPLElBQUksR0FBR2QsV0FBV29FLCtCQUErQjtJQUV2RDtBQXlCRDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNbEM7SUFTTG9GLGdCQUFpQmdCLGFBQWEsRUFBRztRQUVoQyxNQUFNL0gsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTWtILGNBQWNsSCxPQUFPbEIsSUFBSSxDQUFDa0osU0FBUyxDQUFFRCxjQUFlO1FBRTFELElBQUssQ0FBRWIsWUFBWW5JLFVBQVUsSUFBSSxDQUFFbUksWUFBWW5JLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUUsRUFBRyxPQUFPO1FBRWhGLE9BQU9yRyx1REFBb0JBO0lBRTVCO0lBRUE0TixxQkFBc0JDLGFBQWEsRUFBRWQsY0FBYyxFQUFHO1FBRXJELE1BQU1qSCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNa0gsY0FBY2xILE9BQU9sQixJQUFJLENBQUNrSixTQUFTLENBQUVELGNBQWU7UUFFMUQsSUFBSyxDQUFFYixZQUFZbkksVUFBVSxJQUFJLENBQUVtSSxZQUFZbkksVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRSxFQUFHO1lBRXhFLE9BQU9nQixRQUFRQyxPQUFPO1FBRXZCO1FBRUEsTUFBTTJGLFVBQVUsRUFBRTtRQUVsQixNQUFNZ0IsWUFBWWpCLFlBQVluSSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFO1FBRXJELElBQUs0SCxVQUFVQyxlQUFlLEtBQUt0SSxXQUFZO1lBRTlDbUgsZUFBZW9CLFNBQVMsR0FBR0YsVUFBVUMsZUFBZTtRQUVyRDtRQUVBLElBQUtELFVBQVVHLGdCQUFnQixLQUFLeEksV0FBWTtZQUUvQ3FILFFBQVF4SSxJQUFJLENBQUVxQixPQUFPNEgsYUFBYSxDQUFFWCxnQkFBZ0IsZ0JBQWdCa0IsVUFBVUcsZ0JBQWdCO1FBRS9GO1FBRUEsSUFBS0gsVUFBVUksd0JBQXdCLEtBQUt6SSxXQUFZO1lBRXZEbUgsZUFBZXVCLGtCQUFrQixHQUFHTCxVQUFVSSx3QkFBd0I7UUFFdkU7UUFFQSxJQUFLSixVQUFVTSx5QkFBeUIsS0FBSzNJLFdBQVk7WUFFeERxSCxRQUFReEksSUFBSSxDQUFFcUIsT0FBTzRILGFBQWEsQ0FBRVgsZ0JBQWdCLHlCQUF5QmtCLFVBQVVNLHlCQUF5QjtRQUVqSDtRQUVBLElBQUtOLFVBQVVPLHNCQUFzQixLQUFLNUksV0FBWTtZQUVyRHFILFFBQVF4SSxJQUFJLENBQUVxQixPQUFPNEgsYUFBYSxDQUFFWCxnQkFBZ0Isc0JBQXNCa0IsVUFBVU8sc0JBQXNCO1lBRTFHLElBQUtQLFVBQVVPLHNCQUFzQixDQUFDQyxLQUFLLEtBQUs3SSxXQUFZO2dCQUUzRCxNQUFNNkksUUFBUVIsVUFBVU8sc0JBQXNCLENBQUNDLEtBQUs7Z0JBRXBEMUIsZUFBZTJCLG9CQUFvQixHQUFHLElBQUlqTiwwQ0FBT0EsQ0FBRWdOLE9BQU9BO1lBRTNEO1FBRUQ7UUFFQSxPQUFPcEgsUUFBUXNHLEdBQUcsQ0FBRVY7SUFFckI7SUF6RUF6RixZQUFhMUIsTUFBTSxDQUFHO1FBRXJCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ08sSUFBSSxHQUFHZCxXQUFXMkQsdUJBQXVCO0lBRS9DO0FBc0VEO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1mO0lBU0wwRSxnQkFBaUJnQixhQUFhLEVBQUc7UUFFaEMsTUFBTS9ILFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU1rSCxjQUFjbEgsT0FBT2xCLElBQUksQ0FBQ2tKLFNBQVMsQ0FBRUQsY0FBZTtRQUUxRCxJQUFLLENBQUViLFlBQVluSSxVQUFVLElBQUksQ0FBRW1JLFlBQVluSSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLEVBQUcsT0FBTztRQUVoRixPQUFPckcsdURBQW9CQTtJQUU1QjtJQUVBNE4scUJBQXNCQyxhQUFhLEVBQUVkLGNBQWMsRUFBRztRQUVyRCxNQUFNakgsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTWtILGNBQWNsSCxPQUFPbEIsSUFBSSxDQUFDa0osU0FBUyxDQUFFRCxjQUFlO1FBRTFELElBQUssQ0FBRWIsWUFBWW5JLFVBQVUsSUFBSSxDQUFFbUksWUFBWW5JLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUUsRUFBRztZQUV4RSxPQUFPZ0IsUUFBUUMsT0FBTztRQUV2QjtRQUVBLE1BQU0yRixVQUFVLEVBQUU7UUFFbEIsTUFBTWdCLFlBQVlqQixZQUFZbkksVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRTtRQUVyRCxJQUFLNEgsVUFBVVUsaUJBQWlCLEtBQUsvSSxXQUFZO1lBRWhEbUgsZUFBZTZCLFdBQVcsR0FBR1gsVUFBVVUsaUJBQWlCO1FBRXpEO1FBRUEsSUFBS1YsVUFBVVksa0JBQWtCLEtBQUtqSixXQUFZO1lBRWpEcUgsUUFBUXhJLElBQUksQ0FBRXFCLE9BQU80SCxhQUFhLENBQUVYLGdCQUFnQixrQkFBa0JrQixVQUFVWSxrQkFBa0I7UUFFbkc7UUFFQSxJQUFLWixVQUFVYSxjQUFjLEtBQUtsSixXQUFZO1lBRTdDbUgsZUFBZWdDLGNBQWMsR0FBR2QsVUFBVWEsY0FBYztRQUV6RDtRQUVBLElBQUsvQixlQUFlaUMseUJBQXlCLEtBQUtwSixXQUFZO1lBRTdEbUgsZUFBZWlDLHlCQUF5QixHQUFHO2dCQUFFO2dCQUFLO2FBQUs7UUFFeEQ7UUFFQSxJQUFLZixVQUFVZ0IsMkJBQTJCLEtBQUtySixXQUFZO1lBRTFEbUgsZUFBZWlDLHlCQUF5QixDQUFFLEVBQUcsR0FBR2YsVUFBVWdCLDJCQUEyQjtRQUV0RjtRQUVBLElBQUtoQixVQUFVaUIsMkJBQTJCLEtBQUt0SixXQUFZO1lBRTFEbUgsZUFBZWlDLHlCQUF5QixDQUFFLEVBQUcsR0FBR2YsVUFBVWlCLDJCQUEyQjtRQUV0RjtRQUVBLElBQUtqQixVQUFVa0IsMkJBQTJCLEtBQUt2SixXQUFZO1lBRTFEcUgsUUFBUXhJLElBQUksQ0FBRXFCLE9BQU80SCxhQUFhLENBQUVYLGdCQUFnQiwyQkFBMkJrQixVQUFVa0IsMkJBQTJCO1FBRXJIO1FBRUEsT0FBTzlILFFBQVFzRyxHQUFHLENBQUVWO0lBRXJCO0lBN0VBekYsWUFBYTFCLE1BQU0sQ0FBRztRQUVyQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNPLElBQUksR0FBR2QsV0FBV2dFLHlCQUF5QjtJQUVqRDtBQTBFRDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNMUI7SUFTTGdGLGdCQUFpQmdCLGFBQWEsRUFBRztRQUVoQyxNQUFNL0gsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTWtILGNBQWNsSCxPQUFPbEIsSUFBSSxDQUFDa0osU0FBUyxDQUFFRCxjQUFlO1FBRTFELElBQUssQ0FBRWIsWUFBWW5JLFVBQVUsSUFBSSxDQUFFbUksWUFBWW5JLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUUsRUFBRyxPQUFPO1FBRWhGLE9BQU9yRyx1REFBb0JBO0lBRTVCO0lBRUE0TixxQkFBc0JDLGFBQWEsRUFBRWQsY0FBYyxFQUFHO1FBRXJELE1BQU1qSCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNa0gsY0FBY2xILE9BQU9sQixJQUFJLENBQUNrSixTQUFTLENBQUVELGNBQWU7UUFFMUQsSUFBSyxDQUFFYixZQUFZbkksVUFBVSxJQUFJLENBQUVtSSxZQUFZbkksVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRSxFQUFHO1lBRXhFLE9BQU9nQixRQUFRQyxPQUFPO1FBRXZCO1FBRUEsTUFBTTJGLFVBQVUsRUFBRTtRQUVsQkYsZUFBZXFDLFVBQVUsR0FBRyxJQUFJalIsd0NBQUtBLENBQUUsR0FBRyxHQUFHO1FBQzdDNE8sZUFBZXNDLGNBQWMsR0FBRztRQUNoQ3RDLGVBQWV1QyxLQUFLLEdBQUc7UUFFdkIsTUFBTXJCLFlBQVlqQixZQUFZbkksVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRTtRQUVyRCxJQUFLNEgsVUFBVXNCLGdCQUFnQixLQUFLM0osV0FBWTtZQUUvQyxNQUFNNEosY0FBY3ZCLFVBQVVzQixnQkFBZ0I7WUFDOUN4QyxlQUFlcUMsVUFBVSxDQUFDakUsTUFBTSxDQUFFcUUsV0FBVyxDQUFFLEVBQUcsRUFBRUEsV0FBVyxDQUFFLEVBQUcsRUFBRUEsV0FBVyxDQUFFLEVBQUcsRUFBRWhRLHVEQUFvQkE7UUFFN0c7UUFFQSxJQUFLeU8sVUFBVXdCLG9CQUFvQixLQUFLN0osV0FBWTtZQUVuRG1ILGVBQWVzQyxjQUFjLEdBQUdwQixVQUFVd0Isb0JBQW9CO1FBRS9EO1FBRUEsSUFBS3hCLFVBQVV5QixpQkFBaUIsS0FBSzlKLFdBQVk7WUFFaERxSCxRQUFReEksSUFBSSxDQUFFcUIsT0FBTzRILGFBQWEsQ0FBRVgsZ0JBQWdCLGlCQUFpQmtCLFVBQVV5QixpQkFBaUIsRUFBRTlOLGlEQUFjQTtRQUVqSDtRQUVBLElBQUtxTSxVQUFVMEIscUJBQXFCLEtBQUsvSixXQUFZO1lBRXBEcUgsUUFBUXhJLElBQUksQ0FBRXFCLE9BQU80SCxhQUFhLENBQUVYLGdCQUFnQixxQkFBcUJrQixVQUFVMEIscUJBQXFCO1FBRXpHO1FBRUEsT0FBT3RJLFFBQVFzRyxHQUFHLENBQUVWO0lBRXJCO0lBaEVBekYsWUFBYTFCLE1BQU0sQ0FBRztRQUVyQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNPLElBQUksR0FBR2QsV0FBVzZELG1CQUFtQjtJQUUzQztBQTZERDtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTXRCO0lBU0wrRSxnQkFBaUJnQixhQUFhLEVBQUc7UUFFaEMsTUFBTS9ILFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU1rSCxjQUFjbEgsT0FBT2xCLElBQUksQ0FBQ2tKLFNBQVMsQ0FBRUQsY0FBZTtRQUUxRCxJQUFLLENBQUViLFlBQVluSSxVQUFVLElBQUksQ0FBRW1JLFlBQVluSSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLEVBQUcsT0FBTztRQUVoRixPQUFPckcsdURBQW9CQTtJQUU1QjtJQUVBNE4scUJBQXNCQyxhQUFhLEVBQUVkLGNBQWMsRUFBRztRQUVyRCxNQUFNakgsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTWtILGNBQWNsSCxPQUFPbEIsSUFBSSxDQUFDa0osU0FBUyxDQUFFRCxjQUFlO1FBRTFELElBQUssQ0FBRWIsWUFBWW5JLFVBQVUsSUFBSSxDQUFFbUksWUFBWW5JLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUUsRUFBRztZQUV4RSxPQUFPZ0IsUUFBUUMsT0FBTztRQUV2QjtRQUVBLE1BQU0yRixVQUFVLEVBQUU7UUFFbEIsTUFBTWdCLFlBQVlqQixZQUFZbkksVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRTtRQUVyRCxJQUFLNEgsVUFBVTJCLGtCQUFrQixLQUFLaEssV0FBWTtZQUVqRG1ILGVBQWU4QyxZQUFZLEdBQUc1QixVQUFVMkIsa0JBQWtCO1FBRTNEO1FBRUEsSUFBSzNCLFVBQVU2QixtQkFBbUIsS0FBS2xLLFdBQVk7WUFFbERxSCxRQUFReEksSUFBSSxDQUFFcUIsT0FBTzRILGFBQWEsQ0FBRVgsZ0JBQWdCLG1CQUFtQmtCLFVBQVU2QixtQkFBbUI7UUFFckc7UUFFQSxPQUFPekksUUFBUXNHLEdBQUcsQ0FBRVY7SUFFckI7SUEvQ0F6RixZQUFhMUIsTUFBTSxDQUFHO1FBRXJCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ08sSUFBSSxHQUFHZCxXQUFXK0QsMEJBQTBCO0lBRWxEO0FBNENEO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU12QjtJQVNMOEUsZ0JBQWlCZ0IsYUFBYSxFQUFHO1FBRWhDLE1BQU0vSCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNa0gsY0FBY2xILE9BQU9sQixJQUFJLENBQUNrSixTQUFTLENBQUVELGNBQWU7UUFFMUQsSUFBSyxDQUFFYixZQUFZbkksVUFBVSxJQUFJLENBQUVtSSxZQUFZbkksVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRSxFQUFHLE9BQU87UUFFaEYsT0FBT3JHLHVEQUFvQkE7SUFFNUI7SUFFQTROLHFCQUFzQkMsYUFBYSxFQUFFZCxjQUFjLEVBQUc7UUFFckQsTUFBTWpILFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU1rSCxjQUFjbEgsT0FBT2xCLElBQUksQ0FBQ2tKLFNBQVMsQ0FBRUQsY0FBZTtRQUUxRCxJQUFLLENBQUViLFlBQVluSSxVQUFVLElBQUksQ0FBRW1JLFlBQVluSSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLEVBQUc7WUFFeEUsT0FBT2dCLFFBQVFDLE9BQU87UUFFdkI7UUFFQSxNQUFNMkYsVUFBVSxFQUFFO1FBRWxCLE1BQU1nQixZQUFZakIsWUFBWW5JLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUU7UUFFckQwRyxlQUFlZ0QsU0FBUyxHQUFHOUIsVUFBVStCLGVBQWUsS0FBS3BLLFlBQVlxSSxVQUFVK0IsZUFBZSxHQUFHO1FBRWpHLElBQUsvQixVQUFVZ0MsZ0JBQWdCLEtBQUtySyxXQUFZO1lBRS9DcUgsUUFBUXhJLElBQUksQ0FBRXFCLE9BQU80SCxhQUFhLENBQUVYLGdCQUFnQixnQkFBZ0JrQixVQUFVZ0MsZ0JBQWdCO1FBRS9GO1FBRUFsRCxlQUFlbUQsbUJBQW1CLEdBQUdqQyxVQUFVaUMsbUJBQW1CLElBQUlDO1FBRXRFLE1BQU1DLGFBQWFuQyxVQUFVb0MsZ0JBQWdCLElBQUk7WUFBRTtZQUFHO1lBQUc7U0FBRztRQUM1RHRELGVBQWVzRCxnQkFBZ0IsR0FBRyxJQUFJbFMsd0NBQUtBLEdBQUdnTixNQUFNLENBQUVpRixVQUFVLENBQUUsRUFBRyxFQUFFQSxVQUFVLENBQUUsRUFBRyxFQUFFQSxVQUFVLENBQUUsRUFBRyxFQUFFNVEsdURBQW9CQTtRQUU3SCxPQUFPNkgsUUFBUXNHLEdBQUcsQ0FBRVY7SUFFckI7SUFoREF6RixZQUFhMUIsTUFBTSxDQUFHO1FBRXJCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ08sSUFBSSxHQUFHZCxXQUFXa0Usb0JBQW9CO0lBRTVDO0FBNkNEO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU16QjtJQVNMNkUsZ0JBQWlCZ0IsYUFBYSxFQUFHO1FBRWhDLE1BQU0vSCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNa0gsY0FBY2xILE9BQU9sQixJQUFJLENBQUNrSixTQUFTLENBQUVELGNBQWU7UUFFMUQsSUFBSyxDQUFFYixZQUFZbkksVUFBVSxJQUFJLENBQUVtSSxZQUFZbkksVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRSxFQUFHLE9BQU87UUFFaEYsT0FBT3JHLHVEQUFvQkE7SUFFNUI7SUFFQTROLHFCQUFzQkMsYUFBYSxFQUFFZCxjQUFjLEVBQUc7UUFFckQsTUFBTWpILFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU1rSCxjQUFjbEgsT0FBT2xCLElBQUksQ0FBQ2tKLFNBQVMsQ0FBRUQsY0FBZTtRQUUxRCxJQUFLLENBQUViLFlBQVluSSxVQUFVLElBQUksQ0FBRW1JLFlBQVluSSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLEVBQUc7WUFFeEUsT0FBT2dCLFFBQVFDLE9BQU87UUFFdkI7UUFFQSxNQUFNMkcsWUFBWWpCLFlBQVluSSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFO1FBRXJEMEcsZUFBZXVELEdBQUcsR0FBR3JDLFVBQVVxQyxHQUFHLEtBQUsxSyxZQUFZcUksVUFBVXFDLEdBQUcsR0FBRztRQUVuRSxPQUFPakosUUFBUUMsT0FBTztJQUV2QjtJQW5DQUUsWUFBYTFCLE1BQU0sQ0FBRztRQUVyQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNPLElBQUksR0FBR2QsV0FBVzRELGlCQUFpQjtJQUV6QztBQWdDRDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNakI7SUFTTDJFLGdCQUFpQmdCLGFBQWEsRUFBRztRQUVoQyxNQUFNL0gsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTWtILGNBQWNsSCxPQUFPbEIsSUFBSSxDQUFDa0osU0FBUyxDQUFFRCxjQUFlO1FBRTFELElBQUssQ0FBRWIsWUFBWW5JLFVBQVUsSUFBSSxDQUFFbUksWUFBWW5JLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUUsRUFBRyxPQUFPO1FBRWhGLE9BQU9yRyx1REFBb0JBO0lBRTVCO0lBRUE0TixxQkFBc0JDLGFBQWEsRUFBRWQsY0FBYyxFQUFHO1FBRXJELE1BQU1qSCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNa0gsY0FBY2xILE9BQU9sQixJQUFJLENBQUNrSixTQUFTLENBQUVELGNBQWU7UUFFMUQsSUFBSyxDQUFFYixZQUFZbkksVUFBVSxJQUFJLENBQUVtSSxZQUFZbkksVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRSxFQUFHO1lBRXhFLE9BQU9nQixRQUFRQyxPQUFPO1FBRXZCO1FBRUEsTUFBTTJGLFVBQVUsRUFBRTtRQUVsQixNQUFNZ0IsWUFBWWpCLFlBQVluSSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFO1FBRXJEMEcsZUFBZXdELGlCQUFpQixHQUFHdEMsVUFBVXVDLGNBQWMsS0FBSzVLLFlBQVlxSSxVQUFVdUMsY0FBYyxHQUFHO1FBRXZHLElBQUt2QyxVQUFVd0MsZUFBZSxLQUFLN0ssV0FBWTtZQUU5Q3FILFFBQVF4SSxJQUFJLENBQUVxQixPQUFPNEgsYUFBYSxDQUFFWCxnQkFBZ0Isd0JBQXdCa0IsVUFBVXdDLGVBQWU7UUFFdEc7UUFFQSxNQUFNTCxhQUFhbkMsVUFBVXlDLG1CQUFtQixJQUFJO1lBQUU7WUFBRztZQUFHO1NBQUc7UUFDL0QzRCxlQUFlNEQsYUFBYSxHQUFHLElBQUl4Uyx3Q0FBS0EsR0FBR2dOLE1BQU0sQ0FBRWlGLFVBQVUsQ0FBRSxFQUFHLEVBQUVBLFVBQVUsQ0FBRSxFQUFHLEVBQUVBLFVBQVUsQ0FBRSxFQUFHLEVBQUU1USx1REFBb0JBO1FBRTFILElBQUt5TyxVQUFVMkMsb0JBQW9CLEtBQUtoTCxXQUFZO1lBRW5EcUgsUUFBUXhJLElBQUksQ0FBRXFCLE9BQU80SCxhQUFhLENBQUVYLGdCQUFnQixvQkFBb0JrQixVQUFVMkMsb0JBQW9CLEVBQUVoUCxpREFBY0E7UUFFdkg7UUFFQSxPQUFPeUYsUUFBUXNHLEdBQUcsQ0FBRVY7SUFFckI7SUFwREF6RixZQUFhMUIsTUFBTSxDQUFHO1FBRXJCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ08sSUFBSSxHQUFHZCxXQUFXOEQsc0JBQXNCO0lBRTlDO0FBaUREO0FBR0E7Ozs7Q0FJQyxHQUNELE1BQU1oQjtJQVNMd0UsZ0JBQWlCZ0IsYUFBYSxFQUFHO1FBRWhDLE1BQU0vSCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNa0gsY0FBY2xILE9BQU9sQixJQUFJLENBQUNrSixTQUFTLENBQUVELGNBQWU7UUFFMUQsSUFBSyxDQUFFYixZQUFZbkksVUFBVSxJQUFJLENBQUVtSSxZQUFZbkksVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRSxFQUFHLE9BQU87UUFFaEYsT0FBT3JHLHVEQUFvQkE7SUFFNUI7SUFFQTROLHFCQUFzQkMsYUFBYSxFQUFFZCxjQUFjLEVBQUc7UUFFckQsTUFBTWpILFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU1rSCxjQUFjbEgsT0FBT2xCLElBQUksQ0FBQ2tKLFNBQVMsQ0FBRUQsY0FBZTtRQUUxRCxJQUFLLENBQUViLFlBQVluSSxVQUFVLElBQUksQ0FBRW1JLFlBQVluSSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLEVBQUc7WUFFeEUsT0FBT2dCLFFBQVFDLE9BQU87UUFFdkI7UUFFQSxNQUFNMkYsVUFBVSxFQUFFO1FBRWxCLE1BQU1nQixZQUFZakIsWUFBWW5JLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUU7UUFFckQwRyxlQUFlOEQsU0FBUyxHQUFHNUMsVUFBVTZDLFVBQVUsS0FBS2xMLFlBQVlxSSxVQUFVNkMsVUFBVSxHQUFHO1FBRXZGLElBQUs3QyxVQUFVOEMsV0FBVyxLQUFLbkwsV0FBWTtZQUUxQ3FILFFBQVF4SSxJQUFJLENBQUVxQixPQUFPNEgsYUFBYSxDQUFFWCxnQkFBZ0IsV0FBV2tCLFVBQVU4QyxXQUFXO1FBRXJGO1FBRUEsT0FBTzFKLFFBQVFzRyxHQUFHLENBQUVWO0lBRXJCO0lBM0NBekYsWUFBYTFCLE1BQU0sQ0FBRztRQUVyQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNPLElBQUksR0FBR2QsV0FBV3FFLGtCQUFrQjtJQUUxQztBQXdDRDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNeEI7SUFTTHlFLGdCQUFpQmdCLGFBQWEsRUFBRztRQUVoQyxNQUFNL0gsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTWtILGNBQWNsSCxPQUFPbEIsSUFBSSxDQUFDa0osU0FBUyxDQUFFRCxjQUFlO1FBRTFELElBQUssQ0FBRWIsWUFBWW5JLFVBQVUsSUFBSSxDQUFFbUksWUFBWW5JLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUUsRUFBRyxPQUFPO1FBRWhGLE9BQU9yRyx1REFBb0JBO0lBRTVCO0lBRUE0TixxQkFBc0JDLGFBQWEsRUFBRWQsY0FBYyxFQUFHO1FBRXJELE1BQU1qSCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUMxQixNQUFNa0gsY0FBY2xILE9BQU9sQixJQUFJLENBQUNrSixTQUFTLENBQUVELGNBQWU7UUFFMUQsSUFBSyxDQUFFYixZQUFZbkksVUFBVSxJQUFJLENBQUVtSSxZQUFZbkksVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRSxFQUFHO1lBRXhFLE9BQU9nQixRQUFRQyxPQUFPO1FBRXZCO1FBRUEsTUFBTTJGLFVBQVUsRUFBRTtRQUVsQixNQUFNZ0IsWUFBWWpCLFlBQVluSSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFO1FBRXJELElBQUs0SCxVQUFVK0Msa0JBQWtCLEtBQUtwTCxXQUFZO1lBRWpEbUgsZUFBZWtFLFVBQVUsR0FBR2hELFVBQVUrQyxrQkFBa0I7UUFFekQ7UUFFQSxJQUFLL0MsVUFBVWlELGtCQUFrQixLQUFLdEwsV0FBWTtZQUVqRG1ILGVBQWVtRSxrQkFBa0IsR0FBR2pELFVBQVVpRCxrQkFBa0I7UUFFakU7UUFFQSxJQUFLakQsVUFBVWtELGlCQUFpQixLQUFLdkwsV0FBWTtZQUVoRHFILFFBQVF4SSxJQUFJLENBQUVxQixPQUFPNEgsYUFBYSxDQUFFWCxnQkFBZ0IsaUJBQWlCa0IsVUFBVWtELGlCQUFpQjtRQUVqRztRQUVBLE9BQU85SixRQUFRc0csR0FBRyxDQUFFVjtJQUVyQjtJQXJEQXpGLFlBQWExQixNQUFNLENBQUc7UUFFckIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDTyxJQUFJLEdBQUdkLFdBQVdpRSx3QkFBd0I7SUFFaEQ7QUFrREQ7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTTlCO0lBU0wwSixZQUFhQyxZQUFZLEVBQUc7UUFFM0IsTUFBTXZMLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU1sQixPQUFPa0IsT0FBT2xCLElBQUk7UUFFeEIsTUFBTTBNLGFBQWExTSxLQUFLMk0sUUFBUSxDQUFFRixhQUFjO1FBRWhELElBQUssQ0FBRUMsV0FBV3pNLFVBQVUsSUFBSSxDQUFFeU0sV0FBV3pNLFVBQVUsQ0FBRSxJQUFJLENBQUN3QixJQUFJLENBQUUsRUFBRztZQUV0RSxPQUFPO1FBRVI7UUFFQSxNQUFNNEgsWUFBWXFELFdBQVd6TSxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFO1FBQ3BELE1BQU1sRCxTQUFTMkMsT0FBTzBMLE9BQU8sQ0FBQ3ROLFVBQVU7UUFFeEMsSUFBSyxDQUFFZixRQUFTO1lBRWYsSUFBS3lCLEtBQUs0QixrQkFBa0IsSUFBSTVCLEtBQUs0QixrQkFBa0IsQ0FBQ2hDLE9BQU8sQ0FBRSxJQUFJLENBQUM2QixJQUFJLEtBQU0sR0FBSTtnQkFFbkYsTUFBTSxJQUFJckMsTUFBTztZQUVsQixPQUFPO2dCQUVOLGdGQUFnRjtnQkFDaEYsT0FBTztZQUVSO1FBRUQ7UUFFQSxPQUFPOEIsT0FBTzJMLGdCQUFnQixDQUFFSixjQUFjcEQsVUFBVXlELE1BQU0sRUFBRXZPO0lBRWpFO0lBeENBcUUsWUFBYTFCLE1BQU0sQ0FBRztRQUVyQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNPLElBQUksR0FBR2QsV0FBV21FLGtCQUFrQjtJQUUxQztBQXFDRDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNL0I7SUFVTHlKLFlBQWFDLFlBQVksRUFBRztRQUUzQixNQUFNaEwsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTVAsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDMUIsTUFBTWxCLE9BQU9rQixPQUFPbEIsSUFBSTtRQUV4QixNQUFNME0sYUFBYTFNLEtBQUsyTSxRQUFRLENBQUVGLGFBQWM7UUFFaEQsSUFBSyxDQUFFQyxXQUFXek0sVUFBVSxJQUFJLENBQUV5TSxXQUFXek0sVUFBVSxDQUFFd0IsS0FBTSxFQUFHO1lBRWpFLE9BQU87UUFFUjtRQUVBLE1BQU00SCxZQUFZcUQsV0FBV3pNLFVBQVUsQ0FBRXdCLEtBQU07UUFDL0MsTUFBTXFMLFNBQVM5TSxLQUFLK00sTUFBTSxDQUFFMUQsVUFBVXlELE1BQU0sQ0FBRTtRQUU5QyxJQUFJdk8sU0FBUzJDLE9BQU84TCxhQUFhO1FBQ2pDLElBQUtGLE9BQU9HLEdBQUcsRUFBRztZQUVqQixNQUFNQyxVQUFVaE0sT0FBTzBMLE9BQU8sQ0FBQzdPLE9BQU8sQ0FBQ29QLFVBQVUsQ0FBRUwsT0FBT0csR0FBRztZQUM3RCxJQUFLQyxZQUFZLE1BQU8zTyxTQUFTMk87UUFFbEM7UUFFQSxPQUFPLElBQUksQ0FBQ0UsYUFBYSxHQUFHdkYsSUFBSSxDQUFFLFNBQVd3RixXQUFXO1lBRXZELElBQUtBLGFBQWMsT0FBT25NLE9BQU8yTCxnQkFBZ0IsQ0FBRUosY0FBY3BELFVBQVV5RCxNQUFNLEVBQUV2TztZQUVuRixJQUFLeUIsS0FBSzRCLGtCQUFrQixJQUFJNUIsS0FBSzRCLGtCQUFrQixDQUFDaEMsT0FBTyxDQUFFNkIsU0FBVSxHQUFJO2dCQUU5RSxNQUFNLElBQUlyQyxNQUFPO1lBRWxCO1lBRUEsNEJBQTRCO1lBQzVCLE9BQU84QixPQUFPc0wsV0FBVyxDQUFFQztRQUU1QjtJQUVEO0lBRUFXLGdCQUFnQjtRQUVmLElBQUssQ0FBRSxJQUFJLENBQUNDLFdBQVcsRUFBRztZQUV6QixJQUFJLENBQUNBLFdBQVcsR0FBRyxJQUFJNUssUUFBUyxTQUFXQyxPQUFPO2dCQUVqRCxNQUFNNEssUUFBUSxJQUFJQztnQkFFbEIsK0VBQStFO2dCQUMvRSw4QkFBOEI7Z0JBQzlCRCxNQUFNRSxHQUFHLEdBQUc7Z0JBRVpGLE1BQU1HLE1BQU0sR0FBR0gsTUFBTUksT0FBTyxHQUFHO29CQUU5QmhMLFFBQVM0SyxNQUFNSyxNQUFNLEtBQUs7Z0JBRTNCO1lBRUQ7UUFFRDtRQUVBLE9BQU8sSUFBSSxDQUFDTixXQUFXO0lBRXhCO0lBMUVBekssWUFBYTFCLE1BQU0sQ0FBRztRQUVyQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNPLElBQUksR0FBR2QsV0FBV3NFLGdCQUFnQjtRQUN2QyxJQUFJLENBQUNvSSxXQUFXLEdBQUc7SUFFcEI7QUFzRUQ7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTXJLO0lBVUx3SixZQUFhQyxZQUFZLEVBQUc7UUFFM0IsTUFBTWhMLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3RCLE1BQU1QLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLE1BQU1sQixPQUFPa0IsT0FBT2xCLElBQUk7UUFFeEIsTUFBTTBNLGFBQWExTSxLQUFLMk0sUUFBUSxDQUFFRixhQUFjO1FBRWhELElBQUssQ0FBRUMsV0FBV3pNLFVBQVUsSUFBSSxDQUFFeU0sV0FBV3pNLFVBQVUsQ0FBRXdCLEtBQU0sRUFBRztZQUVqRSxPQUFPO1FBRVI7UUFFQSxNQUFNNEgsWUFBWXFELFdBQVd6TSxVQUFVLENBQUV3QixLQUFNO1FBQy9DLE1BQU1xTCxTQUFTOU0sS0FBSytNLE1BQU0sQ0FBRTFELFVBQVV5RCxNQUFNLENBQUU7UUFFOUMsSUFBSXZPLFNBQVMyQyxPQUFPOEwsYUFBYTtRQUNqQyxJQUFLRixPQUFPRyxHQUFHLEVBQUc7WUFFakIsTUFBTUMsVUFBVWhNLE9BQU8wTCxPQUFPLENBQUM3TyxPQUFPLENBQUNvUCxVQUFVLENBQUVMLE9BQU9HLEdBQUc7WUFDN0QsSUFBS0MsWUFBWSxNQUFPM08sU0FBUzJPO1FBRWxDO1FBRUEsT0FBTyxJQUFJLENBQUNFLGFBQWEsR0FBR3ZGLElBQUksQ0FBRSxTQUFXd0YsV0FBVztZQUV2RCxJQUFLQSxhQUFjLE9BQU9uTSxPQUFPMkwsZ0JBQWdCLENBQUVKLGNBQWNwRCxVQUFVeUQsTUFBTSxFQUFFdk87WUFFbkYsSUFBS3lCLEtBQUs0QixrQkFBa0IsSUFBSTVCLEtBQUs0QixrQkFBa0IsQ0FBQ2hDLE9BQU8sQ0FBRTZCLFNBQVUsR0FBSTtnQkFFOUUsTUFBTSxJQUFJckMsTUFBTztZQUVsQjtZQUVBLDRCQUE0QjtZQUM1QixPQUFPOEIsT0FBT3NMLFdBQVcsQ0FBRUM7UUFFNUI7SUFFRDtJQUVBVyxnQkFBZ0I7UUFFZixJQUFLLENBQUUsSUFBSSxDQUFDQyxXQUFXLEVBQUc7WUFFekIsSUFBSSxDQUFDQSxXQUFXLEdBQUcsSUFBSTVLLFFBQVMsU0FBV0MsT0FBTztnQkFFakQsTUFBTTRLLFFBQVEsSUFBSUM7Z0JBRWxCLG9CQUFvQjtnQkFDcEJELE1BQU1FLEdBQUcsR0FBRztnQkFDWkYsTUFBTUcsTUFBTSxHQUFHSCxNQUFNSSxPQUFPLEdBQUc7b0JBRTlCaEwsUUFBUzRLLE1BQU1LLE1BQU0sS0FBSztnQkFFM0I7WUFFRDtRQUVEO1FBRUEsT0FBTyxJQUFJLENBQUNOLFdBQVc7SUFFeEI7SUF4RUF6SyxZQUFhMUIsTUFBTSxDQUFHO1FBRXJCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ08sSUFBSSxHQUFHZCxXQUFXdUUsZ0JBQWdCO1FBQ3ZDLElBQUksQ0FBQ21JLFdBQVcsR0FBRztJQUVwQjtBQW9FRDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNMUo7SUFTTGlLLGVBQWdCbEcsS0FBSyxFQUFHO1FBRXZCLE1BQU0xSCxPQUFPLElBQUksQ0FBQ2tCLE1BQU0sQ0FBQ2xCLElBQUk7UUFDN0IsTUFBTTZOLGFBQWE3TixLQUFLOE4sV0FBVyxDQUFFcEcsTUFBTztRQUU1QyxJQUFLbUcsV0FBVzVOLFVBQVUsSUFBSTROLFdBQVc1TixVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLEVBQUc7WUFFbEUsTUFBTXNNLGVBQWVGLFdBQVc1TixVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFO1lBRXZELE1BQU11TSxTQUFTLElBQUksQ0FBQzlNLE1BQU0sQ0FBQ3VHLGFBQWEsQ0FBRSxVQUFVc0csYUFBYUMsTUFBTTtZQUN2RSxNQUFNQyxVQUFVLElBQUksQ0FBQy9NLE1BQU0sQ0FBQzBMLE9BQU8sQ0FBQ3BOLGNBQWM7WUFFbEQsSUFBSyxDQUFFeU8sV0FBVyxDQUFFQSxRQUFRQyxTQUFTLEVBQUc7Z0JBRXZDLElBQUtsTyxLQUFLNEIsa0JBQWtCLElBQUk1QixLQUFLNEIsa0JBQWtCLENBQUNoQyxPQUFPLENBQUUsSUFBSSxDQUFDNkIsSUFBSSxLQUFNLEdBQUk7b0JBRW5GLE1BQU0sSUFBSXJDLE1BQU87Z0JBRWxCLE9BQU87b0JBRU4sa0ZBQWtGO29CQUNsRixPQUFPO2dCQUVSO1lBRUQ7WUFFQSxPQUFPNE8sT0FBT25HLElBQUksQ0FBRSxTQUFXc0csR0FBRztnQkFFakMsTUFBTUMsYUFBYUwsYUFBYUssVUFBVSxJQUFJO2dCQUM5QyxNQUFNQyxhQUFhTixhQUFhTSxVQUFVLElBQUk7Z0JBRTlDLE1BQU1DLFFBQVFQLGFBQWFPLEtBQUs7Z0JBQ2hDLE1BQU1DLFNBQVNSLGFBQWFTLFVBQVU7Z0JBRXRDLE1BQU0xQixTQUFTLElBQUlyTSxXQUFZME4sS0FBS0MsWUFBWUM7Z0JBRWhELElBQUtKLFFBQVFRLHFCQUFxQixFQUFHO29CQUVwQyxPQUFPUixRQUFRUSxxQkFBcUIsQ0FBRUgsT0FBT0MsUUFBUXpCLFFBQVFpQixhQUFhVyxJQUFJLEVBQUVYLGFBQWFZLE1BQU0sRUFBRzlHLElBQUksQ0FBRSxTQUFXc0csR0FBRzt3QkFFekgsT0FBT0EsSUFBSUgsTUFBTTtvQkFFbEI7Z0JBRUQsT0FBTztvQkFFTiw0RUFBNEU7b0JBQzVFLE9BQU9DLFFBQVFXLEtBQUssQ0FBQy9HLElBQUksQ0FBRTt3QkFFMUIsTUFBTWdILFNBQVMsSUFBSXZPLFlBQWFnTyxRQUFRQzt3QkFDeENOLFFBQVFhLGdCQUFnQixDQUFFLElBQUlyTyxXQUFZb08sU0FBVVAsT0FBT0MsUUFBUXpCLFFBQVFpQixhQUFhVyxJQUFJLEVBQUVYLGFBQWFZLE1BQU07d0JBQ2pILE9BQU9FO29CQUVSO2dCQUVEO1lBRUQ7UUFFRCxPQUFPO1lBRU4sT0FBTztRQUVSO0lBRUQ7SUF6RUFqTSxZQUFhMUIsTUFBTSxDQUFHO1FBRXJCLElBQUksQ0FBQ08sSUFBSSxHQUFHZCxXQUFXd0UsdUJBQXVCO1FBQzlDLElBQUksQ0FBQ2pFLE1BQU0sR0FBR0E7SUFFZjtBQXNFRDtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTTBDO0lBU0xtTCxlQUFnQnZKLFNBQVMsRUFBRztRQUUzQixNQUFNeEYsT0FBTyxJQUFJLENBQUNrQixNQUFNLENBQUNsQixJQUFJO1FBQzdCLE1BQU0wRixVQUFVMUYsS0FBS3VGLEtBQUssQ0FBRUMsVUFBVztRQUV2QyxJQUFLLENBQUVFLFFBQVF6RixVQUFVLElBQUksQ0FBRXlGLFFBQVF6RixVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLElBQzdEaUUsUUFBUXNKLElBQUksS0FBS2hPLFdBQVk7WUFFN0IsT0FBTztRQUVSO1FBRUEsTUFBTWlPLFVBQVVqUCxLQUFLa1AsTUFBTSxDQUFFeEosUUFBUXNKLElBQUksQ0FBRTtRQUUzQyw4Q0FBOEM7UUFFOUMsS0FBTSxNQUFNRyxhQUFhRixRQUFRRyxVQUFVLENBQUc7WUFFN0MsSUFBS0QsVUFBVVQsSUFBSSxLQUFLVyxnQkFBZ0JDLFNBQVMsSUFDL0NILFVBQVVULElBQUksS0FBS1csZ0JBQWdCRSxjQUFjLElBQ2pESixVQUFVVCxJQUFJLEtBQUtXLGdCQUFnQkcsWUFBWSxJQUMvQ0wsVUFBVVQsSUFBSSxLQUFLMU4sV0FBWTtnQkFFaEMsT0FBTztZQUVSO1FBRUQ7UUFFQSxNQUFNK00sZUFBZXJJLFFBQVF6RixVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFO1FBQ3BELE1BQU1nTyxnQkFBZ0IxQixhQUFhMkIsVUFBVTtRQUU3QyxxREFBcUQ7UUFFckQsTUFBTXJILFVBQVUsRUFBRTtRQUNsQixNQUFNcUgsYUFBYSxDQUFDO1FBRXBCLElBQU0sTUFBTTFMLE9BQU95TCxjQUFnQjtZQUVsQ3BILFFBQVF4SSxJQUFJLENBQUUsSUFBSSxDQUFDcUIsTUFBTSxDQUFDdUcsYUFBYSxDQUFFLFlBQVlnSSxhQUFhLENBQUV6TCxJQUFLLEVBQUc2RCxJQUFJLENBQUU4SCxDQUFBQTtnQkFFakZELFVBQVUsQ0FBRTFMLElBQUssR0FBRzJMO2dCQUNwQixPQUFPRCxVQUFVLENBQUUxTCxJQUFLO1lBRXpCO1FBRUQ7UUFFQSxJQUFLcUUsUUFBUTlHLE1BQU0sR0FBRyxHQUFJO1lBRXpCLE9BQU87UUFFUjtRQUVBOEcsUUFBUXhJLElBQUksQ0FBRSxJQUFJLENBQUNxQixNQUFNLENBQUM2TixjQUFjLENBQUV2SjtRQUUxQyxPQUFPL0MsUUFBUXNHLEdBQUcsQ0FBRVYsU0FBVVIsSUFBSSxDQUFFK0gsQ0FBQUE7WUFFbkMsTUFBTUMsYUFBYUQsUUFBUUUsR0FBRztZQUM5QixNQUFNWixTQUFTVyxXQUFXRSxPQUFPLEdBQUdGLFdBQVdHLFFBQVEsR0FBRztnQkFBRUg7YUFBWTtZQUN4RSxNQUFNdkIsUUFBUXNCLE9BQU8sQ0FBRSxFQUFHLENBQUN0QixLQUFLLEVBQUUsc0NBQXNDO1lBQ3hFLE1BQU0yQixrQkFBa0IsRUFBRTtZQUUxQixLQUFNLE1BQU1qQixRQUFRRSxPQUFTO2dCQUU1QixxQkFBcUI7Z0JBQ3JCLE1BQU1nQixJQUFJLElBQUlqViwwQ0FBT0E7Z0JBQ3JCLE1BQU1rVixJQUFJLElBQUlyVCwwQ0FBT0E7Z0JBQ3JCLE1BQU1zVCxJQUFJLElBQUlsVSw2Q0FBVUE7Z0JBQ3hCLE1BQU1tVSxJQUFJLElBQUl2VCwwQ0FBT0EsQ0FBRSxHQUFHLEdBQUc7Z0JBRTdCLE1BQU13VCxnQkFBZ0IsSUFBSXZXLGdEQUFhQSxDQUFFaVYsS0FBS3VCLFFBQVEsRUFBRXZCLEtBQUt3QixRQUFRLEVBQUVsQztnQkFFdkUsSUFBTSxJQUFJaE4sSUFBSSxHQUFHQSxJQUFJZ04sT0FBT2hOLElBQU87b0JBRWxDLElBQUtvTyxXQUFXZSxXQUFXLEVBQUc7d0JBRTdCTixFQUFFTyxtQkFBbUIsQ0FBRWhCLFdBQVdlLFdBQVcsRUFBRW5QO29CQUVoRDtvQkFFQSxJQUFLb08sV0FBV2lCLFFBQVEsRUFBRzt3QkFFMUJQLEVBQUVNLG1CQUFtQixDQUFFaEIsV0FBV2lCLFFBQVEsRUFBRXJQO29CQUU3QztvQkFFQSxJQUFLb08sV0FBV2tCLEtBQUssRUFBRzt3QkFFdkJQLEVBQUVLLG1CQUFtQixDQUFFaEIsV0FBV2tCLEtBQUssRUFBRXRQO29CQUUxQztvQkFFQWdQLGNBQWNPLFdBQVcsQ0FBRXZQLEdBQUc0TyxFQUFFWSxPQUFPLENBQUVYLEdBQUdDLEdBQUdDO2dCQUVoRDtnQkFFQSwwREFBMEQ7Z0JBQzFELElBQU0sTUFBTVUsaUJBQWlCckIsV0FBYTtvQkFFekMsSUFBS3FCLGtCQUFrQixZQUFhO3dCQUVuQyxNQUFNQyxPQUFPdEIsVUFBVSxDQUFFcUIsY0FBZTt3QkFDeENULGNBQWNXLGFBQWEsR0FBRyxJQUFJaFUsMkRBQXdCQSxDQUFFK1QsS0FBS3BJLEtBQUssRUFBRW9JLEtBQUtFLFFBQVEsRUFBRUYsS0FBS0csVUFBVTtvQkFFdkcsT0FBTyxJQUFLSixrQkFBa0IsaUJBQzVCQSxrQkFBa0IsY0FDbEJBLGtCQUFrQixTQUFVO3dCQUU3Qi9CLEtBQUt1QixRQUFRLENBQUNhLFlBQVksQ0FBRUwsZUFBZXJCLFVBQVUsQ0FBRXFCLGNBQWU7b0JBRXZFO2dCQUVEO2dCQUVBLGVBQWU7Z0JBQ2ZwViwyQ0FBUUEsQ0FBQzBWLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLENBQUVqQixlQUFldEI7Z0JBRTdDLElBQUksQ0FBQzlOLE1BQU0sQ0FBQ3NRLG1CQUFtQixDQUFFbEI7Z0JBRWpDTCxnQkFBZ0JwUSxJQUFJLENBQUV5UTtZQUV2QjtZQUVBLElBQUtULFdBQVdFLE9BQU8sRUFBRztnQkFFekJGLFdBQVc0QixLQUFLO2dCQUVoQjVCLFdBQVc1TCxHQUFHLElBQU1nTTtnQkFFcEIsT0FBT0o7WUFFUjtZQUVBLE9BQU9JLGVBQWUsQ0FBRSxFQUFHO1FBRTVCO0lBRUQ7SUFqSkFyTixZQUFhMUIsTUFBTSxDQUFHO1FBRXJCLElBQUksQ0FBQ08sSUFBSSxHQUFHZCxXQUFXeUUsdUJBQXVCO1FBQzlDLElBQUksQ0FBQ2xFLE1BQU0sR0FBR0E7SUFFZjtBQThJRDtBQUVBLG9CQUFvQixHQUNwQixNQUFNUixnQ0FBZ0M7QUFDdEMsTUFBTWdSLGlDQUFpQztBQUN2QyxNQUFNQywrQkFBK0I7SUFBRXRSLE1BQU07SUFBWXVSLEtBQUs7QUFBVztBQUV6RSxNQUFNL1E7SUFFTCtCLFlBQWE5RCxJQUFJLENBQUc7UUFFbkIsSUFBSSxDQUFDMkMsSUFBSSxHQUFHZCxXQUFXQyxlQUFlO1FBQ3RDLElBQUksQ0FBQ0UsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDK1EsSUFBSSxHQUFHO1FBRVosTUFBTUMsYUFBYSxJQUFJQyxTQUFValQsTUFBTSxHQUFHNFM7UUFDMUMsTUFBTXZSLGNBQWMsSUFBSUM7UUFFeEIsSUFBSSxDQUFDNFIsTUFBTSxHQUFHO1lBQ2J6UixPQUFPSixZQUFZSyxNQUFNLENBQUUsSUFBSUMsV0FBWTNCLEtBQUttVCxLQUFLLENBQUUsR0FBRztZQUMxRGhSLFNBQVM2USxXQUFXSSxTQUFTLENBQUUsR0FBRztZQUNsQzNRLFFBQVF1USxXQUFXSSxTQUFTLENBQUUsR0FBRztRQUNsQztRQUVBLElBQUssSUFBSSxDQUFDRixNQUFNLENBQUN6UixLQUFLLEtBQUtHLCtCQUFnQztZQUUxRCxNQUFNLElBQUl0QixNQUFPO1FBRWxCLE9BQU8sSUFBSyxJQUFJLENBQUM0UyxNQUFNLENBQUMvUSxPQUFPLEdBQUcsS0FBTTtZQUV2QyxNQUFNLElBQUk3QixNQUFPO1FBRWxCO1FBRUEsTUFBTStTLHNCQUFzQixJQUFJLENBQUNILE1BQU0sQ0FBQ3pRLE1BQU0sR0FBR21RO1FBQ2pELE1BQU1VLFlBQVksSUFBSUwsU0FBVWpULE1BQU00UztRQUN0QyxJQUFJVyxhQUFhO1FBRWpCLE1BQVFBLGFBQWFGLG9CQUFzQjtZQUUxQyxNQUFNRyxjQUFjRixVQUFVRixTQUFTLENBQUVHLFlBQVk7WUFDckRBLGNBQWM7WUFFZCxNQUFNRSxZQUFZSCxVQUFVRixTQUFTLENBQUVHLFlBQVk7WUFDbkRBLGNBQWM7WUFFZCxJQUFLRSxjQUFjWiw2QkFBNkJ0UixJQUFJLEVBQUc7Z0JBRXRELE1BQU1tUyxlQUFlLElBQUkvUixXQUFZM0IsTUFBTTRTLGlDQUFpQ1csWUFBWUM7Z0JBQ3hGLElBQUksQ0FBQ3hSLE9BQU8sR0FBR1gsWUFBWUssTUFBTSxDQUFFZ1M7WUFFcEMsT0FBTyxJQUFLRCxjQUFjWiw2QkFBNkJDLEdBQUcsRUFBRztnQkFFNUQsTUFBTXhELGFBQWFzRCxpQ0FBaUNXO2dCQUNwRCxJQUFJLENBQUNSLElBQUksR0FBRy9TLEtBQUttVCxLQUFLLENBQUU3RCxZQUFZQSxhQUFha0U7WUFFbEQ7WUFFQSxpREFBaUQ7WUFFakRELGNBQWNDO1FBRWY7UUFFQSxJQUFLLElBQUksQ0FBQ3hSLE9BQU8sS0FBSyxNQUFPO1lBRTVCLE1BQU0sSUFBSTFCLE1BQU87UUFFbEI7SUFFRDtBQUVEO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU00QztJQWlCTHlRLGdCQUFpQnRELFNBQVMsRUFBRWpPLE1BQU0sRUFBRztRQUVwQyxNQUFNbEIsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTWQsY0FBYyxJQUFJLENBQUNBLFdBQVc7UUFDcEMsTUFBTXdULGtCQUFrQnZELFVBQVVsUCxVQUFVLENBQUUsSUFBSSxDQUFDd0IsSUFBSSxDQUFFLENBQUNvTSxVQUFVO1FBQ3BFLE1BQU04RSxtQkFBbUJ4RCxVQUFVbFAsVUFBVSxDQUFFLElBQUksQ0FBQ3dCLElBQUksQ0FBRSxDQUFDaU8sVUFBVTtRQUNyRSxNQUFNa0Qsb0JBQW9CLENBQUM7UUFDM0IsTUFBTUMseUJBQXlCLENBQUM7UUFDaEMsTUFBTUMsbUJBQW1CLENBQUM7UUFFMUIsSUFBTSxNQUFNL0IsaUJBQWlCNEIsaUJBQW1CO1lBRS9DLE1BQU1JLHFCQUFxQkMsVUFBVSxDQUFFakMsY0FBZSxJQUFJQSxjQUFja0MsV0FBVztZQUVuRkwsaUJBQWlCLENBQUVHLG1CQUFvQixHQUFHSixnQkFBZ0IsQ0FBRTVCLGNBQWU7UUFFNUU7UUFFQSxJQUFNLE1BQU1BLGlCQUFpQjVCLFVBQVVPLFVBQVUsQ0FBRztZQUVuRCxNQUFNcUQscUJBQXFCQyxVQUFVLENBQUVqQyxjQUFlLElBQUlBLGNBQWNrQyxXQUFXO1lBRW5GLElBQUtOLGdCQUFnQixDQUFFNUIsY0FBZSxLQUFLL1AsV0FBWTtnQkFFdEQsTUFBTWtTLGNBQWNsVCxLQUFLbVQsU0FBUyxDQUFFaEUsVUFBVU8sVUFBVSxDQUFFcUIsY0FBZSxDQUFFO2dCQUMzRSxNQUFNcUMsZ0JBQWdCQyxxQkFBcUIsQ0FBRUgsWUFBWUUsYUFBYSxDQUFFO2dCQUV4RU4sZ0JBQWdCLENBQUVDLG1CQUFvQixHQUFHSyxjQUFjM1IsSUFBSTtnQkFDM0RvUixzQkFBc0IsQ0FBRUUsbUJBQW9CLEdBQUdHLFlBQVkvQixVQUFVLEtBQUs7WUFFM0U7UUFFRDtRQUVBLE9BQU9qUSxPQUFPdUcsYUFBYSxDQUFFLGNBQWNpTCxpQkFBa0I3SyxJQUFJLENBQUUsU0FBV2dHLFVBQVU7WUFFdkYsT0FBTyxJQUFJcEwsUUFBUyxTQUFXQyxPQUFPLEVBQUVDLE1BQU07Z0JBRTdDekQsWUFBWW9VLGVBQWUsQ0FBRXpGLFlBQVksU0FBVzBDLFFBQVE7b0JBRTNELElBQU0sTUFBTVEsaUJBQWlCUixTQUFTYixVQUFVLENBQUc7d0JBRWxELE1BQU02RCxZQUFZaEQsU0FBU2IsVUFBVSxDQUFFcUIsY0FBZTt3QkFDdEQsTUFBTUksYUFBYTBCLHNCQUFzQixDQUFFOUIsY0FBZTt3QkFFMUQsSUFBS0ksZUFBZW5RLFdBQVl1UyxVQUFVcEMsVUFBVSxHQUFHQTtvQkFFeEQ7b0JBRUF6TyxRQUFTNk47Z0JBRVYsR0FBR3FDLG1CQUFtQkUsa0JBQWtCbFksdURBQW9CQSxFQUFFK0g7WUFFL0Q7UUFFRDtJQUVEO0lBeEVBQyxZQUFhNUMsSUFBSSxFQUFFZCxXQUFXLENBQUc7UUFFaEMsSUFBSyxDQUFFQSxhQUFjO1lBRXBCLE1BQU0sSUFBSUUsTUFBTztRQUVsQjtRQUVBLElBQUksQ0FBQ3FDLElBQUksR0FBR2QsV0FBV29CLDBCQUEwQjtRQUNqRCxJQUFJLENBQUMvQixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDZCxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0EsV0FBVyxDQUFDc1UsT0FBTztJQUV6QjtBQTZERDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNdFI7SUFRTHVSLGNBQWVDLE9BQU8sRUFBRUMsU0FBUyxFQUFHO1FBRW5DLElBQUssQ0FBRUEsVUFBVUMsUUFBUSxLQUFLNVMsYUFBYTJTLFVBQVVDLFFBQVEsS0FBS0YsUUFBUUcsT0FBTyxLQUM3RUYsVUFBVUcsTUFBTSxLQUFLOVMsYUFDckIyUyxVQUFVSSxRQUFRLEtBQUsvUyxhQUN2QjJTLFVBQVU5SixLQUFLLEtBQUs3SSxXQUFZO1lBRW5DLHVEQUF1RDtZQUN2RCxPQUFPMFM7UUFFUjtRQUVBQSxVQUFVQSxRQUFRTSxLQUFLO1FBRXZCLElBQUtMLFVBQVVDLFFBQVEsS0FBSzVTLFdBQVk7WUFFdkMwUyxRQUFRRyxPQUFPLEdBQUdGLFVBQVVDLFFBQVE7UUFFckM7UUFFQSxJQUFLRCxVQUFVRyxNQUFNLEtBQUs5UyxXQUFZO1lBRXJDMFMsUUFBUUksTUFBTSxDQUFDRyxTQUFTLENBQUVOLFVBQVVHLE1BQU07UUFFM0M7UUFFQSxJQUFLSCxVQUFVSSxRQUFRLEtBQUsvUyxXQUFZO1lBRXZDMFMsUUFBUUssUUFBUSxHQUFHSixVQUFVSSxRQUFRO1FBRXRDO1FBRUEsSUFBS0osVUFBVTlKLEtBQUssS0FBSzdJLFdBQVk7WUFFcEMwUyxRQUFRUSxNQUFNLENBQUNELFNBQVMsQ0FBRU4sVUFBVTlKLEtBQUs7UUFFMUM7UUFFQTZKLFFBQVFTLFdBQVcsR0FBRztRQUV0QixPQUFPVDtJQUVSO0lBaERBOVEsYUFBYztRQUViLElBQUksQ0FBQ25CLElBQUksR0FBR2QsV0FBV3NCLHFCQUFxQjtJQUU3QztBQThDRDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNRztJQUVMUSxhQUFjO1FBRWIsSUFBSSxDQUFDbkIsSUFBSSxHQUFHZCxXQUFXd0IscUJBQXFCO0lBRTdDO0FBRUQ7QUFFQSxpQ0FBaUMsR0FDakMsaUNBQWlDLEdBQ2pDLGlDQUFpQyxHQUVqQyx1QkFBdUI7QUFDdkIsOEhBQThIO0FBQzlILE1BQU1pUyxtQ0FBbUNsYSw4Q0FBV0E7SUFRbkRtYSxpQkFBa0IzTSxLQUFLLEVBQUc7UUFFekIsc0VBQXNFO1FBQ3RFLDhEQUE4RDtRQUU5RCxNQUFNbUgsU0FBUyxJQUFJLENBQUN5RixZQUFZLEVBQy9CQyxTQUFTLElBQUksQ0FBQ0MsWUFBWSxFQUMxQkMsWUFBWSxJQUFJLENBQUNBLFNBQVMsRUFDMUJYLFNBQVNwTSxRQUFRK00sWUFBWSxJQUFJQTtRQUVsQyxJQUFNLElBQUluVCxJQUFJLEdBQUdBLE1BQU1tVCxXQUFXblQsSUFBTztZQUV4Q3VOLE1BQU0sQ0FBRXZOLEVBQUcsR0FBR2lULE1BQU0sQ0FBRVQsU0FBU3hTLEVBQUc7UUFFbkM7UUFFQSxPQUFPdU47SUFFUjtJQUVBNkYsYUFBY0MsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLENBQUMsRUFBRUMsRUFBRSxFQUFHO1FBRTdCLE1BQU1qRyxTQUFTLElBQUksQ0FBQ3lGLFlBQVk7UUFDaEMsTUFBTUMsU0FBUyxJQUFJLENBQUNDLFlBQVk7UUFDaEMsTUFBTWpHLFNBQVMsSUFBSSxDQUFDa0csU0FBUztRQUU3QixNQUFNTSxVQUFVeEcsU0FBUztRQUN6QixNQUFNeUcsVUFBVXpHLFNBQVM7UUFFekIsTUFBTTBHLEtBQUtILEtBQUtGO1FBRWhCLE1BQU16RSxJQUFJLENBQUUwRSxJQUFJRCxFQUFDLElBQU1LO1FBQ3ZCLE1BQU1DLEtBQUsvRSxJQUFJQTtRQUNmLE1BQU1nRixNQUFNRCxLQUFLL0U7UUFFakIsTUFBTWlGLFVBQVVULEtBQUtLO1FBQ3JCLE1BQU1LLFVBQVVELFVBQVVKO1FBRTFCLE1BQU1NLEtBQUssQ0FBRSxJQUFJSCxNQUFNLElBQUlEO1FBQzNCLE1BQU1LLEtBQUtKLE1BQU1EO1FBQ2pCLE1BQU1NLEtBQUssSUFBSUY7UUFDZixNQUFNRyxLQUFLRixLQUFLTCxLQUFLL0U7UUFFckIsK0RBQStEO1FBQy9ELG9GQUFvRjtRQUNwRixJQUFNLElBQUk3TyxJQUFJLEdBQUdBLE1BQU1pTixRQUFRak4sSUFBTztZQUVyQyxNQUFNb1UsS0FBS25CLE1BQU0sQ0FBRWMsVUFBVS9ULElBQUlpTixPQUFRLEVBQUUsaUJBQWlCO1lBQzVELE1BQU1vSCxLQUFLcEIsTUFBTSxDQUFFYyxVQUFVL1QsSUFBSXlULFFBQVMsR0FBR0UsSUFBSSwrQkFBK0I7WUFDaEYsTUFBTVcsS0FBS3JCLE1BQU0sQ0FBRWEsVUFBVTlULElBQUlpTixPQUFRLEVBQUUsbUJBQW1CO1lBQzlELE1BQU1zSCxLQUFLdEIsTUFBTSxDQUFFYSxVQUFVOVQsRUFBRyxHQUFHMlQsSUFBSSxnQ0FBZ0M7WUFFdkVwRyxNQUFNLENBQUV2TixFQUFHLEdBQUdrVSxLQUFLRSxLQUFLRCxLQUFLRSxLQUFLTCxLQUFLTSxLQUFLTCxLQUFLTTtRQUVsRDtRQUVBLE9BQU9oSDtJQUVSO0lBaEVBak0sWUFBYWtULGtCQUFrQixFQUFFdEIsWUFBWSxFQUFFdUIsVUFBVSxFQUFFekIsWUFBWSxDQUFHO1FBRXpFLEtBQUssQ0FBRXdCLG9CQUFvQnRCLGNBQWN1QixZQUFZekI7SUFFdEQ7QUE4REQ7QUFFQSxNQUFNMEIsS0FBSyxJQUFJOVosNkNBQVVBO0FBRXpCLE1BQU0rWiw2Q0FBNkM3QjtJQUVsRE0sYUFBY0MsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLENBQUMsRUFBRUMsRUFBRSxFQUFHO1FBRTdCLE1BQU1qRyxTQUFTLEtBQUssQ0FBQzZGLGFBQWNDLElBQUlDLElBQUlDLEdBQUdDO1FBRTlDa0IsR0FBRy9CLFNBQVMsQ0FBRXBGLFFBQVNxSCxTQUFTLEdBQUdDLE9BQU8sQ0FBRXRIO1FBRTVDLE9BQU9BO0lBRVI7QUFFRDtBQUdBLGlDQUFpQyxHQUNqQyxpQ0FBaUMsR0FDakMsaUNBQWlDLEdBRWpDLGFBQWEsR0FFYixNQUFNUSxrQkFBa0I7SUFDdkIrRyxPQUFPO0lBQ1Asb0JBQW9CO0lBQ3BCQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsWUFBWTtJQUNaQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLFdBQVc7SUFDWEMsWUFBWTtJQUNaMUgsV0FBVztJQUNYQyxnQkFBZ0I7SUFDaEJDLGNBQWM7SUFDZHlILGVBQWU7SUFDZkMsZ0JBQWdCO0FBQ2pCO0FBRUEsTUFBTTdELHdCQUF3QjtJQUM3QixNQUFNOEQ7SUFDTixNQUFNMVc7SUFDTixNQUFNMlc7SUFDTixNQUFNQztJQUNOLE1BQU1DO0lBQ04sTUFBTUM7QUFDUDtBQUVBLE1BQU1DLGdCQUFnQjtJQUNyQixNQUFNamMsZ0RBQWFBO0lBQ25CLE1BQU1kLCtDQUFZQTtJQUNsQixNQUFNZ0IsNkRBQTBCQTtJQUNoQyxNQUFNZCw0REFBeUJBO0lBQy9CLE1BQU1hLDREQUF5QkE7SUFDL0IsTUFBTWQsMkRBQXdCQTtBQUMvQjtBQUVBLE1BQU0rYyxrQkFBa0I7SUFDdkIsT0FBT25lLHNEQUFtQkE7SUFDMUIsT0FBT2dDLHlEQUFzQkE7SUFDN0IsT0FBT2MsaURBQWNBO0FBQ3RCO0FBRUEsTUFBTXNiLG1CQUFtQjtJQUN4QixVQUFVO0lBQ1YsUUFBUTtJQUNSLFFBQVE7SUFDUixRQUFRO0lBQ1IsUUFBUTtJQUNSLFFBQVE7SUFDUixRQUFRO0FBQ1Q7QUFFQSxNQUFNMUUsYUFBYTtJQUNsQjJFLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFlBQVk7SUFDWkMsWUFBWTtJQUNaQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsU0FBUztJQUNUQyxXQUFXO0lBQ1hDLFVBQVU7QUFDWDtBQUVBLE1BQU1DLGtCQUFrQjtJQUN2QnhPLE9BQU87SUFDUHlPLGFBQWE7SUFDYnZFLFVBQVU7SUFDVndFLFNBQVM7QUFDVjtBQUVBLE1BQU1DLGdCQUFnQjtJQUNyQkMsYUFBYXpYO0lBQ1ksdUZBQXVGO0lBQ2hIMFYsUUFBUXRjLG9EQUFpQkE7SUFDekJzZSxNQUFNdmUsc0RBQW1CQTtBQUMxQjtBQUVBLE1BQU13ZSxjQUFjO0lBQ25CQyxRQUFRO0lBQ1JDLE1BQU07SUFDTkMsT0FBTztBQUNSO0FBRUE7O0NBRUMsR0FDRCxTQUFTQyxzQkFBdUJsVCxLQUFLO0lBRXBDLElBQUtBLEtBQUssQ0FBRSxrQkFBbUIsS0FBSzdFLFdBQVk7UUFFL0M2RSxLQUFLLENBQUUsa0JBQW1CLEdBQUcsSUFBSXhLLHVEQUFvQkEsQ0FBRTtZQUN0RGlMLE9BQU87WUFDUDBTLFVBQVU7WUFDVkMsV0FBVztZQUNYQyxXQUFXO1lBQ1hDLGFBQWE7WUFDYkMsV0FBVztZQUNYQyxNQUFNemYsNENBQVNBO1FBQ2hCO0lBRUQ7SUFFQSxPQUFPaU0sS0FBSyxDQUFFLGtCQUFtQjtBQUVsQztBQUVBLFNBQVN5VCwrQkFBZ0NDLGVBQWUsRUFBRXJWLE1BQU0sRUFBRXNWLFNBQVM7SUFFMUUsdURBQXVEO0lBRXZELElBQU0sTUFBTS9YLFFBQVErWCxVQUFVdlosVUFBVSxDQUFHO1FBRTFDLElBQUtzWixlQUFlLENBQUU5WCxLQUFNLEtBQUtULFdBQVk7WUFFNUNrRCxPQUFPdVYsUUFBUSxDQUFDQyxjQUFjLEdBQUd4VixPQUFPdVYsUUFBUSxDQUFDQyxjQUFjLElBQUksQ0FBQztZQUNwRXhWLE9BQU91VixRQUFRLENBQUNDLGNBQWMsQ0FBRWpZLEtBQU0sR0FBRytYLFVBQVV2WixVQUFVLENBQUV3QixLQUFNO1FBRXRFO0lBRUQ7QUFFRDtBQUVBOzs7Q0FHQyxHQUNELFNBQVM2Rix1QkFBd0JwRCxNQUFNLEVBQUV5VixPQUFPO0lBRS9DLElBQUtBLFFBQVFDLE1BQU0sS0FBSzVZLFdBQVk7UUFFbkMsSUFBSyxPQUFPMlksUUFBUUMsTUFBTSxLQUFLLFVBQVc7WUFFekNDLE9BQU9DLE1BQU0sQ0FBRTVWLE9BQU91VixRQUFRLEVBQUVFLFFBQVFDLE1BQU07UUFFL0MsT0FBTztZQUVOemIsUUFBUWtFLElBQUksQ0FBRSx3REFBd0RzWCxRQUFRQyxNQUFNO1FBRXJGO0lBRUQ7QUFFRDtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRyxnQkFBaUJ4SixRQUFRLEVBQUV5SixPQUFPLEVBQUU5WSxNQUFNO0lBRWxELElBQUkrWSxtQkFBbUI7SUFDdkIsSUFBSUMsaUJBQWlCO0lBQ3JCLElBQUlDLGdCQUFnQjtJQUVwQixJQUFNLElBQUk3WSxJQUFJLEdBQUc4WSxLQUFLSixRQUFRelksTUFBTSxFQUFFRCxJQUFJOFksSUFBSTlZLElBQU87UUFFcEQsTUFBTW9GLFNBQVNzVCxPQUFPLENBQUUxWSxFQUFHO1FBRTNCLElBQUtvRixPQUFPaVIsUUFBUSxLQUFLM1csV0FBWWlaLG1CQUFtQjtRQUN4RCxJQUFLdlQsT0FBT2tSLE1BQU0sS0FBSzVXLFdBQVlrWixpQkFBaUI7UUFDcEQsSUFBS3hULE9BQU93UixPQUFPLEtBQUtsWCxXQUFZbVosZ0JBQWdCO1FBRXBELElBQUtGLG9CQUFvQkMsa0JBQWtCQyxlQUFnQjtJQUU1RDtJQUVBLElBQUssQ0FBRUYsb0JBQW9CLENBQUVDLGtCQUFrQixDQUFFQyxlQUFnQixPQUFPMVgsUUFBUUMsT0FBTyxDQUFFNk47SUFFekYsTUFBTThKLDJCQUEyQixFQUFFO0lBQ25DLE1BQU1DLHlCQUF5QixFQUFFO0lBQ2pDLE1BQU1DLHdCQUF3QixFQUFFO0lBRWhDLElBQU0sSUFBSWpaLElBQUksR0FBRzhZLEtBQUtKLFFBQVF6WSxNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztRQUVwRCxNQUFNb0YsU0FBU3NULE9BQU8sQ0FBRTFZLEVBQUc7UUFFM0IsSUFBSzJZLGtCQUFtQjtZQUV2QixNQUFNTyxrQkFBa0I5VCxPQUFPaVIsUUFBUSxLQUFLM1csWUFDekNFLE9BQU91RyxhQUFhLENBQUUsWUFBWWYsT0FBT2lSLFFBQVEsSUFDakRwSCxTQUFTYixVQUFVLENBQUMvSSxRQUFRO1lBRS9CMFQseUJBQXlCeGEsSUFBSSxDQUFFMmE7UUFFaEM7UUFFQSxJQUFLTixnQkFBaUI7WUFFckIsTUFBTU0sa0JBQWtCOVQsT0FBT2tSLE1BQU0sS0FBSzVXLFlBQ3ZDRSxPQUFPdUcsYUFBYSxDQUFFLFlBQVlmLE9BQU9rUixNQUFNLElBQy9DckgsU0FBU2IsVUFBVSxDQUFDK0ssTUFBTTtZQUU3QkgsdUJBQXVCemEsSUFBSSxDQUFFMmE7UUFFOUI7UUFFQSxJQUFLTCxlQUFnQjtZQUVwQixNQUFNSyxrQkFBa0I5VCxPQUFPd1IsT0FBTyxLQUFLbFgsWUFDeENFLE9BQU91RyxhQUFhLENBQUUsWUFBWWYsT0FBT3dSLE9BQU8sSUFDaEQzSCxTQUFTYixVQUFVLENBQUNwSixLQUFLO1lBRTVCaVUsc0JBQXNCMWEsSUFBSSxDQUFFMmE7UUFFN0I7SUFFRDtJQUVBLE9BQU8vWCxRQUFRc0csR0FBRyxDQUFFO1FBQ25CdEcsUUFBUXNHLEdBQUcsQ0FBRXNSO1FBQ2I1WCxRQUFRc0csR0FBRyxDQUFFdVI7UUFDYjdYLFFBQVFzRyxHQUFHLENBQUV3UjtLQUNiLEVBQUcxUyxJQUFJLENBQUUsU0FBV3NMLFNBQVM7UUFFN0IsTUFBTXVILGlCQUFpQnZILFNBQVMsQ0FBRSxFQUFHO1FBQ3JDLE1BQU13SCxlQUFleEgsU0FBUyxDQUFFLEVBQUc7UUFDbkMsTUFBTXlILGNBQWN6SCxTQUFTLENBQUUsRUFBRztRQUVsQyxJQUFLOEcsa0JBQW1CMUosU0FBU3NLLGVBQWUsQ0FBQ2xVLFFBQVEsR0FBRytUO1FBQzVELElBQUtSLGdCQUFpQjNKLFNBQVNzSyxlQUFlLENBQUNKLE1BQU0sR0FBR0U7UUFDeEQsSUFBS1IsZUFBZ0I1SixTQUFTc0ssZUFBZSxDQUFDdlUsS0FBSyxHQUFHc1U7UUFDdERySyxTQUFTdUssb0JBQW9CLEdBQUc7UUFFaEMsT0FBT3ZLO0lBRVI7QUFFRDtBQUVBOzs7Q0FHQyxHQUNELFNBQVN3SyxtQkFBb0IvTCxJQUFJLEVBQUVDLE9BQU87SUFFekNELEtBQUsrTCxrQkFBa0I7SUFFdkIsSUFBSzlMLFFBQVFzSixPQUFPLEtBQUt2WCxXQUFZO1FBRXBDLElBQU0sSUFBSU0sSUFBSSxHQUFHOFksS0FBS25MLFFBQVFzSixPQUFPLENBQUNoWCxNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztZQUU1RDBOLEtBQUtnTSxxQkFBcUIsQ0FBRTFaLEVBQUcsR0FBRzJOLFFBQVFzSixPQUFPLENBQUVqWCxFQUFHO1FBRXZEO0lBRUQ7SUFFQSxnRkFBZ0Y7SUFDaEYsSUFBSzJOLFFBQVEySyxNQUFNLElBQUluUixNQUFNQyxPQUFPLENBQUV1RyxRQUFRMkssTUFBTSxDQUFDcUIsV0FBVyxHQUFLO1FBRXBFLE1BQU1BLGNBQWNoTSxRQUFRMkssTUFBTSxDQUFDcUIsV0FBVztRQUU5QyxJQUFLak0sS0FBS2dNLHFCQUFxQixDQUFDelosTUFBTSxLQUFLMFosWUFBWTFaLE1BQU0sRUFBRztZQUUvRHlOLEtBQUtrTSxxQkFBcUIsR0FBRyxDQUFDO1lBRTlCLElBQU0sSUFBSTVaLElBQUksR0FBRzhZLEtBQUthLFlBQVkxWixNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztnQkFFeEQwTixLQUFLa00scUJBQXFCLENBQUVELFdBQVcsQ0FBRTNaLEVBQUcsQ0FBRSxHQUFHQTtZQUVsRDtRQUVELE9BQU87WUFFTm5ELFFBQVFrRSxJQUFJLENBQUU7UUFFZjtJQUVEO0FBRUQ7QUFFQSxTQUFTOFksbUJBQW9CQyxZQUFZO0lBRXhDLElBQUlDO0lBRUosTUFBTUMsaUJBQWlCRixhQUFhbmIsVUFBVSxJQUFJbWIsYUFBYW5iLFVBQVUsQ0FBRVUsV0FBV29CLDBCQUEwQixDQUFFO0lBRWxILElBQUt1WixnQkFBaUI7UUFFckJELGNBQWMsV0FBV0MsZUFBZXpOLFVBQVUsR0FDOUMsTUFBTXlOLGVBQWVDLE9BQU8sR0FDNUIsTUFBTUMsb0JBQXFCRixlQUFlNUwsVUFBVTtJQUV6RCxPQUFPO1FBRU4yTCxjQUFjRCxhQUFhRyxPQUFPLEdBQUcsTUFBTUMsb0JBQXFCSixhQUFhMUwsVUFBVSxJQUFLLE1BQU0wTCxhQUFhMU0sSUFBSTtJQUVwSDtJQUVBLElBQUswTSxhQUFhcEIsT0FBTyxLQUFLaFosV0FBWTtRQUV6QyxJQUFNLElBQUlNLElBQUksR0FBRzhZLEtBQUtnQixhQUFhcEIsT0FBTyxDQUFDelksTUFBTSxFQUFFRCxJQUFJOFksSUFBSTlZLElBQU87WUFFakUrWixlQUFlLE1BQU1HLG9CQUFxQkosYUFBYXBCLE9BQU8sQ0FBRTFZLEVBQUc7UUFFcEU7SUFFRDtJQUVBLE9BQU8rWjtBQUVSO0FBRUEsU0FBU0csb0JBQXFCOUwsVUFBVTtJQUV2QyxJQUFJK0wsZ0JBQWdCO0lBRXBCLE1BQU1DLE9BQU83QixPQUFPNkIsSUFBSSxDQUFFaE0sWUFBYWlNLElBQUk7SUFFM0MsSUFBTSxJQUFJcmEsSUFBSSxHQUFHOFksS0FBS3NCLEtBQUtuYSxNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztRQUVqRG1hLGlCQUFpQkMsSUFBSSxDQUFFcGEsRUFBRyxHQUFHLE1BQU1vTyxVQUFVLENBQUVnTSxJQUFJLENBQUVwYSxFQUFHLENBQUUsR0FBRztJQUU5RDtJQUVBLE9BQU9tYTtBQUVSO0FBRUEsU0FBU0csNEJBQTZCaFosV0FBVztJQUVoRCxhQUFhO0lBQ2Isd0hBQXdIO0lBRXhILE9BQVNBO1FBRVIsS0FBS3VVO1lBQ0osT0FBTyxJQUFJO1FBRVosS0FBSzFXO1lBQ0osT0FBTyxJQUFJO1FBRVosS0FBSzJXO1lBQ0osT0FBTyxJQUFJO1FBRVosS0FBS0M7WUFDSixPQUFPLElBQUk7UUFFWjtZQUNDLE1BQU0sSUFBSWpZLE1BQU87SUFFbkI7QUFFRDtBQUVBLFNBQVN5YyxvQkFBcUI1TyxHQUFHO0lBRWhDLElBQUtBLElBQUk2TyxNQUFNLENBQUUsb0JBQXFCLEtBQUs3TyxJQUFJNk8sTUFBTSxDQUFFLDBCQUEyQixHQUFJLE9BQU87SUFDN0YsSUFBSzdPLElBQUk2TyxNQUFNLENBQUUsbUJBQW9CLEtBQUs3TyxJQUFJNk8sTUFBTSxDQUFFLDBCQUEyQixHQUFJLE9BQU87SUFFNUYsT0FBTztBQUVSO0FBRUEsTUFBTUMsa0JBQWtCLElBQUk5Z0IsMENBQU9BO0FBRW5DLGVBQWUsR0FFZixNQUFNa0c7SUF1RUxtQixjQUFlckMsVUFBVSxFQUFHO1FBRTNCLElBQUksQ0FBQ0EsVUFBVSxHQUFHQTtJQUVuQjtJQUVBc0MsV0FBWXJDLE9BQU8sRUFBRztRQUVyQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFFaEI7SUFFQW5CLE1BQU96QixNQUFNLEVBQUVFLE9BQU8sRUFBRztRQUV4QixNQUFNMEQsU0FBUyxJQUFJO1FBQ25CLE1BQU1sQixPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNQyxhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUVsQyx5QkFBeUI7UUFDekIsSUFBSSxDQUFDNEYsS0FBSyxDQUFDekIsU0FBUztRQUNwQixJQUFJLENBQUM0WCxTQUFTLEdBQUcsQ0FBQztRQUVsQiw0REFBNEQ7UUFDNUQsSUFBSSxDQUFDQyxVQUFVLENBQUUsU0FBV0MsR0FBRztZQUU5QixPQUFPQSxJQUFJN1csU0FBUyxJQUFJNlcsSUFBSTdXLFNBQVM7UUFFdEM7UUFFQTVDLFFBQVFzRyxHQUFHLENBQUUsSUFBSSxDQUFDa1QsVUFBVSxDQUFFLFNBQVdDLEdBQUc7WUFFM0MsT0FBT0EsSUFBSUMsVUFBVSxJQUFJRCxJQUFJQyxVQUFVO1FBRXhDLElBQU10VSxJQUFJLENBQUU7WUFFWCxPQUFPcEYsUUFBUXNHLEdBQUcsQ0FBRTtnQkFFbkI3SCxPQUFPa2IsZUFBZSxDQUFFO2dCQUN4QmxiLE9BQU9rYixlQUFlLENBQUU7Z0JBQ3hCbGIsT0FBT2tiLGVBQWUsQ0FBRTthQUV4QjtRQUVGLEdBQUl2VSxJQUFJLENBQUUsU0FBV3dVLFlBQVk7WUFFaEMsTUFBTXhOLFNBQVM7Z0JBQ2R5TixPQUFPRCxZQUFZLENBQUUsRUFBRyxDQUFFcmMsS0FBS3NjLEtBQUssSUFBSSxFQUFHO2dCQUMzQ0MsUUFBUUYsWUFBWSxDQUFFLEVBQUc7Z0JBQ3pCRyxZQUFZSCxZQUFZLENBQUUsRUFBRztnQkFDN0JJLFNBQVNKLFlBQVksQ0FBRSxFQUFHO2dCQUMxQnRiLE9BQU9mLEtBQUtlLEtBQUs7Z0JBQ2pCRyxRQUFRQTtnQkFDUnVZLFVBQVUsQ0FBQztZQUNaO1lBRUFILCtCQUFnQ3JaLFlBQVk0TyxRQUFRN087WUFFcERzSCx1QkFBd0J1SCxRQUFRN087WUFFaEMsT0FBT3lDLFFBQVFzRyxHQUFHLENBQUU3SCxPQUFPK2EsVUFBVSxDQUFFLFNBQVdDLEdBQUc7Z0JBRXBELE9BQU9BLElBQUlRLFNBQVMsSUFBSVIsSUFBSVEsU0FBUyxDQUFFN047WUFFeEMsSUFBTWhILElBQUksQ0FBRTtnQkFFWHZLLE9BQVF1UjtZQUVUO1FBRUQsR0FBSThOLEtBQUssQ0FBRW5mO0lBRVo7SUFFQTs7RUFFQyxHQUNENkgsWUFBWTtRQUVYLE1BQU1DLFdBQVcsSUFBSSxDQUFDdEYsSUFBSSxDQUFDdUYsS0FBSyxJQUFJLEVBQUU7UUFDdEMsTUFBTXFYLFdBQVcsSUFBSSxDQUFDNWMsSUFBSSxDQUFDNmMsS0FBSyxJQUFJLEVBQUU7UUFDdEMsTUFBTUMsV0FBVyxJQUFJLENBQUM5YyxJQUFJLENBQUNrUCxNQUFNLElBQUksRUFBRTtRQUV2QyxzRUFBc0U7UUFDdEUsMkRBQTJEO1FBQzNELElBQU0sSUFBSTZOLFlBQVksR0FBR0MsYUFBYUosU0FBU3JiLE1BQU0sRUFBRXdiLFlBQVlDLFlBQVlELFlBQWU7WUFFN0YsTUFBTUUsU0FBU0wsUUFBUSxDQUFFRyxVQUFXLENBQUNFLE1BQU07WUFFM0MsSUFBTSxJQUFJM2IsSUFBSSxHQUFHOFksS0FBSzZDLE9BQU8xYixNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztnQkFFbkRnRSxRQUFRLENBQUUyWCxNQUFNLENBQUUzYixFQUFHLENBQUUsQ0FBQzRiLE1BQU0sR0FBRztZQUVsQztRQUVEO1FBRUEsa0VBQWtFO1FBQ2xFLDhCQUE4QjtRQUM5QixJQUFNLElBQUkxWCxZQUFZLEdBQUdDLGFBQWFILFNBQVMvRCxNQUFNLEVBQUVpRSxZQUFZQyxZQUFZRCxZQUFlO1lBRTdGLE1BQU1FLFVBQVVKLFFBQVEsQ0FBRUUsVUFBVztZQUVyQyxJQUFLRSxRQUFRc0osSUFBSSxLQUFLaE8sV0FBWTtnQkFFakMsSUFBSSxDQUFDNEUsV0FBVyxDQUFFLElBQUksQ0FBQ3VYLFNBQVMsRUFBRXpYLFFBQVFzSixJQUFJO2dCQUU5Qyx5REFBeUQ7Z0JBQ3pELHVEQUF1RDtnQkFDdkQsd0NBQXdDO2dCQUN4QyxJQUFLdEosUUFBUTBYLElBQUksS0FBS3BjLFdBQVk7b0JBRWpDOGIsUUFBUSxDQUFFcFgsUUFBUXNKLElBQUksQ0FBRSxDQUFDcU8sYUFBYSxHQUFHO2dCQUUxQztZQUVEO1lBRUEsSUFBSzNYLFFBQVE0WCxNQUFNLEtBQUt0YyxXQUFZO2dCQUVuQyxJQUFJLENBQUM0RSxXQUFXLENBQUUsSUFBSSxDQUFDMlgsV0FBVyxFQUFFN1gsUUFBUTRYLE1BQU07WUFFbkQ7UUFFRDtJQUVEO0lBRUE7Ozs7Ozs7O0VBUUMsR0FDRDFYLFlBQWFDLEtBQUssRUFBRTZCLEtBQUssRUFBRztRQUUzQixJQUFLQSxVQUFVMUcsV0FBWTtRQUUzQixJQUFLNkUsTUFBTWtDLElBQUksQ0FBRUwsTUFBTyxLQUFLMUcsV0FBWTtZQUV4QzZFLE1BQU1rQyxJQUFJLENBQUVMLE1BQU8sR0FBRzdCLE1BQU1tQyxJQUFJLENBQUVOLE1BQU8sR0FBRztRQUU3QztRQUVBN0IsTUFBTWtDLElBQUksQ0FBRUwsTUFBTztJQUVwQjtJQUVBLHVFQUF1RSxHQUN2RUksWUFBYWpDLEtBQUssRUFBRTZCLEtBQUssRUFBRXhELE1BQU0sRUFBRztRQUVuQyxJQUFLMkIsTUFBTWtDLElBQUksQ0FBRUwsTUFBTyxJQUFJLEdBQUksT0FBT3hEO1FBRXZDLE1BQU1zWixNQUFNdFosT0FBTzhQLEtBQUs7UUFFeEIscUVBQXFFO1FBQ3JFLG1DQUFtQztRQUNuQyxNQUFNeUosaUJBQWlCLENBQUVDLFVBQVUxSjtZQUVsQyxNQUFNMkosV0FBVyxJQUFJLENBQUNDLFlBQVksQ0FBQzdaLEdBQUcsQ0FBRTJaO1lBQ3hDLElBQUtDLFlBQVksTUFBTztnQkFFdkIsSUFBSSxDQUFDQyxZQUFZLENBQUNoWCxHQUFHLENBQUVvTixPQUFPMko7WUFFL0I7WUFFQSxLQUFNLE1BQU0sQ0FBRXJjLEdBQUd1YyxNQUFPLElBQUlILFNBQVMxTixRQUFRLENBQUM4TixPQUFPLEdBQUs7Z0JBRXpETCxlQUFnQkksT0FBTzdKLE1BQU1oRSxRQUFRLENBQUUxTyxFQUFHO1lBRTNDO1FBRUQ7UUFFQW1jLGVBQWdCdlosUUFBUXNaO1FBRXhCQSxJQUFJL2IsSUFBSSxJQUFJLGVBQWlCb0UsTUFBTW1DLElBQUksQ0FBRU4sTUFBTztRQUVoRCxPQUFPOFY7SUFFUjtJQUVBTyxXQUFZQyxJQUFJLEVBQUc7UUFFbEIsTUFBTS9kLGFBQWE0WixPQUFPdEYsTUFBTSxDQUFFLElBQUksQ0FBQ3JVLE9BQU87UUFDOUNELFdBQVdKLElBQUksQ0FBRSxJQUFJO1FBRXJCLElBQU0sSUFBSXlCLElBQUksR0FBR0EsSUFBSXJCLFdBQVdzQixNQUFNLEVBQUVELElBQU87WUFFOUMsTUFBTXVOLFNBQVNtUCxLQUFNL2QsVUFBVSxDQUFFcUIsRUFBRztZQUVwQyxJQUFLdU4sUUFBUyxPQUFPQTtRQUV0QjtRQUVBLE9BQU87SUFFUjtJQUVBb04sV0FBWStCLElBQUksRUFBRztRQUVsQixNQUFNL2QsYUFBYTRaLE9BQU90RixNQUFNLENBQUUsSUFBSSxDQUFDclUsT0FBTztRQUM5Q0QsV0FBV2dlLE9BQU8sQ0FBRSxJQUFJO1FBRXhCLE1BQU01VixVQUFVLEVBQUU7UUFFbEIsSUFBTSxJQUFJL0csSUFBSSxHQUFHQSxJQUFJckIsV0FBV3NCLE1BQU0sRUFBRUQsSUFBTztZQUU5QyxNQUFNdU4sU0FBU21QLEtBQU0vZCxVQUFVLENBQUVxQixFQUFHO1lBRXBDLElBQUt1TixRQUFTeEcsUUFBUXhJLElBQUksQ0FBRWdQO1FBRTdCO1FBRUEsT0FBT3hHO0lBRVI7SUFFQTs7Ozs7RUFLQyxHQUNEWixjQUFlaEIsSUFBSSxFQUFFaUIsS0FBSyxFQUFHO1FBRTVCLE1BQU0xQixXQUFXUyxPQUFPLE1BQU1pQjtRQUM5QixJQUFJekIsYUFBYSxJQUFJLENBQUNKLEtBQUssQ0FBQzlCLEdBQUcsQ0FBRWlDO1FBRWpDLElBQUssQ0FBRUMsWUFBYTtZQUVuQixPQUFTUTtnQkFFUixLQUFLO29CQUNKUixhQUFhLElBQUksQ0FBQ2lZLFNBQVMsQ0FBRXhXO29CQUM3QjtnQkFFRCxLQUFLO29CQUNKekIsYUFBYSxJQUFJLENBQUM4WCxVQUFVLENBQUUsU0FBVzdCLEdBQUc7d0JBRTNDLE9BQU9BLElBQUlpQyxRQUFRLElBQUlqQyxJQUFJaUMsUUFBUSxDQUFFelc7b0JBRXRDO29CQUNBO2dCQUVELEtBQUs7b0JBQ0p6QixhQUFhLElBQUksQ0FBQzhYLFVBQVUsQ0FBRSxTQUFXN0IsR0FBRzt3QkFFM0MsT0FBT0EsSUFBSWtDLFFBQVEsSUFBSWxDLElBQUlrQyxRQUFRLENBQUUxVztvQkFFdEM7b0JBQ0E7Z0JBRUQsS0FBSztvQkFDSnpCLGFBQWEsSUFBSSxDQUFDb1ksWUFBWSxDQUFFM1c7b0JBQ2hDO2dCQUVELEtBQUs7b0JBQ0p6QixhQUFhLElBQUksQ0FBQzhYLFVBQVUsQ0FBRSxTQUFXN0IsR0FBRzt3QkFFM0MsT0FBT0EsSUFBSXRPLGNBQWMsSUFBSXNPLElBQUl0TyxjQUFjLENBQUVsRztvQkFFbEQ7b0JBQ0E7Z0JBRUQsS0FBSztvQkFDSnpCLGFBQWEsSUFBSSxDQUFDcVksVUFBVSxDQUFFNVc7b0JBQzlCO2dCQUVELEtBQUs7b0JBQ0p6QixhQUFhLElBQUksQ0FBQzhYLFVBQVUsQ0FBRSxTQUFXN0IsR0FBRzt3QkFFM0MsT0FBT0EsSUFBSXFDLFlBQVksSUFBSXJDLElBQUlxQyxZQUFZLENBQUU3VztvQkFFOUM7b0JBQ0E7Z0JBRUQsS0FBSztvQkFDSnpCLGFBQWEsSUFBSSxDQUFDOFgsVUFBVSxDQUFFLFNBQVc3QixHQUFHO3dCQUUzQyxPQUFPQSxJQUFJMVAsV0FBVyxJQUFJMFAsSUFBSTFQLFdBQVcsQ0FBRTlFO29CQUU1QztvQkFDQTtnQkFFRCxLQUFLO29CQUNKekIsYUFBYSxJQUFJLENBQUN1WSxRQUFRLENBQUU5VztvQkFDNUI7Z0JBRUQsS0FBSztvQkFDSnpCLGFBQWEsSUFBSSxDQUFDOFgsVUFBVSxDQUFFLFNBQVc3QixHQUFHO3dCQUUzQyxPQUFPQSxJQUFJdUMsYUFBYSxJQUFJdkMsSUFBSXVDLGFBQWEsQ0FBRS9XO29CQUVoRDtvQkFDQTtnQkFFRCxLQUFLO29CQUNKekIsYUFBYSxJQUFJLENBQUN5WSxVQUFVLENBQUVoWDtvQkFDOUI7Z0JBRUQ7b0JBQ0N6QixhQUFhLElBQUksQ0FBQzhYLFVBQVUsQ0FBRSxTQUFXN0IsR0FBRzt3QkFFM0MsT0FBT0EsT0FBTyxJQUFJLElBQUlBLElBQUl6VSxhQUFhLElBQUl5VSxJQUFJelUsYUFBYSxDQUFFaEIsTUFBTWlCO29CQUVyRTtvQkFFQSxJQUFLLENBQUV6QixZQUFhO3dCQUVuQixNQUFNLElBQUk3RyxNQUFPLG1CQUFtQnFIO29CQUVyQztvQkFFQTtZQUVGO1lBRUEsSUFBSSxDQUFDWixLQUFLLENBQUM1QixHQUFHLENBQUUrQixVQUFVQztRQUUzQjtRQUVBLE9BQU9BO0lBRVI7SUFFQTs7OztFQUlDLEdBQ0RtVyxnQkFBaUIzVixJQUFJLEVBQUc7UUFFdkIsSUFBSTRWLGVBQWUsSUFBSSxDQUFDeFcsS0FBSyxDQUFDOUIsR0FBRyxDQUFFMEM7UUFFbkMsSUFBSyxDQUFFNFYsY0FBZTtZQUVyQixNQUFNbmIsU0FBUyxJQUFJO1lBQ25CLE1BQU15ZCxPQUFPLElBQUksQ0FBQzNlLElBQUksQ0FBRXlHLE9BQVNBLENBQUFBLFNBQVMsU0FBUyxPQUFPLEdBQUUsRUFBSyxJQUFJLEVBQUU7WUFFdkU0VixlQUFlNVosUUFBUXNHLEdBQUcsQ0FBRTRWLEtBQUtDLEdBQUcsQ0FBRSxTQUFXQyxHQUFHLEVBQUVuWCxLQUFLO2dCQUUxRCxPQUFPeEcsT0FBT3VHLGFBQWEsQ0FBRWhCLE1BQU1pQjtZQUVwQztZQUVBLElBQUksQ0FBQzdCLEtBQUssQ0FBQzVCLEdBQUcsQ0FBRXdDLE1BQU00VjtRQUV2QjtRQUVBLE9BQU9BO0lBRVI7SUFFQTs7OztFQUlDLEdBQ0RpQyxXQUFZUSxXQUFXLEVBQUc7UUFFekIsTUFBTUMsWUFBWSxJQUFJLENBQUMvZSxJQUFJLENBQUNnZixPQUFPLENBQUVGLFlBQWE7UUFDbEQsTUFBTXZnQixTQUFTLElBQUksQ0FBQzhDLFVBQVU7UUFFOUIsSUFBSzBkLFVBQVV0WSxJQUFJLElBQUlzWSxVQUFVdFksSUFBSSxLQUFLLGVBQWdCO1lBRXpELE1BQU0sSUFBSXJILE1BQU8sdUJBQXVCMmYsVUFBVXRZLElBQUksR0FBRztRQUUxRDtRQUVBLGdFQUFnRTtRQUNoRSxJQUFLc1ksVUFBVTlSLEdBQUcsS0FBS2pNLGFBQWE4ZCxnQkFBZ0IsR0FBSTtZQUV2RCxPQUFPcmMsUUFBUUMsT0FBTyxDQUFFLElBQUksQ0FBQ3pDLFVBQVUsQ0FBRVUsV0FBV0MsZUFBZSxDQUFFLENBQUNpUixJQUFJO1FBRTNFO1FBRUEsTUFBTWpGLFVBQVUsSUFBSSxDQUFDQSxPQUFPO1FBRTVCLE9BQU8sSUFBSW5LLFFBQVMsU0FBV0MsT0FBTyxFQUFFQyxNQUFNO1lBRTdDcEUsT0FBT25CLElBQUksQ0FBRXRDLDhDQUFXQSxDQUFDZ0QsVUFBVSxDQUFFaWhCLFVBQVU5UixHQUFHLEVBQUVMLFFBQVFqUCxJQUFJLEdBQUkrRSxTQUFTMUIsV0FBVztnQkFFdkYyQixPQUFRLElBQUl2RCxNQUFPLDhDQUE4QzJmLFVBQVU5UixHQUFHLEdBQUc7WUFFbEY7UUFFRDtJQUVEO0lBRUE7Ozs7RUFJQyxHQUNEVyxlQUFnQjhFLGVBQWUsRUFBRztRQUVqQyxNQUFNdU0sZ0JBQWdCLElBQUksQ0FBQ2pmLElBQUksQ0FBQzhOLFdBQVcsQ0FBRTRFLGdCQUFpQjtRQUU5RCxPQUFPLElBQUksQ0FBQ2pMLGFBQWEsQ0FBRSxVQUFVd1gsY0FBY2pSLE1BQU0sRUFBR25HLElBQUksQ0FBRSxTQUFXbUcsTUFBTTtZQUVsRixNQUFNSyxhQUFhNFEsY0FBYzVRLFVBQVUsSUFBSTtZQUMvQyxNQUFNRCxhQUFhNlEsY0FBYzdRLFVBQVUsSUFBSTtZQUMvQyxPQUFPSixPQUFPaUUsS0FBSyxDQUFFN0QsWUFBWUEsYUFBYUM7UUFFL0M7SUFFRDtJQUVBOzs7O0VBSUMsR0FDRGdRLGFBQWNhLGFBQWEsRUFBRztRQUU3QixNQUFNaGUsU0FBUyxJQUFJO1FBQ25CLE1BQU1sQixPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUV0QixNQUFNa1QsY0FBYyxJQUFJLENBQUNsVCxJQUFJLENBQUNtVCxTQUFTLENBQUUrTCxjQUFlO1FBRXhELElBQUtoTSxZQUFZckYsVUFBVSxLQUFLN00sYUFBYWtTLFlBQVlpTSxNQUFNLEtBQUtuZSxXQUFZO1lBRS9FLE1BQU1rUSxXQUFXd0csZ0JBQWdCLENBQUV4RSxZQUFZek0sSUFBSSxDQUFFO1lBQ3JELE1BQU0yWSxhQUFhL0wscUJBQXFCLENBQUVILFlBQVlFLGFBQWEsQ0FBRTtZQUNyRSxNQUFNakMsYUFBYStCLFlBQVkvQixVQUFVLEtBQUs7WUFFOUMsTUFBTXZJLFFBQVEsSUFBSXdXLFdBQVlsTSxZQUFZNUUsS0FBSyxHQUFHNEM7WUFDbEQsT0FBT3pPLFFBQVFDLE9BQU8sQ0FBRSxJQUFJdEosa0RBQWVBLENBQUV3UCxPQUFPc0ksVUFBVUM7UUFFL0Q7UUFFQSxNQUFNa08scUJBQXFCLEVBQUU7UUFFN0IsSUFBS25NLFlBQVlyRixVQUFVLEtBQUs3TSxXQUFZO1lBRTNDcWUsbUJBQW1CeGYsSUFBSSxDQUFFLElBQUksQ0FBQzRILGFBQWEsQ0FBRSxjQUFjeUwsWUFBWXJGLFVBQVU7UUFFbEYsT0FBTztZQUVOd1IsbUJBQW1CeGYsSUFBSSxDQUFFO1FBRTFCO1FBRUEsSUFBS3FULFlBQVlpTSxNQUFNLEtBQUtuZSxXQUFZO1lBRXZDcWUsbUJBQW1CeGYsSUFBSSxDQUFFLElBQUksQ0FBQzRILGFBQWEsQ0FBRSxjQUFjeUwsWUFBWWlNLE1BQU0sQ0FBQzVELE9BQU8sQ0FBQzFOLFVBQVU7WUFDaEd3UixtQkFBbUJ4ZixJQUFJLENBQUUsSUFBSSxDQUFDNEgsYUFBYSxDQUFFLGNBQWN5TCxZQUFZaU0sTUFBTSxDQUFDNUssTUFBTSxDQUFDMUcsVUFBVTtRQUVoRztRQUVBLE9BQU9wTCxRQUFRc0csR0FBRyxDQUFFc1csb0JBQXFCeFgsSUFBSSxDQUFFLFNBQVdpRyxXQUFXO1lBRXBFLE1BQU1ELGFBQWFDLFdBQVcsQ0FBRSxFQUFHO1lBRW5DLE1BQU1vRCxXQUFXd0csZ0JBQWdCLENBQUV4RSxZQUFZek0sSUFBSSxDQUFFO1lBQ3JELE1BQU0yWSxhQUFhL0wscUJBQXFCLENBQUVILFlBQVlFLGFBQWEsQ0FBRTtZQUVyRSwrREFBK0Q7WUFDL0QsTUFBTWtNLGVBQWVGLFdBQVdHLGlCQUFpQjtZQUNqRCxNQUFNQyxZQUFZRixlQUFlcE87WUFDakMsTUFBTTlDLGFBQWE4RSxZQUFZOUUsVUFBVSxJQUFJO1lBQzdDLE1BQU1JLGFBQWEwRSxZQUFZckYsVUFBVSxLQUFLN00sWUFBWWhCLEtBQUs4TixXQUFXLENBQUVvRixZQUFZckYsVUFBVSxDQUFFLENBQUNXLFVBQVUsR0FBR3hOO1lBQ2xILE1BQU1tUSxhQUFhK0IsWUFBWS9CLFVBQVUsS0FBSztZQUM5QyxJQUFJdkksT0FBTzZXO1lBRVgseUVBQXlFO1lBQ3pFLElBQUtqUixjQUFjQSxlQUFlZ1IsV0FBWTtnQkFFN0MsbUhBQW1IO2dCQUNuSCxrRUFBa0U7Z0JBQ2xFLE1BQU1FLFVBQVV6WSxLQUFLMFksS0FBSyxDQUFFdlIsYUFBYUk7Z0JBQ3pDLE1BQU1vUixhQUFhLHVCQUF1QjFNLFlBQVlyRixVQUFVLEdBQUcsTUFBTXFGLFlBQVlFLGFBQWEsR0FBRyxNQUFNc00sVUFBVSxNQUFNeE0sWUFBWTVFLEtBQUs7Z0JBQzVJLElBQUl1UixLQUFLM2UsT0FBTzJFLEtBQUssQ0FBQzlCLEdBQUcsQ0FBRTZiO2dCQUUzQixJQUFLLENBQUVDLElBQUs7b0JBRVhqWCxRQUFRLElBQUl3VyxXQUFZdlIsWUFBWTZSLFVBQVVsUixZQUFZMEUsWUFBWTVFLEtBQUssR0FBR0UsYUFBYThRO29CQUUzRixpRUFBaUU7b0JBQ2pFTyxLQUFLLElBQUk3bEIsb0RBQWlCQSxDQUFFNE8sT0FBTzRGLGFBQWE4UTtvQkFFaERwZSxPQUFPMkUsS0FBSyxDQUFDNUIsR0FBRyxDQUFFMmIsWUFBWUM7Z0JBRS9CO2dCQUVBSixrQkFBa0IsSUFBSXhsQiw2REFBMEJBLENBQUU0bEIsSUFBSTNPLFVBQVUsYUFBZTFDLGFBQWU4USxjQUFjbk87WUFFN0csT0FBTztnQkFFTixJQUFLdEQsZUFBZSxNQUFPO29CQUUxQmpGLFFBQVEsSUFBSXdXLFdBQVlsTSxZQUFZNUUsS0FBSyxHQUFHNEM7Z0JBRTdDLE9BQU87b0JBRU50SSxRQUFRLElBQUl3VyxXQUFZdlIsWUFBWU8sWUFBWThFLFlBQVk1RSxLQUFLLEdBQUc0QztnQkFFckU7Z0JBRUF1TyxrQkFBa0IsSUFBSXJtQixrREFBZUEsQ0FBRXdQLE9BQU9zSSxVQUFVQztZQUV6RDtZQUVBLGdHQUFnRztZQUNoRyxJQUFLK0IsWUFBWWlNLE1BQU0sS0FBS25lLFdBQVk7Z0JBRXZDLE1BQU04ZSxrQkFBa0JwSSxpQkFBaUJxSSxNQUFNO2dCQUMvQyxNQUFNQyxvQkFBb0IzTSxxQkFBcUIsQ0FBRUgsWUFBWWlNLE1BQU0sQ0FBQzVELE9BQU8sQ0FBQ25JLGFBQWEsQ0FBRTtnQkFFM0YsTUFBTTZNLG9CQUFvQi9NLFlBQVlpTSxNQUFNLENBQUM1RCxPQUFPLENBQUNuTixVQUFVLElBQUk7Z0JBQ25FLE1BQU04UixtQkFBbUJoTixZQUFZaU0sTUFBTSxDQUFDNUssTUFBTSxDQUFDbkcsVUFBVSxJQUFJO2dCQUVqRSxNQUFNK1IsZ0JBQWdCLElBQUlILGtCQUFtQmxTLFdBQVcsQ0FBRSxFQUFHLEVBQUVtUyxtQkFBbUIvTSxZQUFZaU0sTUFBTSxDQUFDN1EsS0FBSyxHQUFHd1I7Z0JBQzdHLE1BQU1NLGVBQWUsSUFBSWhCLFdBQVl0UixXQUFXLENBQUUsRUFBRyxFQUFFb1Msa0JBQWtCaE4sWUFBWWlNLE1BQU0sQ0FBQzdRLEtBQUssR0FBRzRDO2dCQUVwRyxJQUFLckQsZUFBZSxNQUFPO29CQUUxQiw4RkFBOEY7b0JBQzlGNFIsa0JBQWtCLElBQUlybUIsa0RBQWVBLENBQUVxbUIsZ0JBQWdCN1csS0FBSyxDQUFDcUosS0FBSyxJQUFJd04sZ0JBQWdCdk8sUUFBUSxFQUFFdU8sZ0JBQWdCdE8sVUFBVTtnQkFFM0g7Z0JBRUEsSUFBTSxJQUFJN1AsSUFBSSxHQUFHOFksS0FBSytGLGNBQWM1ZSxNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztvQkFFMUQsTUFBTW9HLFFBQVF5WSxhQUFhLENBQUU3ZSxFQUFHO29CQUVoQ21lLGdCQUFnQlksSUFBSSxDQUFFM1ksT0FBTzBZLFlBQVksQ0FBRTllLElBQUk0UCxTQUFVO29CQUN6RCxJQUFLQSxZQUFZLEdBQUl1TyxnQkFBZ0JhLElBQUksQ0FBRTVZLE9BQU8wWSxZQUFZLENBQUU5ZSxJQUFJNFAsV0FBVyxFQUFHO29CQUNsRixJQUFLQSxZQUFZLEdBQUl1TyxnQkFBZ0JjLElBQUksQ0FBRTdZLE9BQU8wWSxZQUFZLENBQUU5ZSxJQUFJNFAsV0FBVyxFQUFHO29CQUNsRixJQUFLQSxZQUFZLEdBQUl1TyxnQkFBZ0JlLElBQUksQ0FBRTlZLE9BQU8wWSxZQUFZLENBQUU5ZSxJQUFJNFAsV0FBVyxFQUFHO29CQUNsRixJQUFLQSxZQUFZLEdBQUksTUFBTSxJQUFJOVIsTUFBTztnQkFFdkM7WUFFRDtZQUVBLE9BQU9xZ0I7UUFFUjtJQUVEO0lBRUE7Ozs7RUFJQyxHQUNEalQsWUFBYUMsWUFBWSxFQUFHO1FBRTNCLE1BQU16TSxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNNE0sVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsTUFBTUYsYUFBYTFNLEtBQUsyTSxRQUFRLENBQUVGLGFBQWM7UUFDaEQsTUFBTWdVLGNBQWMvVCxXQUFXSSxNQUFNO1FBQ3JDLE1BQU00VCxZQUFZMWdCLEtBQUsrTSxNQUFNLENBQUUwVCxZQUFhO1FBRTVDLElBQUlsaUIsU0FBUyxJQUFJLENBQUN5TyxhQUFhO1FBRS9CLElBQUswVCxVQUFVelQsR0FBRyxFQUFHO1lBRXBCLE1BQU1DLFVBQVVOLFFBQVE3TyxPQUFPLENBQUNvUCxVQUFVLENBQUV1VCxVQUFVelQsR0FBRztZQUN6RCxJQUFLQyxZQUFZLE1BQU8zTyxTQUFTMk87UUFFbEM7UUFFQSxPQUFPLElBQUksQ0FBQ0wsZ0JBQWdCLENBQUVKLGNBQWNnVSxhQUFhbGlCO0lBRTFEO0lBRUFzTyxpQkFBa0JKLFlBQVksRUFBRWdVLFdBQVcsRUFBRWxpQixNQUFNLEVBQUc7UUFFckQsTUFBTTJDLFNBQVMsSUFBSTtRQUNuQixNQUFNbEIsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFFdEIsTUFBTTBNLGFBQWExTSxLQUFLMk0sUUFBUSxDQUFFRixhQUFjO1FBQ2hELE1BQU1pVSxZQUFZMWdCLEtBQUsrTSxNQUFNLENBQUUwVCxZQUFhO1FBRTVDLE1BQU16YSxXQUFXLENBQUUwYSxVQUFVelQsR0FBRyxJQUFJeVQsVUFBVTdTLFVBQVUsSUFBSyxNQUFNbkIsV0FBV2lVLE9BQU87UUFFckYsSUFBSyxJQUFJLENBQUNDLFlBQVksQ0FBRTVhLFNBQVUsRUFBRztZQUVwQyx1REFBdUQ7WUFDdkQsT0FBTyxJQUFJLENBQUM0YSxZQUFZLENBQUU1YSxTQUFVO1FBRXJDO1FBRUEsTUFBTTZhLFVBQVUsSUFBSSxDQUFDQyxlQUFlLENBQUVMLGFBQWFsaUIsUUFBU3NKLElBQUksQ0FBRSxTQUFXNkwsT0FBTztZQUVuRkEsUUFBUXFOLEtBQUssR0FBRztZQUVoQnJOLFFBQVFqUyxJQUFJLEdBQUdpTCxXQUFXakwsSUFBSSxJQUFJaWYsVUFBVWpmLElBQUksSUFBSTtZQUVwRCxJQUFLaVMsUUFBUWpTLElBQUksS0FBSyxNQUFNLE9BQU9pZixVQUFVelQsR0FBRyxLQUFLLFlBQVl5VCxVQUFVelQsR0FBRyxDQUFDK1QsVUFBVSxDQUFFLG1CQUFvQixPQUFRO2dCQUV0SHROLFFBQVFqUyxJQUFJLEdBQUdpZixVQUFVelQsR0FBRztZQUU3QjtZQUVBLE1BQU1nVSxXQUFXamhCLEtBQUtpaEIsUUFBUSxJQUFJLENBQUM7WUFDbkMsTUFBTU4sVUFBVU0sUUFBUSxDQUFFdlUsV0FBV2lVLE9BQU8sQ0FBRSxJQUFJLENBQUM7WUFFbkRqTixRQUFRd04sU0FBUyxHQUFHMUosYUFBYSxDQUFFbUosUUFBUU8sU0FBUyxDQUFFLElBQUl6bUIsK0NBQVlBO1lBQ3RFaVosUUFBUXlOLFNBQVMsR0FBRzNKLGFBQWEsQ0FBRW1KLFFBQVFRLFNBQVMsQ0FBRSxJQUFJem1CLDJEQUF3QkE7WUFDbEZnWixRQUFRME4sS0FBSyxHQUFHM0osZUFBZSxDQUFFa0osUUFBUVMsS0FBSyxDQUFFLElBQUlobEIsaURBQWNBO1lBQ2xFc1gsUUFBUTJOLEtBQUssR0FBRzVKLGVBQWUsQ0FBRWtKLFFBQVFVLEtBQUssQ0FBRSxJQUFJamxCLGlEQUFjQTtZQUVsRThFLE9BQU8wYyxZQUFZLENBQUNoWCxHQUFHLENBQUU4TSxTQUFTO2dCQUFFL0csVUFBVUY7WUFBYTtZQUUzRCxPQUFPaUg7UUFFUixHQUFJaUosS0FBSyxDQUFFO1lBRVYsT0FBTztRQUVSO1FBRUEsSUFBSSxDQUFDaUUsWUFBWSxDQUFFNWEsU0FBVSxHQUFHNmE7UUFFaEMsT0FBT0E7SUFFUjtJQUVBQyxnQkFBaUJMLFdBQVcsRUFBRWxpQixNQUFNLEVBQUc7UUFFdEMsTUFBTTJDLFNBQVMsSUFBSTtRQUNuQixNQUFNbEIsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTTRNLFVBQVUsSUFBSSxDQUFDQSxPQUFPO1FBRTVCLElBQUssSUFBSSxDQUFDMFUsV0FBVyxDQUFFYixZQUFhLEtBQUt6ZixXQUFZO1lBRXBELE9BQU8sSUFBSSxDQUFDc2dCLFdBQVcsQ0FBRWIsWUFBYSxDQUFDNVksSUFBSSxDQUFFLENBQUU2TCxVQUFhQSxRQUFRTSxLQUFLO1FBRTFFO1FBRUEsTUFBTTBNLFlBQVkxZ0IsS0FBSytNLE1BQU0sQ0FBRTBULFlBQWE7UUFFNUMsTUFBTWMsTUFBTTNaLEtBQUsyWixHQUFHLElBQUkzWixLQUFLNFosU0FBUztRQUV0QyxJQUFJQyxZQUFZZixVQUFVelQsR0FBRyxJQUFJO1FBQ2pDLElBQUl5VSxjQUFjO1FBRWxCLElBQUtoQixVQUFVN1MsVUFBVSxLQUFLN00sV0FBWTtZQUV6Qyx1REFBdUQ7WUFFdkR5Z0IsWUFBWXZnQixPQUFPdUcsYUFBYSxDQUFFLGNBQWNpWixVQUFVN1MsVUFBVSxFQUFHaEcsSUFBSSxDQUFFLFNBQVdnRyxVQUFVO2dCQUVqRzZULGNBQWM7Z0JBQ2QsTUFBTUMsT0FBTyxJQUFJQyxLQUFNO29CQUFFL1Q7aUJBQVksRUFBRTtvQkFBRXBILE1BQU1pYSxVQUFVbUIsUUFBUTtnQkFBQztnQkFDbEVKLFlBQVlGLElBQUlPLGVBQWUsQ0FBRUg7Z0JBQ2pDLE9BQU9GO1lBRVI7UUFFRCxPQUFPLElBQUtmLFVBQVV6VCxHQUFHLEtBQUtqTSxXQUFZO1lBRXpDLE1BQU0sSUFBSTVCLE1BQU8sNkJBQTZCcWhCLGNBQWM7UUFFN0Q7UUFFQSxNQUFNSSxVQUFVcGUsUUFBUUMsT0FBTyxDQUFFK2UsV0FBWTVaLElBQUksQ0FBRSxTQUFXNFosU0FBUztZQUV0RSxPQUFPLElBQUloZixRQUFTLFNBQVdDLE9BQU8sRUFBRUMsTUFBTTtnQkFFN0MsSUFBSXJGLFNBQVNvRjtnQkFFYixJQUFLbkUsT0FBT3dqQixtQkFBbUIsS0FBSyxNQUFPO29CQUUxQ3prQixTQUFTLFNBQVcwa0IsV0FBVzt3QkFFOUIsTUFBTXRPLFVBQVUsSUFBSWpYLDBDQUFPQSxDQUFFdWxCO3dCQUM3QnRPLFFBQVFTLFdBQVcsR0FBRzt3QkFFdEJ6UixRQUFTZ1I7b0JBRVY7Z0JBRUQ7Z0JBRUFuVixPQUFPbkIsSUFBSSxDQUFFdEMsOENBQVdBLENBQUNnRCxVQUFVLENBQUUyakIsV0FBVzdVLFFBQVFqUCxJQUFJLEdBQUlMLFFBQVEwRCxXQUFXMkI7WUFFcEY7UUFFRCxHQUFJa0YsSUFBSSxDQUFFLFNBQVc2TCxPQUFPO1lBRTNCLDRDQUE0QztZQUU1QyxJQUFLZ08sZ0JBQWdCLE1BQU87Z0JBRTNCSCxJQUFJVSxlQUFlLENBQUVSO1lBRXRCO1lBRUEvTixRQUFRK0YsUUFBUSxDQUFDb0ksUUFBUSxHQUFHbkIsVUFBVW1CLFFBQVEsSUFBSWhHLG9CQUFxQjZFLFVBQVV6VCxHQUFHO1lBRXBGLE9BQU95RztRQUVSLEdBQUlpSixLQUFLLENBQUUsU0FBV3ZlLEtBQUs7WUFFMUJELFFBQVFDLEtBQUssQ0FBRSwyQ0FBNENxakI7WUFDM0QsTUFBTXJqQjtRQUVQO1FBRUEsSUFBSSxDQUFDa2pCLFdBQVcsQ0FBRWIsWUFBYSxHQUFHSTtRQUNsQyxPQUFPQTtJQUVSO0lBRUE7Ozs7OztFQU1DLEdBQ0QvWCxjQUFlWCxjQUFjLEVBQUUrWixPQUFPLEVBQUVDLE1BQU0sRUFBRUMsVUFBVSxFQUFHO1FBRTVELE1BQU1saEIsU0FBUyxJQUFJO1FBRW5CLE9BQU8sSUFBSSxDQUFDdUcsYUFBYSxDQUFFLFdBQVcwYSxPQUFPemEsS0FBSyxFQUFHRyxJQUFJLENBQUUsU0FBVzZMLE9BQU87WUFFNUUsSUFBSyxDQUFFQSxTQUFVLE9BQU87WUFFeEIsSUFBS3lPLE9BQU92TyxRQUFRLEtBQUs1UyxhQUFhbWhCLE9BQU92TyxRQUFRLEdBQUcsR0FBSTtnQkFFM0RGLFVBQVVBLFFBQVFNLEtBQUs7Z0JBQ3ZCTixRQUFRRyxPQUFPLEdBQUdzTyxPQUFPdk8sUUFBUTtZQUVsQztZQUVBLElBQUsxUyxPQUFPakIsVUFBVSxDQUFFVSxXQUFXc0IscUJBQXFCLENBQUUsRUFBRztnQkFFNUQsTUFBTTBSLFlBQVl3TyxPQUFPbGlCLFVBQVUsS0FBS2UsWUFBWW1oQixPQUFPbGlCLFVBQVUsQ0FBRVUsV0FBV3NCLHFCQUFxQixDQUFFLEdBQUdqQjtnQkFFNUcsSUFBSzJTLFdBQVk7b0JBRWhCLE1BQU0wTyxnQkFBZ0JuaEIsT0FBTzBjLFlBQVksQ0FBQzdaLEdBQUcsQ0FBRTJQO29CQUMvQ0EsVUFBVXhTLE9BQU9qQixVQUFVLENBQUVVLFdBQVdzQixxQkFBcUIsQ0FBRSxDQUFDd1IsYUFBYSxDQUFFQyxTQUFTQztvQkFDeEZ6UyxPQUFPMGMsWUFBWSxDQUFDaFgsR0FBRyxDQUFFOE0sU0FBUzJPO2dCQUVuQztZQUVEO1lBRUEsSUFBS0QsZUFBZXBoQixXQUFZO2dCQUUvQjBTLFFBQVEwTyxVQUFVLEdBQUdBO1lBRXRCO1lBRUFqYSxjQUFjLENBQUUrWixRQUFTLEdBQUd4TztZQUU1QixPQUFPQTtRQUVSO0lBRUQ7SUFFQTs7Ozs7OztFQU9DLEdBQ0RsQyxvQkFBcUJ4QyxJQUFJLEVBQUc7UUFFM0IsTUFBTXVCLFdBQVd2QixLQUFLdUIsUUFBUTtRQUM5QixJQUFJQyxXQUFXeEIsS0FBS3dCLFFBQVE7UUFFNUIsTUFBTThSLHdCQUF3Qi9SLFNBQVNiLFVBQVUsQ0FBQzZTLE9BQU8sS0FBS3ZoQjtRQUM5RCxNQUFNd2hCLGtCQUFrQmpTLFNBQVNiLFVBQVUsQ0FBQ3BKLEtBQUssS0FBS3RGO1FBQ3RELE1BQU15aEIsaUJBQWlCbFMsU0FBU2IsVUFBVSxDQUFDK0ssTUFBTSxLQUFLelo7UUFFdEQsSUFBS2dPLEtBQUswVCxRQUFRLEVBQUc7WUFFcEIsTUFBTTFjLFdBQVcsb0JBQW9Cd0ssU0FBU21TLElBQUk7WUFFbEQsSUFBSUMsaUJBQWlCLElBQUksQ0FBQy9jLEtBQUssQ0FBQzlCLEdBQUcsQ0FBRWlDO1lBRXJDLElBQUssQ0FBRTRjLGdCQUFpQjtnQkFFdkJBLGlCQUFpQixJQUFJNW1CLGlEQUFjQTtnQkFDbkNqQiwyQ0FBUUEsQ0FBQ3NXLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLENBQUVxUixnQkFBZ0JwUztnQkFDOUNvUyxlQUFldGMsS0FBSyxDQUFDZ0wsSUFBSSxDQUFFZCxTQUFTbEssS0FBSztnQkFDekNzYyxlQUFlaEUsR0FBRyxHQUFHcE8sU0FBU29PLEdBQUc7Z0JBQ2pDZ0UsZUFBZUMsZUFBZSxHQUFHLE9BQU8sc0NBQXNDO2dCQUU5RSxJQUFJLENBQUNoZCxLQUFLLENBQUM1QixHQUFHLENBQUUrQixVQUFVNGM7WUFFM0I7WUFFQXBTLFdBQVdvUztRQUVaLE9BQU8sSUFBSzVULEtBQUs4VCxNQUFNLEVBQUc7WUFFekIsTUFBTTljLFdBQVcsdUJBQXVCd0ssU0FBU21TLElBQUk7WUFFckQsSUFBSUksZUFBZSxJQUFJLENBQUNsZCxLQUFLLENBQUM5QixHQUFHLENBQUVpQztZQUVuQyxJQUFLLENBQUUrYyxjQUFlO2dCQUVyQkEsZUFBZSxJQUFJem9CLG9EQUFpQkE7Z0JBQ3BDUywyQ0FBUUEsQ0FBQ3NXLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLENBQUV3UixjQUFjdlM7Z0JBQzVDdVMsYUFBYXpjLEtBQUssQ0FBQ2dMLElBQUksQ0FBRWQsU0FBU2xLLEtBQUs7Z0JBQ3ZDeWMsYUFBYW5FLEdBQUcsR0FBR3BPLFNBQVNvTyxHQUFHO2dCQUUvQixJQUFJLENBQUMvWSxLQUFLLENBQUM1QixHQUFHLENBQUUrQixVQUFVK2M7WUFFM0I7WUFFQXZTLFdBQVd1UztRQUVaO1FBRUEsNENBQTRDO1FBQzVDLElBQUtULHlCQUF5QkUsbUJBQW1CQyxnQkFBaUI7WUFFakUsSUFBSXpjLFdBQVcsb0JBQW9Cd0ssU0FBU21TLElBQUksR0FBRztZQUVuRCxJQUFLTCx1QkFBd0J0YyxZQUFZO1lBQ3pDLElBQUt3YyxpQkFBa0J4YyxZQUFZO1lBQ25DLElBQUt5YyxnQkFBaUJ6YyxZQUFZO1lBRWxDLElBQUlnZCxpQkFBaUIsSUFBSSxDQUFDbmQsS0FBSyxDQUFDOUIsR0FBRyxDQUFFaUM7WUFFckMsSUFBSyxDQUFFZ2QsZ0JBQWlCO2dCQUV2QkEsaUJBQWlCeFMsU0FBU3dELEtBQUs7Z0JBRS9CLElBQUt3TyxpQkFBa0JRLGVBQWVDLFlBQVksR0FBRztnQkFDckQsSUFBS1IsZ0JBQWlCTyxlQUFlRSxXQUFXLEdBQUc7Z0JBRW5ELElBQUtaLHVCQUF3QjtvQkFFNUIseUVBQXlFO29CQUN6RSxJQUFLVSxlQUFlRyxXQUFXLEVBQUdILGVBQWVHLFdBQVcsQ0FBQ0MsQ0FBQyxJQUFJLENBQUU7b0JBQ3BFLElBQUtKLGVBQWVsWixvQkFBb0IsRUFBR2taLGVBQWVsWixvQkFBb0IsQ0FBQ3NaLENBQUMsSUFBSSxDQUFFO2dCQUV2RjtnQkFFQSxJQUFJLENBQUN2ZCxLQUFLLENBQUM1QixHQUFHLENBQUUrQixVQUFVZ2Q7Z0JBRTFCLElBQUksQ0FBQ3BGLFlBQVksQ0FBQ2hYLEdBQUcsQ0FBRW9jLGdCQUFnQixJQUFJLENBQUNwRixZQUFZLENBQUM3WixHQUFHLENBQUV5TTtZQUUvRDtZQUVBQSxXQUFXd1M7UUFFWjtRQUVBaFUsS0FBS3dCLFFBQVEsR0FBR0E7SUFFakI7SUFFQXZJLGtCQUF1QztRQUV0QyxPQUFPNU0sdURBQW9CQTtJQUU1QjtJQUVBOzs7O0VBSUMsR0FDRGtqQixhQUFjdFYsYUFBYSxFQUFHO1FBRTdCLE1BQU0vSCxTQUFTLElBQUk7UUFDbkIsTUFBTWxCLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3RCLE1BQU1DLGFBQWEsSUFBSSxDQUFDQSxVQUFVO1FBQ2xDLE1BQU1tSSxjQUFjcEksS0FBS2tKLFNBQVMsQ0FBRUQsY0FBZTtRQUVuRCxJQUFJb2E7UUFDSixNQUFNbGIsaUJBQWlCLENBQUM7UUFDeEIsTUFBTW1iLHFCQUFxQmxiLFlBQVluSSxVQUFVLElBQUksQ0FBQztRQUV0RCxNQUFNb0ksVUFBVSxFQUFFO1FBRWxCLElBQUtpYixrQkFBa0IsQ0FBRTNpQixXQUFXa0IsbUJBQW1CLENBQUUsRUFBRztZQUUzRCxNQUFNMGhCLGVBQWV0akIsVUFBVSxDQUFFVSxXQUFXa0IsbUJBQW1CLENBQUU7WUFDakV3aEIsZUFBZUUsYUFBYXRiLGVBQWU7WUFDM0NJLFFBQVF4SSxJQUFJLENBQUUwakIsYUFBYXJiLFlBQVksQ0FBRUMsZ0JBQWdCQyxhQUFhbEg7UUFFdkUsT0FBTztZQUVOLGlCQUFpQjtZQUNqQixpR0FBaUc7WUFFakcsTUFBTXFILG9CQUFvQkgsWUFBWUksb0JBQW9CLElBQUksQ0FBQztZQUUvREwsZUFBZTdCLEtBQUssR0FBRyxJQUFJL00sd0NBQUtBLENBQUUsS0FBSyxLQUFLO1lBQzVDNE8sZUFBZUcsT0FBTyxHQUFHO1lBRXpCLElBQUtHLE1BQU1DLE9BQU8sQ0FBRUgsa0JBQWtCSSxlQUFlLEdBQUs7Z0JBRXpELE1BQU1DLFFBQVFMLGtCQUFrQkksZUFBZTtnQkFFL0NSLGVBQWU3QixLQUFLLENBQUNDLE1BQU0sQ0FBRXFDLEtBQUssQ0FBRSxFQUFHLEVBQUVBLEtBQUssQ0FBRSxFQUFHLEVBQUVBLEtBQUssQ0FBRSxFQUFHLEVBQUVoTyx1REFBb0JBO2dCQUNyRnVOLGVBQWVHLE9BQU8sR0FBR00sS0FBSyxDQUFFLEVBQUc7WUFFcEM7WUFFQSxJQUFLTCxrQkFBa0JNLGdCQUFnQixLQUFLN0gsV0FBWTtnQkFFdkRxSCxRQUFReEksSUFBSSxDQUFFcUIsT0FBTzRILGFBQWEsQ0FBRVgsZ0JBQWdCLE9BQU9JLGtCQUFrQk0sZ0JBQWdCLEVBQUU3TCxpREFBY0E7WUFFOUc7WUFFQW1MLGVBQWU4USxTQUFTLEdBQUcxUSxrQkFBa0JpYixjQUFjLEtBQUt4aUIsWUFBWXVILGtCQUFrQmliLGNBQWMsR0FBRztZQUMvR3JiLGVBQWUrUSxTQUFTLEdBQUczUSxrQkFBa0JrYixlQUFlLEtBQUt6aUIsWUFBWXVILGtCQUFrQmtiLGVBQWUsR0FBRztZQUVqSCxJQUFLbGIsa0JBQWtCbWIsd0JBQXdCLEtBQUsxaUIsV0FBWTtnQkFFL0RxSCxRQUFReEksSUFBSSxDQUFFcUIsT0FBTzRILGFBQWEsQ0FBRVgsZ0JBQWdCLGdCQUFnQkksa0JBQWtCbWIsd0JBQXdCO2dCQUM5R3JiLFFBQVF4SSxJQUFJLENBQUVxQixPQUFPNEgsYUFBYSxDQUFFWCxnQkFBZ0IsZ0JBQWdCSSxrQkFBa0JtYix3QkFBd0I7WUFFL0c7WUFFQUwsZUFBZSxJQUFJLENBQUN0RixVQUFVLENBQUUsU0FBVzdCLEdBQUc7Z0JBRTdDLE9BQU9BLElBQUlqVSxlQUFlLElBQUlpVSxJQUFJalUsZUFBZSxDQUFFZ0I7WUFFcEQ7WUFFQVosUUFBUXhJLElBQUksQ0FBRTRDLFFBQVFzRyxHQUFHLENBQUUsSUFBSSxDQUFDa1QsVUFBVSxDQUFFLFNBQVdDLEdBQUc7Z0JBRXpELE9BQU9BLElBQUlsVCxvQkFBb0IsSUFBSWtULElBQUlsVCxvQkFBb0IsQ0FBRUMsZUFBZWQ7WUFFN0U7UUFFRDtRQUVBLElBQUtDLFlBQVl1YixXQUFXLEtBQUssTUFBTztZQUV2Q3hiLGVBQWVrUixJQUFJLEdBQUczZiw2Q0FBVUE7UUFFakM7UUFFQSxNQUFNa3FCLFlBQVl4YixZQUFZd2IsU0FBUyxJQUFJakwsWUFBWUMsTUFBTTtRQUU3RCxJQUFLZ0wsY0FBY2pMLFlBQVlHLEtBQUssRUFBRztZQUV0QzNRLGVBQWVnUixXQUFXLEdBQUc7WUFFN0IsdURBQXVEO1lBQ3ZEaFIsZUFBZTBiLFVBQVUsR0FBRztRQUU3QixPQUFPO1lBRU4xYixlQUFlZ1IsV0FBVyxHQUFHO1lBRTdCLElBQUt5SyxjQUFjakwsWUFBWUUsSUFBSSxFQUFHO2dCQUVyQzFRLGVBQWUyYixTQUFTLEdBQUcxYixZQUFZMmIsV0FBVyxLQUFLL2lCLFlBQVlvSCxZQUFZMmIsV0FBVyxHQUFHO1lBRTlGO1FBRUQ7UUFFQSxJQUFLM2IsWUFBWTRiLGFBQWEsS0FBS2hqQixhQUFhcWlCLGlCQUFpQmxvQixvREFBaUJBLEVBQUc7WUFFcEZrTixRQUFReEksSUFBSSxDQUFFcUIsT0FBTzRILGFBQWEsQ0FBRVgsZ0JBQWdCLGFBQWFDLFlBQVk0YixhQUFhO1lBRTFGN2IsZUFBZWdiLFdBQVcsR0FBRyxJQUFJdG1CLDBDQUFPQSxDQUFFLEdBQUc7WUFFN0MsSUFBS3VMLFlBQVk0YixhQUFhLENBQUNuYSxLQUFLLEtBQUs3SSxXQUFZO2dCQUVwRCxNQUFNNkksUUFBUXpCLFlBQVk0YixhQUFhLENBQUNuYSxLQUFLO2dCQUU3QzFCLGVBQWVnYixXQUFXLENBQUN2YyxHQUFHLENBQUVpRCxPQUFPQTtZQUV4QztRQUVEO1FBRUEsSUFBS3pCLFlBQVk2YixnQkFBZ0IsS0FBS2pqQixhQUFhcWlCLGlCQUFpQmxvQixvREFBaUJBLEVBQUc7WUFFdkZrTixRQUFReEksSUFBSSxDQUFFcUIsT0FBTzRILGFBQWEsQ0FBRVgsZ0JBQWdCLFNBQVNDLFlBQVk2YixnQkFBZ0I7WUFFekYsSUFBSzdiLFlBQVk2YixnQkFBZ0IsQ0FBQ0MsUUFBUSxLQUFLbGpCLFdBQVk7Z0JBRTFEbUgsZUFBZWdjLGNBQWMsR0FBRy9iLFlBQVk2YixnQkFBZ0IsQ0FBQ0MsUUFBUTtZQUV0RTtRQUVEO1FBRUEsSUFBSzliLFlBQVlnYyxjQUFjLEtBQUtwakIsYUFBYXFpQixpQkFBaUJsb0Isb0RBQWlCQSxFQUFHO1lBRXJGLE1BQU1pcEIsaUJBQWlCaGMsWUFBWWdjLGNBQWM7WUFDakRqYyxlQUFlNlEsUUFBUSxHQUFHLElBQUl6Zix3Q0FBS0EsR0FBR2dOLE1BQU0sQ0FBRTZkLGNBQWMsQ0FBRSxFQUFHLEVBQUVBLGNBQWMsQ0FBRSxFQUFHLEVBQUVBLGNBQWMsQ0FBRSxFQUFHLEVBQUV4cEIsdURBQW9CQTtRQUVsSTtRQUVBLElBQUt3TixZQUFZaWMsZUFBZSxLQUFLcmpCLGFBQWFxaUIsaUJBQWlCbG9CLG9EQUFpQkEsRUFBRztZQUV0RmtOLFFBQVF4SSxJQUFJLENBQUVxQixPQUFPNEgsYUFBYSxDQUFFWCxnQkFBZ0IsZUFBZUMsWUFBWWljLGVBQWUsRUFBRXJuQixpREFBY0E7UUFFL0c7UUFFQSxPQUFPeUYsUUFBUXNHLEdBQUcsQ0FBRVYsU0FBVVIsSUFBSSxDQUFFO1lBRW5DLE1BQU0ySSxXQUFXLElBQUk2UyxhQUFjbGI7WUFFbkMsSUFBS0MsWUFBWTNHLElBQUksRUFBRytPLFNBQVMvTyxJQUFJLEdBQUcyRyxZQUFZM0csSUFBSTtZQUV4RDZGLHVCQUF3QmtKLFVBQVVwSTtZQUVsQ2xILE9BQU8wYyxZQUFZLENBQUNoWCxHQUFHLENBQUU0SixVQUFVO2dCQUFFdEgsV0FBV0Q7WUFBYztZQUU5RCxJQUFLYixZQUFZbkksVUFBVSxFQUFHcVosK0JBQWdDclosWUFBWXVRLFVBQVVwSTtZQUVwRixPQUFPb0k7UUFFUjtJQUVEO0lBRUEsK0VBQStFLEdBQy9FaEosaUJBQWtCOGMsWUFBWSxFQUFHO1FBRWhDLE1BQU1DLGdCQUFnQnRvQixrREFBZUEsQ0FBQ3VvQixnQkFBZ0IsQ0FBRUYsZ0JBQWdCO1FBRXhFLElBQUtDLGlCQUFpQixJQUFJLENBQUNFLGFBQWEsRUFBRztZQUUxQyxPQUFPRixnQkFBZ0IsTUFBUSxFQUFHLElBQUksQ0FBQ0UsYUFBYSxDQUFFRixjQUFlO1FBRXRFLE9BQU87WUFFTixJQUFJLENBQUNFLGFBQWEsQ0FBRUYsY0FBZSxHQUFHO1lBRXRDLE9BQU9BO1FBRVI7SUFFRDtJQUVBOzs7Ozs7O0VBT0MsR0FDREcsZUFBZ0J0VixVQUFVLEVBQUc7UUFFNUIsTUFBTWxPLFNBQVMsSUFBSTtRQUNuQixNQUFNakIsYUFBYSxJQUFJLENBQUNBLFVBQVU7UUFDbEMsTUFBTTRGLFFBQVEsSUFBSSxDQUFDOGUsY0FBYztRQUVqQyxTQUFTQyxxQkFBc0J6VixTQUFTO1lBRXZDLE9BQU9sUCxVQUFVLENBQUVVLFdBQVdvQiwwQkFBMEIsQ0FBRSxDQUN4RDBRLGVBQWUsQ0FBRXRELFdBQVdqTyxRQUM1QjJHLElBQUksQ0FBRSxTQUFXMEksUUFBUTtnQkFFekIsT0FBT3NVLHVCQUF3QnRVLFVBQVVwQixXQUFXak87WUFFckQ7UUFFRjtRQUVBLE1BQU1tSCxVQUFVLEVBQUU7UUFFbEIsSUFBTSxJQUFJL0csSUFBSSxHQUFHOFksS0FBS2hMLFdBQVc3TixNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztZQUV2RCxNQUFNNk4sWUFBWUMsVUFBVSxDQUFFOU4sRUFBRztZQUNqQyxNQUFNMEUsV0FBV21WLG1CQUFvQmhNO1lBRXJDLDZDQUE2QztZQUM3QyxNQUFNMlYsU0FBU2pmLEtBQUssQ0FBRUcsU0FBVTtZQUVoQyxJQUFLOGUsUUFBUztnQkFFYix1Q0FBdUM7Z0JBQ3ZDemMsUUFBUXhJLElBQUksQ0FBRWlsQixPQUFPakUsT0FBTztZQUU3QixPQUFPO2dCQUVOLElBQUlrRTtnQkFFSixJQUFLNVYsVUFBVWxQLFVBQVUsSUFBSWtQLFVBQVVsUCxVQUFVLENBQUVVLFdBQVdvQiwwQkFBMEIsQ0FBRSxFQUFHO29CQUU1RixrQ0FBa0M7b0JBQ2xDZ2pCLGtCQUFrQkgscUJBQXNCelY7Z0JBRXpDLE9BQU87b0JBRU4sa0NBQWtDO29CQUNsQzRWLGtCQUFrQkYsdUJBQXdCLElBQUl4ckIsaURBQWNBLElBQUk4VixXQUFXak87Z0JBRTVFO2dCQUVBLHNCQUFzQjtnQkFDdEIyRSxLQUFLLENBQUVHLFNBQVUsR0FBRztvQkFBRW1KLFdBQVdBO29CQUFXMFIsU0FBU2tFO2dCQUFnQjtnQkFFckUxYyxRQUFReEksSUFBSSxDQUFFa2xCO1lBRWY7UUFFRDtRQUVBLE9BQU90aUIsUUFBUXNHLEdBQUcsQ0FBRVY7SUFFckI7SUFFQTs7OztFQUlDLEdBQ0QrVixTQUFVNEcsU0FBUyxFQUFHO1FBRXJCLE1BQU05akIsU0FBUyxJQUFJO1FBQ25CLE1BQU1sQixPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNQyxhQUFhLElBQUksQ0FBQ0EsVUFBVTtRQUVsQyxNQUFNZ1AsVUFBVWpQLEtBQUtrUCxNQUFNLENBQUU4VixVQUFXO1FBQ3hDLE1BQU01VixhQUFhSCxRQUFRRyxVQUFVO1FBRXJDLE1BQU0vRyxVQUFVLEVBQUU7UUFFbEIsSUFBTSxJQUFJL0csSUFBSSxHQUFHOFksS0FBS2hMLFdBQVc3TixNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztZQUV2RCxNQUFNa1AsV0FBV3BCLFVBQVUsQ0FBRTlOLEVBQUcsQ0FBQ2tQLFFBQVEsS0FBS3hQLFlBQzNDK1gsc0JBQXVCLElBQUksQ0FBQ2xULEtBQUssSUFDakMsSUFBSSxDQUFDNEIsYUFBYSxDQUFFLFlBQVkySCxVQUFVLENBQUU5TixFQUFHLENBQUNrUCxRQUFRO1lBRTNEbkksUUFBUXhJLElBQUksQ0FBRTJRO1FBRWY7UUFFQW5JLFFBQVF4SSxJQUFJLENBQUVxQixPQUFPd2pCLGNBQWMsQ0FBRXRWO1FBRXJDLE9BQU8zTSxRQUFRc0csR0FBRyxDQUFFVixTQUFVUixJQUFJLENBQUUsU0FBVytILE9BQU87WUFFckQsTUFBTTFHLFlBQVkwRyxRQUFRcUMsS0FBSyxDQUFFLEdBQUdyQyxRQUFRck8sTUFBTSxHQUFHO1lBQ3JELE1BQU0wakIsYUFBYXJWLE9BQU8sQ0FBRUEsUUFBUXJPLE1BQU0sR0FBRyxFQUFHO1lBRWhELE1BQU0yTixTQUFTLEVBQUU7WUFFakIsSUFBTSxJQUFJNU4sSUFBSSxHQUFHOFksS0FBSzZLLFdBQVcxakIsTUFBTSxFQUFFRCxJQUFJOFksSUFBSTlZLElBQU87Z0JBRXZELE1BQU1pUCxXQUFXMFUsVUFBVSxDQUFFM2pCLEVBQUc7Z0JBQ2hDLE1BQU02TixZQUFZQyxVQUFVLENBQUU5TixFQUFHO2dCQUVqQyxpQkFBaUI7Z0JBRWpCLElBQUkwTjtnQkFFSixNQUFNd0IsV0FBV3RILFNBQVMsQ0FBRTVILEVBQUc7Z0JBRS9CLElBQUs2TixVQUFVVCxJQUFJLEtBQUtXLGdCQUFnQkMsU0FBUyxJQUMvQ0gsVUFBVVQsSUFBSSxLQUFLVyxnQkFBZ0JFLGNBQWMsSUFDakRKLFVBQVVULElBQUksS0FBS1csZ0JBQWdCRyxZQUFZLElBQy9DTCxVQUFVVCxJQUFJLEtBQUsxTixXQUFZO29CQUVoQyxzREFBc0Q7b0JBQ3REZ08sT0FBT0MsUUFBUW9PLGFBQWEsS0FBSyxPQUM5QixJQUFJL2dCLDhDQUFXQSxDQUFFaVUsVUFBVUMsWUFDM0IsSUFBSXRWLHVDQUFJQSxDQUFFcVYsVUFBVUM7b0JBRXZCLElBQUt4QixLQUFLcU8sYUFBYSxLQUFLLE1BQU87d0JBRWxDLDhEQUE4RDt3QkFDOURyTyxLQUFLa1csb0JBQW9CO29CQUUxQjtvQkFFQSxJQUFLL1YsVUFBVVQsSUFBSSxLQUFLVyxnQkFBZ0JFLGNBQWMsRUFBRzt3QkFFeERQLEtBQUt1QixRQUFRLEdBQUdyVCxrRkFBbUJBLENBQUU4UixLQUFLdUIsUUFBUSxFQUFFM1Qsd0RBQXFCQTtvQkFFMUUsT0FBTyxJQUFLdVMsVUFBVVQsSUFBSSxLQUFLVyxnQkFBZ0JHLFlBQVksRUFBRzt3QkFFN0RSLEtBQUt1QixRQUFRLEdBQUdyVCxrRkFBbUJBLENBQUU4UixLQUFLdUIsUUFBUSxFQUFFNVQsc0RBQW1CQTtvQkFFeEU7Z0JBRUQsT0FBTyxJQUFLd1MsVUFBVVQsSUFBSSxLQUFLVyxnQkFBZ0J5SCxLQUFLLEVBQUc7b0JBRXREOUgsT0FBTyxJQUFJeFUsK0NBQVlBLENBQUUrVixVQUFVQztnQkFFcEMsT0FBTyxJQUFLckIsVUFBVVQsSUFBSSxLQUFLVyxnQkFBZ0IySCxVQUFVLEVBQUc7b0JBRTNEaEksT0FBTyxJQUFJM1UsdUNBQUlBLENBQUVrVyxVQUFVQztnQkFFNUIsT0FBTyxJQUFLckIsVUFBVVQsSUFBSSxLQUFLVyxnQkFBZ0IwSCxTQUFTLEVBQUc7b0JBRTFEL0gsT0FBTyxJQUFJelUsMkNBQVFBLENBQUVnVyxVQUFVQztnQkFFaEMsT0FBTyxJQUFLckIsVUFBVVQsSUFBSSxLQUFLVyxnQkFBZ0J3SCxNQUFNLEVBQUc7b0JBRXZEN0gsT0FBTyxJQUFJalQseUNBQU1BLENBQUV3VSxVQUFVQztnQkFFOUIsT0FBTztvQkFFTixNQUFNLElBQUlwUixNQUFPLG1EQUFtRCtQLFVBQVVULElBQUk7Z0JBRW5GO2dCQUVBLElBQUttTCxPQUFPNkIsSUFBSSxDQUFFMU0sS0FBS3VCLFFBQVEsQ0FBQ3NLLGVBQWUsRUFBR3RaLE1BQU0sR0FBRyxHQUFJO29CQUU5RHdaLG1CQUFvQi9MLE1BQU1DO2dCQUUzQjtnQkFFQUQsS0FBS3ZOLElBQUksR0FBR1AsT0FBT3NHLGdCQUFnQixDQUFFeUgsUUFBUXhOLElBQUksSUFBTSxVQUFVdWpCO2dCQUVqRTFkLHVCQUF3QjBILE1BQU1DO2dCQUU5QixJQUFLRSxVQUFVbFAsVUFBVSxFQUFHcVosK0JBQWdDclosWUFBWStPLE1BQU1HO2dCQUU5RWpPLE9BQU9zUSxtQkFBbUIsQ0FBRXhDO2dCQUU1QkUsT0FBT3JQLElBQUksQ0FBRW1QO1lBRWQ7WUFFQSxJQUFNLElBQUkxTixJQUFJLEdBQUc4WSxLQUFLbEwsT0FBTzNOLE1BQU0sRUFBRUQsSUFBSThZLElBQUk5WSxJQUFPO2dCQUVuREosT0FBTzBjLFlBQVksQ0FBQ2hYLEdBQUcsQ0FBRXNJLE1BQU0sQ0FBRTVOLEVBQUcsRUFBRTtvQkFDckM0TixRQUFROFY7b0JBQ1I1VixZQUFZOU47Z0JBQ2I7WUFFRDtZQUVBLElBQUs0TixPQUFPM04sTUFBTSxLQUFLLEdBQUk7Z0JBRTFCLElBQUswTixRQUFRaFAsVUFBVSxFQUFHcVosK0JBQWdDclosWUFBWWlQLE1BQU0sQ0FBRSxFQUFHLEVBQUVEO2dCQUVuRixPQUFPQyxNQUFNLENBQUUsRUFBRztZQUVuQjtZQUVBLE1BQU1pVyxRQUFRLElBQUl0ckIsd0NBQUtBO1lBRXZCLElBQUtvVixRQUFRaFAsVUFBVSxFQUFHcVosK0JBQWdDclosWUFBWWtsQixPQUFPbFc7WUFFN0UvTixPQUFPMGMsWUFBWSxDQUFDaFgsR0FBRyxDQUFFdWUsT0FBTztnQkFBRWpXLFFBQVE4VjtZQUFVO1lBRXBELElBQU0sSUFBSTFqQixJQUFJLEdBQUc4WSxLQUFLbEwsT0FBTzNOLE1BQU0sRUFBRUQsSUFBSThZLElBQUk5WSxJQUFPO2dCQUVuRDZqQixNQUFNbGhCLEdBQUcsQ0FBRWlMLE1BQU0sQ0FBRTVOLEVBQUc7WUFFdkI7WUFFQSxPQUFPNmpCO1FBRVI7SUFFRDtJQUVBOzs7O0VBSUMsR0FDRHpHLFdBQVkwRyxXQUFXLEVBQUc7UUFFekIsSUFBSTlIO1FBQ0osTUFBTStILFlBQVksSUFBSSxDQUFDcmxCLElBQUksQ0FBQ3ljLE9BQU8sQ0FBRTJJLFlBQWE7UUFDbEQsTUFBTUUsU0FBU0QsU0FBUyxDQUFFQSxVQUFVNWUsSUFBSSxDQUFFO1FBRTFDLElBQUssQ0FBRTZlLFFBQVM7WUFFZm5uQixRQUFRa0UsSUFBSSxDQUFFO1lBQ2Q7UUFFRDtRQUVBLElBQUtnakIsVUFBVTVlLElBQUksS0FBSyxlQUFnQjtZQUV2QzZXLFNBQVMsSUFBSXpoQixvREFBaUJBLENBQUViLDRDQUFTQSxDQUFDdXFCLFFBQVEsQ0FBRUQsT0FBT0UsSUFBSSxHQUFJRixPQUFPRyxXQUFXLElBQUksR0FBR0gsT0FBT0ksS0FBSyxJQUFJLEdBQUdKLE9BQU9LLElBQUksSUFBSTtRQUUvSCxPQUFPLElBQUtOLFVBQVU1ZSxJQUFJLEtBQUssZ0JBQWlCO1lBRS9DNlcsU0FBUyxJQUFJMWhCLHFEQUFrQkEsQ0FBRSxDQUFFMHBCLE9BQU9NLElBQUksRUFBRU4sT0FBT00sSUFBSSxFQUFFTixPQUFPTyxJQUFJLEVBQUUsQ0FBRVAsT0FBT08sSUFBSSxFQUFFUCxPQUFPSSxLQUFLLEVBQUVKLE9BQU9LLElBQUk7UUFFbkg7UUFFQSxJQUFLTixVQUFVNWpCLElBQUksRUFBRzZiLE9BQU83YixJQUFJLEdBQUcsSUFBSSxDQUFDK0YsZ0JBQWdCLENBQUU2ZCxVQUFVNWpCLElBQUk7UUFFekU2Rix1QkFBd0JnVyxRQUFRK0g7UUFFaEMsT0FBTzVpQixRQUFRQyxPQUFPLENBQUU0YTtJQUV6QjtJQUVBOzs7O0VBSUMsR0FDRGtCLFNBQVV6QixTQUFTLEVBQUc7UUFFckIsTUFBTStJLFVBQVUsSUFBSSxDQUFDOWxCLElBQUksQ0FBQzZjLEtBQUssQ0FBRUUsVUFBVztRQUU1QyxNQUFNMVUsVUFBVSxFQUFFO1FBRWxCLElBQU0sSUFBSS9HLElBQUksR0FBRzhZLEtBQUswTCxRQUFRN0ksTUFBTSxDQUFDMWIsTUFBTSxFQUFFRCxJQUFJOFksSUFBSTlZLElBQU87WUFFM0QrRyxRQUFReEksSUFBSSxDQUFFLElBQUksQ0FBQ2ttQixnQkFBZ0IsQ0FBRUQsUUFBUTdJLE1BQU0sQ0FBRTNiLEVBQUc7UUFFekQ7UUFFQSxJQUFLd2tCLFFBQVFFLG1CQUFtQixLQUFLaGxCLFdBQVk7WUFFaERxSCxRQUFReEksSUFBSSxDQUFFLElBQUksQ0FBQzRILGFBQWEsQ0FBRSxZQUFZcWUsUUFBUUUsbUJBQW1CO1FBRTFFLE9BQU87WUFFTjNkLFFBQVF4SSxJQUFJLENBQUU7UUFFZjtRQUVBLE9BQU80QyxRQUFRc0csR0FBRyxDQUFFVixTQUFVUixJQUFJLENBQUUsU0FBVytILE9BQU87WUFFckQsTUFBTW9XLHNCQUFzQnBXLFFBQVFFLEdBQUc7WUFDdkMsTUFBTW1XLGFBQWFyVztZQUVuQix5REFBeUQ7WUFDekQsNEJBQTRCO1lBRTVCLE1BQU1zVyxRQUFRLEVBQUU7WUFDaEIsTUFBTUMsZUFBZSxFQUFFO1lBRXZCLElBQU0sSUFBSTdrQixJQUFJLEdBQUc4WSxLQUFLNkwsV0FBVzFrQixNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztnQkFFdkQsTUFBTThrQixZQUFZSCxVQUFVLENBQUUza0IsRUFBRztnQkFFakMsSUFBSzhrQixXQUFZO29CQUVoQkYsTUFBTXJtQixJQUFJLENBQUV1bUI7b0JBRVosTUFBTUMsTUFBTSxJQUFJcHJCLDBDQUFPQTtvQkFFdkIsSUFBSytxQix3QkFBd0IsTUFBTzt3QkFFbkNLLElBQUlwUyxTQUFTLENBQUUrUixvQkFBb0JwZCxLQUFLLEVBQUV0SCxJQUFJO29CQUUvQztvQkFFQTZrQixhQUFhdG1CLElBQUksQ0FBRXdtQjtnQkFFcEIsT0FBTztvQkFFTmxvQixRQUFRa0UsSUFBSSxDQUFFLG9EQUFvRHlqQixRQUFRN0ksTUFBTSxDQUFFM2IsRUFBRztnQkFFdEY7WUFFRDtZQUVBLE9BQU8sSUFBSWpGLDJDQUFRQSxDQUFFNnBCLE9BQU9DO1FBRTdCO0lBRUQ7SUFFQTs7OztFQUlDLEdBQ0QxSCxjQUFlNkgsY0FBYyxFQUFHO1FBRS9CLE1BQU10bUIsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTWtCLFNBQVMsSUFBSTtRQUVuQixNQUFNcWxCLGVBQWV2bUIsS0FBS3djLFVBQVUsQ0FBRThKLGVBQWdCO1FBQ3RELE1BQU1FLGdCQUFnQkQsYUFBYTlrQixJQUFJLEdBQUc4a0IsYUFBYTlrQixJQUFJLEdBQUcsZUFBZTZrQjtRQUU3RSxNQUFNRyxlQUFlLEVBQUU7UUFDdkIsTUFBTUMsd0JBQXdCLEVBQUU7UUFDaEMsTUFBTUMseUJBQXlCLEVBQUU7UUFDakMsTUFBTUMsa0JBQWtCLEVBQUU7UUFDMUIsTUFBTUMsaUJBQWlCLEVBQUU7UUFFekIsSUFBTSxJQUFJdmxCLElBQUksR0FBRzhZLEtBQUttTSxhQUFhTyxRQUFRLENBQUN2bEIsTUFBTSxFQUFFRCxJQUFJOFksSUFBSTlZLElBQU87WUFFbEUsTUFBTXVTLFVBQVUwUyxhQUFhTyxRQUFRLENBQUV4bEIsRUFBRztZQUMxQyxNQUFNcWYsVUFBVTRGLGFBQWF0RixRQUFRLENBQUVwTixRQUFROE0sT0FBTyxDQUFFO1lBQ3hELE1BQU1qYSxTQUFTbU4sUUFBUW5OLE1BQU07WUFDN0IsTUFBTWpGLE9BQU9pRixPQUFPcWdCLElBQUk7WUFDeEIsTUFBTUMsUUFBUVQsYUFBYVUsVUFBVSxLQUFLam1CLFlBQVl1bEIsYUFBYVUsVUFBVSxDQUFFdEcsUUFBUXFHLEtBQUssQ0FBRSxHQUFHckcsUUFBUXFHLEtBQUs7WUFDOUcsTUFBTUUsU0FBU1gsYUFBYVUsVUFBVSxLQUFLam1CLFlBQVl1bEIsYUFBYVUsVUFBVSxDQUFFdEcsUUFBUXVHLE1BQU0sQ0FBRSxHQUFHdkcsUUFBUXVHLE1BQU07WUFFakgsSUFBS3hnQixPQUFPcWdCLElBQUksS0FBSy9sQixXQUFZO1lBRWpDeWxCLGFBQWE1bUIsSUFBSSxDQUFFLElBQUksQ0FBQzRILGFBQWEsQ0FBRSxRQUFRaEc7WUFDL0NpbEIsc0JBQXNCN21CLElBQUksQ0FBRSxJQUFJLENBQUM0SCxhQUFhLENBQUUsWUFBWXVmO1lBQzVETCx1QkFBdUI5bUIsSUFBSSxDQUFFLElBQUksQ0FBQzRILGFBQWEsQ0FBRSxZQUFZeWY7WUFDN0ROLGdCQUFnQi9tQixJQUFJLENBQUU4Z0I7WUFDdEJrRyxlQUFlaG5CLElBQUksQ0FBRTZHO1FBRXRCO1FBRUEsT0FBT2pFLFFBQVFzRyxHQUFHLENBQUU7WUFFbkJ0RyxRQUFRc0csR0FBRyxDQUFFMGQ7WUFDYmhrQixRQUFRc0csR0FBRyxDQUFFMmQ7WUFDYmprQixRQUFRc0csR0FBRyxDQUFFNGQ7WUFDYmxrQixRQUFRc0csR0FBRyxDQUFFNmQ7WUFDYm5rQixRQUFRc0csR0FBRyxDQUFFOGQ7U0FFYixFQUFHaGYsSUFBSSxDQUFFLFNBQVd3VSxZQUFZO1lBRWhDLE1BQU05VyxRQUFROFcsWUFBWSxDQUFFLEVBQUc7WUFDL0IsTUFBTThLLGlCQUFpQjlLLFlBQVksQ0FBRSxFQUFHO1lBQ3hDLE1BQU0rSyxrQkFBa0IvSyxZQUFZLENBQUUsRUFBRztZQUN6QyxNQUFNNEUsV0FBVzVFLFlBQVksQ0FBRSxFQUFHO1lBQ2xDLE1BQU1yQyxVQUFVcUMsWUFBWSxDQUFFLEVBQUc7WUFFakMsTUFBTWdMLFNBQVMsRUFBRTtZQUVqQixJQUFNLElBQUkvbEIsSUFBSSxHQUFHOFksS0FBSzdVLE1BQU1oRSxNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztnQkFFbEQsTUFBTXlsQixPQUFPeGhCLEtBQUssQ0FBRWpFLEVBQUc7Z0JBQ3ZCLE1BQU1nbUIsZ0JBQWdCSCxjQUFjLENBQUU3bEIsRUFBRztnQkFDekMsTUFBTWltQixpQkFBaUJILGVBQWUsQ0FBRTlsQixFQUFHO2dCQUMzQyxNQUFNcWYsVUFBVU0sUUFBUSxDQUFFM2YsRUFBRztnQkFDN0IsTUFBTW9GLFNBQVNzVCxPQUFPLENBQUUxWSxFQUFHO2dCQUUzQixJQUFLeWxCLFNBQVMvbEIsV0FBWTtnQkFFMUIsSUFBSytsQixLQUFLUyxZQUFZLEVBQUc7b0JBRXhCVCxLQUFLUyxZQUFZO2dCQUVsQjtnQkFFQSxNQUFNQyxnQkFBZ0J2bUIsT0FBT3dtQixzQkFBc0IsQ0FBRVgsTUFBTU8sZUFBZUMsZ0JBQWdCNUcsU0FBU2phO2dCQUVuRyxJQUFLK2dCLGVBQWdCO29CQUVwQixJQUFNLElBQUlFLElBQUksR0FBR0EsSUFBSUYsY0FBY2xtQixNQUFNLEVBQUVvbUIsSUFBTzt3QkFFakROLE9BQU94bkIsSUFBSSxDQUFFNG5CLGFBQWEsQ0FBRUUsRUFBRztvQkFFaEM7Z0JBRUQ7WUFFRDtZQUVBLE9BQU8sSUFBSTF1QixnREFBYUEsQ0FBRXV0QixlQUFleGxCLFdBQVdxbUI7UUFFckQ7SUFFRDtJQUVBdFksZUFBZ0J2SixTQUFTLEVBQUc7UUFFM0IsTUFBTXhGLE9BQU8sSUFBSSxDQUFDQSxJQUFJO1FBQ3RCLE1BQU1rQixTQUFTLElBQUk7UUFDbkIsTUFBTXdFLFVBQVUxRixLQUFLdUYsS0FBSyxDQUFFQyxVQUFXO1FBRXZDLElBQUtFLFFBQVFzSixJQUFJLEtBQUtoTyxXQUFZLE9BQU87UUFFekMsT0FBT0UsT0FBT3VHLGFBQWEsQ0FBRSxRQUFRL0IsUUFBUXNKLElBQUksRUFBR25ILElBQUksQ0FBRSxTQUFXbUgsSUFBSTtZQUV4RSxNQUFNK1gsT0FBTzdsQixPQUFPNEcsV0FBVyxDQUFFNUcsT0FBT2ljLFNBQVMsRUFBRXpYLFFBQVFzSixJQUFJLEVBQUVBO1lBRWpFLHFFQUFxRTtZQUNyRSxJQUFLdEosUUFBUTZTLE9BQU8sS0FBS3ZYLFdBQVk7Z0JBRXBDK2xCLEtBQUthLFFBQVEsQ0FBRSxTQUFXQyxDQUFDO29CQUUxQixJQUFLLENBQUVBLEVBQUVDLE1BQU0sRUFBRztvQkFFbEIsSUFBTSxJQUFJeG1CLElBQUksR0FBRzhZLEtBQUsxVSxRQUFRNlMsT0FBTyxDQUFDaFgsTUFBTSxFQUFFRCxJQUFJOFksSUFBSTlZLElBQU87d0JBRTVEdW1CLEVBQUU3TSxxQkFBcUIsQ0FBRTFaLEVBQUcsR0FBR29FLFFBQVE2UyxPQUFPLENBQUVqWCxFQUFHO29CQUVwRDtnQkFFRDtZQUVEO1lBRUEsT0FBT3lsQjtRQUVSO0lBRUQ7SUFFQTs7OztFQUlDLEdBQ0Q1SSxTQUFVM1ksU0FBUyxFQUFHO1FBRXJCLE1BQU14RixPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUN0QixNQUFNa0IsU0FBUyxJQUFJO1FBRW5CLE1BQU13RSxVQUFVMUYsS0FBS3VGLEtBQUssQ0FBRUMsVUFBVztRQUV2QyxNQUFNdWlCLGNBQWM3bUIsT0FBTzZrQixnQkFBZ0IsQ0FBRXZnQjtRQUU3QyxNQUFNd2lCLGVBQWUsRUFBRTtRQUN2QixNQUFNQyxjQUFjdmlCLFFBQVFzSyxRQUFRLElBQUksRUFBRTtRQUUxQyxJQUFNLElBQUkxTyxJQUFJLEdBQUc4WSxLQUFLNk4sWUFBWTFtQixNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztZQUV4RDBtQixhQUFhbm9CLElBQUksQ0FBRXFCLE9BQU91RyxhQUFhLENBQUUsUUFBUXdnQixXQUFXLENBQUUzbUIsRUFBRztRQUVsRTtRQUVBLE1BQU00bUIsa0JBQWtCeGlCLFFBQVEwWCxJQUFJLEtBQUtwYyxZQUN0Q3lCLFFBQVFDLE9BQU8sQ0FBRSxRQUNqQnhCLE9BQU91RyxhQUFhLENBQUUsUUFBUS9CLFFBQVEwWCxJQUFJO1FBRTdDLE9BQU8zYSxRQUFRc0csR0FBRyxDQUFFO1lBQ25CZ2Y7WUFDQXRsQixRQUFRc0csR0FBRyxDQUFFaWY7WUFDYkU7U0FDQSxFQUFHcmdCLElBQUksQ0FBRSxTQUFXK0gsT0FBTztZQUUzQixNQUFNbVgsT0FBT25YLE9BQU8sQ0FBRSxFQUFHO1lBQ3pCLE1BQU1JLFdBQVdKLE9BQU8sQ0FBRSxFQUFHO1lBQzdCLE1BQU11WSxXQUFXdlksT0FBTyxDQUFFLEVBQUc7WUFFN0IsSUFBS3VZLGFBQWEsTUFBTztnQkFFeEIsNENBQTRDO2dCQUM1Qyx5REFBeUQ7Z0JBQ3pEcEIsS0FBS2EsUUFBUSxDQUFFLFNBQVc1WSxJQUFJO29CQUU3QixJQUFLLENBQUVBLEtBQUtxTyxhQUFhLEVBQUc7b0JBRTVCck8sS0FBS29aLElBQUksQ0FBRUQsVUFBVXBNO2dCQUV0QjtZQUVEO1lBRUEsSUFBTSxJQUFJemEsSUFBSSxHQUFHOFksS0FBS3BLLFNBQVN6TyxNQUFNLEVBQUVELElBQUk4WSxJQUFJOVksSUFBTztnQkFFckR5bEIsS0FBSzlpQixHQUFHLENBQUUrTCxRQUFRLENBQUUxTyxFQUFHO1lBRXhCO1lBRUEsT0FBT3lsQjtRQUVSO0lBRUQ7SUFFQSw0Q0FBNEM7SUFDNUMsNkVBQTZFO0lBQzdFaEIsaUJBQWtCdmdCLFNBQVMsRUFBRztRQUU3QixNQUFNeEYsT0FBTyxJQUFJLENBQUNBLElBQUk7UUFDdEIsTUFBTUMsYUFBYSxJQUFJLENBQUNBLFVBQVU7UUFDbEMsTUFBTWlCLFNBQVMsSUFBSTtRQUVuQiwwREFBMEQ7UUFDMUQscUNBQXFDO1FBRXJDLElBQUssSUFBSSxDQUFDOGEsU0FBUyxDQUFFeFcsVUFBVyxLQUFLeEUsV0FBWTtZQUVoRCxPQUFPLElBQUksQ0FBQ2diLFNBQVMsQ0FBRXhXLFVBQVc7UUFFbkM7UUFFQSxNQUFNRSxVQUFVMUYsS0FBS3VGLEtBQUssQ0FBRUMsVUFBVztRQUV2QyxrRkFBa0Y7UUFDbEYsTUFBTTZpQixXQUFXM2lCLFFBQVFqRSxJQUFJLEdBQUdQLE9BQU9zRyxnQkFBZ0IsQ0FBRTlCLFFBQVFqRSxJQUFJLElBQUs7UUFFMUUsTUFBTTRHLFVBQVUsRUFBRTtRQUVsQixNQUFNaWdCLGNBQWNwbkIsT0FBTzZjLFVBQVUsQ0FBRSxTQUFXN0IsR0FBRztZQUVwRCxPQUFPQSxJQUFJbk4sY0FBYyxJQUFJbU4sSUFBSW5OLGNBQWMsQ0FBRXZKO1FBRWxEO1FBRUEsSUFBSzhpQixhQUFjO1lBRWxCamdCLFFBQVF4SSxJQUFJLENBQUV5b0I7UUFFZjtRQUVBLElBQUs1aUIsUUFBUTRYLE1BQU0sS0FBS3RjLFdBQVk7WUFFbkNxSCxRQUFReEksSUFBSSxDQUFFcUIsT0FBT3VHLGFBQWEsQ0FBRSxVQUFVL0IsUUFBUTRYLE1BQU0sRUFBR3pWLElBQUksQ0FBRSxTQUFXeVYsTUFBTTtnQkFFckYsT0FBT3BjLE9BQU80RyxXQUFXLENBQUU1RyxPQUFPcWMsV0FBVyxFQUFFN1gsUUFBUTRYLE1BQU0sRUFBRUE7WUFFaEU7UUFFRDtRQUVBcGMsT0FBTythLFVBQVUsQ0FBRSxTQUFXQyxHQUFHO1lBRWhDLE9BQU9BLElBQUl2VSxvQkFBb0IsSUFBSXVVLElBQUl2VSxvQkFBb0IsQ0FBRW5DO1FBRTlELEdBQUkraUIsT0FBTyxDQUFFLFNBQVcxSCxPQUFPO1lBRTlCeFksUUFBUXhJLElBQUksQ0FBRWdoQjtRQUVmO1FBRUEsSUFBSSxDQUFDN0UsU0FBUyxDQUFFeFcsVUFBVyxHQUFHL0MsUUFBUXNHLEdBQUcsQ0FBRVYsU0FBVVIsSUFBSSxDQUFFLFNBQVcvRCxPQUFPO1lBRTVFLElBQUlpakI7WUFFSiw2Q0FBNkM7WUFDN0MsSUFBS3JoQixRQUFRd1gsTUFBTSxLQUFLLE1BQU87Z0JBRTlCNkosT0FBTyxJQUFJN3RCLHVDQUFJQTtZQUVoQixPQUFPLElBQUs0SyxRQUFRdkMsTUFBTSxHQUFHLEdBQUk7Z0JBRWhDd2xCLE9BQU8sSUFBSWx0Qix3Q0FBS0E7WUFFakIsT0FBTyxJQUFLaUssUUFBUXZDLE1BQU0sS0FBSyxHQUFJO2dCQUVsQ3dsQixPQUFPampCLE9BQU8sQ0FBRSxFQUFHO1lBRXBCLE9BQU87Z0JBRU5pakIsT0FBTyxJQUFJcHJCLDJDQUFRQTtZQUVwQjtZQUVBLElBQUtvckIsU0FBU2pqQixPQUFPLENBQUUsRUFBRyxFQUFHO2dCQUU1QixJQUFNLElBQUl4QyxJQUFJLEdBQUc4WSxLQUFLdFcsUUFBUXZDLE1BQU0sRUFBRUQsSUFBSThZLElBQUk5WSxJQUFPO29CQUVwRHlsQixLQUFLOWlCLEdBQUcsQ0FBRUgsT0FBTyxDQUFFeEMsRUFBRztnQkFFdkI7WUFFRDtZQUVBLElBQUtvRSxRQUFRakUsSUFBSSxFQUFHO2dCQUVuQnNsQixLQUFLdE4sUUFBUSxDQUFDaFksSUFBSSxHQUFHaUUsUUFBUWpFLElBQUk7Z0JBQ2pDc2xCLEtBQUt0bEIsSUFBSSxHQUFHNG1CO1lBRWI7WUFFQS9nQix1QkFBd0J5ZixNQUFNcmhCO1lBRTlCLElBQUtBLFFBQVF6RixVQUFVLEVBQUdxWiwrQkFBZ0NyWixZQUFZOG1CLE1BQU1yaEI7WUFFNUUsSUFBS0EsUUFBUThpQixNQUFNLEtBQUt4bkIsV0FBWTtnQkFFbkMsTUFBTXduQixTQUFTLElBQUl2dEIsMENBQU9BO2dCQUMxQnV0QixPQUFPdlUsU0FBUyxDQUFFdk8sUUFBUThpQixNQUFNO2dCQUNoQ3pCLEtBQUswQixZQUFZLENBQUVEO1lBRXBCLE9BQU87Z0JBRU4sSUFBSzlpQixRQUFRNFMsV0FBVyxLQUFLdFgsV0FBWTtvQkFFeEMrbEIsS0FBS3BnQixRQUFRLENBQUNzTixTQUFTLENBQUV2TyxRQUFRNFMsV0FBVztnQkFFN0M7Z0JBRUEsSUFBSzVTLFFBQVFxTyxRQUFRLEtBQUsvUyxXQUFZO29CQUVyQytsQixLQUFLMkIsVUFBVSxDQUFDelUsU0FBUyxDQUFFdk8sUUFBUXFPLFFBQVE7Z0JBRTVDO2dCQUVBLElBQUtyTyxRQUFRbUUsS0FBSyxLQUFLN0ksV0FBWTtvQkFFbEMrbEIsS0FBS2xkLEtBQUssQ0FBQ29LLFNBQVMsQ0FBRXZPLFFBQVFtRSxLQUFLO2dCQUVwQztZQUVEO1lBRUEsSUFBSyxDQUFFM0ksT0FBTzBjLFlBQVksQ0FBQytLLEdBQUcsQ0FBRTVCLE9BQVM7Z0JBRXhDN2xCLE9BQU8wYyxZQUFZLENBQUNoWCxHQUFHLENBQUVtZ0IsTUFBTSxDQUFDO1lBRWpDO1lBRUE3bEIsT0FBTzBjLFlBQVksQ0FBQzdaLEdBQUcsQ0FBRWdqQixNQUFPeGhCLEtBQUssR0FBR0M7WUFFeEMsT0FBT3VoQjtRQUVSO1FBRUEsT0FBTyxJQUFJLENBQUMvSyxTQUFTLENBQUV4VyxVQUFXO0lBRW5DO0lBRUE7Ozs7RUFJQyxHQUNEMFksVUFBVzBLLFVBQVUsRUFBRztRQUV2QixNQUFNM29CLGFBQWEsSUFBSSxDQUFDQSxVQUFVO1FBQ2xDLE1BQU00b0IsV0FBVyxJQUFJLENBQUM3b0IsSUFBSSxDQUFDdWMsTUFBTSxDQUFFcU0sV0FBWTtRQUMvQyxNQUFNMW5CLFNBQVMsSUFBSTtRQUVuQixtQ0FBbUM7UUFDbkMsOEVBQThFO1FBQzlFLE1BQU1vYixRQUFRLElBQUl6aUIsd0NBQUtBO1FBQ3ZCLElBQUtndkIsU0FBU3BuQixJQUFJLEVBQUc2YSxNQUFNN2EsSUFBSSxHQUFHUCxPQUFPc0csZ0JBQWdCLENBQUVxaEIsU0FBU3BuQixJQUFJO1FBRXhFNkYsdUJBQXdCZ1YsT0FBT3VNO1FBRS9CLElBQUtBLFNBQVM1b0IsVUFBVSxFQUFHcVosK0JBQWdDclosWUFBWXFjLE9BQU91TTtRQUU5RSxNQUFNQyxVQUFVRCxTQUFTdGpCLEtBQUssSUFBSSxFQUFFO1FBRXBDLE1BQU04QyxVQUFVLEVBQUU7UUFFbEIsSUFBTSxJQUFJL0csSUFBSSxHQUFHOFksS0FBSzBPLFFBQVF2bkIsTUFBTSxFQUFFRCxJQUFJOFksSUFBSTlZLElBQU87WUFFcEQrRyxRQUFReEksSUFBSSxDQUFFcUIsT0FBT3VHLGFBQWEsQ0FBRSxRQUFRcWhCLE9BQU8sQ0FBRXhuQixFQUFHO1FBRXpEO1FBRUEsT0FBT21CLFFBQVFzRyxHQUFHLENBQUVWLFNBQVVSLElBQUksQ0FBRSxTQUFXdEMsS0FBSztZQUVuRCxJQUFNLElBQUlqRSxJQUFJLEdBQUc4WSxLQUFLN1UsTUFBTWhFLE1BQU0sRUFBRUQsSUFBSThZLElBQUk5WSxJQUFPO2dCQUVsRGdiLE1BQU1yWSxHQUFHLENBQUVzQixLQUFLLENBQUVqRSxFQUFHO1lBRXRCO1lBRUEseUVBQXlFO1lBQ3pFLGlDQUFpQztZQUNqQyxNQUFNeW5CLHFCQUFxQixDQUFFaEM7Z0JBRTVCLE1BQU1pQyxzQkFBc0IsSUFBSUM7Z0JBRWhDLEtBQU0sTUFBTSxDQUFFamxCLEtBQUtrbEIsTUFBTyxJQUFJaG9CLE9BQU8wYyxZQUFZLENBQUc7b0JBRW5ELElBQUs1WixlQUFlakosMkNBQVFBLElBQUlpSixlQUFldkgsMENBQU9BLEVBQUc7d0JBRXhEdXNCLG9CQUFvQnBpQixHQUFHLENBQUU1QyxLQUFLa2xCO29CQUUvQjtnQkFFRDtnQkFFQW5DLEtBQUthLFFBQVEsQ0FBRSxDQUFFYjtvQkFFaEIsTUFBTXBKLFdBQVd6YyxPQUFPMGMsWUFBWSxDQUFDN1osR0FBRyxDQUFFZ2pCO29CQUUxQyxJQUFLcEosWUFBWSxNQUFPO3dCQUV2QnFMLG9CQUFvQnBpQixHQUFHLENBQUVtZ0IsTUFBTXBKO29CQUVoQztnQkFFRDtnQkFFQSxPQUFPcUw7WUFFUjtZQUVBOW5CLE9BQU8wYyxZQUFZLEdBQUdtTCxtQkFBb0J6TTtZQUUxQyxPQUFPQTtRQUVSO0lBRUQ7SUFFQW9MLHVCQUF3QlgsSUFBSSxFQUFFTyxhQUFhLEVBQUVDLGNBQWMsRUFBRTVHLE9BQU8sRUFBRWphLE1BQU0sRUFBRztRQUU5RSxNQUFNMmdCLFNBQVMsRUFBRTtRQUVqQixNQUFNOEIsYUFBYXBDLEtBQUt0bEIsSUFBSSxHQUFHc2xCLEtBQUt0bEIsSUFBSSxHQUFHc2xCLEtBQUtwRSxJQUFJO1FBQ3BELE1BQU0xSCxjQUFjLEVBQUU7UUFFdEIsSUFBSzVDLGVBQWUsQ0FBRTNSLE9BQU8vSSxJQUFJLENBQUUsS0FBSzBhLGdCQUFnQkUsT0FBTyxFQUFHO1lBRWpFd08sS0FBS2EsUUFBUSxDQUFFLFNBQVcxakIsTUFBTTtnQkFFL0IsSUFBS0EsT0FBTzhXLHFCQUFxQixFQUFHO29CQUVuQ0MsWUFBWXBiLElBQUksQ0FBRXFFLE9BQU96QyxJQUFJLEdBQUd5QyxPQUFPekMsSUFBSSxHQUFHeUMsT0FBT3llLElBQUk7Z0JBRTFEO1lBRUQ7UUFFRCxPQUFPO1lBRU4xSCxZQUFZcGIsSUFBSSxDQUFFc3BCO1FBRW5CO1FBRUEsSUFBSUM7UUFFSixPQUFTL1EsZUFBZSxDQUFFM1IsT0FBTy9JLElBQUksQ0FBRTtZQUV0QyxLQUFLMGEsZ0JBQWdCRSxPQUFPO2dCQUUzQjZRLHFCQUFxQjF0QixzREFBbUJBO2dCQUN4QztZQUVELEtBQUsyYyxnQkFBZ0J0RSxRQUFRO2dCQUU1QnFWLHFCQUFxQmp0QiwwREFBdUJBO2dCQUM1QztZQUVELEtBQUtrYyxnQkFBZ0IxUixRQUFRO1lBQzdCLEtBQUswUixnQkFBZ0J4TyxLQUFLO2dCQUV6QnVmLHFCQUFxQnJzQixzREFBbUJBO2dCQUN4QztZQUVEO2dCQUVDLE9BQVN3cUIsZUFBZXJXLFFBQVE7b0JBRS9CLEtBQUs7d0JBQ0prWSxxQkFBcUIxdEIsc0RBQW1CQTt3QkFDeEM7b0JBQ0QsS0FBSztvQkFDTCxLQUFLO29CQUNMO3dCQUNDMHRCLHFCQUFxQnJzQixzREFBbUJBO3dCQUN4QztnQkFFRjtnQkFFQTtRQUVGO1FBRUEsTUFBTXNzQixnQkFBZ0IxSSxRQUFRMEksYUFBYSxLQUFLcm9CLFlBQVl3WCxhQUFhLENBQUVtSSxRQUFRMEksYUFBYSxDQUFFLEdBQUdqdkIsb0RBQWlCQTtRQUd0SCxNQUFNa3ZCLGNBQWMsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBRWhDO1FBRWhELElBQU0sSUFBSWlDLElBQUksR0FBR0MsS0FBS3hPLFlBQVkxWixNQUFNLEVBQUVpb0IsSUFBSUMsSUFBSUQsSUFBTztZQUV4RCxNQUFNRSxRQUFRLElBQUlOLG1CQUNqQm5PLFdBQVcsQ0FBRXVPLEVBQUcsR0FBRyxNQUFNblIsZUFBZSxDQUFFM1IsT0FBTy9JLElBQUksQ0FBRSxFQUN2RDJwQixjQUFjMWUsS0FBSyxFQUNuQjBnQixhQUNBRDtZQUdELHFEQUFxRDtZQUNyRCxJQUFLMUksUUFBUTBJLGFBQWEsS0FBSyxlQUFnQjtnQkFFOUMsSUFBSSxDQUFDTSxrQ0FBa0MsQ0FBRUQ7WUFFMUM7WUFFQXJDLE9BQU94bkIsSUFBSSxDQUFFNnBCO1FBRWQ7UUFFQSxPQUFPckM7SUFFUjtJQUVBa0Msc0JBQXVCNVosUUFBUSxFQUFHO1FBRWpDLElBQUkyWixjQUFjM1osU0FBUy9HLEtBQUs7UUFFaEMsSUFBSytHLFNBQVN3QixVQUFVLEVBQUc7WUFFMUIsTUFBTXRILFFBQVErUiw0QkFBNkIwTixZQUFZMW1CLFdBQVc7WUFDbEUsTUFBTWduQixTQUFTLElBQUlyUyxhQUFjK1IsWUFBWS9uQixNQUFNO1lBRW5ELElBQU0sSUFBSWlvQixJQUFJLEdBQUdDLEtBQUtILFlBQVkvbkIsTUFBTSxFQUFFaW9CLElBQUlDLElBQUlELElBQU87Z0JBRXhESSxNQUFNLENBQUVKLEVBQUcsR0FBR0YsV0FBVyxDQUFFRSxFQUFHLEdBQUczZjtZQUVsQztZQUVBeWYsY0FBY007UUFFZjtRQUVBLE9BQU9OO0lBRVI7SUFFQUssbUNBQW9DRCxLQUFLLEVBQUc7UUFFM0NBLE1BQU1HLGlCQUFpQixHQUFHLFNBQVNDLHdDQUF5Q2piLE1BQU07WUFFakYsK0VBQStFO1lBQy9FLDBGQUEwRjtZQUMxRix5RUFBeUU7WUFFekUsTUFBTWtiLGtCQUFrQixJQUFNLFlBQVk1dEIsMERBQXVCQSxHQUFLOFosdUNBQXVDN0I7WUFFN0csT0FBTyxJQUFJMlYsZ0JBQWlCLElBQUksQ0FBQ0MsS0FBSyxFQUFFLElBQUksQ0FBQ3pWLE1BQU0sRUFBRSxJQUFJLENBQUMwVixZQUFZLEtBQUssR0FBR3BiO1FBRS9FO1FBRUEsdUZBQXVGO1FBQ3ZGNmEsTUFBTUcsaUJBQWlCLENBQUNLLHlDQUF5QyxHQUFHO0lBRXJFO0lBOTdEQXRuQixZQUFhNUMsT0FBTyxDQUFDLENBQUMsRUFBRTRNLFVBQVUsQ0FBQyxDQUFDLENBQUc7UUFFdEMsSUFBSSxDQUFDNU0sSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsQ0FBQztRQUNoQixJQUFJLENBQUMwTSxPQUFPLEdBQUdBO1FBRWYsc0JBQXNCO1FBQ3RCLElBQUksQ0FBQy9HLEtBQUssR0FBRyxJQUFJaEM7UUFFakIsMERBQTBEO1FBQzFELElBQUksQ0FBQytaLFlBQVksR0FBRyxJQUFJcUw7UUFFeEIseUJBQXlCO1FBQ3pCLElBQUksQ0FBQ3RFLGNBQWMsR0FBRyxDQUFDO1FBRXZCLGFBQWE7UUFDYixJQUFJLENBQUMzSSxTQUFTLEdBQUcsQ0FBQztRQUVsQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDbUIsU0FBUyxHQUFHO1lBQUVwVixNQUFNLENBQUM7WUFBR0MsTUFBTSxDQUFDO1FBQUU7UUFDdEMsSUFBSSxDQUFDdVYsV0FBVyxHQUFHO1lBQUV4VixNQUFNLENBQUM7WUFBR0MsTUFBTSxDQUFDO1FBQUU7UUFDeEMsSUFBSSxDQUFDbWlCLFVBQVUsR0FBRztZQUFFcGlCLE1BQU0sQ0FBQztZQUFHQyxNQUFNLENBQUM7UUFBRTtRQUV2QyxJQUFJLENBQUNzWixXQUFXLEdBQUcsQ0FBQztRQUNwQixJQUFJLENBQUNWLFlBQVksR0FBRyxDQUFDO1FBRXJCLDRDQUE0QztRQUM1QyxJQUFJLENBQUM2RCxhQUFhLEdBQUcsQ0FBQztRQUV0Qiw0RUFBNEU7UUFDNUUsd0VBQXdFO1FBRXhFLElBQUkyRixXQUFXO1FBQ2YsSUFBSUMsWUFBWTtRQUNoQixJQUFJQyxpQkFBaUIsQ0FBRTtRQUV2QixJQUFLLE9BQU9DLGNBQWMsYUFBYztZQUV2Q0gsV0FBVyxpQ0FBaUNJLElBQUksQ0FBRUQsVUFBVUUsU0FBUyxNQUFPO1lBQzVFSixZQUFZRSxVQUFVRSxTQUFTLENBQUM3cUIsT0FBTyxDQUFFLGFBQWMsQ0FBRTtZQUN6RDBxQixpQkFBaUJELFlBQVlFLFVBQVVFLFNBQVMsQ0FBQ0MsS0FBSyxDQUFFLHNCQUF1QixDQUFFLEVBQUcsR0FBRyxDQUFFO1FBRTFGO1FBRUEsSUFBSyxPQUFPQyxzQkFBc0IsZUFBZVAsWUFBY0MsYUFBYUMsaUJBQWlCLElBQU87WUFFbkcsSUFBSSxDQUFDdGQsYUFBYSxHQUFHLElBQUl0USxnREFBYUEsQ0FBRSxJQUFJLENBQUNrUSxPQUFPLENBQUM3TyxPQUFPO1FBRTdELE9BQU87WUFFTixJQUFJLENBQUNpUCxhQUFhLEdBQUcsSUFBSWxULG9EQUFpQkEsQ0FBRSxJQUFJLENBQUM4UyxPQUFPLENBQUM3TyxPQUFPO1FBRWpFO1FBRUEsSUFBSSxDQUFDaVAsYUFBYSxDQUFDNGQsY0FBYyxDQUFFLElBQUksQ0FBQ2hlLE9BQU8sQ0FBQ3hMLFdBQVc7UUFDM0QsSUFBSSxDQUFDNEwsYUFBYSxDQUFDdE8sZ0JBQWdCLENBQUUsSUFBSSxDQUFDa08sT0FBTyxDQUFDak8sYUFBYTtRQUUvRCxJQUFJLENBQUMwQyxVQUFVLEdBQUcsSUFBSTFILDZDQUFVQSxDQUFFLElBQUksQ0FBQ2lULE9BQU8sQ0FBQzdPLE9BQU87UUFDdEQsSUFBSSxDQUFDc0QsVUFBVSxDQUFDNUMsZUFBZSxDQUFFO1FBRWpDLElBQUssSUFBSSxDQUFDbU8sT0FBTyxDQUFDeEwsV0FBVyxLQUFLLG1CQUFvQjtZQUVyRCxJQUFJLENBQUNDLFVBQVUsQ0FBQ3pDLGtCQUFrQixDQUFFO1FBRXJDO0lBRUQ7QUE2M0REO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNpc0IsY0FBZXRhLFFBQVEsRUFBRTZLLFlBQVksRUFBRWxhLE1BQU07SUFFckQsTUFBTXdPLGFBQWEwTCxhQUFhMUwsVUFBVTtJQUUxQyxNQUFNb2IsTUFBTSxJQUFJM3hCLHVDQUFJQTtJQUVwQixJQUFLdVcsV0FBV2lJLFFBQVEsS0FBSzNXLFdBQVk7UUFFeEMsTUFBTTJPLFdBQVd6TyxPQUFPbEIsSUFBSSxDQUFDbVQsU0FBUyxDQUFFekQsV0FBV2lJLFFBQVEsQ0FBRTtRQUU3RCxNQUFNb1QsTUFBTXBiLFNBQVNvYixHQUFHO1FBQ3hCLE1BQU1DLE1BQU1yYixTQUFTcWIsR0FBRztRQUV4QixrR0FBa0c7UUFFbEcsSUFBS0QsUUFBUS9wQixhQUFhZ3FCLFFBQVFocUIsV0FBWTtZQUU3QzhwQixJQUFJbGtCLEdBQUcsQ0FDTixJQUFJOUosMENBQU9BLENBQUVpdUIsR0FBRyxDQUFFLEVBQUcsRUFBRUEsR0FBRyxDQUFFLEVBQUcsRUFBRUEsR0FBRyxDQUFFLEVBQUcsR0FDekMsSUFBSWp1QiwwQ0FBT0EsQ0FBRWt1QixHQUFHLENBQUUsRUFBRyxFQUFFQSxHQUFHLENBQUUsRUFBRyxFQUFFQSxHQUFHLENBQUUsRUFBRztZQUcxQyxJQUFLcmIsU0FBU3dCLFVBQVUsRUFBRztnQkFFMUIsTUFBTThaLFdBQVdyUCw0QkFBNkJ2SSxxQkFBcUIsQ0FBRTFELFNBQVN5RCxhQUFhLENBQUU7Z0JBQzdGMFgsSUFBSUMsR0FBRyxDQUFDRyxjQUFjLENBQUVEO2dCQUN4QkgsSUFBSUUsR0FBRyxDQUFDRSxjQUFjLENBQUVEO1lBRXpCO1FBRUQsT0FBTztZQUVOOXNCLFFBQVFrRSxJQUFJLENBQUU7WUFFZDtRQUVEO0lBRUQsT0FBTztRQUVOO0lBRUQ7SUFFQSxNQUFNMlgsVUFBVW9CLGFBQWFwQixPQUFPO0lBRXBDLElBQUtBLFlBQVloWixXQUFZO1FBRTVCLE1BQU1tcUIsa0JBQWtCLElBQUlydUIsMENBQU9BO1FBQ25DLE1BQU1zdUIsU0FBUyxJQUFJdHVCLDBDQUFPQTtRQUUxQixJQUFNLElBQUl3RSxJQUFJLEdBQUc4WSxLQUFLSixRQUFRelksTUFBTSxFQUFFRCxJQUFJOFksSUFBSTlZLElBQU87WUFFcEQsTUFBTW9GLFNBQVNzVCxPQUFPLENBQUUxWSxFQUFHO1lBRTNCLElBQUtvRixPQUFPaVIsUUFBUSxLQUFLM1csV0FBWTtnQkFFcEMsTUFBTTJPLFdBQVd6TyxPQUFPbEIsSUFBSSxDQUFDbVQsU0FBUyxDQUFFek0sT0FBT2lSLFFBQVEsQ0FBRTtnQkFDekQsTUFBTW9ULE1BQU1wYixTQUFTb2IsR0FBRztnQkFDeEIsTUFBTUMsTUFBTXJiLFNBQVNxYixHQUFHO2dCQUV4QixrR0FBa0c7Z0JBRWxHLElBQUtELFFBQVEvcEIsYUFBYWdxQixRQUFRaHFCLFdBQVk7b0JBRTdDLDRFQUE0RTtvQkFDNUVvcUIsT0FBTy9LLElBQUksQ0FBRXBaLEtBQUsrakIsR0FBRyxDQUFFL2pCLEtBQUtva0IsR0FBRyxDQUFFTixHQUFHLENBQUUsRUFBRyxHQUFJOWpCLEtBQUtva0IsR0FBRyxDQUFFTCxHQUFHLENBQUUsRUFBRztvQkFDL0RJLE9BQU85SyxJQUFJLENBQUVyWixLQUFLK2pCLEdBQUcsQ0FBRS9qQixLQUFLb2tCLEdBQUcsQ0FBRU4sR0FBRyxDQUFFLEVBQUcsR0FBSTlqQixLQUFLb2tCLEdBQUcsQ0FBRUwsR0FBRyxDQUFFLEVBQUc7b0JBQy9ESSxPQUFPN0ssSUFBSSxDQUFFdFosS0FBSytqQixHQUFHLENBQUUvakIsS0FBS29rQixHQUFHLENBQUVOLEdBQUcsQ0FBRSxFQUFHLEdBQUk5akIsS0FBS29rQixHQUFHLENBQUVMLEdBQUcsQ0FBRSxFQUFHO29CQUcvRCxJQUFLcmIsU0FBU3dCLFVBQVUsRUFBRzt3QkFFMUIsTUFBTThaLFdBQVdyUCw0QkFBNkJ2SSxxQkFBcUIsQ0FBRTFELFNBQVN5RCxhQUFhLENBQUU7d0JBQzdGZ1ksT0FBT0YsY0FBYyxDQUFFRDtvQkFFeEI7b0JBRUEsaUhBQWlIO29CQUNqSCxtSEFBbUg7b0JBQ25ILG9IQUFvSDtvQkFDcEgsaUhBQWlIO29CQUNqSEUsZ0JBQWdCSCxHQUFHLENBQUVJO2dCQUV0QixPQUFPO29CQUVOanRCLFFBQVFrRSxJQUFJLENBQUU7Z0JBRWY7WUFFRDtRQUVEO1FBRUEsd0hBQXdIO1FBQ3hIeW9CLElBQUlRLGNBQWMsQ0FBRUg7SUFFckI7SUFFQTVhLFNBQVNnYixXQUFXLEdBQUdUO0lBRXZCLE1BQU1VLFNBQVMsSUFBSWp2Qix5Q0FBTUE7SUFFekJ1dUIsSUFBSVcsU0FBUyxDQUFFRCxPQUFPRSxNQUFNO0lBQzVCRixPQUFPRyxNQUFNLEdBQUdiLElBQUlDLEdBQUcsQ0FBQ2EsVUFBVSxDQUFFZCxJQUFJRSxHQUFHLElBQUs7SUFFaER6YSxTQUFTc2IsY0FBYyxHQUFHTDtBQUUzQjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBUzNHLHVCQUF3QnRVLFFBQVEsRUFBRTZLLFlBQVksRUFBRWxhLE1BQU07SUFFOUQsTUFBTXdPLGFBQWEwTCxhQUFhMUwsVUFBVTtJQUUxQyxNQUFNckgsVUFBVSxFQUFFO0lBRWxCLFNBQVN5akIsd0JBQXlCNU0sYUFBYSxFQUFFbk8sYUFBYTtRQUU3RCxPQUFPN1AsT0FBT3VHLGFBQWEsQ0FBRSxZQUFZeVgsZUFDdkNyWCxJQUFJLENBQUUsU0FBVzhILFFBQVE7WUFFekJZLFNBQVNhLFlBQVksQ0FBRUwsZUFBZXBCO1FBRXZDO0lBRUY7SUFFQSxJQUFNLE1BQU1vYyxxQkFBcUJyYyxXQUFhO1FBRTdDLE1BQU1xRCxxQkFBcUJDLFVBQVUsQ0FBRStZLGtCQUFtQixJQUFJQSxrQkFBa0I5WSxXQUFXO1FBRTNGLDREQUE0RDtRQUM1RCxJQUFLRixzQkFBc0J4QyxTQUFTYixVQUFVLEVBQUc7UUFFakRySCxRQUFReEksSUFBSSxDQUFFaXNCLHdCQUF5QnBjLFVBQVUsQ0FBRXFjLGtCQUFtQixFQUFFaFo7SUFFekU7SUFFQSxJQUFLcUksYUFBYUcsT0FBTyxLQUFLdmEsYUFBYSxDQUFFdVAsU0FBUzdJLEtBQUssRUFBRztRQUU3RCxNQUFNaUksV0FBV3pPLE9BQU91RyxhQUFhLENBQUUsWUFBWTJULGFBQWFHLE9BQU8sRUFBRzFULElBQUksQ0FBRSxTQUFXOEgsUUFBUTtZQUVsR1ksU0FBU3liLFFBQVEsQ0FBRXJjO1FBRXBCO1FBRUF0SCxRQUFReEksSUFBSSxDQUFFOFA7SUFFZjtJQUVBLElBQUtuVyxrREFBZUEsQ0FBQ3l5QixpQkFBaUIsS0FBS3J4Qix1REFBb0JBLElBQUksYUFBYThVLFlBQWE7UUFFNUZ2UixRQUFRa0UsSUFBSSxDQUFFLHFFQUF1RyxPQUFsQzdJLGtEQUFlQSxDQUFDeXlCLGlCQUFpQixFQUFDO0lBRXRIO0lBRUEza0IsdUJBQXdCaUosVUFBVTZLO0lBRWxDeVAsY0FBZXRhLFVBQVU2SyxjQUFjbGE7SUFFdkMsT0FBT3VCLFFBQVFzRyxHQUFHLENBQUVWLFNBQVVSLElBQUksQ0FBRTtRQUVuQyxPQUFPdVQsYUFBYXBCLE9BQU8sS0FBS2haLFlBQzdCK1ksZ0JBQWlCeEosVUFBVTZLLGFBQWFwQixPQUFPLEVBQUU5WSxVQUNqRHFQO0lBRUo7QUFFRDtBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlci5qcz8zNjQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdEFuaW1hdGlvbkNsaXAsXG5cdEJvbmUsXG5cdEJveDMsXG5cdEJ1ZmZlckF0dHJpYnV0ZSxcblx0QnVmZmVyR2VvbWV0cnksXG5cdENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdENvbG9yLFxuXHRDb2xvck1hbmFnZW1lbnQsXG5cdERpcmVjdGlvbmFsTGlnaHQsXG5cdERvdWJsZVNpZGUsXG5cdEZpbGVMb2FkZXIsXG5cdEZyb250U2lkZSxcblx0R3JvdXAsXG5cdEltYWdlQml0bWFwTG9hZGVyLFxuXHRJbnN0YW5jZWRNZXNoLFxuXHRJbnRlcmxlYXZlZEJ1ZmZlcixcblx0SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsXG5cdEludGVycG9sYW50LFxuXHRJbnRlcnBvbGF0ZURpc2NyZXRlLFxuXHRJbnRlcnBvbGF0ZUxpbmVhcixcblx0TGluZSxcblx0TGluZUJhc2ljTWF0ZXJpYWwsXG5cdExpbmVMb29wLFxuXHRMaW5lU2VnbWVudHMsXG5cdExpbmVhckZpbHRlcixcblx0TGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLFxuXHRMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHRMaW5lYXJTUkdCQ29sb3JTcGFjZSxcblx0TG9hZGVyLFxuXHRMb2FkZXJVdGlscyxcblx0TWF0ZXJpYWwsXG5cdE1hdGhVdGlscyxcblx0TWF0cml4NCxcblx0TWVzaCxcblx0TWVzaEJhc2ljTWF0ZXJpYWwsXG5cdE1lc2hQaHlzaWNhbE1hdGVyaWFsLFxuXHRNZXNoU3RhbmRhcmRNYXRlcmlhbCxcblx0TWlycm9yZWRSZXBlYXRXcmFwcGluZyxcblx0TmVhcmVzdEZpbHRlcixcblx0TmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcixcblx0TmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdE51bWJlcktleWZyYW1lVHJhY2ssXG5cdE9iamVjdDNELFxuXHRPcnRob2dyYXBoaWNDYW1lcmEsXG5cdFBlcnNwZWN0aXZlQ2FtZXJhLFxuXHRQb2ludExpZ2h0LFxuXHRQb2ludHMsXG5cdFBvaW50c01hdGVyaWFsLFxuXHRQcm9wZXJ0eUJpbmRpbmcsXG5cdFF1YXRlcm5pb24sXG5cdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLFxuXHRSZXBlYXRXcmFwcGluZyxcblx0U2tlbGV0b24sXG5cdFNraW5uZWRNZXNoLFxuXHRTcGhlcmUsXG5cdFNwb3RMaWdodCxcblx0VGV4dHVyZSxcblx0VGV4dHVyZUxvYWRlcixcblx0VHJpYW5nbGVGYW5EcmF3TW9kZSxcblx0VHJpYW5nbGVTdHJpcERyYXdNb2RlLFxuXHRWZWN0b3IyLFxuXHRWZWN0b3IzLFxuXHRWZWN0b3JLZXlmcmFtZVRyYWNrLFxuXHRTUkdCQ29sb3JTcGFjZSxcblx0SW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlXG59IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHRvVHJpYW5nbGVzRHJhd01vZGUgfSBmcm9tICcuLi91dGlscy9CdWZmZXJHZW9tZXRyeVV0aWxzLmpzJztcblxuY2xhc3MgR0xURkxvYWRlciBleHRlbmRzIExvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XG5cblx0XHRzdXBlciggbWFuYWdlciApO1xuXG5cdFx0dGhpcy5kcmFjb0xvYWRlciA9IG51bGw7XG5cdFx0dGhpcy5rdHgyTG9hZGVyID0gbnVsbDtcblx0XHR0aGlzLm1lc2hvcHREZWNvZGVyID0gbnVsbDtcblxuXHRcdHRoaXMucGx1Z2luQ2FsbGJhY2tzID0gW107XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0J1bXBFeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURkxpZ2h0c0V4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWVzaG9wdENvbXByZXNzaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZNZXNoR3B1SW5zdGFuY2luZyggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xuXG5cdFx0bGV0IHJlc291cmNlUGF0aDtcblxuXHRcdGlmICggdGhpcy5yZXNvdXJjZVBhdGggIT09ICcnICkge1xuXG5cdFx0XHRyZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aDtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMucGF0aCAhPT0gJycgKSB7XG5cblx0XHRcdC8vIElmIGEgYmFzZSBwYXRoIGlzIHNldCwgcmVzb3VyY2VzIHdpbGwgYmUgcmVsYXRpdmUgcGF0aHMgZnJvbSB0aGF0IHBsdXMgdGhlIHJlbGF0aXZlIHBhdGggb2YgdGhlIGdsdGYgZmlsZVxuXHRcdFx0Ly8gRXhhbXBsZSAgcGF0aCA9ICdodHRwczovL215LWNuZC1zZXJ2ZXIuY29tLycsIHVybCA9ICdhc3NldHMvbW9kZWxzL21vZGVsLmdsdGYnXG5cdFx0XHQvLyByZXNvdXJjZVBhdGggPSAnaHR0cHM6Ly9teS1jbmQtc2VydmVyLmNvbS9hc3NldHMvbW9kZWxzLydcblx0XHRcdC8vIHJlZmVyZW5jZWQgcmVzb3VyY2UgJ21vZGVsLmJpbicgd2lsbCBiZSBsb2FkZWQgZnJvbSAnaHR0cHM6Ly9teS1jbmQtc2VydmVyLmNvbS9hc3NldHMvbW9kZWxzL21vZGVsLmJpbidcblx0XHRcdC8vIHJlZmVyZW5jZWQgcmVzb3VyY2UgJy4uL3RleHR1cmVzL3RleHR1cmUucG5nJyB3aWxsIGJlIGxvYWRlZCBmcm9tICdodHRwczovL215LWNuZC1zZXJ2ZXIuY29tL2Fzc2V0cy90ZXh0dXJlcy90ZXh0dXJlLnBuZydcblx0XHRcdGNvbnN0IHJlbGF0aXZlVXJsID0gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApO1xuXHRcdFx0cmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMucmVzb2x2ZVVSTCggcmVsYXRpdmVVcmwsIHRoaXMucGF0aCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gVGVsbHMgdGhlIExvYWRpbmdNYW5hZ2VyIHRvIHRyYWNrIGFuIGV4dHJhIGl0ZW0sIHdoaWNoIHJlc29sdmVzIGFmdGVyXG5cdFx0Ly8gdGhlIG1vZGVsIGlzIGZ1bGx5IGxvYWRlZC4gVGhpcyBtZWFucyB0aGUgY291bnQgb2YgaXRlbXMgbG9hZGVkIHdpbGxcblx0XHQvLyBiZSBpbmNvcnJlY3QsIGJ1dCBlbnN1cmVzIG1hbmFnZXIub25Mb2FkKCkgZG9lcyBub3QgZmlyZSBlYXJseS5cblx0XHR0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdGNvbnN0IF9vbkVycm9yID0gZnVuY3Rpb24gKCBlICkge1xuXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0fTtcblxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblxuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0c2NvcGUucGFyc2UoIGRhdGEsIHJlc291cmNlUGF0aCwgZnVuY3Rpb24gKCBnbHRmICkge1xuXG5cdFx0XHRcdFx0b25Mb2FkKCBnbHRmICk7XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHRcdH0sIF9vbkVycm9yICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdF9vbkVycm9yKCBlICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIF9vbkVycm9yICk7XG5cblx0fVxuXG5cdHNldERSQUNPTG9hZGVyKCBkcmFjb0xvYWRlciApIHtcblxuXHRcdHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RERTTG9hZGVyKCkge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXG5cdFx0XHQnVEhSRUUuR0xURkxvYWRlcjogXCJNU0ZUX3RleHR1cmVfZGRzXCIgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSB0byBcIktIUl90ZXh0dXJlX2Jhc2lzdVwiLidcblxuXHRcdCk7XG5cblx0fVxuXG5cdHNldEtUWDJMb2FkZXIoIGt0eDJMb2FkZXIgKSB7XG5cblx0XHR0aGlzLmt0eDJMb2FkZXIgPSBrdHgyTG9hZGVyO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRNZXNob3B0RGVjb2RlciggbWVzaG9wdERlY29kZXIgKSB7XG5cblx0XHR0aGlzLm1lc2hvcHREZWNvZGVyID0gbWVzaG9wdERlY29kZXI7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJlZ2lzdGVyKCBjYWxsYmFjayApIHtcblxuXHRcdGlmICggdGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZiggY2FsbGJhY2sgKSA9PT0gLSAxICkge1xuXG5cdFx0XHR0aGlzLnBsdWdpbkNhbGxiYWNrcy5wdXNoKCBjYWxsYmFjayApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVucmVnaXN0ZXIoIGNhbGxiYWNrICkge1xuXG5cdFx0aWYgKCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKCBjYWxsYmFjayApICE9PSAtIDEgKSB7XG5cblx0XHRcdHRoaXMucGx1Z2luQ2FsbGJhY2tzLnNwbGljZSggdGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZiggY2FsbGJhY2sgKSwgMSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHBhcnNlKCBkYXRhLCBwYXRoLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cblx0XHRsZXQganNvbjtcblx0XHRjb25zdCBleHRlbnNpb25zID0ge307XG5cdFx0Y29uc3QgcGx1Z2lucyA9IHt9O1xuXHRcdGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0anNvbiA9IEpTT04ucGFyc2UoIGRhdGEgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciApIHtcblxuXHRcdFx0Y29uc3QgbWFnaWMgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoIG5ldyBVaW50OEFycmF5KCBkYXRhLCAwLCA0ICkgKTtcblxuXHRcdFx0aWYgKCBtYWdpYyA9PT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgKSB7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGIF0gPSBuZXcgR0xURkJpbmFyeUV4dGVuc2lvbiggZGF0YSApO1xuXG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGVycm9yICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZSggZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEYgXS5jb250ZW50ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0anNvbiA9IEpTT04ucGFyc2UoIHRleHREZWNvZGVyLmRlY29kZSggZGF0YSApICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGpzb24gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uLmFzc2V0ID09PSB1bmRlZmluZWQgfHwganNvbi5hc3NldC52ZXJzaW9uWyAwIF0gPCAyICkge1xuXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBhc3NldC4gZ2xURiB2ZXJzaW9ucyA+PTIuMCBhcmUgc3VwcG9ydGVkLicgKSApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcGFyc2VyID0gbmV3IEdMVEZQYXJzZXIoIGpzb24sIHtcblxuXHRcdFx0cGF0aDogcGF0aCB8fCB0aGlzLnJlc291cmNlUGF0aCB8fCAnJyxcblx0XHRcdGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luLFxuXHRcdFx0cmVxdWVzdEhlYWRlcjogdGhpcy5yZXF1ZXN0SGVhZGVyLFxuXHRcdFx0bWFuYWdlcjogdGhpcy5tYW5hZ2VyLFxuXHRcdFx0a3R4MkxvYWRlcjogdGhpcy5rdHgyTG9hZGVyLFxuXHRcdFx0bWVzaG9wdERlY29kZXI6IHRoaXMubWVzaG9wdERlY29kZXJcblxuXHRcdH0gKTtcblxuXHRcdHBhcnNlci5maWxlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5DYWxsYmFja3MubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbkNhbGxiYWNrc1sgaSBdKCBwYXJzZXIgKTtcblxuXHRcdFx0aWYgKCAhIHBsdWdpbi5uYW1lICkgY29uc29sZS5lcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgcGx1Z2luIGZvdW5kOiBtaXNzaW5nIG5hbWUnICk7XG5cblx0XHRcdHBsdWdpbnNbIHBsdWdpbi5uYW1lIF0gPSBwbHVnaW47XG5cblx0XHRcdC8vIFdvcmthcm91bmQgdG8gYXZvaWQgZGV0ZXJtaW5pbmcgYXMgdW5rbm93biBleHRlbnNpb25cblx0XHRcdC8vIGluIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSgpLlxuXHRcdFx0Ly8gUmVtb3ZlIHRoaXMgd29ya2Fyb3VuZCBpZiB3ZSBtb3ZlIGFsbCB0aGUgZXhpc3Rpbmdcblx0XHRcdC8vIGV4dGVuc2lvbiBoYW5kbGVycyB0byBwbHVnaW4gc3lzdGVtXG5cdFx0XHRleHRlbnNpb25zWyBwbHVnaW4ubmFtZSBdID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICgganNvbi5leHRlbnNpb25zVXNlZCApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwganNvbi5leHRlbnNpb25zVXNlZC5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdFx0Y29uc3QgZXh0ZW5zaW9uTmFtZSA9IGpzb24uZXh0ZW5zaW9uc1VzZWRbIGkgXTtcblx0XHRcdFx0Y29uc3QgZXh0ZW5zaW9uc1JlcXVpcmVkID0ganNvbi5leHRlbnNpb25zUmVxdWlyZWQgfHwgW107XG5cblx0XHRcdFx0c3dpdGNoICggZXh0ZW5zaW9uTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUOlxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgZXh0ZW5zaW9uTmFtZSBdID0gbmV3IEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046XG5cdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKCBqc29uLCB0aGlzLmRyYWNvTG9hZGVyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk06XG5cdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjpcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXSA9IG5ldyBHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRpZiAoIGV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKCBleHRlbnNpb25OYW1lICkgPj0gMCAmJiBwbHVnaW5zWyBleHRlbnNpb25OYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBVbmtub3duIGV4dGVuc2lvbiBcIicgKyBleHRlbnNpb25OYW1lICsgJ1wiLicgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cGFyc2VyLnNldEV4dGVuc2lvbnMoIGV4dGVuc2lvbnMgKTtcblx0XHRwYXJzZXIuc2V0UGx1Z2lucyggcGx1Z2lucyApO1xuXHRcdHBhcnNlci5wYXJzZSggb25Mb2FkLCBvbkVycm9yICk7XG5cblx0fVxuXG5cdHBhcnNlQXN5bmMoIGRhdGEsIHBhdGggKSB7XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSwgcmVqZWN0ICkge1xuXG5cdFx0XHRzY29wZS5wYXJzZSggZGF0YSwgcGF0aCwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG59XG5cbi8qIEdMVEZSRUdJU1RSWSAqL1xuXG5mdW5jdGlvbiBHTFRGUmVnaXN0cnkoKSB7XG5cblx0bGV0IG9iamVjdHMgPSB7fTtcblxuXHRyZXR1cm5cdHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRcdHJldHVybiBvYmplY3RzWyBrZXkgXTtcblxuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBvYmplY3QgKSB7XG5cblx0XHRcdG9iamVjdHNbIGtleSBdID0gb2JqZWN0O1xuXG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRcdGRlbGV0ZSBvYmplY3RzWyBrZXkgXTtcblxuXHRcdH0sXG5cblx0XHRyZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0b2JqZWN0cyA9IHt9O1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqIEVYVEVOU0lPTlMgKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jb25zdCBFWFRFTlNJT05TID0ge1xuXHRLSFJfQklOQVJZX0dMVEY6ICdLSFJfYmluYXJ5X2dsVEYnLFxuXHRLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjogJ0tIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uJyxcblx0S0hSX0xJR0hUU19QVU5DVFVBTDogJ0tIUl9saWdodHNfcHVuY3R1YWwnLFxuXHRLSFJfTUFURVJJQUxTX0NMRUFSQ09BVDogJ0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0Jyxcblx0S0hSX01BVEVSSUFMU19JT1I6ICdLSFJfbWF0ZXJpYWxzX2lvcicsXG5cdEtIUl9NQVRFUklBTFNfU0hFRU46ICdLSFJfbWF0ZXJpYWxzX3NoZWVuJyxcblx0S0hSX01BVEVSSUFMU19TUEVDVUxBUjogJ0tIUl9tYXRlcmlhbHNfc3BlY3VsYXInLFxuXHRLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjogJ0tIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uJyxcblx0S0hSX01BVEVSSUFMU19JUklERVNDRU5DRTogJ0tIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2UnLFxuXHRLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFk6ICdLSFJfbWF0ZXJpYWxzX2FuaXNvdHJvcHknLFxuXHRLSFJfTUFURVJJQUxTX1VOTElUOiAnS0hSX21hdGVyaWFsc191bmxpdCcsXG5cdEtIUl9NQVRFUklBTFNfVk9MVU1FOiAnS0hSX21hdGVyaWFsc192b2x1bWUnLFxuXHRLSFJfVEVYVFVSRV9CQVNJU1U6ICdLSFJfdGV4dHVyZV9iYXNpc3UnLFxuXHRLSFJfVEVYVFVSRV9UUkFOU0ZPUk06ICdLSFJfdGV4dHVyZV90cmFuc2Zvcm0nLFxuXHRLSFJfTUVTSF9RVUFOVElaQVRJT046ICdLSFJfbWVzaF9xdWFudGl6YXRpb24nLFxuXHRLSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIOiAnS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aCcsXG5cdEVYVF9NQVRFUklBTFNfQlVNUDogJ0VYVF9tYXRlcmlhbHNfYnVtcCcsXG5cdEVYVF9URVhUVVJFX1dFQlA6ICdFWFRfdGV4dHVyZV93ZWJwJyxcblx0RVhUX1RFWFRVUkVfQVZJRjogJ0VYVF90ZXh0dXJlX2F2aWYnLFxuXHRFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjogJ0VYVF9tZXNob3B0X2NvbXByZXNzaW9uJyxcblx0RVhUX01FU0hfR1BVX0lOU1RBTkNJTkc6ICdFWFRfbWVzaF9ncHVfaW5zdGFuY2luZydcbn07XG5cbi8qKlxuICogUHVuY3R1YWwgTGlnaHRzIEV4dGVuc2lvblxuICpcbiAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9saWdodHNfcHVuY3R1YWxcbiAqL1xuY2xhc3MgR0xURkxpZ2h0c0V4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTDtcblxuXHRcdC8vIE9iamVjdDNEIGluc3RhbmNlIGNhY2hlc1xuXHRcdHRoaXMuY2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuXG5cdH1cblxuXHRfbWFya0RlZnMoKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHRjb25zdCBub2RlRGVmcyA9IHRoaXMucGFyc2VyLmpzb24ubm9kZXMgfHwgW107XG5cblx0XHRmb3IgKCBsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4ICsrICkge1xuXG5cdFx0XHRjb25zdCBub2RlRGVmID0gbm9kZURlZnNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYuZXh0ZW5zaW9uc1xuXHRcdFx0XHRcdCYmIG5vZGVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF1cblx0XHRcdFx0XHQmJiBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmxpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGFyc2VyLl9hZGROb2RlUmVmKCB0aGlzLmNhY2hlLCBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmxpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0X2xvYWRMaWdodCggbGlnaHRJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IGNhY2hlS2V5ID0gJ2xpZ2h0OicgKyBsaWdodEluZGV4O1xuXHRcdGxldCBkZXBlbmRlbmN5ID0gcGFyc2VyLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdGlmICggZGVwZW5kZW5jeSApIHJldHVybiBkZXBlbmRlbmN5O1xuXG5cdFx0Y29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSAoIGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgfHwge307XG5cdFx0Y29uc3QgbGlnaHREZWZzID0gZXh0ZW5zaW9ucy5saWdodHMgfHwgW107XG5cdFx0Y29uc3QgbGlnaHREZWYgPSBsaWdodERlZnNbIGxpZ2h0SW5kZXggXTtcblx0XHRsZXQgbGlnaHROb2RlO1xuXG5cdFx0Y29uc3QgY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0XHRpZiAoIGxpZ2h0RGVmLmNvbG9yICE9PSB1bmRlZmluZWQgKSBjb2xvci5zZXRSR0IoIGxpZ2h0RGVmLmNvbG9yWyAwIF0sIGxpZ2h0RGVmLmNvbG9yWyAxIF0sIGxpZ2h0RGVmLmNvbG9yWyAyIF0sIExpbmVhclNSR0JDb2xvclNwYWNlICk7XG5cblx0XHRjb25zdCByYW5nZSA9IGxpZ2h0RGVmLnJhbmdlICE9PSB1bmRlZmluZWQgPyBsaWdodERlZi5yYW5nZSA6IDA7XG5cblx0XHRzd2l0Y2ggKCBsaWdodERlZi50eXBlICkge1xuXG5cdFx0XHRjYXNlICdkaXJlY3Rpb25hbCc6XG5cdFx0XHRcdGxpZ2h0Tm9kZSA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBjb2xvciApO1xuXHRcdFx0XHRsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCggMCwgMCwgLSAxICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5hZGQoIGxpZ2h0Tm9kZS50YXJnZXQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3BvaW50Jzpcblx0XHRcdFx0bGlnaHROb2RlID0gbmV3IFBvaW50TGlnaHQoIGNvbG9yICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnc3BvdCc6XG5cdFx0XHRcdGxpZ2h0Tm9kZSA9IG5ldyBTcG90TGlnaHQoIGNvbG9yICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuXHRcdFx0XHQvLyBIYW5kbGUgc3BvdGxpZ2h0IHByb3BlcnRpZXMuXG5cdFx0XHRcdGxpZ2h0RGVmLnNwb3QgPSBsaWdodERlZi5zcG90IHx8IHt9O1xuXHRcdFx0XHRsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAhPT0gdW5kZWZpbmVkID8gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA6IDA7XG5cdFx0XHRcdGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlICE9PSB1bmRlZmluZWQgPyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlIDogTWF0aC5QSSAvIDQuMDtcblx0XHRcdFx0bGlnaHROb2RlLmFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcblx0XHRcdFx0bGlnaHROb2RlLnBlbnVtYnJhID0gMS4wIC0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAvIGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG5cdFx0XHRcdGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KCAwLCAwLCAtIDEgKTtcblx0XHRcdFx0bGlnaHROb2RlLmFkZCggbGlnaHROb2RlLnRhcmdldCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5leHBlY3RlZCBsaWdodCB0eXBlOiAnICsgbGlnaHREZWYudHlwZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gU29tZSBsaWdodHMgKGUuZy4gc3BvdCkgZGVmYXVsdCB0byBhIHBvc2l0aW9uIG90aGVyIHRoYW4gdGhlIG9yaWdpbi4gUmVzZXQgdGhlIHBvc2l0aW9uXG5cdFx0Ly8gaGVyZSwgYmVjYXVzZSBub2RlLWxldmVsIHBhcnNpbmcgd2lsbCBvbmx5IG92ZXJyaWRlIHBvc2l0aW9uIGlmIGV4cGxpY2l0bHkgc3BlY2lmaWVkLlxuXHRcdGxpZ2h0Tm9kZS5wb3NpdGlvbi5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdGxpZ2h0Tm9kZS5kZWNheSA9IDI7XG5cblx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBsaWdodE5vZGUsIGxpZ2h0RGVmICk7XG5cblx0XHRpZiAoIGxpZ2h0RGVmLmludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbGlnaHROb2RlLmludGVuc2l0eSA9IGxpZ2h0RGVmLmludGVuc2l0eTtcblxuXHRcdGxpZ2h0Tm9kZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoIGxpZ2h0RGVmLm5hbWUgfHwgKCAnbGlnaHRfJyArIGxpZ2h0SW5kZXggKSApO1xuXG5cdFx0ZGVwZW5kZW5jeSA9IFByb21pc2UucmVzb2x2ZSggbGlnaHROb2RlICk7XG5cblx0XHRwYXJzZXIuY2FjaGUuYWRkKCBjYWNoZUtleSwgZGVwZW5kZW5jeSApO1xuXG5cdFx0cmV0dXJuIGRlcGVuZGVuY3k7XG5cblx0fVxuXG5cdGdldERlcGVuZGVuY3koIHR5cGUsIGluZGV4ICkge1xuXG5cdFx0aWYgKCB0eXBlICE9PSAnbGlnaHQnICkgcmV0dXJuO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRMaWdodCggaW5kZXggKTtcblxuXHR9XG5cblx0Y3JlYXRlTm9kZUF0dGFjaG1lbnQoIG5vZGVJbmRleCApIHtcblxuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcblx0XHRjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1sgbm9kZUluZGV4IF07XG5cdFx0Y29uc3QgbGlnaHREZWYgPSAoIG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgfHwge307XG5cdFx0Y29uc3QgbGlnaHRJbmRleCA9IGxpZ2h0RGVmLmxpZ2h0O1xuXG5cdFx0aWYgKCBsaWdodEluZGV4ID09PSB1bmRlZmluZWQgKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzLl9sb2FkTGlnaHQoIGxpZ2h0SW5kZXggKS50aGVuKCBmdW5jdGlvbiAoIGxpZ2h0ICkge1xuXG5cdFx0XHRyZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKCBzZWxmLmNhY2hlLCBsaWdodEluZGV4LCBsaWdodCApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIFVubGl0IE1hdGVyaWFscyBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX3VubGl0XG4gKi9cbmNsYXNzIEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ7XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsVHlwZSgpIHtcblxuXHRcdHJldHVybiBNZXNoQmFzaWNNYXRlcmlhbDtcblxuXHR9XG5cblx0ZXh0ZW5kUGFyYW1zKCBtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlciApIHtcblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKCAxLjAsIDEuMCwgMS4wICk7XG5cdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDEuMDtcblxuXHRcdGNvbnN0IG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3M7XG5cblx0XHRpZiAoIG1ldGFsbGljUm91Z2huZXNzICkge1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvciApICkge1xuXG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yLnNldFJHQiggYXJyYXlbIDAgXSwgYXJyYXlbIDEgXSwgYXJyYXlbIDIgXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UgKTtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WyAzIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIE1hdGVyaWFscyBFbWlzc2l2ZSBTdHJlbmd0aCBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi81NzY4YjNjZTBlZjMyYmMzOWNkZjFiZWYxMGI5NDg1ODY2MzVlYWQzL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aC9SRUFETUUubWRcbiAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEg7XG5cblx0fVxuXG5cdGV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBlbWlzc2l2ZVN0cmVuZ3RoID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0uZW1pc3NpdmVTdHJlbmd0aDtcblxuXHRcdGlmICggZW1pc3NpdmVTdHJlbmd0aCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZUludGVuc2l0eSA9IGVtaXNzaXZlU3RyZW5ndGg7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogQ2xlYXJjb2F0IE1hdGVyaWFscyBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX2NsZWFyY29hdFxuICovXG5jbGFzcyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0NMRUFSQ09BVDtcblxuXHR9XG5cblx0Z2V0TWF0ZXJpYWxUeXBlKCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcblxuXHR9XG5cblx0ZXh0ZW5kTWF0ZXJpYWxQYXJhbXMoIG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdCA9IGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3I7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnY2xlYXJjb2F0TWFwJywgZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdFJvdWdobmVzcyA9IGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3I7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnY2xlYXJjb2F0Um91Z2huZXNzTWFwJywgZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2NsZWFyY29hdE5vcm1hbE1hcCcsIGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlICkgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnN0IHNjYWxlID0gZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGU7XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggc2NhbGUsIHNjYWxlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIElyaWRlc2NlbmNlIE1hdGVyaWFscyBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlXG4gKi9cbmNsYXNzIEdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JUklERVNDRU5DRTtcblxuXHR9XG5cblx0Z2V0TWF0ZXJpYWxUeXBlKCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcblxuXHR9XG5cblx0ZXh0ZW5kTWF0ZXJpYWxQYXJhbXMoIG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0aWYgKCBleHRlbnNpb24uaXJpZGVzY2VuY2VGYWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2UgPSBleHRlbnNpb24uaXJpZGVzY2VuY2VGYWN0b3I7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdpcmlkZXNjZW5jZU1hcCcsIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uaXJpZGVzY2VuY2VJb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VJT1IgPSBleHRlbnNpb24uaXJpZGVzY2VuY2VJb3I7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsgMTAwLCA0MDAgXTtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWyAwIF0gPSBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbIDEgXSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW07XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdpcmlkZXNjZW5jZVRoaWNrbmVzc01hcCcsIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogU2hlZW4gTWF0ZXJpYWxzIEV4dGVuc2lvblxuICpcbiAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21haW4vZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX3NoZWVuXG4gKi9cbmNsYXNzIEdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TSEVFTjtcblxuXHR9XG5cblx0Z2V0TWF0ZXJpYWxUeXBlKCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcblxuXHR9XG5cblx0ZXh0ZW5kTWF0ZXJpYWxQYXJhbXMoIG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdG1hdGVyaWFsUGFyYW1zLnNoZWVuQ29sb3IgPSBuZXcgQ29sb3IoIDAsIDAsIDAgKTtcblx0XHRtYXRlcmlhbFBhcmFtcy5zaGVlblJvdWdobmVzcyA9IDA7XG5cdFx0bWF0ZXJpYWxQYXJhbXMuc2hlZW4gPSAxO1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5zaGVlbkNvbG9yRmFjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGNvbG9yRmFjdG9yID0gZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3I7XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5zaGVlbkNvbG9yLnNldFJHQiggY29sb3JGYWN0b3JbIDAgXSwgY29sb3JGYWN0b3JbIDEgXSwgY29sb3JGYWN0b3JbIDIgXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzRmFjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLnNoZWVuUm91Z2huZXNzID0gZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzRmFjdG9yO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uc2hlZW5Db2xvclRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdzaGVlbkNvbG9yTWFwJywgZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc1RleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdzaGVlblJvdWdobmVzc01hcCcsIGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc1RleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogVHJhbnNtaXNzaW9uIE1hdGVyaWFscyBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvblxuICogRHJhZnQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9wdWxsLzE2OThcbiAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT047XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsVHlwZSggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdGlmICggZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy50cmFuc21pc3Npb24gPSBleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3RyYW5zbWlzc2lvbk1hcCcsIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIE1hdGVyaWFscyBWb2x1bWUgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc192b2x1bWVcbiAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiB7XG5cblx0Y29uc3RydWN0b3IoIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19WT0xVTUU7XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsVHlwZSggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdG1hdGVyaWFsUGFyYW1zLnRoaWNrbmVzcyA9IGV4dGVuc2lvbi50aGlja25lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCA/IGV4dGVuc2lvbi50aGlja25lc3NGYWN0b3IgOiAwO1xuXG5cdFx0aWYgKCBleHRlbnNpb24udGhpY2tuZXNzVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3RoaWNrbmVzc01hcCcsIGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdG1hdGVyaWFsUGFyYW1zLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBleHRlbnNpb24uYXR0ZW51YXRpb25EaXN0YW5jZSB8fCBJbmZpbml0eTtcblxuXHRcdGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uYXR0ZW51YXRpb25Db2xvciB8fCBbIDEsIDEsIDEgXTtcblx0XHRtYXRlcmlhbFBhcmFtcy5hdHRlbnVhdGlvbkNvbG9yID0gbmV3IENvbG9yKCkuc2V0UkdCKCBjb2xvckFycmF5WyAwIF0sIGNvbG9yQXJyYXlbIDEgXSwgY29sb3JBcnJheVsgMiBdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSApO1xuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogTWF0ZXJpYWxzIGlvciBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX2lvclxuICovXG5jbGFzcyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0lPUjtcblxuXHR9XG5cblx0Z2V0TWF0ZXJpYWxUeXBlKCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcblxuXHR9XG5cblx0ZXh0ZW5kTWF0ZXJpYWxQYXJhbXMoIG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0bWF0ZXJpYWxQYXJhbXMuaW9yID0gZXh0ZW5zaW9uLmlvciAhPT0gdW5kZWZpbmVkID8gZXh0ZW5zaW9uLmlvciA6IDEuNTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBNYXRlcmlhbHMgc3BlY3VsYXIgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19zcGVjdWxhclxuICovXG5jbGFzcyBHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfU1BFQ1VMQVI7XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsVHlwZSggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFySW50ZW5zaXR5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yICE9PSB1bmRlZmluZWQgPyBleHRlbnNpb24uc3BlY3VsYXJGYWN0b3IgOiAxLjA7XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5zcGVjdWxhclRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdzcGVjdWxhckludGVuc2l0eU1hcCcsIGV4dGVuc2lvbi5zcGVjdWxhclRleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgY29sb3JBcnJheSA9IGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yRmFjdG9yIHx8IFsgMSwgMSwgMSBdO1xuXHRcdG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyQ29sb3IgPSBuZXcgQ29sb3IoKS5zZXRSR0IoIGNvbG9yQXJyYXlbIDAgXSwgY29sb3JBcnJheVsgMSBdLCBjb2xvckFycmF5WyAyIF0sIExpbmVhclNSR0JDb2xvclNwYWNlICk7XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3NwZWN1bGFyQ29sb3JNYXAnLCBleHRlbnNpb24uc3BlY3VsYXJDb2xvclRleHR1cmUsIFNSR0JDb2xvclNwYWNlICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH1cblxufVxuXG5cbi8qKlxuICogTWF0ZXJpYWxzIGJ1bXAgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvRVhUX21hdGVyaWFsc19idW1wXG4gKi9cbmNsYXNzIEdMVEZNYXRlcmlhbHNCdW1wRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUFURVJJQUxTX0JVTVA7XG5cblx0fVxuXG5cdGdldE1hdGVyaWFsVHlwZSggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fVxuXG5cdGV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwZW5kaW5nID0gW107XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdG1hdGVyaWFsUGFyYW1zLmJ1bXBTY2FsZSA9IGV4dGVuc2lvbi5idW1wRmFjdG9yICE9PSB1bmRlZmluZWQgPyBleHRlbnNpb24uYnVtcEZhY3RvciA6IDEuMDtcblxuXHRcdGlmICggZXh0ZW5zaW9uLmJ1bXBUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnYnVtcE1hcCcsIGV4dGVuc2lvbi5idW1wVGV4dHVyZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBNYXRlcmlhbHMgYW5pc290cm9weSBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX2FuaXNvdHJvcHlcbiAqL1xuY2xhc3MgR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfQU5JU09UUk9QWTtcblxuXHR9XG5cblx0Z2V0TWF0ZXJpYWxUeXBlKCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcblxuXHR9XG5cblx0ZXh0ZW5kTWF0ZXJpYWxQYXJhbXMoIG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0Y29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0aWYgKCBleHRlbnNpb24uYW5pc290cm9weVN0cmVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmFuaXNvdHJvcHkgPSBleHRlbnNpb24uYW5pc290cm9weVN0cmVuZ3RoO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uYW5pc290cm9weVJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmFuaXNvdHJvcHlSb3RhdGlvbiA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5Um90YXRpb247XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5hbmlzb3Ryb3B5VGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2FuaXNvdHJvcHlNYXAnLCBleHRlbnNpb24uYW5pc290cm9weVRleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogQmFzaXNVIFRleHR1cmUgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX3RleHR1cmVfYmFzaXN1XG4gKi9cbmNsYXNzIEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9CQVNJU1U7XG5cblx0fVxuXG5cdGxvYWRUZXh0dXJlKCB0ZXh0dXJlSW5kZXggKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHRjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG5cblx0XHRjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1sgdGV4dHVyZUluZGV4IF07XG5cblx0XHRpZiAoICEgdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICEgdGV4dHVyZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXHRcdGNvbnN0IGxvYWRlciA9IHBhcnNlci5vcHRpb25zLmt0eDJMb2FkZXI7XG5cblx0XHRpZiAoICEgbG9hZGVyICkge1xuXG5cdFx0XHRpZiAoIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoIHRoaXMubmFtZSApID49IDAgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogc2V0S1RYMkxvYWRlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBLVFgyIHRleHR1cmVzJyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEFzc3VtZXMgdGhhdCB0aGUgZXh0ZW5zaW9uIGlzIG9wdGlvbmFsIGFuZCB0aGF0IGEgZmFsbGJhY2sgdGV4dHVyZSBpcyBwcmVzZW50XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UoIHRleHR1cmVJbmRleCwgZXh0ZW5zaW9uLnNvdXJjZSwgbG9hZGVyICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogV2ViUCBUZXh0dXJlIEV4dGVuc2lvblxuICpcbiAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9WZW5kb3IvRVhUX3RleHR1cmVfd2VicFxuICovXG5jbGFzcyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX1dFQlA7XG5cdFx0dGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG5cblx0fVxuXG5cdGxvYWRUZXh0dXJlKCB0ZXh0dXJlSW5kZXggKSB7XG5cblx0XHRjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcblxuXHRcdGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblxuXHRcdGlmICggISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIG5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIG5hbWUgXTtcblx0XHRjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1sgZXh0ZW5zaW9uLnNvdXJjZSBdO1xuXG5cdFx0bGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuXHRcdGlmICggc291cmNlLnVyaSApIHtcblxuXHRcdFx0Y29uc3QgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlciggc291cmNlLnVyaSApO1xuXHRcdFx0aWYgKCBoYW5kbGVyICE9PSBudWxsICkgbG9hZGVyID0gaGFuZGxlcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKCBmdW5jdGlvbiAoIGlzU3VwcG9ydGVkICkge1xuXG5cdFx0XHRpZiAoIGlzU3VwcG9ydGVkICkgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlciApO1xuXG5cdFx0XHRpZiAoIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoIG5hbWUgKSA+PSAwICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFdlYlAgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGYWxsIGJhY2sgdG8gUE5HIG9yIEpQRUcuXG5cdFx0XHRyZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlKCB0ZXh0dXJlSW5kZXggKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0ZGV0ZWN0U3VwcG9ydCgpIHtcblxuXHRcdGlmICggISB0aGlzLmlzU3VwcG9ydGVkICkge1xuXG5cdFx0XHR0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSApIHtcblxuXHRcdFx0XHRjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG5cdFx0XHRcdC8vIExvc3N5IHRlc3QgaW1hZ2UuIFN1cHBvcnQgZm9yIGxvc3N5IGltYWdlcyBkb2Vzbid0IGd1YXJhbnRlZSBzdXBwb3J0IGZvciBhbGxcblx0XHRcdFx0Ly8gV2ViUCBpbWFnZXMsIHVuZm9ydHVuYXRlbHkuXG5cdFx0XHRcdGltYWdlLnNyYyA9ICdkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaUlBQUFCWFJVSlFWbEE0SUJZQUFBQXdBUUNkQVNvQkFBRUFEc0QrSmFRQUEzQUFBQUFBJztcblxuXHRcdFx0XHRpbWFnZS5vbmxvYWQgPSBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0cmVzb2x2ZSggaW1hZ2UuaGVpZ2h0ID09PSAxICk7XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG5cblx0fVxuXG59XG5cbi8qKlxuICogQVZJRiBUZXh0dXJlIEV4dGVuc2lvblxuICpcbiAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9WZW5kb3IvRVhUX3RleHR1cmVfYXZpZlxuICovXG5jbGFzcyBHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX0FWSUY7XG5cdFx0dGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG5cblx0fVxuXG5cdGxvYWRUZXh0dXJlKCB0ZXh0dXJlSW5kZXggKSB7XG5cblx0XHRjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcblxuXHRcdGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblxuXHRcdGlmICggISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIG5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIG5hbWUgXTtcblx0XHRjb25zdCBzb3VyY2UgPSBqc29uLmltYWdlc1sgZXh0ZW5zaW9uLnNvdXJjZSBdO1xuXG5cdFx0bGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuXHRcdGlmICggc291cmNlLnVyaSApIHtcblxuXHRcdFx0Y29uc3QgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlciggc291cmNlLnVyaSApO1xuXHRcdFx0aWYgKCBoYW5kbGVyICE9PSBudWxsICkgbG9hZGVyID0gaGFuZGxlcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKCBmdW5jdGlvbiAoIGlzU3VwcG9ydGVkICkge1xuXG5cdFx0XHRpZiAoIGlzU3VwcG9ydGVkICkgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlciApO1xuXG5cdFx0XHRpZiAoIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoIG5hbWUgKSA+PSAwICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IEFWSUYgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGYWxsIGJhY2sgdG8gUE5HIG9yIEpQRUcuXG5cdFx0XHRyZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlKCB0ZXh0dXJlSW5kZXggKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0ZGV0ZWN0U3VwcG9ydCgpIHtcblxuXHRcdGlmICggISB0aGlzLmlzU3VwcG9ydGVkICkge1xuXG5cdFx0XHR0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSApIHtcblxuXHRcdFx0XHRjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG5cdFx0XHRcdC8vIExvc3N5IHRlc3QgaW1hZ2UuXG5cdFx0XHRcdGltYWdlLnNyYyA9ICdkYXRhOmltYWdlL2F2aWY7YmFzZTY0LEFBQUFJR1owZVhCaGRtbG1BQUFBQUdGMmFXWnRhV1l4YldsaFprMUJNVUlBQUFEeWJXVjBZUUFBQUFBQUFBQW9hR1JzY2dBQUFBQUFBQUFBY0dsamRBQUFBQUFBQUFBQUFBQUFBR3hwWW1GMmFXWUFBQUFBRG5CcGRHMEFBQUFBQUFFQUFBQWVhV3h2WXdBQUFBQkVBQUFCQUFFQUFBQUJBQUFCR2dBQUFCY0FBQUFvYVdsdVpnQUFBQUFBQVFBQUFCcHBibVpsQWdBQUFBQUJBQUJoZGpBeFEyOXNiM0lBQUFBQWFtbHdjbkFBQUFCTGFYQmpid0FBQUJScGMzQmxBQUFBQUFBQUFBRUFBQUFCQUFBQUVIQnBlR2tBQUFBQUF3Z0lDQUFBQUF4aGRqRkRnUUFNQUFBQUFCTmpiMnh5Ym1Oc2VBQUNBQUlBQm9BQUFBQVhhWEJ0WVFBQUFBQUFBQUFCQUFFRUFRS0RCQUFBQUI5dFpHRjBFZ0FLQ0JnQUJvZ1FFRFFnTWdrUUFBQUFCOGRTTGZJPSc7XG5cdFx0XHRcdGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXNvbHZlKCBpbWFnZS5oZWlnaHQgPT09IDEgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBtZXNob3B0IEJ1ZmZlclZpZXcgQ29tcHJlc3Npb24gRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL1ZlbmRvci9FWFRfbWVzaG9wdF9jb21wcmVzc2lvblxuICovXG5jbGFzcyBHTFRGTWVzaG9wdENvbXByZXNzaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSE9QVF9DT01QUkVTU0lPTjtcblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblxuXHR9XG5cblx0bG9hZEJ1ZmZlclZpZXcoIGluZGV4ICkge1xuXG5cdFx0Y29uc3QganNvbiA9IHRoaXMucGFyc2VyLmpzb247XG5cdFx0Y29uc3QgYnVmZmVyVmlldyA9IGpzb24uYnVmZmVyVmlld3NbIGluZGV4IF07XG5cblx0XHRpZiAoIGJ1ZmZlclZpZXcuZXh0ZW5zaW9ucyAmJiBidWZmZXJWaWV3LmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRjb25zdCBleHRlbnNpb25EZWYgPSBidWZmZXJWaWV3LmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyJywgZXh0ZW5zaW9uRGVmLmJ1ZmZlciApO1xuXHRcdFx0Y29uc3QgZGVjb2RlciA9IHRoaXMucGFyc2VyLm9wdGlvbnMubWVzaG9wdERlY29kZXI7XG5cblx0XHRcdGlmICggISBkZWNvZGVyIHx8ICEgZGVjb2Rlci5zdXBwb3J0ZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKCB0aGlzLm5hbWUgKSA+PSAwICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogc2V0TWVzaG9wdERlY29kZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgY29tcHJlc3NlZCBmaWxlcycgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gQXNzdW1lcyB0aGF0IHRoZSBleHRlbnNpb24gaXMgb3B0aW9uYWwgYW5kIHRoYXQgZmFsbGJhY2sgYnVmZmVyIGRhdGEgaXMgcHJlc2VudFxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVmZmVyLnRoZW4oIGZ1bmN0aW9uICggcmVzICkge1xuXG5cdFx0XHRcdGNvbnN0IGJ5dGVPZmZzZXQgPSBleHRlbnNpb25EZWYuYnl0ZU9mZnNldCB8fCAwO1xuXHRcdFx0XHRjb25zdCBieXRlTGVuZ3RoID0gZXh0ZW5zaW9uRGVmLmJ5dGVMZW5ndGggfHwgMDtcblxuXHRcdFx0XHRjb25zdCBjb3VudCA9IGV4dGVuc2lvbkRlZi5jb3VudDtcblx0XHRcdFx0Y29uc3Qgc3RyaWRlID0gZXh0ZW5zaW9uRGVmLmJ5dGVTdHJpZGU7XG5cblx0XHRcdFx0Y29uc3Qgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoIHJlcywgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCApO1xuXG5cdFx0XHRcdGlmICggZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyQXN5bmMgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyQXN5bmMoIGNvdW50LCBzdHJpZGUsIHNvdXJjZSwgZXh0ZW5zaW9uRGVmLm1vZGUsIGV4dGVuc2lvbkRlZi5maWx0ZXIgKS50aGVuKCBmdW5jdGlvbiAoIHJlcyApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcy5idWZmZXI7XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQgZm9yIE1lc2hvcHREZWNvZGVyIDAuMTggb3IgZWFybGllciwgd2l0aG91dCBkZWNvZGVHbHRmQnVmZmVyQXN5bmNcblx0XHRcdFx0XHRyZXR1cm4gZGVjb2Rlci5yZWFkeS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlciggY291bnQgKiBzdHJpZGUgKTtcblx0XHRcdFx0XHRcdGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlciggbmV3IFVpbnQ4QXJyYXkoIHJlc3VsdCApLCBjb3VudCwgc3RyaWRlLCBzb3VyY2UsIGV4dGVuc2lvbkRlZi5tb2RlLCBleHRlbnNpb25EZWYuZmlsdGVyICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8qKlxuICogR1BVIEluc3RhbmNpbmcgRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL1ZlbmRvci9FWFRfbWVzaF9ncHVfaW5zdGFuY2luZ1xuICpcbiAqL1xuY2xhc3MgR0xURk1lc2hHcHVJbnN0YW5jaW5nIHtcblxuXHRjb25zdHJ1Y3RvciggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSF9HUFVfSU5TVEFOQ0lORztcblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblxuXHR9XG5cblx0Y3JlYXRlTm9kZU1lc2goIG5vZGVJbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuXHRcdGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdGlmICggISBub2RlRGVmLmV4dGVuc2lvbnMgfHwgISBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdIHx8XG5cdFx0XHRub2RlRGVmLm1lc2ggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRjb25zdCBtZXNoRGVmID0ganNvbi5tZXNoZXNbIG5vZGVEZWYubWVzaCBdO1xuXG5cdFx0Ly8gTm8gUG9pbnRzIG9yIExpbmVzICsgSW5zdGFuY2luZyBzdXBwb3J0IHlldFxuXG5cdFx0Zm9yICggY29uc3QgcHJpbWl0aXZlIG9mIG1lc2hEZWYucHJpbWl0aXZlcyApIHtcblxuXHRcdFx0aWYgKCBwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyAmJlxuXHRcdFx0XHQgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCAmJlxuXHRcdFx0XHQgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gJiZcblx0XHRcdFx0IHByaW1pdGl2ZS5tb2RlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGV4dGVuc2lvbkRlZiA9IG5vZGVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cdFx0Y29uc3QgYXR0cmlidXRlc0RlZiA9IGV4dGVuc2lvbkRlZi5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gQFRPRE86IENhbiB3ZSBzdXBwb3J0IEluc3RhbmNlZE1lc2ggKyBTa2lubmVkTWVzaD9cblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0ge307XG5cblx0XHRmb3IgKCBjb25zdCBrZXkgaW4gYXR0cmlidXRlc0RlZiApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCBhdHRyaWJ1dGVzRGVmWyBrZXkgXSApLnRoZW4oIGFjY2Vzc29yID0+IHtcblxuXHRcdFx0XHRhdHRyaWJ1dGVzWyBrZXkgXSA9IGFjY2Vzc29yO1xuXHRcdFx0XHRyZXR1cm4gYXR0cmlidXRlc1sga2V5IF07XG5cblx0XHRcdH0gKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwZW5kaW5nLmxlbmd0aCA8IDEgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0cGVuZGluZy5wdXNoKCB0aGlzLnBhcnNlci5jcmVhdGVOb2RlTWVzaCggbm9kZUluZGV4ICkgKTtcblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIHJlc3VsdHMgPT4ge1xuXG5cdFx0XHRjb25zdCBub2RlT2JqZWN0ID0gcmVzdWx0cy5wb3AoKTtcblx0XHRcdGNvbnN0IG1lc2hlcyA9IG5vZGVPYmplY3QuaXNHcm91cCA/IG5vZGVPYmplY3QuY2hpbGRyZW4gOiBbIG5vZGVPYmplY3QgXTtcblx0XHRcdGNvbnN0IGNvdW50ID0gcmVzdWx0c1sgMCBdLmNvdW50OyAvLyBBbGwgYXR0cmlidXRlIGNvdW50cyBzaG91bGQgYmUgc2FtZVxuXHRcdFx0Y29uc3QgaW5zdGFuY2VkTWVzaGVzID0gW107XG5cblx0XHRcdGZvciAoIGNvbnN0IG1lc2ggb2YgbWVzaGVzICkge1xuXG5cdFx0XHRcdC8vIFRlbXBvcmFsIHZhcmlhYmxlc1xuXHRcdFx0XHRjb25zdCBtID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdFx0Y29uc3QgcCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpO1xuXHRcdFx0XHRjb25zdCBzID0gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcblxuXHRcdFx0XHRjb25zdCBpbnN0YW5jZWRNZXNoID0gbmV3IEluc3RhbmNlZE1lc2goIG1lc2guZ2VvbWV0cnksIG1lc2gubWF0ZXJpYWwsIGNvdW50ICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuVFJBTlNMQVRJT04gKSB7XG5cblx0XHRcdFx0XHRcdHAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlcy5UUkFOU0xBVElPTiwgaSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLlJPVEFUSU9OICkge1xuXG5cdFx0XHRcdFx0XHRxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuUk9UQVRJT04sIGkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlcy5TQ0FMRSApIHtcblxuXHRcdFx0XHRcdFx0cy5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGVzLlNDQUxFLCBpICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KCBpLCBtLmNvbXBvc2UoIHAsIHEsIHMgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgaW5zdGFuY2UgYXR0cmlidXRlcyB0byB0aGUgZ2VvbWV0cnksIGV4Y2x1ZGluZyBUUlMuXG5cdFx0XHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlTmFtZSA9PT0gJ19DT0xPUl8wJyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbIGF0dHJpYnV0ZU5hbWUgXTtcblx0XHRcdFx0XHRcdGluc3RhbmNlZE1lc2guaW5zdGFuY2VDb2xvciA9IG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoIGF0dHIuYXJyYXksIGF0dHIuaXRlbVNpemUsIGF0dHIubm9ybWFsaXplZCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYXR0cmlidXRlTmFtZSAhPT0gJ1RSQU5TTEFUSU9OJyAmJlxuXHRcdFx0XHRcdFx0IGF0dHJpYnV0ZU5hbWUgIT09ICdST1RBVElPTicgJiZcblx0XHRcdFx0XHRcdCBhdHRyaWJ1dGVOYW1lICE9PSAnU0NBTEUnICkge1xuXG5cdFx0XHRcdFx0XHRtZXNoLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEp1c3QgaW4gY2FzZVxuXHRcdFx0XHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCBpbnN0YW5jZWRNZXNoLCBtZXNoICk7XG5cblx0XHRcdFx0dGhpcy5wYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbCggaW5zdGFuY2VkTWVzaCApO1xuXG5cdFx0XHRcdGluc3RhbmNlZE1lc2hlcy5wdXNoKCBpbnN0YW5jZWRNZXNoICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlT2JqZWN0LmlzR3JvdXAgKSB7XG5cblx0XHRcdFx0bm9kZU9iamVjdC5jbGVhcigpO1xuXG5cdFx0XHRcdG5vZGVPYmplY3QuYWRkKCAuLi4gaW5zdGFuY2VkTWVzaGVzICk7XG5cblx0XHRcdFx0cmV0dXJuIG5vZGVPYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGluc3RhbmNlZE1lc2hlc1sgMCBdO1xuXG5cdFx0fSApO1xuXG5cdH1cblxufVxuXG4vKiBCSU5BUlkgRVhURU5TSU9OICovXG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyA9ICdnbFRGJztcbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCA9IDEyO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUyA9IHsgSlNPTjogMHg0RTRGNTM0QSwgQklOOiAweDAwNEU0OTQyIH07XG5cbmNsYXNzIEdMVEZCaW5hcnlFeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBkYXRhICkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEY7XG5cdFx0dGhpcy5jb250ZW50ID0gbnVsbDtcblx0XHR0aGlzLmJvZHkgPSBudWxsO1xuXG5cdFx0Y29uc3QgaGVhZGVyVmlldyA9IG5ldyBEYXRhVmlldyggZGF0YSwgMCwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICk7XG5cdFx0Y29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcblxuXHRcdHRoaXMuaGVhZGVyID0ge1xuXHRcdFx0bWFnaWM6IHRleHREZWNvZGVyLmRlY29kZSggbmV3IFVpbnQ4QXJyYXkoIGRhdGEuc2xpY2UoIDAsIDQgKSApICksXG5cdFx0XHR2ZXJzaW9uOiBoZWFkZXJWaWV3LmdldFVpbnQzMiggNCwgdHJ1ZSApLFxuXHRcdFx0bGVuZ3RoOiBoZWFkZXJWaWV3LmdldFVpbnQzMiggOCwgdHJ1ZSApXG5cdFx0fTtcblxuXHRcdGlmICggdGhpcy5oZWFkZXIubWFnaWMgIT09IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBnbFRGLUJpbmFyeSBoZWFkZXIuJyApO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5oZWFkZXIudmVyc2lvbiA8IDIuMCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogTGVnYWN5IGJpbmFyeSBmaWxlIGRldGVjdGVkLicgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGNodW5rQ29udGVudHNMZW5ndGggPSB0aGlzLmhlYWRlci5sZW5ndGggLSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEg7XG5cdFx0Y29uc3QgY2h1bmtWaWV3ID0gbmV3IERhdGFWaWV3KCBkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKTtcblx0XHRsZXQgY2h1bmtJbmRleCA9IDA7XG5cblx0XHR3aGlsZSAoIGNodW5rSW5kZXggPCBjaHVua0NvbnRlbnRzTGVuZ3RoICkge1xuXG5cdFx0XHRjb25zdCBjaHVua0xlbmd0aCA9IGNodW5rVmlldy5nZXRVaW50MzIoIGNodW5rSW5kZXgsIHRydWUgKTtcblx0XHRcdGNodW5rSW5kZXggKz0gNDtcblxuXHRcdFx0Y29uc3QgY2h1bmtUeXBlID0gY2h1bmtWaWV3LmdldFVpbnQzMiggY2h1bmtJbmRleCwgdHJ1ZSApO1xuXHRcdFx0Y2h1bmtJbmRleCArPSA0O1xuXG5cdFx0XHRpZiAoIGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5KU09OICkge1xuXG5cdFx0XHRcdGNvbnN0IGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KCBkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4LCBjaHVua0xlbmd0aCApO1xuXHRcdFx0XHR0aGlzLmNvbnRlbnQgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoIGNvbnRlbnRBcnJheSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuQklOICkge1xuXG5cdFx0XHRcdGNvbnN0IGJ5dGVPZmZzZXQgPSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4O1xuXHRcdFx0XHR0aGlzLmJvZHkgPSBkYXRhLnNsaWNlKCBieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgY2h1bmtMZW5ndGggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGllbnRzIG11c3QgaWdub3JlIGNodW5rcyB3aXRoIHVua25vd24gdHlwZXMuXG5cblx0XHRcdGNodW5rSW5kZXggKz0gY2h1bmtMZW5ndGg7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY29udGVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogSlNPTiBjb250ZW50IG5vdCBmb3VuZC4nICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8qKlxuICogRFJBQ08gTWVzaCBDb21wcmVzc2lvbiBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvblxuICovXG5jbGFzcyBHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCBqc29uLCBkcmFjb0xvYWRlciApIHtcblxuXHRcdGlmICggISBkcmFjb0xvYWRlciApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogTm8gRFJBQ09Mb2FkZXIgaW5zdGFuY2UgcHJvdmlkZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjtcblx0XHR0aGlzLmpzb24gPSBqc29uO1xuXHRcdHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcblx0XHR0aGlzLmRyYWNvTG9hZGVyLnByZWxvYWQoKTtcblxuXHR9XG5cblx0ZGVjb2RlUHJpbWl0aXZlKCBwcmltaXRpdmUsIHBhcnNlciApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgZHJhY29Mb2FkZXIgPSB0aGlzLmRyYWNvTG9hZGVyO1xuXHRcdGNvbnN0IGJ1ZmZlclZpZXdJbmRleCA9IHByaW1pdGl2ZS5leHRlbnNpb25zWyB0aGlzLm5hbWUgXS5idWZmZXJWaWV3O1xuXHRcdGNvbnN0IGdsdGZBdHRyaWJ1dGVNYXAgPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0uYXR0cmlidXRlcztcblx0XHRjb25zdCB0aHJlZUF0dHJpYnV0ZU1hcCA9IHt9O1xuXHRcdGNvbnN0IGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXAgPSB7fTtcblx0XHRjb25zdCBhdHRyaWJ1dGVUeXBlTWFwID0ge307XG5cblx0XHRmb3IgKCBjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGdsdGZBdHRyaWJ1dGVNYXAgKSB7XG5cblx0XHRcdGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbIGF0dHJpYnV0ZU5hbWUgXSB8fCBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdHRocmVlQXR0cmlidXRlTWFwWyB0aHJlZUF0dHJpYnV0ZU5hbWUgXSA9IGdsdGZBdHRyaWJ1dGVNYXBbIGF0dHJpYnV0ZU5hbWUgXTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gcHJpbWl0aXZlLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbIGF0dHJpYnV0ZU5hbWUgXSB8fCBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggZ2x0ZkF0dHJpYnV0ZU1hcFsgYXR0cmlidXRlTmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3QgYWNjZXNzb3JEZWYgPSBqc29uLmFjY2Vzc29yc1sgcHJpbWl0aXZlLmF0dHJpYnV0ZXNbIGF0dHJpYnV0ZU5hbWUgXSBdO1xuXHRcdFx0XHRjb25zdCBjb21wb25lbnRUeXBlID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlIF07XG5cblx0XHRcdFx0YXR0cmlidXRlVHlwZU1hcFsgdGhyZWVBdHRyaWJ1dGVOYW1lIF0gPSBjb21wb25lbnRUeXBlLm5hbWU7XG5cdFx0XHRcdGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbIHRocmVlQXR0cmlidXRlTmFtZSBdID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIGJ1ZmZlclZpZXdJbmRleCApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyVmlldyApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUsIHJlamVjdCApIHtcblxuXHRcdFx0XHRkcmFjb0xvYWRlci5kZWNvZGVEcmFjb0ZpbGUoIGJ1ZmZlclZpZXcsIGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGF0dHJpYnV0ZU5hbWUgXTtcblx0XHRcdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwWyBhdHRyaWJ1dGVOYW1lIF07XG5cblx0XHRcdFx0XHRcdGlmICggbm9ybWFsaXplZCAhPT0gdW5kZWZpbmVkICkgYXR0cmlidXRlLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzb2x2ZSggZ2VvbWV0cnkgKTtcblxuXHRcdFx0XHR9LCB0aHJlZUF0dHJpYnV0ZU1hcCwgYXR0cmlidXRlVHlwZU1hcCwgTGluZWFyU1JHQkNvbG9yU3BhY2UsIHJlamVjdCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG59XG5cbi8qKlxuICogVGV4dHVyZSBUcmFuc2Zvcm0gRXh0ZW5zaW9uXG4gKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX3RleHR1cmVfdHJhbnNmb3JtXG4gKi9cbmNsYXNzIEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNO1xuXG5cdH1cblxuXHRleHRlbmRUZXh0dXJlKCB0ZXh0dXJlLCB0cmFuc2Zvcm0gKSB7XG5cblx0XHRpZiAoICggdHJhbnNmb3JtLnRleENvb3JkID09PSB1bmRlZmluZWQgfHwgdHJhbnNmb3JtLnRleENvb3JkID09PSB0ZXh0dXJlLmNoYW5uZWwgKVxuXHRcdFx0JiYgdHJhbnNmb3JtLm9mZnNldCA9PT0gdW5kZWZpbmVkXG5cdFx0XHQmJiB0cmFuc2Zvcm0ucm90YXRpb24gPT09IHVuZGVmaW5lZFxuXHRcdFx0JiYgdHJhbnNmb3JtLnNjYWxlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8yMTgxOS5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fVxuXG5cdFx0dGV4dHVyZSA9IHRleHR1cmUuY2xvbmUoKTtcblxuXHRcdGlmICggdHJhbnNmb3JtLnRleENvb3JkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUuY2hhbm5lbCA9IHRyYW5zZm9ybS50ZXhDb29yZDtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtLm9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIHRyYW5zZm9ybS5vZmZzZXQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUucm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb247XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYW5zZm9ybS5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIHRyYW5zZm9ybS5zY2FsZSApO1xuXG5cdFx0fVxuXG5cdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cbn1cblxuLyoqXG4gKiBNZXNoIFF1YW50aXphdGlvbiBFeHRlbnNpb25cbiAqXG4gKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWVzaF9xdWFudGl6YXRpb25cbiAqL1xuY2xhc3MgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24ge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT047XG5cblx0fVxuXG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKiBJTlRFUlBPTEFUSU9OICoqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gU3BsaW5lIEludGVycG9sYXRpb25cbi8vIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYXBwZW5kaXgtYy1zcGxpbmUtaW50ZXJwb2xhdGlvblxuY2xhc3MgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG5cblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0XHRzdXBlciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xuXG5cdH1cblxuXHRjb3B5U2FtcGxlVmFsdWVfKCBpbmRleCApIHtcblxuXHRcdC8vIENvcGllcyBhIHNhbXBsZSB2YWx1ZSB0byB0aGUgcmVzdWx0IGJ1ZmZlci4gU2VlIGRlc2NyaXB0aW9uIG9mIGdsVEZcblx0XHQvLyBDVUJJQ1NQTElORSB2YWx1ZXMgbGF5b3V0IGluIGludGVycG9sYXRlXygpIGZ1bmN0aW9uIGJlbG93LlxuXG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdHZhbHVlU2l6ZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0b2Zmc2V0ID0gaW5kZXggKiB2YWx1ZVNpemUgKiAzICsgdmFsdWVTaXplO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSB2YWx1ZVNpemU7IGkgKysgKSB7XG5cblx0XHRcdHJlc3VsdFsgaSBdID0gdmFsdWVzWyBvZmZzZXQgKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRpbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcjtcblx0XHRjb25zdCB2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcztcblx0XHRjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcblxuXHRcdGNvbnN0IHN0cmlkZTIgPSBzdHJpZGUgKiAyO1xuXHRcdGNvbnN0IHN0cmlkZTMgPSBzdHJpZGUgKiAzO1xuXG5cdFx0Y29uc3QgdGQgPSB0MSAtIHQwO1xuXG5cdFx0Y29uc3QgcCA9ICggdCAtIHQwICkgLyB0ZDtcblx0XHRjb25zdCBwcCA9IHAgKiBwO1xuXHRcdGNvbnN0IHBwcCA9IHBwICogcDtcblxuXHRcdGNvbnN0IG9mZnNldDEgPSBpMSAqIHN0cmlkZTM7XG5cdFx0Y29uc3Qgb2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUzO1xuXG5cdFx0Y29uc3QgczIgPSAtIDIgKiBwcHAgKyAzICogcHA7XG5cdFx0Y29uc3QgczMgPSBwcHAgLSBwcDtcblx0XHRjb25zdCBzMCA9IDEgLSBzMjtcblx0XHRjb25zdCBzMSA9IHMzIC0gcHAgKyBwO1xuXG5cdFx0Ly8gTGF5b3V0IG9mIGtleWZyYW1lIG91dHB1dCB2YWx1ZXMgZm9yIENVQklDU1BMSU5FIGFuaW1hdGlvbnM6XG5cdFx0Ly8gICBbIGluVGFuZ2VudF8xLCBzcGxpbmVWZXJ0ZXhfMSwgb3V0VGFuZ2VudF8xLCBpblRhbmdlbnRfMiwgc3BsaW5lVmVydGV4XzIsIC4uLiBdXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHAwID0gdmFsdWVzWyBvZmZzZXQwICsgaSArIHN0cmlkZSBdOyAvLyBzcGxpbmVWZXJ0ZXhfa1xuXHRcdFx0Y29uc3QgbTAgPSB2YWx1ZXNbIG9mZnNldDAgKyBpICsgc3RyaWRlMiBdICogdGQ7IC8vIG91dFRhbmdlbnRfayAqICh0X2srMSAtIHRfaylcblx0XHRcdGNvbnN0IHAxID0gdmFsdWVzWyBvZmZzZXQxICsgaSArIHN0cmlkZSBdOyAvLyBzcGxpbmVWZXJ0ZXhfaysxXG5cdFx0XHRjb25zdCBtMSA9IHZhbHVlc1sgb2Zmc2V0MSArIGkgXSAqIHRkOyAvLyBpblRhbmdlbnRfaysxICogKHRfaysxIC0gdF9rKVxuXG5cdFx0XHRyZXN1bHRbIGkgXSA9IHMwICogcDAgKyBzMSAqIG0wICsgczIgKiBwMSArIHMzICogbTE7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxufVxuXG5jb25zdCBfcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmNsYXNzIEdMVEZDdWJpY1NwbGluZVF1YXRlcm5pb25JbnRlcnBvbGFudCBleHRlbmRzIEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50IHtcblxuXHRpbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHRjb25zdCByZXN1bHQgPSBzdXBlci5pbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKTtcblxuXHRcdF9xLmZyb21BcnJheSggcmVzdWx0ICkubm9ybWFsaXplKCkudG9BcnJheSggcmVzdWx0ICk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxufVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKiBJTlRFUk5BTFMgKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogQ09OU1RBTlRTICovXG5cbmNvbnN0IFdFQkdMX0NPTlNUQU5UUyA9IHtcblx0RkxPQVQ6IDUxMjYsXG5cdC8vRkxPQVRfTUFUMjogMzU2NzQsXG5cdEZMT0FUX01BVDM6IDM1Njc1LFxuXHRGTE9BVF9NQVQ0OiAzNTY3Nixcblx0RkxPQVRfVkVDMjogMzU2NjQsXG5cdEZMT0FUX1ZFQzM6IDM1NjY1LFxuXHRGTE9BVF9WRUM0OiAzNTY2Nixcblx0TElORUFSOiA5NzI5LFxuXHRSRVBFQVQ6IDEwNDk3LFxuXHRTQU1QTEVSXzJEOiAzNTY3OCxcblx0UE9JTlRTOiAwLFxuXHRMSU5FUzogMSxcblx0TElORV9MT09QOiAyLFxuXHRMSU5FX1NUUklQOiAzLFxuXHRUUklBTkdMRVM6IDQsXG5cdFRSSUFOR0xFX1NUUklQOiA1LFxuXHRUUklBTkdMRV9GQU46IDYsXG5cdFVOU0lHTkVEX0JZVEU6IDUxMjEsXG5cdFVOU0lHTkVEX1NIT1JUOiA1MTIzXG59O1xuXG5jb25zdCBXRUJHTF9DT01QT05FTlRfVFlQRVMgPSB7XG5cdDUxMjA6IEludDhBcnJheSxcblx0NTEyMTogVWludDhBcnJheSxcblx0NTEyMjogSW50MTZBcnJheSxcblx0NTEyMzogVWludDE2QXJyYXksXG5cdDUxMjU6IFVpbnQzMkFycmF5LFxuXHQ1MTI2OiBGbG9hdDMyQXJyYXlcbn07XG5cbmNvbnN0IFdFQkdMX0ZJTFRFUlMgPSB7XG5cdDk3Mjg6IE5lYXJlc3RGaWx0ZXIsXG5cdDk3Mjk6IExpbmVhckZpbHRlcixcblx0OTk4NDogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdDk5ODU6IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdDk5ODY6IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdDk5ODc6IExpbmVhck1pcG1hcExpbmVhckZpbHRlclxufTtcblxuY29uc3QgV0VCR0xfV1JBUFBJTkdTID0ge1xuXHQzMzA3MTogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcblx0MzM2NDg6IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsXG5cdDEwNDk3OiBSZXBlYXRXcmFwcGluZ1xufTtcblxuY29uc3QgV0VCR0xfVFlQRV9TSVpFUyA9IHtcblx0J1NDQUxBUic6IDEsXG5cdCdWRUMyJzogMixcblx0J1ZFQzMnOiAzLFxuXHQnVkVDNCc6IDQsXG5cdCdNQVQyJzogNCxcblx0J01BVDMnOiA5LFxuXHQnTUFUNCc6IDE2XG59O1xuXG5jb25zdCBBVFRSSUJVVEVTID0ge1xuXHRQT1NJVElPTjogJ3Bvc2l0aW9uJyxcblx0Tk9STUFMOiAnbm9ybWFsJyxcblx0VEFOR0VOVDogJ3RhbmdlbnQnLFxuXHRURVhDT09SRF8wOiAndXYnLFxuXHRURVhDT09SRF8xOiAndXYxJyxcblx0VEVYQ09PUkRfMjogJ3V2MicsXG5cdFRFWENPT1JEXzM6ICd1djMnLFxuXHRDT0xPUl8wOiAnY29sb3InLFxuXHRXRUlHSFRTXzA6ICdza2luV2VpZ2h0Jyxcblx0Sk9JTlRTXzA6ICdza2luSW5kZXgnLFxufTtcblxuY29uc3QgUEFUSF9QUk9QRVJUSUVTID0ge1xuXHRzY2FsZTogJ3NjYWxlJyxcblx0dHJhbnNsYXRpb246ICdwb3NpdGlvbicsXG5cdHJvdGF0aW9uOiAncXVhdGVybmlvbicsXG5cdHdlaWdodHM6ICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnXG59O1xuXG5jb25zdCBJTlRFUlBPTEFUSU9OID0ge1xuXHRDVUJJQ1NQTElORTogdW5kZWZpbmVkLCAvLyBXZSB1c2UgYSBjdXN0b20gaW50ZXJwb2xhbnQgKEdMVEZDdWJpY1NwbGluZUludGVycG9sYXRpb24pIGZvciBDVUJJQ1NQTElORSB0cmFja3MuIEVhY2hcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBrZXlmcmFtZSB0cmFjayB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYSBkZWZhdWx0IGludGVycG9sYXRpb24gdHlwZSwgdGhlbiBtb2RpZmllZC5cblx0TElORUFSOiBJbnRlcnBvbGF0ZUxpbmVhcixcblx0U1RFUDogSW50ZXJwb2xhdGVEaXNjcmV0ZVxufTtcblxuY29uc3QgQUxQSEFfTU9ERVMgPSB7XG5cdE9QQVFVRTogJ09QQVFVRScsXG5cdE1BU0s6ICdNQVNLJyxcblx0QkxFTkQ6ICdCTEVORCdcbn07XG5cbi8qKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNkZWZhdWx0LW1hdGVyaWFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRNYXRlcmlhbCggY2FjaGUgKSB7XG5cblx0aWYgKCBjYWNoZVsgJ0RlZmF1bHRNYXRlcmlhbCcgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Y2FjaGVbICdEZWZhdWx0TWF0ZXJpYWwnIF0gPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoIHtcblx0XHRcdGNvbG9yOiAweEZGRkZGRixcblx0XHRcdGVtaXNzaXZlOiAweDAwMDAwMCxcblx0XHRcdG1ldGFsbmVzczogMSxcblx0XHRcdHJvdWdobmVzczogMSxcblx0XHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcblx0XHRcdGRlcHRoVGVzdDogdHJ1ZSxcblx0XHRcdHNpZGU6IEZyb250U2lkZVxuXHRcdH0gKTtcblxuXHR9XG5cblx0cmV0dXJuIGNhY2hlWyAnRGVmYXVsdE1hdGVyaWFsJyBdO1xuXG59XG5cbmZ1bmN0aW9uIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSgga25vd25FeHRlbnNpb25zLCBvYmplY3QsIG9iamVjdERlZiApIHtcblxuXHQvLyBBZGQgdW5rbm93biBnbFRGIGV4dGVuc2lvbnMgdG8gYW4gb2JqZWN0J3MgdXNlckRhdGEuXG5cblx0Zm9yICggY29uc3QgbmFtZSBpbiBvYmplY3REZWYuZXh0ZW5zaW9ucyApIHtcblxuXHRcdGlmICgga25vd25FeHRlbnNpb25zWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0b2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zID0gb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zIHx8IHt9O1xuXHRcdFx0b2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zWyBuYW1lIF0gPSBvYmplY3REZWYuZXh0ZW5zaW9uc1sgbmFtZSBdO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0M0R8TWF0ZXJpYWx8QnVmZmVyR2VvbWV0cnl9IG9iamVjdFxuICogQHBhcmFtIHtHTFRGLmRlZmluaXRpb259IGdsdGZEZWZcbiAqL1xuZnVuY3Rpb24gYXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggb2JqZWN0LCBnbHRmRGVmICkge1xuXG5cdGlmICggZ2x0ZkRlZi5leHRyYXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggdHlwZW9mIGdsdGZEZWYuZXh0cmFzID09PSAnb2JqZWN0JyApIHtcblxuXHRcdFx0T2JqZWN0LmFzc2lnbiggb2JqZWN0LnVzZXJEYXRhLCBnbHRmRGVmLmV4dHJhcyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogSWdub3JpbmcgcHJpbWl0aXZlIHR5cGUgLmV4dHJhcywgJyArIGdsdGZEZWYuZXh0cmFzICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8qKlxuICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtb3JwaC10YXJnZXRzXG4gKlxuICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnlcbiAqIEBwYXJhbSB7QXJyYXk8R0xURi5UYXJnZXQ+fSB0YXJnZXRzXG4gKiBAcGFyYW0ge0dMVEZQYXJzZXJ9IHBhcnNlclxuICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJHZW9tZXRyeT59XG4gKi9cbmZ1bmN0aW9uIGFkZE1vcnBoVGFyZ2V0cyggZ2VvbWV0cnksIHRhcmdldHMsIHBhcnNlciApIHtcblxuXHRsZXQgaGFzTW9ycGhQb3NpdGlvbiA9IGZhbHNlO1xuXHRsZXQgaGFzTW9ycGhOb3JtYWwgPSBmYWxzZTtcblx0bGV0IGhhc01vcnBoQ29sb3IgPSBmYWxzZTtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGNvbnN0IHRhcmdldCA9IHRhcmdldHNbIGkgXTtcblxuXHRcdGlmICggdGFyZ2V0LlBPU0lUSU9OICE9PSB1bmRlZmluZWQgKSBoYXNNb3JwaFBvc2l0aW9uID0gdHJ1ZTtcblx0XHRpZiAoIHRhcmdldC5OT1JNQUwgIT09IHVuZGVmaW5lZCApIGhhc01vcnBoTm9ybWFsID0gdHJ1ZTtcblx0XHRpZiAoIHRhcmdldC5DT0xPUl8wICE9PSB1bmRlZmluZWQgKSBoYXNNb3JwaENvbG9yID0gdHJ1ZTtcblxuXHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiAmJiBoYXNNb3JwaE5vcm1hbCAmJiBoYXNNb3JwaENvbG9yICkgYnJlYWs7XG5cblx0fVxuXG5cdGlmICggISBoYXNNb3JwaFBvc2l0aW9uICYmICEgaGFzTW9ycGhOb3JtYWwgJiYgISBoYXNNb3JwaENvbG9yICkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSggZ2VvbWV0cnkgKTtcblxuXHRjb25zdCBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMgPSBbXTtcblx0Y29uc3QgcGVuZGluZ05vcm1hbEFjY2Vzc29ycyA9IFtdO1xuXHRjb25zdCBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMgPSBbXTtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGNvbnN0IHRhcmdldCA9IHRhcmdldHNbIGkgXTtcblxuXHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiApIHtcblxuXHRcdFx0Y29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LlBPU0lUSU9OICE9PSB1bmRlZmluZWRcblx0XHRcdFx0PyBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgdGFyZ2V0LlBPU0lUSU9OIClcblx0XHRcdFx0OiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMucHVzaCggcGVuZGluZ0FjY2Vzc29yICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGhhc01vcnBoTm9ybWFsICkge1xuXG5cdFx0XHRjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuTk9STUFMICE9PSB1bmRlZmluZWRcblx0XHRcdFx0PyBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgdGFyZ2V0Lk5PUk1BTCApXG5cdFx0XHRcdDogZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRcdHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMucHVzaCggcGVuZGluZ0FjY2Vzc29yICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGhhc01vcnBoQ29sb3IgKSB7XG5cblx0XHRcdGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5DT0xPUl8wICE9PSB1bmRlZmluZWRcblx0XHRcdFx0PyBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgdGFyZ2V0LkNPTE9SXzAgKVxuXHRcdFx0XHQ6IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3I7XG5cblx0XHRcdHBlbmRpbmdDb2xvckFjY2Vzc29ycy5wdXNoKCBwZW5kaW5nQWNjZXNzb3IgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIFByb21pc2UuYWxsKCBbXG5cdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyApLFxuXHRcdFByb21pc2UuYWxsKCBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzICksXG5cdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdDb2xvckFjY2Vzc29ycyApXG5cdF0gKS50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29ycyApIHtcblxuXHRcdGNvbnN0IG1vcnBoUG9zaXRpb25zID0gYWNjZXNzb3JzWyAwIF07XG5cdFx0Y29uc3QgbW9ycGhOb3JtYWxzID0gYWNjZXNzb3JzWyAxIF07XG5cdFx0Y29uc3QgbW9ycGhDb2xvcnMgPSBhY2Nlc3NvcnNbIDIgXTtcblxuXHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiApIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiA9IG1vcnBoUG9zaXRpb25zO1xuXHRcdGlmICggaGFzTW9ycGhOb3JtYWwgKSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsID0gbW9ycGhOb3JtYWxzO1xuXHRcdGlmICggaGFzTW9ycGhDb2xvciApIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciA9IG1vcnBoQ29sb3JzO1xuXHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdHJ1ZTtcblxuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9ICk7XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge01lc2h9IG1lc2hcbiAqIEBwYXJhbSB7R0xURi5NZXNofSBtZXNoRGVmXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU1vcnBoVGFyZ2V0cyggbWVzaCwgbWVzaERlZiApIHtcblxuXHRtZXNoLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXG5cdGlmICggbWVzaERlZi53ZWlnaHRzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbWVzaERlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdID0gbWVzaERlZi53ZWlnaHRzWyBpIF07XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIC5leHRyYXMgaGFzIHVzZXItZGVmaW5lZCBkYXRhLCBzbyBjaGVjayB0aGF0IC5leHRyYXMudGFyZ2V0TmFtZXMgaXMgYW4gYXJyYXkuXG5cdGlmICggbWVzaERlZi5leHRyYXMgJiYgQXJyYXkuaXNBcnJheSggbWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXMgKSApIHtcblxuXHRcdGNvbnN0IHRhcmdldE5hbWVzID0gbWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXM7XG5cblx0XHRpZiAoIG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aCA9PT0gdGFyZ2V0TmFtZXMubGVuZ3RoICkge1xuXG5cdFx0XHRtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0bWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRhcmdldE5hbWVzWyBpIF0gXSA9IGk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgZXh0cmFzLnRhcmdldE5hbWVzIGxlbmd0aC4gSWdub3JpbmcgbmFtZXMuJyApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVLZXkoIHByaW1pdGl2ZURlZiApIHtcblxuXHRsZXQgZ2VvbWV0cnlLZXk7XG5cblx0Y29uc3QgZHJhY29FeHRlbnNpb24gPSBwcmltaXRpdmVEZWYuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmVEZWYuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiBdO1xuXG5cdGlmICggZHJhY29FeHRlbnNpb24gKSB7XG5cblx0XHRnZW9tZXRyeUtleSA9ICdkcmFjbzonICsgZHJhY29FeHRlbnNpb24uYnVmZmVyVmlld1xuXHRcdFx0XHQrICc6JyArIGRyYWNvRXh0ZW5zaW9uLmluZGljZXNcblx0XHRcdFx0KyAnOicgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KCBkcmFjb0V4dGVuc2lvbi5hdHRyaWJ1dGVzICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGdlb21ldHJ5S2V5ID0gcHJpbWl0aXZlRGVmLmluZGljZXMgKyAnOicgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KCBwcmltaXRpdmVEZWYuYXR0cmlidXRlcyApICsgJzonICsgcHJpbWl0aXZlRGVmLm1vZGU7XG5cblx0fVxuXG5cdGlmICggcHJpbWl0aXZlRGVmLnRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVEZWYudGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Z2VvbWV0cnlLZXkgKz0gJzonICsgY3JlYXRlQXR0cmlidXRlc0tleSggcHJpbWl0aXZlRGVmLnRhcmdldHNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZ2VvbWV0cnlLZXk7XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlc0tleSggYXR0cmlidXRlcyApIHtcblxuXHRsZXQgYXR0cmlidXRlc0tleSA9ICcnO1xuXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggYXR0cmlidXRlcyApLnNvcnQoKTtcblxuXHRmb3IgKCBsZXQgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGF0dHJpYnV0ZXNLZXkgKz0ga2V5c1sgaSBdICsgJzonICsgYXR0cmlidXRlc1sga2V5c1sgaSBdIF0gKyAnOyc7XG5cblx0fVxuXG5cdHJldHVybiBhdHRyaWJ1dGVzS2V5O1xuXG59XG5cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSggY29uc3RydWN0b3IgKSB7XG5cblx0Ly8gUmVmZXJlbmNlOlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWVzaF9xdWFudGl6YXRpb24jZW5jb2RpbmctcXVhbnRpemVkLWRhdGFcblxuXHRzd2l0Y2ggKCBjb25zdHJ1Y3RvciApIHtcblxuXHRcdGNhc2UgSW50OEFycmF5OlxuXHRcdFx0cmV0dXJuIDEgLyAxMjc7XG5cblx0XHRjYXNlIFVpbnQ4QXJyYXk6XG5cdFx0XHRyZXR1cm4gMSAvIDI1NTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblx0XHRcdHJldHVybiAxIC8gMzI3Njc7XG5cblx0XHRjYXNlIFVpbnQxNkFycmF5OlxuXHRcdFx0cmV0dXJuIDEgLyA2NTUzNTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBub3JtYWxpemVkIGFjY2Vzc29yIGNvbXBvbmVudCB0eXBlLicgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VVUklNaW1lVHlwZSggdXJpICkge1xuXG5cdGlmICggdXJpLnNlYXJjaCggL1xcLmpwZT9nKCR8XFw/KS9pICkgPiAwIHx8IHVyaS5zZWFyY2goIC9eZGF0YVxcOmltYWdlXFwvanBlZy8gKSA9PT0gMCApIHJldHVybiAnaW1hZ2UvanBlZyc7XG5cdGlmICggdXJpLnNlYXJjaCggL1xcLndlYnAoJHxcXD8pL2kgKSA+IDAgfHwgdXJpLnNlYXJjaCggL15kYXRhXFw6aW1hZ2VcXC93ZWJwLyApID09PSAwICkgcmV0dXJuICdpbWFnZS93ZWJwJztcblxuXHRyZXR1cm4gJ2ltYWdlL3BuZyc7XG5cbn1cblxuY29uc3QgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuLyogR0xURiBQQVJTRVIgKi9cblxuY2xhc3MgR0xURlBhcnNlciB7XG5cblx0Y29uc3RydWN0b3IoIGpzb24gPSB7fSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0dGhpcy5qc29uID0ganNvbjtcblx0XHR0aGlzLmV4dGVuc2lvbnMgPSB7fTtcblx0XHR0aGlzLnBsdWdpbnMgPSB7fTtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0Ly8gbG9hZGVyIG9iamVjdCBjYWNoZVxuXHRcdHRoaXMuY2FjaGUgPSBuZXcgR0xURlJlZ2lzdHJ5KCk7XG5cblx0XHQvLyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBUaHJlZS5qcyBvYmplY3RzIGFuZCBnbFRGIGVsZW1lbnRzXG5cdFx0dGhpcy5hc3NvY2lhdGlvbnMgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBCdWZmZXJHZW9tZXRyeSBjYWNoaW5nXG5cdFx0dGhpcy5wcmltaXRpdmVDYWNoZSA9IHt9O1xuXG5cdFx0Ly8gTm9kZSBjYWNoZVxuXHRcdHRoaXMubm9kZUNhY2hlID0ge307XG5cblx0XHQvLyBPYmplY3QzRCBpbnN0YW5jZSBjYWNoZXNcblx0XHR0aGlzLm1lc2hDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG5cdFx0dGhpcy5jYW1lcmFDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG5cdFx0dGhpcy5saWdodENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcblxuXHRcdHRoaXMuc291cmNlQ2FjaGUgPSB7fTtcblx0XHR0aGlzLnRleHR1cmVDYWNoZSA9IHt9O1xuXG5cdFx0Ly8gVHJhY2sgbm9kZSBuYW1lcywgdG8gZW5zdXJlIG5vIGR1cGxpY2F0ZXNcblx0XHR0aGlzLm5vZGVOYW1lc1VzZWQgPSB7fTtcblxuXHRcdC8vIFVzZSBhbiBJbWFnZUJpdG1hcExvYWRlciBpZiBpbWFnZUJpdG1hcHMgYXJlIHN1cHBvcnRlZC4gTW92ZXMgbXVjaCBvZiB0aGVcblx0XHQvLyBleHBlbnNpdmUgd29yayBvZiB1cGxvYWRpbmcgYSB0ZXh0dXJlIHRvIHRoZSBHUFUgb2ZmIHRoZSBtYWluIHRocmVhZC5cblxuXHRcdGxldCBpc1NhZmFyaSA9IGZhbHNlO1xuXHRcdGxldCBpc0ZpcmVmb3ggPSBmYWxzZTtcblx0XHRsZXQgZmlyZWZveFZlcnNpb24gPSAtIDE7XG5cblx0XHRpZiAoIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICkge1xuXG5cdFx0XHRpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoIG5hdmlnYXRvci51c2VyQWdlbnQgKSA9PT0gdHJ1ZTtcblx0XHRcdGlzRmlyZWZveCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZiggJ0ZpcmVmb3gnICkgPiAtIDE7XG5cdFx0XHRmaXJlZm94VmVyc2lvbiA9IGlzRmlyZWZveCA/IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goIC9GaXJlZm94XFwvKFswLTldKylcXC4vIClbIDEgXSA6IC0gMTtcblxuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJyB8fCBpc1NhZmFyaSB8fCAoIGlzRmlyZWZveCAmJiBmaXJlZm94VmVyc2lvbiA8IDk4ICkgKSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKCB0aGlzLm9wdGlvbnMubWFuYWdlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IEltYWdlQml0bWFwTG9hZGVyKCB0aGlzLm9wdGlvbnMubWFuYWdlciApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy50ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gKTtcblx0XHR0aGlzLnRleHR1cmVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXIgKTtcblxuXHRcdHRoaXMuZmlsZUxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm9wdGlvbnMubWFuYWdlciApO1xuXHRcdHRoaXMuZmlsZUxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJyApIHtcblxuXHRcdFx0dGhpcy5maWxlTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdHJ1ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXRFeHRlbnNpb25zKCBleHRlbnNpb25zICkge1xuXG5cdFx0dGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcblxuXHR9XG5cblx0c2V0UGx1Z2lucyggcGx1Z2lucyApIHtcblxuXHRcdHRoaXMucGx1Z2lucyA9IHBsdWdpbnM7XG5cblx0fVxuXG5cdHBhcnNlKCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblxuXHRcdC8vIENsZWFyIHRoZSBsb2FkZXIgY2FjaGVcblx0XHR0aGlzLmNhY2hlLnJlbW92ZUFsbCgpO1xuXHRcdHRoaXMubm9kZUNhY2hlID0ge307XG5cblx0XHQvLyBNYXJrIHRoZSBzcGVjaWFsIG5vZGVzL21lc2hlcyBpbiBqc29uIGZvciBlZmZpY2llbnQgcGFyc2Vcblx0XHR0aGlzLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRyZXR1cm4gZXh0Ll9tYXJrRGVmcyAmJiBleHQuX21hcmtEZWZzKCk7XG5cblx0XHR9ICk7XG5cblx0XHRQcm9taXNlLmFsbCggdGhpcy5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0cmV0dXJuIGV4dC5iZWZvcmVSb290ICYmIGV4dC5iZWZvcmVSb290KCk7XG5cblx0XHR9ICkgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggW1xuXG5cdFx0XHRcdHBhcnNlci5nZXREZXBlbmRlbmNpZXMoICdzY2VuZScgKSxcblx0XHRcdFx0cGFyc2VyLmdldERlcGVuZGVuY2llcyggJ2FuaW1hdGlvbicgKSxcblx0XHRcdFx0cGFyc2VyLmdldERlcGVuZGVuY2llcyggJ2NhbWVyYScgKSxcblxuXHRcdFx0XSApO1xuXG5cdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggZGVwZW5kZW5jaWVzICkge1xuXG5cdFx0XHRjb25zdCByZXN1bHQgPSB7XG5cdFx0XHRcdHNjZW5lOiBkZXBlbmRlbmNpZXNbIDAgXVsganNvbi5zY2VuZSB8fCAwIF0sXG5cdFx0XHRcdHNjZW5lczogZGVwZW5kZW5jaWVzWyAwIF0sXG5cdFx0XHRcdGFuaW1hdGlvbnM6IGRlcGVuZGVuY2llc1sgMSBdLFxuXHRcdFx0XHRjYW1lcmFzOiBkZXBlbmRlbmNpZXNbIDIgXSxcblx0XHRcdFx0YXNzZXQ6IGpzb24uYXNzZXQsXG5cdFx0XHRcdHBhcnNlcjogcGFyc2VyLFxuXHRcdFx0XHR1c2VyRGF0YToge31cblx0XHRcdH07XG5cblx0XHRcdGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgcmVzdWx0LCBqc29uICk7XG5cblx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIHJlc3VsdCwganNvbiApO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBhcnNlci5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0LmFmdGVyUm9vdCAmJiBleHQuYWZ0ZXJSb290KCByZXN1bHQgKTtcblxuXHRcdFx0fSApICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdG9uTG9hZCggcmVzdWx0ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKS5jYXRjaCggb25FcnJvciApO1xuXG5cdH1cblxuXHQvKipcblx0ICogTWFya3MgdGhlIHNwZWNpYWwgbm9kZXMvbWVzaGVzIGluIGpzb24gZm9yIGVmZmljaWVudCBwYXJzZS5cblx0ICovXG5cdF9tYXJrRGVmcygpIHtcblxuXHRcdGNvbnN0IG5vZGVEZWZzID0gdGhpcy5qc29uLm5vZGVzIHx8IFtdO1xuXHRcdGNvbnN0IHNraW5EZWZzID0gdGhpcy5qc29uLnNraW5zIHx8IFtdO1xuXHRcdGNvbnN0IG1lc2hEZWZzID0gdGhpcy5qc29uLm1lc2hlcyB8fCBbXTtcblxuXHRcdC8vIE5vdGhpbmcgaW4gdGhlIG5vZGUgZGVmaW5pdGlvbiBpbmRpY2F0ZXMgd2hldGhlciBpdCBpcyBhIEJvbmUgb3IgYW5cblx0XHQvLyBPYmplY3QzRC4gVXNlIHRoZSBza2lucycgam9pbnQgcmVmZXJlbmNlcyB0byBtYXJrIGJvbmVzLlxuXHRcdGZvciAoIGxldCBza2luSW5kZXggPSAwLCBza2luTGVuZ3RoID0gc2tpbkRlZnMubGVuZ3RoOyBza2luSW5kZXggPCBza2luTGVuZ3RoOyBza2luSW5kZXggKysgKSB7XG5cblx0XHRcdGNvbnN0IGpvaW50cyA9IHNraW5EZWZzWyBza2luSW5kZXggXS5qb2ludHM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBqb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0bm9kZURlZnNbIGpvaW50c1sgaSBdIF0uaXNCb25lID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgbWFya2luZyByZWZlcmVuY2VzIHRvIHNoYXJlZCByZXNvdXJjZXMsXG5cdFx0Ly8gYXMgd2VsbCBhcyBza2VsZXRvbiBqb2ludHMuXG5cdFx0Zm9yICggbGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCArKyApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZURlZiA9IG5vZGVEZWZzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0aWYgKCBub2RlRGVmLm1lc2ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLl9hZGROb2RlUmVmKCB0aGlzLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoICk7XG5cblx0XHRcdFx0Ly8gTm90aGluZyBpbiB0aGUgbWVzaCBkZWZpbml0aW9uIGluZGljYXRlcyB3aGV0aGVyIGl0IGlzXG5cdFx0XHRcdC8vIGEgU2tpbm5lZE1lc2ggb3IgTWVzaC4gVXNlIHRoZSBub2RlJ3MgbWVzaCByZWZlcmVuY2Vcblx0XHRcdFx0Ly8gdG8gbWFyayBTa2lubmVkTWVzaCBpZiBub2RlIGhhcyBza2luLlxuXHRcdFx0XHRpZiAoIG5vZGVEZWYuc2tpbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bWVzaERlZnNbIG5vZGVEZWYubWVzaCBdLmlzU2tpbm5lZE1lc2ggPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGVEZWYuY2FtZXJhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5fYWRkTm9kZVJlZiggdGhpcy5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQ291bnRzIHJlZmVyZW5jZXMgdG8gc2hhcmVkIG5vZGUgLyBPYmplY3QzRCByZXNvdXJjZXMuIFRoZXNlIHJlc291cmNlc1xuXHQgKiBjYW4gYmUgcmV1c2VkLCBvciBcImluc3RhbnRpYXRlZFwiLCBhdCBtdWx0aXBsZSBub2RlcyBpbiB0aGUgc2NlbmVcblx0ICogaGllcmFyY2h5LiBNZXNoLCBDYW1lcmEsIGFuZCBMaWdodCBpbnN0YW5jZXMgYXJlIGluc3RhbnRpYXRlZCBhbmQgbXVzdFxuXHQgKiBiZSBtYXJrZWQuIE5vbi1zY2VuZWdyYXBoIHJlc291cmNlcyAobGlrZSBNYXRlcmlhbHMsIEdlb21ldHJpZXMsIGFuZFxuXHQgKiBUZXh0dXJlcykgY2FuIGJlIHJldXNlZCBkaXJlY3RseSBhbmQgYXJlIG5vdCBtYXJrZWQgaGVyZS5cblx0ICpcblx0ICogRXhhbXBsZTogQ2VzaXVtTWlsa1RydWNrIHNhbXBsZSBtb2RlbCByZXVzZXMgXCJXaGVlbFwiIG1lc2hlcy5cblx0ICovXG5cdF9hZGROb2RlUmVmKCBjYWNoZSwgaW5kZXggKSB7XG5cblx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRpZiAoIGNhY2hlLnJlZnNbIGluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y2FjaGUucmVmc1sgaW5kZXggXSA9IGNhY2hlLnVzZXNbIGluZGV4IF0gPSAwO1xuXG5cdFx0fVxuXG5cdFx0Y2FjaGUucmVmc1sgaW5kZXggXSArKztcblxuXHR9XG5cblx0LyoqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gYSBzaGFyZWQgcmVzb3VyY2UsIGNsb25pbmcgaXQgaWYgbmVjZXNzYXJ5LiAqL1xuXHRfZ2V0Tm9kZVJlZiggY2FjaGUsIGluZGV4LCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGNhY2hlLnJlZnNbIGluZGV4IF0gPD0gMSApIHJldHVybiBvYmplY3Q7XG5cblx0XHRjb25zdCByZWYgPSBvYmplY3QuY2xvbmUoKTtcblxuXHRcdC8vIFByb3BhZ2F0ZXMgbWFwcGluZ3MgdG8gdGhlIGNsb25lZCBvYmplY3QsIHByZXZlbnRzIG1hcHBpbmdzIG9uIHRoZVxuXHRcdC8vIG9yaWdpbmFsIG9iamVjdCBmcm9tIGJlaW5nIGxvc3QuXG5cdFx0Y29uc3QgdXBkYXRlTWFwcGluZ3MgPSAoIG9yaWdpbmFsLCBjbG9uZSApID0+IHtcblxuXHRcdFx0Y29uc3QgbWFwcGluZ3MgPSB0aGlzLmFzc29jaWF0aW9ucy5nZXQoIG9yaWdpbmFsICk7XG5cdFx0XHRpZiAoIG1hcHBpbmdzICE9IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5hc3NvY2lhdGlvbnMuc2V0KCBjbG9uZSwgbWFwcGluZ3MgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBjb25zdCBbIGksIGNoaWxkIF0gb2Ygb3JpZ2luYWwuY2hpbGRyZW4uZW50cmllcygpICkge1xuXG5cdFx0XHRcdHVwZGF0ZU1hcHBpbmdzKCBjaGlsZCwgY2xvbmUuY2hpbGRyZW5bIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dXBkYXRlTWFwcGluZ3MoIG9iamVjdCwgcmVmICk7XG5cblx0XHRyZWYubmFtZSArPSAnX2luc3RhbmNlXycgKyAoIGNhY2hlLnVzZXNbIGluZGV4IF0gKysgKTtcblxuXHRcdHJldHVybiByZWY7XG5cblx0fVxuXG5cdF9pbnZva2VPbmUoIGZ1bmMgKSB7XG5cblx0XHRjb25zdCBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyggdGhpcy5wbHVnaW5zICk7XG5cdFx0ZXh0ZW5zaW9ucy5wdXNoKCB0aGlzICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZnVuYyggZXh0ZW5zaW9uc1sgaSBdICk7XG5cblx0XHRcdGlmICggcmVzdWx0ICkgcmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHRfaW52b2tlQWxsKCBmdW5jICkge1xuXG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXMoIHRoaXMucGx1Z2lucyApO1xuXHRcdGV4dGVuc2lvbnMudW5zaGlmdCggdGhpcyApO1xuXG5cdFx0Y29uc3QgcGVuZGluZyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHJlc3VsdCA9IGZ1bmMoIGV4dGVuc2lvbnNbIGkgXSApO1xuXG5cdFx0XHRpZiAoIHJlc3VsdCApIHBlbmRpbmcucHVzaCggcmVzdWx0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcGVuZGluZztcblxuXHR9XG5cblx0LyoqXG5cdCAqIFJlcXVlc3RzIHRoZSBzcGVjaWZpZWQgZGVwZW5kZW5jeSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRHxNYXRlcmlhbHxUSFJFRS5UZXh0dXJlfEFuaW1hdGlvbkNsaXB8QXJyYXlCdWZmZXJ8T2JqZWN0Pn1cblx0ICovXG5cdGdldERlcGVuZGVuY3koIHR5cGUsIGluZGV4ICkge1xuXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSB0eXBlICsgJzonICsgaW5kZXg7XG5cdFx0bGV0IGRlcGVuZGVuY3kgPSB0aGlzLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdGlmICggISBkZXBlbmRlbmN5ICkge1xuXG5cdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ3NjZW5lJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2NlbmUoIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbm9kZSc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZSggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBleHQubG9hZE5vZGUgJiYgZXh0LmxvYWROb2RlKCBpbmRleCApO1xuXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21lc2gnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXh0LmxvYWRNZXNoICYmIGV4dC5sb2FkTWVzaCggaW5kZXggKTtcblxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdhY2Nlc3Nvcic6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZEFjY2Vzc29yKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2J1ZmZlclZpZXcnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXh0LmxvYWRCdWZmZXJWaWV3ICYmIGV4dC5sb2FkQnVmZmVyVmlldyggaW5kZXggKTtcblxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdidWZmZXInOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRCdWZmZXIoIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWF0ZXJpYWwnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXh0LmxvYWRNYXRlcmlhbCAmJiBleHQubG9hZE1hdGVyaWFsKCBpbmRleCApO1xuXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RleHR1cmUnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXh0LmxvYWRUZXh0dXJlICYmIGV4dC5sb2FkVGV4dHVyZSggaW5kZXggKTtcblxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdza2luJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2tpbiggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdhbmltYXRpb24nOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXh0LmxvYWRBbmltYXRpb24gJiYgZXh0LmxvYWRBbmltYXRpb24oIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnY2FtZXJhJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQ2FtZXJhKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZSggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBleHQgIT0gdGhpcyAmJiBleHQuZ2V0RGVwZW5kZW5jeSAmJiBleHQuZ2V0RGVwZW5kZW5jeSggdHlwZSwgaW5kZXggKTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdGlmICggISBkZXBlbmRlbmN5ICkge1xuXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdVbmtub3duIHR5cGU6ICcgKyB0eXBlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIGRlcGVuZGVuY3kgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkZXBlbmRlbmN5O1xuXG5cdH1cblxuXHQvKipcblx0ICogUmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxPYmplY3Q+Pn1cblx0ICovXG5cdGdldERlcGVuZGVuY2llcyggdHlwZSApIHtcblxuXHRcdGxldCBkZXBlbmRlbmNpZXMgPSB0aGlzLmNhY2hlLmdldCggdHlwZSApO1xuXG5cdFx0aWYgKCAhIGRlcGVuZGVuY2llcyApIHtcblxuXHRcdFx0Y29uc3QgcGFyc2VyID0gdGhpcztcblx0XHRcdGNvbnN0IGRlZnMgPSB0aGlzLmpzb25bIHR5cGUgKyAoIHR5cGUgPT09ICdtZXNoJyA/ICdlcycgOiAncycgKSBdIHx8IFtdO1xuXG5cdFx0XHRkZXBlbmRlbmNpZXMgPSBQcm9taXNlLmFsbCggZGVmcy5tYXAoIGZ1bmN0aW9uICggZGVmLCBpbmRleCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koIHR5cGUsIGluZGV4ICk7XG5cblx0XHRcdH0gKSApO1xuXG5cdFx0XHR0aGlzLmNhY2hlLmFkZCggdHlwZSwgZGVwZW5kZW5jaWVzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3Ncblx0ICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlckluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuXHQgKi9cblx0bG9hZEJ1ZmZlciggYnVmZmVySW5kZXggKSB7XG5cblx0XHRjb25zdCBidWZmZXJEZWYgPSB0aGlzLmpzb24uYnVmZmVyc1sgYnVmZmVySW5kZXggXTtcblx0XHRjb25zdCBsb2FkZXIgPSB0aGlzLmZpbGVMb2FkZXI7XG5cblx0XHRpZiAoIGJ1ZmZlckRlZi50eXBlICYmIGJ1ZmZlckRlZi50eXBlICE9PSAnYXJyYXlidWZmZXInICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiAnICsgYnVmZmVyRGVmLnR5cGUgKyAnIGJ1ZmZlciB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgcHJlc2VudCwgR0xCIGNvbnRhaW5lciBpcyByZXF1aXJlZCB0byBiZSB0aGUgZmlyc3QgYnVmZmVyLlxuXHRcdGlmICggYnVmZmVyRGVmLnVyaSA9PT0gdW5kZWZpbmVkICYmIGJ1ZmZlckluZGV4ID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCB0aGlzLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGIF0uYm9keSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlLCByZWplY3QgKSB7XG5cblx0XHRcdGxvYWRlci5sb2FkKCBMb2FkZXJVdGlscy5yZXNvbHZlVVJMKCBidWZmZXJEZWYudXJpLCBvcHRpb25zLnBhdGggKSwgcmVzb2x2ZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmVqZWN0KCBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBGYWlsZWQgdG8gbG9hZCBidWZmZXIgXCInICsgYnVmZmVyRGVmLnVyaSArICdcIi4nICkgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3Ncblx0ICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclZpZXdJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cblx0ICovXG5cdGxvYWRCdWZmZXJWaWV3KCBidWZmZXJWaWV3SW5kZXggKSB7XG5cblx0XHRjb25zdCBidWZmZXJWaWV3RGVmID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzWyBidWZmZXJWaWV3SW5kZXggXTtcblxuXHRcdHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXInLCBidWZmZXJWaWV3RGVmLmJ1ZmZlciApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRjb25zdCBieXRlTGVuZ3RoID0gYnVmZmVyVmlld0RlZi5ieXRlTGVuZ3RoIHx8IDA7XG5cdFx0XHRjb25zdCBieXRlT2Zmc2V0ID0gYnVmZmVyVmlld0RlZi5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRyZXR1cm4gYnVmZmVyLnNsaWNlKCBieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNhY2Nlc3NvcnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFjY2Vzc29ySW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJBdHRyaWJ1dGV8SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU+fVxuXHQgKi9cblx0bG9hZEFjY2Vzc29yKCBhY2Nlc3NvckluZGV4ICkge1xuXG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcztcblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXG5cdFx0Y29uc3QgYWNjZXNzb3JEZWYgPSB0aGlzLmpzb24uYWNjZXNzb3JzWyBhY2Nlc3NvckluZGV4IF07XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgPT09IHVuZGVmaW5lZCAmJiBhY2Nlc3NvckRlZi5zcGFyc2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTWyBhY2Nlc3NvckRlZi50eXBlIF07XG5cdFx0XHRjb25zdCBUeXBlZEFycmF5ID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlIF07XG5cdFx0XHRjb25zdCBub3JtYWxpemVkID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheSggYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSApO1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBlbmRpbmdCdWZmZXJWaWV3cyA9IFtdO1xuXG5cdFx0aWYgKCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXJWaWV3JywgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRwZW5kaW5nQnVmZmVyVmlld3MucHVzaCggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZ0J1ZmZlclZpZXdzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5idWZmZXJWaWV3ICkgKTtcblx0XHRcdHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXJWaWV3JywgYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5idWZmZXJWaWV3ICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZ0J1ZmZlclZpZXdzICkudGhlbiggZnVuY3Rpb24gKCBidWZmZXJWaWV3cyApIHtcblxuXHRcdFx0Y29uc3QgYnVmZmVyVmlldyA9IGJ1ZmZlclZpZXdzWyAwIF07XG5cblx0XHRcdGNvbnN0IGl0ZW1TaXplID0gV0VCR0xfVFlQRV9TSVpFU1sgYWNjZXNzb3JEZWYudHlwZSBdO1xuXHRcdFx0Y29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1sgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSBdO1xuXG5cdFx0XHQvLyBGb3IgVkVDMzogaXRlbVNpemUgaXMgMywgZWxlbWVudEJ5dGVzIGlzIDQsIGl0ZW1CeXRlcyBpcyAxMi5cblx0XHRcdGNvbnN0IGVsZW1lbnRCeXRlcyA9IFR5cGVkQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG5cdFx0XHRjb25zdCBpdGVtQnl0ZXMgPSBlbGVtZW50Qnl0ZXMgKiBpdGVtU2l6ZTtcblx0XHRcdGNvbnN0IGJ5dGVPZmZzZXQgPSBhY2Nlc3NvckRlZi5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRjb25zdCBieXRlU3RyaWRlID0gYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdW5kZWZpbmVkID8ganNvbi5idWZmZXJWaWV3c1sgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyBdLmJ5dGVTdHJpZGUgOiB1bmRlZmluZWQ7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcblx0XHRcdGxldCBhcnJheSwgYnVmZmVyQXR0cmlidXRlO1xuXG5cdFx0XHQvLyBUaGUgYnVmZmVyIGlzIG5vdCBpbnRlcmxlYXZlZCBpZiB0aGUgc3RyaWRlIGlzIHRoZSBpdGVtIHNpemUgaW4gYnl0ZXMuXG5cdFx0XHRpZiAoIGJ5dGVTdHJpZGUgJiYgYnl0ZVN0cmlkZSAhPT0gaXRlbUJ5dGVzICkge1xuXG5cdFx0XHRcdC8vIEVhY2ggXCJzbGljZVwiIG9mIHRoZSBidWZmZXIsIGFzIGRlZmluZWQgYnkgJ2NvdW50JyBlbGVtZW50cyBvZiAnYnl0ZVN0cmlkZScgYnl0ZXMsIGdldHMgaXRzIG93biBJbnRlcmxlYXZlZEJ1ZmZlclxuXHRcdFx0XHQvLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBJQkEuY291bnQgcmVmbGVjdHMgYWNjZXNzb3IuY291bnQgcHJvcGVybHlcblx0XHRcdFx0Y29uc3QgaWJTbGljZSA9IE1hdGguZmxvb3IoIGJ5dGVPZmZzZXQgLyBieXRlU3RyaWRlICk7XG5cdFx0XHRcdGNvbnN0IGliQ2FjaGVLZXkgPSAnSW50ZXJsZWF2ZWRCdWZmZXI6JyArIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgKyAnOicgKyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlICsgJzonICsgaWJTbGljZSArICc6JyArIGFjY2Vzc29yRGVmLmNvdW50O1xuXHRcdFx0XHRsZXQgaWIgPSBwYXJzZXIuY2FjaGUuZ2V0KCBpYkNhY2hlS2V5ICk7XG5cblx0XHRcdFx0aWYgKCAhIGliICkge1xuXG5cdFx0XHRcdFx0YXJyYXkgPSBuZXcgVHlwZWRBcnJheSggYnVmZmVyVmlldywgaWJTbGljZSAqIGJ5dGVTdHJpZGUsIGFjY2Vzc29yRGVmLmNvdW50ICogYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyApO1xuXG5cdFx0XHRcdFx0Ly8gSW50ZWdlciBwYXJhbWV0ZXJzIHRvIElCL0lCQSBhcmUgaW4gYXJyYXkgZWxlbWVudHMsIG5vdCBieXRlcy5cblx0XHRcdFx0XHRpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMgKTtcblxuXHRcdFx0XHRcdHBhcnNlci5jYWNoZS5hZGQoIGliQ2FjaGVLZXksIGliICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaWIsIGl0ZW1TaXplLCAoIGJ5dGVPZmZzZXQgJSBieXRlU3RyaWRlICkgLyBlbGVtZW50Qnl0ZXMsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGJ1ZmZlclZpZXcgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRhcnJheSA9IG5ldyBUeXBlZEFycmF5KCBhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoIGJ1ZmZlclZpZXcsIGJ5dGVPZmZzZXQsIGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNzcGFyc2UtYWNjZXNzb3JzXG5cdFx0XHRpZiAoIGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnN0IGl0ZW1TaXplSW5kaWNlcyA9IFdFQkdMX1RZUEVfU0laRVMuU0NBTEFSO1xuXHRcdFx0XHRjb25zdCBUeXBlZEFycmF5SW5kaWNlcyA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1sgYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuY29tcG9uZW50VHlwZSBdO1xuXG5cdFx0XHRcdGNvbnN0IGJ5dGVPZmZzZXRJbmRpY2VzID0gYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnl0ZU9mZnNldCB8fCAwO1xuXHRcdFx0XHRjb25zdCBieXRlT2Zmc2V0VmFsdWVzID0gYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0IHx8IDA7XG5cblx0XHRcdFx0Y29uc3Qgc3BhcnNlSW5kaWNlcyA9IG5ldyBUeXBlZEFycmF5SW5kaWNlcyggYnVmZmVyVmlld3NbIDEgXSwgYnl0ZU9mZnNldEluZGljZXMsIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplSW5kaWNlcyApO1xuXHRcdFx0XHRjb25zdCBzcGFyc2VWYWx1ZXMgPSBuZXcgVHlwZWRBcnJheSggYnVmZmVyVmlld3NbIDIgXSwgYnl0ZU9mZnNldFZhbHVlcywgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHRpZiAoIGJ1ZmZlclZpZXcgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHQvLyBBdm9pZCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIEFycmF5QnVmZmVyLCBpZiB0aGUgYnVmZmVyVmlldyB3YXNuJ3QgaW5pdGlhbGl6ZWQgd2l0aCB6ZXJvZXMuXG5cdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyQXR0cmlidXRlLmFycmF5LnNsaWNlKCksIGJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSwgYnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHNwYXJzZUluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IHNwYXJzZUluZGljZXNbIGkgXTtcblxuXHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZS5zZXRYKCBpbmRleCwgc3BhcnNlVmFsdWVzWyBpICogaXRlbVNpemUgXSApO1xuXHRcdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMiApIGJ1ZmZlckF0dHJpYnV0ZS5zZXRZKCBpbmRleCwgc3BhcnNlVmFsdWVzWyBpICogaXRlbVNpemUgKyAxIF0gKTtcblx0XHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDMgKSBidWZmZXJBdHRyaWJ1dGUuc2V0WiggaW5kZXgsIHNwYXJzZVZhbHVlc1sgaSAqIGl0ZW1TaXplICsgMiBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA0ICkgYnVmZmVyQXR0cmlidXRlLnNldFcoIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSArIDMgXSApO1xuXHRcdFx0XHRcdGlmICggaXRlbVNpemUgPj0gNSApIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGl0ZW1TaXplIGluIHNwYXJzZSBCdWZmZXJBdHRyaWJ1dGUuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVmZmVyQXR0cmlidXRlO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3RleHR1cmVzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0dXJlSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5UZXh0dXJlfG51bGw+fVxuXHQgKi9cblx0bG9hZFRleHR1cmUoIHRleHR1cmVJbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1sgdGV4dHVyZUluZGV4IF07XG5cdFx0Y29uc3Qgc291cmNlSW5kZXggPSB0ZXh0dXJlRGVmLnNvdXJjZTtcblx0XHRjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1sgc291cmNlSW5kZXggXTtcblxuXHRcdGxldCBsb2FkZXIgPSB0aGlzLnRleHR1cmVMb2FkZXI7XG5cblx0XHRpZiAoIHNvdXJjZURlZi51cmkgKSB7XG5cblx0XHRcdGNvbnN0IGhhbmRsZXIgPSBvcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlciggc291cmNlRGVmLnVyaSApO1xuXHRcdFx0aWYgKCBoYW5kbGVyICE9PSBudWxsICkgbG9hZGVyID0gaGFuZGxlcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmxvYWRUZXh0dXJlSW1hZ2UoIHRleHR1cmVJbmRleCwgc291cmNlSW5kZXgsIGxvYWRlciApO1xuXG5cdH1cblxuXHRsb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIHNvdXJjZUluZGV4LCBsb2FkZXIgKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cblx0XHRjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1sgdGV4dHVyZUluZGV4IF07XG5cdFx0Y29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbIHNvdXJjZUluZGV4IF07XG5cblx0XHRjb25zdCBjYWNoZUtleSA9ICggc291cmNlRGVmLnVyaSB8fCBzb3VyY2VEZWYuYnVmZmVyVmlldyApICsgJzonICsgdGV4dHVyZURlZi5zYW1wbGVyO1xuXG5cdFx0aWYgKCB0aGlzLnRleHR1cmVDYWNoZVsgY2FjaGVLZXkgXSApIHtcblxuXHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzIxNTU5LlxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlWyBjYWNoZUtleSBdO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcHJvbWlzZSA9IHRoaXMubG9hZEltYWdlU291cmNlKCBzb3VyY2VJbmRleCwgbG9hZGVyICkudGhlbiggZnVuY3Rpb24gKCB0ZXh0dXJlICkge1xuXG5cdFx0XHR0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG5cblx0XHRcdHRleHR1cmUubmFtZSA9IHRleHR1cmVEZWYubmFtZSB8fCBzb3VyY2VEZWYubmFtZSB8fCAnJztcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLm5hbWUgPT09ICcnICYmIHR5cGVvZiBzb3VyY2VEZWYudXJpID09PSAnc3RyaW5nJyAmJiBzb3VyY2VEZWYudXJpLnN0YXJ0c1dpdGgoICdkYXRhOmltYWdlLycgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5uYW1lID0gc291cmNlRGVmLnVyaTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzYW1wbGVycyA9IGpzb24uc2FtcGxlcnMgfHwge307XG5cdFx0XHRjb25zdCBzYW1wbGVyID0gc2FtcGxlcnNbIHRleHR1cmVEZWYuc2FtcGxlciBdIHx8IHt9O1xuXG5cdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbIHNhbXBsZXIubWFnRmlsdGVyIF0gfHwgTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBXRUJHTF9GSUxURVJTWyBzYW1wbGVyLm1pbkZpbHRlciBdIHx8IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjtcblx0XHRcdHRleHR1cmUud3JhcFMgPSBXRUJHTF9XUkFQUElOR1NbIHNhbXBsZXIud3JhcFMgXSB8fCBSZXBlYXRXcmFwcGluZztcblx0XHRcdHRleHR1cmUud3JhcFQgPSBXRUJHTF9XUkFQUElOR1NbIHNhbXBsZXIud3JhcFQgXSB8fCBSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoIHRleHR1cmUsIHsgdGV4dHVyZXM6IHRleHR1cmVJbmRleCB9ICk7XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSApLmNhdGNoKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy50ZXh0dXJlQ2FjaGVbIGNhY2hlS2V5IF0gPSBwcm9taXNlO1xuXG5cdFx0cmV0dXJuIHByb21pc2U7XG5cblx0fVxuXG5cdGxvYWRJbWFnZVNvdXJjZSggc291cmNlSW5kZXgsIGxvYWRlciApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cdFx0Y29uc3QganNvbiA9IHRoaXMuanNvbjtcblx0XHRjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCB0aGlzLnNvdXJjZUNhY2hlWyBzb3VyY2VJbmRleCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnNvdXJjZUNhY2hlWyBzb3VyY2VJbmRleCBdLnRoZW4oICggdGV4dHVyZSApID0+IHRleHR1cmUuY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbIHNvdXJjZUluZGV4IF07XG5cblx0XHRjb25zdCBVUkwgPSBzZWxmLlVSTCB8fCBzZWxmLndlYmtpdFVSTDtcblxuXHRcdGxldCBzb3VyY2VVUkkgPSBzb3VyY2VEZWYudXJpIHx8ICcnO1xuXHRcdGxldCBpc09iamVjdFVSTCA9IGZhbHNlO1xuXG5cdFx0aWYgKCBzb3VyY2VEZWYuYnVmZmVyVmlldyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBMb2FkIGJpbmFyeSBpbWFnZSBkYXRhIGZyb20gYnVmZmVyVmlldywgaWYgcHJvdmlkZWQuXG5cblx0XHRcdHNvdXJjZVVSSSA9IHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIHNvdXJjZURlZi5idWZmZXJWaWV3ICkudGhlbiggZnVuY3Rpb24gKCBidWZmZXJWaWV3ICkge1xuXG5cdFx0XHRcdGlzT2JqZWN0VVJMID0gdHJ1ZTtcblx0XHRcdFx0Y29uc3QgYmxvYiA9IG5ldyBCbG9iKCBbIGJ1ZmZlclZpZXcgXSwgeyB0eXBlOiBzb3VyY2VEZWYubWltZVR5cGUgfSApO1xuXHRcdFx0XHRzb3VyY2VVUkkgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKCBibG9iICk7XG5cdFx0XHRcdHJldHVybiBzb3VyY2VVUkk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gZWxzZSBpZiAoIHNvdXJjZURlZi51cmkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogSW1hZ2UgJyArIHNvdXJjZUluZGV4ICsgJyBpcyBtaXNzaW5nIFVSSSBhbmQgYnVmZmVyVmlldycgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoIHNvdXJjZVVSSSApLnRoZW4oIGZ1bmN0aW9uICggc291cmNlVVJJICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSwgcmVqZWN0ICkge1xuXG5cdFx0XHRcdGxldCBvbkxvYWQgPSByZXNvbHZlO1xuXG5cdFx0XHRcdGlmICggbG9hZGVyLmlzSW1hZ2VCaXRtYXBMb2FkZXIgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRvbkxvYWQgPSBmdW5jdGlvbiAoIGltYWdlQml0bWFwICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoIGltYWdlQml0bWFwICk7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0cmVzb2x2ZSggdGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bG9hZGVyLmxvYWQoIExvYWRlclV0aWxzLnJlc29sdmVVUkwoIHNvdXJjZVVSSSwgb3B0aW9ucy5wYXRoICksIG9uTG9hZCwgdW5kZWZpbmVkLCByZWplY3QgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgcmVzb3VyY2VzIGFuZCBjb25maWd1cmUgVGV4dHVyZS5cblxuXHRcdFx0aWYgKCBpc09iamVjdFVSTCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKCBzb3VyY2VVUkkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlLnVzZXJEYXRhLm1pbWVUeXBlID0gc291cmNlRGVmLm1pbWVUeXBlIHx8IGdldEltYWdlVVJJTWltZVR5cGUoIHNvdXJjZURlZi51cmkgKTtcblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9ICkuY2F0Y2goIGZ1bmN0aW9uICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBDb3VsZG5cXCd0IGxvYWQgdGV4dHVyZScsIHNvdXJjZVVSSSApO1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnNvdXJjZUNhY2hlWyBzb3VyY2VJbmRleCBdID0gcHJvbWlzZTtcblx0XHRyZXR1cm4gcHJvbWlzZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IGFzc2lnbnMgYSB0ZXh0dXJlIHRvIHRoZSBnaXZlbiBtYXRlcmlhbCBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxQYXJhbXNcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IG1hcERlZlxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRleHR1cmU+fVxuXHQgKi9cblx0YXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsIG1hcE5hbWUsIG1hcERlZiwgY29sb3JTcGFjZSApIHtcblxuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KCAndGV4dHVyZScsIG1hcERlZi5pbmRleCApLnRoZW4oIGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuXHRcdFx0aWYgKCAhIHRleHR1cmUgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0aWYgKCBtYXBEZWYudGV4Q29vcmQgIT09IHVuZGVmaW5lZCAmJiBtYXBEZWYudGV4Q29vcmQgPiAwICkge1xuXG5cdFx0XHRcdHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG5cdFx0XHRcdHRleHR1cmUuY2hhbm5lbCA9IG1hcERlZi50ZXhDb29yZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBhcnNlci5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STSBdICkge1xuXG5cdFx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IG1hcERlZi5leHRlbnNpb25zICE9PSB1bmRlZmluZWQgPyBtYXBEZWYuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk0gXSA6IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRpZiAoIHRyYW5zZm9ybSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdsdGZSZWZlcmVuY2UgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldCggdGV4dHVyZSApO1xuXHRcdFx0XHRcdHRleHR1cmUgPSBwYXJzZXIuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk0gXS5leHRlbmRUZXh0dXJlKCB0ZXh0dXJlLCB0cmFuc2Zvcm0gKTtcblx0XHRcdFx0XHRwYXJzZXIuYXNzb2NpYXRpb25zLnNldCggdGV4dHVyZSwgZ2x0ZlJlZmVyZW5jZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNvbG9yU3BhY2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zWyBtYXBOYW1lIF0gPSB0ZXh0dXJlO1xuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEFzc2lnbnMgZmluYWwgbWF0ZXJpYWwgdG8gYSBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuIFRoZSBpbnN0YW5jZVxuXHQgKiBhbHJlYWR5IGhhcyBhIG1hdGVyaWFsIChnZW5lcmF0ZWQgZnJvbSB0aGUgZ2xURiBtYXRlcmlhbCBvcHRpb25zIGFsb25lKVxuXHQgKiBidXQgcmV1c2Ugb2YgdGhlIHNhbWUgZ2xURiBtYXRlcmlhbCBtYXkgcmVxdWlyZSBtdWx0aXBsZSB0aHJlZWpzIG1hdGVyaWFsc1xuXHQgKiB0byBhY2NvbW1vZGF0ZSBkaWZmZXJlbnQgcHJpbWl0aXZlIHR5cGVzLCBkZWZpbmVzLCBldGMuIE5ldyBtYXRlcmlhbHMgd2lsbFxuXHQgKiBiZSBjcmVhdGVkIGlmIG5lY2Vzc2FyeSwgYW5kIHJldXNlZCBmcm9tIGEgY2FjaGUuXG5cdCAqIEBwYXJhbSAge09iamVjdDNEfSBtZXNoIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS5cblx0ICovXG5cdGFzc2lnbkZpbmFsTWF0ZXJpYWwoIG1lc2ggKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IG1lc2guZ2VvbWV0cnk7XG5cdFx0bGV0IG1hdGVyaWFsID0gbWVzaC5tYXRlcmlhbDtcblxuXHRcdGNvbnN0IHVzZURlcml2YXRpdmVUYW5nZW50cyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudGFuZ2VudCA9PT0gdW5kZWZpbmVkO1xuXHRcdGNvbnN0IHVzZVZlcnRleENvbG9ycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZDtcblx0XHRjb25zdCB1c2VGbGF0U2hhZGluZyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIG1lc2guaXNQb2ludHMgKSB7XG5cblx0XHRcdGNvbnN0IGNhY2hlS2V5ID0gJ1BvaW50c01hdGVyaWFsOicgKyBtYXRlcmlhbC51dWlkO1xuXG5cdFx0XHRsZXQgcG9pbnRzTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdFx0aWYgKCAhIHBvaW50c01hdGVyaWFsICkge1xuXG5cdFx0XHRcdHBvaW50c01hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCk7XG5cdFx0XHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHBvaW50c01hdGVyaWFsLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRwb2ludHNNYXRlcmlhbC5jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXHRcdFx0XHRwb2ludHNNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHRcdHBvaW50c01hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGZhbHNlOyAvLyBnbFRGIHNwZWMgc2F5cyBwb2ludHMgc2hvdWxkIGJlIDFweFxuXG5cdFx0XHRcdHRoaXMuY2FjaGUuYWRkKCBjYWNoZUtleSwgcG9pbnRzTWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbCA9IHBvaW50c01hdGVyaWFsO1xuXG5cdFx0fSBlbHNlIGlmICggbWVzaC5pc0xpbmUgKSB7XG5cblx0XHRcdGNvbnN0IGNhY2hlS2V5ID0gJ0xpbmVCYXNpY01hdGVyaWFsOicgKyBtYXRlcmlhbC51dWlkO1xuXG5cdFx0XHRsZXQgbGluZU1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRcdGlmICggISBsaW5lTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0bGluZU1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCk7XG5cdFx0XHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIGxpbmVNYXRlcmlhbCwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0bGluZU1hdGVyaWFsLmNvbG9yLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XG5cdFx0XHRcdGxpbmVNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG5cblx0XHRcdFx0dGhpcy5jYWNoZS5hZGQoIGNhY2hlS2V5LCBsaW5lTWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbCA9IGxpbmVNYXRlcmlhbDtcblxuXHRcdH1cblxuXHRcdC8vIENsb25lIHRoZSBtYXRlcmlhbCBpZiBpdCB3aWxsIGJlIG1vZGlmaWVkXG5cdFx0aWYgKCB1c2VEZXJpdmF0aXZlVGFuZ2VudHMgfHwgdXNlVmVydGV4Q29sb3JzIHx8IHVzZUZsYXRTaGFkaW5nICkge1xuXG5cdFx0XHRsZXQgY2FjaGVLZXkgPSAnQ2xvbmVkTWF0ZXJpYWw6JyArIG1hdGVyaWFsLnV1aWQgKyAnOic7XG5cblx0XHRcdGlmICggdXNlRGVyaXZhdGl2ZVRhbmdlbnRzICkgY2FjaGVLZXkgKz0gJ2Rlcml2YXRpdmUtdGFuZ2VudHM6Jztcblx0XHRcdGlmICggdXNlVmVydGV4Q29sb3JzICkgY2FjaGVLZXkgKz0gJ3ZlcnRleC1jb2xvcnM6Jztcblx0XHRcdGlmICggdXNlRmxhdFNoYWRpbmcgKSBjYWNoZUtleSArPSAnZmxhdC1zaGFkaW5nOic7XG5cblx0XHRcdGxldCBjYWNoZWRNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0XHRpZiAoICEgY2FjaGVkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0Y2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbC5jbG9uZSgpO1xuXG5cdFx0XHRcdGlmICggdXNlVmVydGV4Q29sb3JzICkgY2FjaGVkTWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VGbGF0U2hhZGluZyApIGNhY2hlZE1hdGVyaWFsLmZsYXRTaGFkaW5nID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIHVzZURlcml2YXRpdmVUYW5nZW50cyApIHtcblxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzExNDM4I2lzc3VlY29tbWVudC01MDcwMDM5OTVcblx0XHRcdFx0XHRpZiAoIGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlICkgY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUueSAqPSAtIDE7XG5cdFx0XHRcdFx0aWYgKCBjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSApIGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlLnkgKj0gLSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIGNhY2hlZE1hdGVyaWFsICk7XG5cblx0XHRcdFx0dGhpcy5hc3NvY2lhdGlvbnMuc2V0KCBjYWNoZWRNYXRlcmlhbCwgdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KCBtYXRlcmlhbCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwgPSBjYWNoZWRNYXRlcmlhbDtcblxuXHRcdH1cblxuXHRcdG1lc2gubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuXHR9XG5cblx0Z2V0TWF0ZXJpYWxUeXBlKCAvKiBtYXRlcmlhbEluZGV4ICovICkge1xuXG5cdFx0cmV0dXJuIE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtYXRlcmlhbHNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1hdGVyaWFsSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxNYXRlcmlhbD59XG5cdCAqL1xuXHRsb2FkTWF0ZXJpYWwoIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHRjb25zdCBtYXRlcmlhbERlZiA9IGpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRsZXQgbWF0ZXJpYWxUeXBlO1xuXHRcdGNvbnN0IG1hdGVyaWFsUGFyYW1zID0ge307XG5cdFx0Y29uc3QgbWF0ZXJpYWxFeHRlbnNpb25zID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCB7fTtcblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGlmICggbWF0ZXJpYWxFeHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQgXSApIHtcblxuXHRcdFx0Y29uc3Qga211RXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUIF07XG5cdFx0XHRtYXRlcmlhbFR5cGUgPSBrbXVFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG5cdFx0XHRwZW5kaW5nLnB1c2goIGttdUV4dGVuc2lvbi5leHRlbmRQYXJhbXMoIG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFNwZWNpZmljYXRpb246XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbWV0YWxsaWMtcm91Z2huZXNzLW1hdGVyaWFsXG5cblx0XHRcdGNvbnN0IG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MgfHwge307XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKCAxLjAsIDEuMCwgMS4wICk7XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMS4wO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvciApICkge1xuXG5cdFx0XHRcdGNvbnN0IGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yLnNldFJHQiggYXJyYXlbIDAgXSwgYXJyYXlbIDEgXSwgYXJyYXlbIDIgXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UgKTtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WyAzIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMubWV0YWxuZXNzID0gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgIT09IHVuZGVmaW5lZCA/IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yIDogMS4wO1xuXHRcdFx0bWF0ZXJpYWxQYXJhbXMucm91Z2huZXNzID0gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yICE9PSB1bmRlZmluZWQgPyBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgOiAxLjA7XG5cblx0XHRcdGlmICggbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtZXRhbG5lc3NNYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgKSApO1xuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3JvdWdobmVzc01hcCcsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWxUeXBlID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0LmdldE1hdGVyaWFsVHlwZSAmJiBleHQuZ2V0TWF0ZXJpYWxUeXBlKCBtYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBQcm9taXNlLmFsbCggdGhpcy5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zICYmIGV4dC5leHRlbmRNYXRlcmlhbFBhcmFtcyggbWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMgKTtcblxuXHRcdFx0fSApICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYuZG91YmxlU2lkZWQgPT09IHRydWUgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLnNpZGUgPSBEb3VibGVTaWRlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYWxwaGFNb2RlID0gbWF0ZXJpYWxEZWYuYWxwaGFNb2RlIHx8IEFMUEhBX01PREVTLk9QQVFVRTtcblxuXHRcdGlmICggYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5CTEVORCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0XHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE3NzA2XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5kZXB0aFdyaXRlID0gZmFsc2U7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIGFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuTUFTSyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5hbHBoYVRlc3QgPSBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgOiAwLjU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnbm9ybWFsTWFwJywgbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSApICk7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2NhbGUgPSBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlLnNldCggc2NhbGUsIHNjYWxlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnYW9NYXAnLCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlICkgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuYW9NYXBJbnRlbnNpdHkgPSBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0Y29uc3QgZW1pc3NpdmVGYWN0b3IgPSBtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3Rvcjtcblx0XHRcdG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlID0gbmV3IENvbG9yKCkuc2V0UkdCKCBlbWlzc2l2ZUZhY3RvclsgMCBdLCBlbWlzc2l2ZUZhY3RvclsgMSBdLCBlbWlzc2l2ZUZhY3RvclsgMiBdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2VtaXNzaXZlTWFwJywgbWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IG1hdGVyaWFsVHlwZSggbWF0ZXJpYWxQYXJhbXMgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5uYW1lICkgbWF0ZXJpYWwubmFtZSA9IG1hdGVyaWFsRGVmLm5hbWU7XG5cblx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIG1hdGVyaWFsLCBtYXRlcmlhbERlZiApO1xuXG5cdFx0XHRwYXJzZXIuYXNzb2NpYXRpb25zLnNldCggbWF0ZXJpYWwsIHsgbWF0ZXJpYWxzOiBtYXRlcmlhbEluZGV4IH0gKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5leHRlbnNpb25zICkgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKiogV2hlbiBPYmplY3QzRCBpbnN0YW5jZXMgYXJlIHRhcmdldGVkIGJ5IGFuaW1hdGlvbiwgdGhleSBuZWVkIHVuaXF1ZSBuYW1lcy4gKi9cblx0Y3JlYXRlVW5pcXVlTmFtZSggb3JpZ2luYWxOYW1lICkge1xuXG5cdFx0Y29uc3Qgc2FuaXRpemVkTmFtZSA9IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCBvcmlnaW5hbE5hbWUgfHwgJycgKTtcblxuXHRcdGlmICggc2FuaXRpemVkTmFtZSBpbiB0aGlzLm5vZGVOYW1lc1VzZWQgKSB7XG5cblx0XHRcdHJldHVybiBzYW5pdGl6ZWROYW1lICsgJ18nICsgKCArKyB0aGlzLm5vZGVOYW1lc1VzZWRbIHNhbml0aXplZE5hbWUgXSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5ub2RlTmFtZXNVc2VkWyBzYW5pdGl6ZWROYW1lIF0gPSAwO1xuXG5cdFx0XHRyZXR1cm4gc2FuaXRpemVkTmFtZTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjZ2VvbWV0cnlcblx0ICpcblx0ICogQ3JlYXRlcyBCdWZmZXJHZW9tZXRyaWVzIGZyb20gcHJpbWl0aXZlcy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxHTFRGLlByaW1pdGl2ZT59IHByaW1pdGl2ZXNcblx0ICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxCdWZmZXJHZW9tZXRyeT4+fVxuXHQgKi9cblx0bG9hZEdlb21ldHJpZXMoIHByaW1pdGl2ZXMgKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLnByaW1pdGl2ZUNhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlRHJhY29QcmltaXRpdmUoIHByaW1pdGl2ZSApIHtcblxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04gXVxuXHRcdFx0XHQuZGVjb2RlUHJpbWl0aXZlKCBwcmltaXRpdmUsIHBhcnNlciApXG5cdFx0XHRcdC50aGVuKCBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoIGdlb21ldHJ5LCBwcmltaXRpdmUsIHBhcnNlciApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzWyBpIF07XG5cdFx0XHRjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVByaW1pdGl2ZUtleSggcHJpbWl0aXZlICk7XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgdGhpcyBnZW9tZXRyeVxuXHRcdFx0Y29uc3QgY2FjaGVkID0gY2FjaGVbIGNhY2hlS2V5IF07XG5cblx0XHRcdGlmICggY2FjaGVkICkge1xuXG5cdFx0XHRcdC8vIFVzZSB0aGUgY2FjaGVkIGdlb21ldHJ5IGlmIGl0IGV4aXN0c1xuXHRcdFx0XHRwZW5kaW5nLnB1c2goIGNhY2hlZC5wcm9taXNlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bGV0IGdlb21ldHJ5UHJvbWlzZTtcblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5leHRlbnNpb25zICYmIHByaW1pdGl2ZS5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBVc2UgRFJBQ08gZ2VvbWV0cnkgaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0Z2VvbWV0cnlQcm9taXNlID0gY3JlYXRlRHJhY29QcmltaXRpdmUoIHByaW1pdGl2ZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGdlb21ldHJ5XG5cdFx0XHRcdFx0Z2VvbWV0cnlQcm9taXNlID0gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyggbmV3IEJ1ZmZlckdlb21ldHJ5KCksIHByaW1pdGl2ZSwgcGFyc2VyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhY2hlIHRoaXMgZ2VvbWV0cnlcblx0XHRcdFx0Y2FjaGVbIGNhY2hlS2V5IF0gPSB7IHByaW1pdGl2ZTogcHJpbWl0aXZlLCBwcm9taXNlOiBnZW9tZXRyeVByb21pc2UgfTtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIGdlb21ldHJ5UHJvbWlzZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWVzaGVzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtZXNoSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxHcm91cHxNZXNofFNraW5uZWRNZXNoPn1cblx0ICovXG5cdGxvYWRNZXNoKCBtZXNoSW5kZXggKSB7XG5cblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblxuXHRcdGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1sgbWVzaEluZGV4IF07XG5cdFx0Y29uc3QgcHJpbWl0aXZlcyA9IG1lc2hEZWYucHJpbWl0aXZlcztcblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IHByaW1pdGl2ZXNbIGkgXS5tYXRlcmlhbCA9PT0gdW5kZWZpbmVkXG5cdFx0XHRcdD8gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKCB0aGlzLmNhY2hlIClcblx0XHRcdFx0OiB0aGlzLmdldERlcGVuZGVuY3koICdtYXRlcmlhbCcsIHByaW1pdGl2ZXNbIGkgXS5tYXRlcmlhbCApO1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5sb2FkR2VvbWV0cmllcyggcHJpbWl0aXZlcyApICk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoIHJlc3VsdHMgKSB7XG5cblx0XHRcdGNvbnN0IG1hdGVyaWFscyA9IHJlc3VsdHMuc2xpY2UoIDAsIHJlc3VsdHMubGVuZ3RoIC0gMSApO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cmllcyA9IHJlc3VsdHNbIHJlc3VsdHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRjb25zdCBtZXNoZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbIGkgXTtcblxuXHRcdFx0XHQvLyAxLiBjcmVhdGUgTWVzaFxuXG5cdFx0XHRcdGxldCBtZXNoO1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbWF0ZXJpYWxzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyB8fFxuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCB8fFxuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gfHxcblx0XHRcdFx0XHRcdHByaW1pdGl2ZS5tb2RlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyAuaXNTa2lubmVkTWVzaCBpc24ndCBpbiBnbFRGIHNwZWMuIFNlZSAuX21hcmtEZWZzKClcblx0XHRcdFx0XHRtZXNoID0gbWVzaERlZi5pc1NraW5uZWRNZXNoID09PSB0cnVlXG5cdFx0XHRcdFx0XHQ/IG5ldyBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsIClcblx0XHRcdFx0XHRcdDogbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZXNoLmlzU2tpbm5lZE1lc2ggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIG5vcm1hbGl6ZSBza2luIHdlaWdodHMgdG8gZml4IG1hbGZvcm1lZCBhc3NldHMgKHNlZSAjMTUzMTkpXG5cdFx0XHRcdFx0XHRtZXNoLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgKSB7XG5cblx0XHRcdFx0XHRcdG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKCBtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZVN0cmlwRHJhd01vZGUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOICkge1xuXG5cdFx0XHRcdFx0XHRtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZSggbWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVGYW5EcmF3TW9kZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORVMgKSB7XG5cblx0XHRcdFx0XHRtZXNoID0gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX1NUUklQICkge1xuXG5cdFx0XHRcdFx0bWVzaCA9IG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfTE9PUCApIHtcblxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgTGluZUxvb3AoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuUE9JTlRTICkge1xuXG5cdFx0XHRcdFx0bWVzaCA9IG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBQcmltaXRpdmUgbW9kZSB1bnN1cHBvcnRlZDogJyArIHByaW1pdGl2ZS5tb2RlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggT2JqZWN0LmtleXMoIG1lc2guZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICkubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdHVwZGF0ZU1vcnBoVGFyZ2V0cyggbWVzaCwgbWVzaERlZiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtZXNoLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZSggbWVzaERlZi5uYW1lIHx8ICggJ21lc2hfJyArIG1lc2hJbmRleCApICk7XG5cblx0XHRcdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggbWVzaCwgbWVzaERlZiApO1xuXG5cdFx0XHRcdGlmICggcHJpbWl0aXZlLmV4dGVuc2lvbnMgKSBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIG1lc2gsIHByaW1pdGl2ZSApO1xuXG5cdFx0XHRcdHBhcnNlci5hc3NpZ25GaW5hbE1hdGVyaWFsKCBtZXNoICk7XG5cblx0XHRcdFx0bWVzaGVzLnB1c2goIG1lc2ggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KCBtZXNoZXNbIGkgXSwge1xuXHRcdFx0XHRcdG1lc2hlczogbWVzaEluZGV4LFxuXHRcdFx0XHRcdHByaW1pdGl2ZXM6IGlcblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWVzaGVzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRpZiAoIG1lc2hEZWYuZXh0ZW5zaW9ucyApIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgbWVzaGVzWyAwIF0sIG1lc2hEZWYgKTtcblxuXHRcdFx0XHRyZXR1cm4gbWVzaGVzWyAwIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0aWYgKCBtZXNoRGVmLmV4dGVuc2lvbnMgKSBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIGdyb3VwLCBtZXNoRGVmICk7XG5cblx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KCBncm91cCwgeyBtZXNoZXM6IG1lc2hJbmRleCB9ICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Z3JvdXAuYWRkKCBtZXNoZXNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBncm91cDtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNjYW1lcmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjYW1lcmFJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLkNhbWVyYT59XG5cdCAqL1xuXHRsb2FkQ2FtZXJhKCBjYW1lcmFJbmRleCApIHtcblxuXHRcdGxldCBjYW1lcmE7XG5cdFx0Y29uc3QgY2FtZXJhRGVmID0gdGhpcy5qc29uLmNhbWVyYXNbIGNhbWVyYUluZGV4IF07XG5cdFx0Y29uc3QgcGFyYW1zID0gY2FtZXJhRGVmWyBjYW1lcmFEZWYudHlwZSBdO1xuXG5cdFx0aWYgKCAhIHBhcmFtcyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBjYW1lcmEgcGFyYW1ldGVycy4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIGNhbWVyYURlZi50eXBlID09PSAncGVyc3BlY3RpdmUnICkge1xuXG5cdFx0XHRjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIE1hdGhVdGlscy5yYWRUb0RlZyggcGFyYW1zLnlmb3YgKSwgcGFyYW1zLmFzcGVjdFJhdGlvIHx8IDEsIHBhcmFtcy56bmVhciB8fCAxLCBwYXJhbXMuemZhciB8fCAyZTYgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGNhbWVyYURlZi50eXBlID09PSAnb3J0aG9ncmFwaGljJyApIHtcblxuXHRcdFx0Y2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSBwYXJhbXMueG1hZywgcGFyYW1zLnhtYWcsIHBhcmFtcy55bWFnLCAtIHBhcmFtcy55bWFnLCBwYXJhbXMuem5lYXIsIHBhcmFtcy56ZmFyICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNhbWVyYURlZi5uYW1lICkgY2FtZXJhLm5hbWUgPSB0aGlzLmNyZWF0ZVVuaXF1ZU5hbWUoIGNhbWVyYURlZi5uYW1lICk7XG5cblx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBjYW1lcmEsIGNhbWVyYURlZiApO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggY2FtZXJhICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2tpbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNraW5JbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFNrZWxldG9uPn1cblx0ICovXG5cdGxvYWRTa2luKCBza2luSW5kZXggKSB7XG5cblx0XHRjb25zdCBza2luRGVmID0gdGhpcy5qc29uLnNraW5zWyBza2luSW5kZXggXTtcblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBza2luRGVmLmpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCB0aGlzLl9sb2FkTm9kZVNoYWxsb3coIHNraW5EZWYuam9pbnRzWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcyApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIG51bGwgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICggcmVzdWx0cyApIHtcblxuXHRcdFx0Y29uc3QgaW52ZXJzZUJpbmRNYXRyaWNlcyA9IHJlc3VsdHMucG9wKCk7XG5cdFx0XHRjb25zdCBqb2ludE5vZGVzID0gcmVzdWx0cztcblxuXHRcdFx0Ly8gTm90ZSB0aGF0IGJvbmVzIChqb2ludCBub2RlcykgbWF5IG9yIG1heSBub3QgYmUgaW4gdGhlXG5cdFx0XHQvLyBzY2VuZSBncmFwaCBhdCB0aGlzIHRpbWUuXG5cblx0XHRcdGNvbnN0IGJvbmVzID0gW107XG5cdFx0XHRjb25zdCBib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGpvaW50Tm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgam9pbnROb2RlID0gam9pbnROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggam9pbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ym9uZXMucHVzaCggam9pbnROb2RlICk7XG5cblx0XHRcdFx0XHRjb25zdCBtYXQgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnZlcnNlQmluZE1hdHJpY2VzICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRtYXQuZnJvbUFycmF5KCBpbnZlcnNlQmluZE1hdHJpY2VzLmFycmF5LCBpICogMTYgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJvbmVJbnZlcnNlcy5wdXNoKCBtYXQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogSm9pbnQgXCIlc1wiIGNvdWxkIG5vdCBiZSBmb3VuZC4nLCBza2luRGVmLmpvaW50c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgU2tlbGV0b24oIGJvbmVzLCBib25lSW52ZXJzZXMgKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbmltYXRpb25JbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFuaW1hdGlvbkNsaXA+fVxuXHQgKi9cblx0bG9hZEFuaW1hdGlvbiggYW5pbWF0aW9uSW5kZXggKSB7XG5cblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cblx0XHRjb25zdCBhbmltYXRpb25EZWYgPSBqc29uLmFuaW1hdGlvbnNbIGFuaW1hdGlvbkluZGV4IF07XG5cdFx0Y29uc3QgYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbkRlZi5uYW1lID8gYW5pbWF0aW9uRGVmLm5hbWUgOiAnYW5pbWF0aW9uXycgKyBhbmltYXRpb25JbmRleDtcblxuXHRcdGNvbnN0IHBlbmRpbmdOb2RlcyA9IFtdO1xuXHRcdGNvbnN0IHBlbmRpbmdJbnB1dEFjY2Vzc29ycyA9IFtdO1xuXHRcdGNvbnN0IHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMgPSBbXTtcblx0XHRjb25zdCBwZW5kaW5nU2FtcGxlcnMgPSBbXTtcblx0XHRjb25zdCBwZW5kaW5nVGFyZ2V0cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2hhbm5lbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVsc1sgaSBdO1xuXHRcdFx0Y29uc3Qgc2FtcGxlciA9IGFuaW1hdGlvbkRlZi5zYW1wbGVyc1sgY2hhbm5lbC5zYW1wbGVyIF07XG5cdFx0XHRjb25zdCB0YXJnZXQgPSBjaGFubmVsLnRhcmdldDtcblx0XHRcdGNvbnN0IG5hbWUgPSB0YXJnZXQubm9kZTtcblx0XHRcdGNvbnN0IGlucHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzWyBzYW1wbGVyLmlucHV0IF0gOiBzYW1wbGVyLmlucHV0O1xuXHRcdFx0Y29uc3Qgb3V0cHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzWyBzYW1wbGVyLm91dHB1dCBdIDogc2FtcGxlci5vdXRwdXQ7XG5cblx0XHRcdGlmICggdGFyZ2V0Lm5vZGUgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRwZW5kaW5nTm9kZXMucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnbm9kZScsIG5hbWUgKSApO1xuXHRcdFx0cGVuZGluZ0lucHV0QWNjZXNzb3JzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgaW5wdXQgKSApO1xuXHRcdFx0cGVuZGluZ091dHB1dEFjY2Vzc29ycy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIG91dHB1dCApICk7XG5cdFx0XHRwZW5kaW5nU2FtcGxlcnMucHVzaCggc2FtcGxlciApO1xuXHRcdFx0cGVuZGluZ1RhcmdldHMucHVzaCggdGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIFtcblxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdOb2RlcyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdJbnB1dEFjY2Vzc29ycyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMgKSxcblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nU2FtcGxlcnMgKSxcblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nVGFyZ2V0cyApXG5cblx0XHRdICkudGhlbiggZnVuY3Rpb24gKCBkZXBlbmRlbmNpZXMgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGVzID0gZGVwZW5kZW5jaWVzWyAwIF07XG5cdFx0XHRjb25zdCBpbnB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1sgMSBdO1xuXHRcdFx0Y29uc3Qgb3V0cHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWyAyIF07XG5cdFx0XHRjb25zdCBzYW1wbGVycyA9IGRlcGVuZGVuY2llc1sgMyBdO1xuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9IGRlcGVuZGVuY2llc1sgNCBdO1xuXG5cdFx0XHRjb25zdCB0cmFja3MgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBpbnB1dEFjY2Vzc29yID0gaW5wdXRBY2Nlc3NvcnNbIGkgXTtcblx0XHRcdFx0Y29uc3Qgb3V0cHV0QWNjZXNzb3IgPSBvdXRwdXRBY2Nlc3NvcnNbIGkgXTtcblx0XHRcdFx0Y29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHRhcmdldCA9IHRhcmdldHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIG5vZGUgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmICggbm9kZS51cGRhdGVNYXRyaXggKSB7XG5cblx0XHRcdFx0XHRub2RlLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBjcmVhdGVkVHJhY2tzID0gcGFyc2VyLl9jcmVhdGVBbmltYXRpb25UcmFja3MoIG5vZGUsIGlucHV0QWNjZXNzb3IsIG91dHB1dEFjY2Vzc29yLCBzYW1wbGVyLCB0YXJnZXQgKTtcblxuXHRcdFx0XHRpZiAoIGNyZWF0ZWRUcmFja3MgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgayA9IDA7IGsgPCBjcmVhdGVkVHJhY2tzLmxlbmd0aDsgayArKyApIHtcblxuXHRcdFx0XHRcdFx0dHJhY2tzLnB1c2goIGNyZWF0ZWRUcmFja3NbIGsgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoIGFuaW1hdGlvbk5hbWUsIHVuZGVmaW5lZCwgdHJhY2tzICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGNyZWF0ZU5vZGVNZXNoKCBub2RlSW5kZXggKSB7XG5cblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cdFx0Y29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0aWYgKCBub2RlRGVmLm1lc2ggPT09IHVuZGVmaW5lZCApIHJldHVybiBudWxsO1xuXG5cdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnbWVzaCcsIG5vZGVEZWYubWVzaCApLnRoZW4oIGZ1bmN0aW9uICggbWVzaCApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZSA9IHBhcnNlci5fZ2V0Tm9kZVJlZiggcGFyc2VyLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoLCBtZXNoICk7XG5cblx0XHRcdC8vIGlmIHdlaWdodHMgYXJlIHByb3ZpZGVkIG9uIHRoZSBub2RlLCBvdmVycmlkZSB3ZWlnaHRzIG9uIHRoZSBtZXNoLlxuXHRcdFx0aWYgKCBub2RlRGVmLndlaWdodHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRub2RlLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG8gKSB7XG5cblx0XHRcdFx0XHRpZiAoICEgby5pc01lc2ggKSByZXR1cm47XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbm9kZURlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRvLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdID0gbm9kZURlZi53ZWlnaHRzWyBpIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI25vZGVzLWFuZC1oaWVyYXJjaHlcblx0ICogQHBhcmFtIHtudW1iZXJ9IG5vZGVJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEPn1cblx0ICovXG5cdGxvYWROb2RlKCBub2RlSW5kZXggKSB7XG5cblx0XHRjb25zdCBqc29uID0gdGhpcy5qc29uO1xuXHRcdGNvbnN0IHBhcnNlciA9IHRoaXM7XG5cblx0XHRjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRjb25zdCBub2RlUGVuZGluZyA9IHBhcnNlci5fbG9hZE5vZGVTaGFsbG93KCBub2RlSW5kZXggKTtcblxuXHRcdGNvbnN0IGNoaWxkUGVuZGluZyA9IFtdO1xuXHRcdGNvbnN0IGNoaWxkcmVuRGVmID0gbm9kZURlZi5jaGlsZHJlbiB8fCBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjaGlsZHJlbkRlZi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRQZW5kaW5nLnB1c2goIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnbm9kZScsIGNoaWxkcmVuRGVmWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2tlbGV0b25QZW5kaW5nID0gbm9kZURlZi5za2luID09PSB1bmRlZmluZWRcblx0XHRcdD8gUHJvbWlzZS5yZXNvbHZlKCBudWxsIClcblx0XHRcdDogcGFyc2VyLmdldERlcGVuZGVuY3koICdza2luJywgbm9kZURlZi5za2luICk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIFtcblx0XHRcdG5vZGVQZW5kaW5nLFxuXHRcdFx0UHJvbWlzZS5hbGwoIGNoaWxkUGVuZGluZyApLFxuXHRcdFx0c2tlbGV0b25QZW5kaW5nXG5cdFx0XSApLnRoZW4oIGZ1bmN0aW9uICggcmVzdWx0cyApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZSA9IHJlc3VsdHNbIDAgXTtcblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gcmVzdWx0c1sgMSBdO1xuXHRcdFx0Y29uc3Qgc2tlbGV0b24gPSByZXN1bHRzWyAyIF07XG5cblx0XHRcdGlmICggc2tlbGV0b24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gVGhpcyBmdWxsIHRyYXZlcnNlIHNob3VsZCBiZSBmaW5lIGJlY2F1c2Vcblx0XHRcdFx0Ly8gY2hpbGQgZ2xURiBub2RlcyBoYXZlIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgbm9kZSB5ZXQuXG5cdFx0XHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggbWVzaCApIHtcblxuXHRcdFx0XHRcdGlmICggISBtZXNoLmlzU2tpbm5lZE1lc2ggKSByZXR1cm47XG5cblx0XHRcdFx0XHRtZXNoLmJpbmQoIHNrZWxldG9uLCBfaWRlbnRpdHlNYXRyaXggKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdG5vZGUuYWRkKCBjaGlsZHJlblsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8vIC5fbG9hZE5vZGVTaGFsbG93KCkgcGFyc2VzIGEgc2luZ2xlIG5vZGUuXG5cdC8vIHNraW4gYW5kIGNoaWxkIG5vZGVzIGFyZSBjcmVhdGVkIGFuZCBhZGRlZCBpbiAubG9hZE5vZGUoKSAobm8gJ18nIHByZWZpeCkuXG5cdF9sb2FkTm9kZVNoYWxsb3coIG5vZGVJbmRleCApIHtcblxuXHRcdGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHRjb25zdCBwYXJzZXIgPSB0aGlzO1xuXG5cdFx0Ly8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGZyb20gLmxvYWROb2RlKCkgYW5kIC5sb2FkU2tpbigpLlxuXHRcdC8vIENhY2hlIGEgbm9kZSB0byBhdm9pZCBkdXBsaWNhdGlvbi5cblxuXHRcdGlmICggdGhpcy5ub2RlQ2FjaGVbIG5vZGVJbmRleCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm5vZGVDYWNoZVsgbm9kZUluZGV4IF07XG5cblx0XHR9XG5cblx0XHRjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHQvLyByZXNlcnZlIG5vZGUncyBuYW1lIGJlZm9yZSBpdHMgZGVwZW5kZW5jaWVzLCBzbyB0aGUgcm9vdCBoYXMgdGhlIGludGVuZGVkIG5hbWUuXG5cdFx0Y29uc3Qgbm9kZU5hbWUgPSBub2RlRGVmLm5hbWUgPyBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZSggbm9kZURlZi5uYW1lICkgOiAnJztcblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGNvbnN0IG1lc2hQcm9taXNlID0gcGFyc2VyLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRyZXR1cm4gZXh0LmNyZWF0ZU5vZGVNZXNoICYmIGV4dC5jcmVhdGVOb2RlTWVzaCggbm9kZUluZGV4ICk7XG5cblx0XHR9ICk7XG5cblx0XHRpZiAoIG1lc2hQcm9taXNlICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIG1lc2hQcm9taXNlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG5vZGVEZWYuY2FtZXJhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmdldERlcGVuZGVuY3koICdjYW1lcmEnLCBub2RlRGVmLmNhbWVyYSApLnRoZW4oIGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYoIHBhcnNlci5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEsIGNhbWVyYSApO1xuXG5cdFx0XHR9ICkgKTtcblxuXHRcdH1cblxuXHRcdHBhcnNlci5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0cmV0dXJuIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudCAmJiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQoIG5vZGVJbmRleCApO1xuXG5cdFx0fSApLmZvckVhY2goIGZ1bmN0aW9uICggcHJvbWlzZSApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwcm9taXNlICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLm5vZGVDYWNoZVsgbm9kZUluZGV4IF0gPSBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICggb2JqZWN0cyApIHtcblxuXHRcdFx0bGV0IG5vZGU7XG5cblx0XHRcdC8vIC5pc0JvbmUgaXNuJ3QgaW4gZ2xURiBzcGVjLiBTZWUgLl9tYXJrRGVmc1xuXHRcdFx0aWYgKCBub2RlRGVmLmlzQm9uZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRub2RlID0gbmV3IEJvbmUoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdG5vZGUgPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0cy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0bm9kZSA9IG9iamVjdHNbIDAgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlID0gbmV3IE9iamVjdDNEKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlICE9PSBvYmplY3RzWyAwIF0gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRub2RlLmFkZCggb2JqZWN0c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZURlZi5uYW1lICkge1xuXG5cdFx0XHRcdG5vZGUudXNlckRhdGEubmFtZSA9IG5vZGVEZWYubmFtZTtcblx0XHRcdFx0bm9kZS5uYW1lID0gbm9kZU5hbWU7XG5cblx0XHRcdH1cblxuXHRcdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggbm9kZSwgbm9kZURlZiApO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYuZXh0ZW5zaW9ucyApIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgbm9kZSwgbm9kZURlZiApO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdFx0bWF0cml4LmZyb21BcnJheSggbm9kZURlZi5tYXRyaXggKTtcblx0XHRcdFx0bm9kZS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggbm9kZURlZi50cmFuc2xhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9kZS5wb3NpdGlvbi5mcm9tQXJyYXkoIG5vZGVEZWYudHJhbnNsYXRpb24gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBub2RlRGVmLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub2RlLnF1YXRlcm5pb24uZnJvbUFycmF5KCBub2RlRGVmLnJvdGF0aW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbm9kZURlZi5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9kZS5zY2FsZS5mcm9tQXJyYXkoIG5vZGVEZWYuc2NhbGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIHBhcnNlci5hc3NvY2lhdGlvbnMuaGFzKCBub2RlICkgKSB7XG5cblx0XHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoIG5vZGUsIHt9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucy5nZXQoIG5vZGUgKS5ub2RlcyA9IG5vZGVJbmRleDtcblxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gdGhpcy5ub2RlQ2FjaGVbIG5vZGVJbmRleCBdO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NjZW5lc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NlbmVJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwPn1cblx0ICovXG5cdGxvYWRTY2VuZSggc2NlbmVJbmRleCApIHtcblxuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG5cdFx0Y29uc3Qgc2NlbmVEZWYgPSB0aGlzLmpzb24uc2NlbmVzWyBzY2VuZUluZGV4IF07XG5cdFx0Y29uc3QgcGFyc2VyID0gdGhpcztcblxuXHRcdC8vIExvYWRlciByZXR1cm5zIEdyb3VwLCBub3QgU2NlbmUuXG5cdFx0Ly8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xODM0MiNpc3N1ZWNvbW1lbnQtNTc4OTgxMTcyXG5cdFx0Y29uc3Qgc2NlbmUgPSBuZXcgR3JvdXAoKTtcblx0XHRpZiAoIHNjZW5lRGVmLm5hbWUgKSBzY2VuZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoIHNjZW5lRGVmLm5hbWUgKTtcblxuXHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIHNjZW5lLCBzY2VuZURlZiApO1xuXG5cdFx0aWYgKCBzY2VuZURlZi5leHRlbnNpb25zICkgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCBzY2VuZSwgc2NlbmVEZWYgKTtcblxuXHRcdGNvbnN0IG5vZGVJZHMgPSBzY2VuZURlZi5ub2RlcyB8fCBbXTtcblxuXHRcdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBub2RlSWRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnbm9kZScsIG5vZGVJZHNbIGkgXSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoIG5vZGVzICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0c2NlbmUuYWRkKCBub2Rlc1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlcyBkYW5nbGluZyBhc3NvY2lhdGlvbnMsIGFzc29jaWF0aW9ucyB0aGF0IHJlZmVyZW5jZSBhIG5vZGUgdGhhdFxuXHRcdFx0Ly8gZGlkbid0IG1ha2UgaXQgaW50byB0aGUgc2NlbmUuXG5cdFx0XHRjb25zdCByZWR1Y2VBc3NvY2lhdGlvbnMgPSAoIG5vZGUgKSA9PiB7XG5cblx0XHRcdFx0Y29uc3QgcmVkdWNlZEFzc29jaWF0aW9ucyA9IG5ldyBNYXAoKTtcblxuXHRcdFx0XHRmb3IgKCBjb25zdCBbIGtleSwgdmFsdWUgXSBvZiBwYXJzZXIuYXNzb2NpYXRpb25zICkge1xuXG5cdFx0XHRcdFx0aWYgKCBrZXkgaW5zdGFuY2VvZiBNYXRlcmlhbCB8fCBrZXkgaW5zdGFuY2VvZiBUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHRyZWR1Y2VkQXNzb2NpYXRpb25zLnNldCgga2V5LCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRub2RlLnRyYXZlcnNlKCAoIG5vZGUgKSA9PiB7XG5cblx0XHRcdFx0XHRjb25zdCBtYXBwaW5ncyA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KCBub2RlICk7XG5cblx0XHRcdFx0XHRpZiAoIG1hcHBpbmdzICE9IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdHJlZHVjZWRBc3NvY2lhdGlvbnMuc2V0KCBub2RlLCBtYXBwaW5ncyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRyZXR1cm4gcmVkdWNlZEFzc29jaWF0aW9ucztcblxuXHRcdFx0fTtcblxuXHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucyA9IHJlZHVjZUFzc29jaWF0aW9ucyggc2NlbmUgKTtcblxuXHRcdFx0cmV0dXJuIHNjZW5lO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRfY3JlYXRlQW5pbWF0aW9uVHJhY2tzKCBub2RlLCBpbnB1dEFjY2Vzc29yLCBvdXRwdXRBY2Nlc3Nvciwgc2FtcGxlciwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgdHJhY2tzID0gW107XG5cblx0XHRjb25zdCB0YXJnZXROYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lIDogbm9kZS51dWlkO1xuXHRcdGNvbnN0IHRhcmdldE5hbWVzID0gW107XG5cblx0XHRpZiAoIFBBVEhfUFJPUEVSVElFU1sgdGFyZ2V0LnBhdGggXSA9PT0gUEFUSF9QUk9QRVJUSUVTLndlaWdodHMgKSB7XG5cblx0XHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApIHtcblxuXHRcdFx0XHRcdHRhcmdldE5hbWVzLnB1c2goIG9iamVjdC5uYW1lID8gb2JqZWN0Lm5hbWUgOiBvYmplY3QudXVpZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGFyZ2V0TmFtZXMucHVzaCggdGFyZ2V0TmFtZSApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IFR5cGVkS2V5ZnJhbWVUcmFjaztcblxuXHRcdHN3aXRjaCAoIFBBVEhfUFJPUEVSVElFU1sgdGFyZ2V0LnBhdGggXSApIHtcblxuXHRcdFx0Y2FzZSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0czpcblxuXHRcdFx0XHRUeXBlZEtleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBQQVRIX1BST1BFUlRJRVMucm90YXRpb246XG5cblx0XHRcdFx0VHlwZWRLZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFBBVEhfUFJPUEVSVElFUy5wb3NpdGlvbjpcblx0XHRcdGNhc2UgUEFUSF9QUk9QRVJUSUVTLnNjYWxlOlxuXG5cdFx0XHRcdFR5cGVkS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdHN3aXRjaCAoIG91dHB1dEFjY2Vzc29yLml0ZW1TaXplICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0VHlwZWRLZXlmcmFtZVRyYWNrID0gTnVtYmVyS2V5ZnJhbWVUcmFjaztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFR5cGVkS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gc2FtcGxlci5pbnRlcnBvbGF0aW9uICE9PSB1bmRlZmluZWQgPyBJTlRFUlBPTEFUSU9OWyBzYW1wbGVyLmludGVycG9sYXRpb24gXSA6IEludGVycG9sYXRlTGluZWFyO1xuXG5cblx0XHRjb25zdCBvdXRwdXRBcnJheSA9IHRoaXMuX2dldEFycmF5RnJvbUFjY2Vzc29yKCBvdXRwdXRBY2Nlc3NvciApO1xuXG5cdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRjb25zdCB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2soXG5cdFx0XHRcdHRhcmdldE5hbWVzWyBqIF0gKyAnLicgKyBQQVRIX1BST1BFUlRJRVNbIHRhcmdldC5wYXRoIF0sXG5cdFx0XHRcdGlucHV0QWNjZXNzb3IuYXJyYXksXG5cdFx0XHRcdG91dHB1dEFycmF5LFxuXHRcdFx0XHRpbnRlcnBvbGF0aW9uXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBPdmVycmlkZSBpbnRlcnBvbGF0aW9uIHdpdGggY3VzdG9tIGZhY3RvcnkgbWV0aG9kLlxuXHRcdFx0aWYgKCBzYW1wbGVyLmludGVycG9sYXRpb24gPT09ICdDVUJJQ1NQTElORScgKSB7XG5cblx0XHRcdFx0dGhpcy5fY3JlYXRlQ3ViaWNTcGxpbmVUcmFja0ludGVycG9sYW50KCB0cmFjayApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRyYWNrcy5wdXNoKCB0cmFjayApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRyYWNrcztcblxuXHR9XG5cblx0X2dldEFycmF5RnJvbUFjY2Vzc29yKCBhY2Nlc3NvciApIHtcblxuXHRcdGxldCBvdXRwdXRBcnJheSA9IGFjY2Vzc29yLmFycmF5O1xuXG5cdFx0aWYgKCBhY2Nlc3Nvci5ub3JtYWxpemVkICkge1xuXG5cdFx0XHRjb25zdCBzY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSggb3V0cHV0QXJyYXkuY29uc3RydWN0b3IgKTtcblx0XHRcdGNvbnN0IHNjYWxlZCA9IG5ldyBGbG9hdDMyQXJyYXkoIG91dHB1dEFycmF5Lmxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gb3V0cHV0QXJyYXkubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0c2NhbGVkWyBqIF0gPSBvdXRwdXRBcnJheVsgaiBdICogc2NhbGU7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0cHV0QXJyYXkgPSBzY2FsZWQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0QXJyYXk7XG5cblx0fVxuXG5cdF9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQoIHRyYWNrICkge1xuXG5cdFx0dHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgPSBmdW5jdGlvbiBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUoIHJlc3VsdCApIHtcblxuXHRcdFx0Ly8gQSBDVUJJQ1NQTElORSBrZXlmcmFtZSBpbiBnbFRGIGhhcyB0aHJlZSBvdXRwdXQgdmFsdWVzIGZvciBlYWNoIGlucHV0IHZhbHVlLFxuXHRcdFx0Ly8gcmVwcmVzZW50aW5nIGluVGFuZ2VudCwgc3BsaW5lVmVydGV4LCBhbmQgb3V0VGFuZ2VudC4gQXMgYSByZXN1bHQsIHRyYWNrLmdldFZhbHVlU2l6ZSgpXG5cdFx0XHQvLyBtdXN0IGJlIGRpdmlkZWQgYnkgdGhyZWUgdG8gZ2V0IHRoZSBpbnRlcnBvbGFudCdzIHNhbXBsZVNpemUgYXJndW1lbnQuXG5cblx0XHRcdGNvbnN0IGludGVycG9sYW50VHlwZSA9ICggdGhpcyBpbnN0YW5jZW9mIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrICkgPyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgOiBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudDtcblxuXHRcdFx0cmV0dXJuIG5ldyBpbnRlcnBvbGFudFR5cGUoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpIC8gMywgcmVzdWx0ICk7XG5cblx0XHR9O1xuXG5cdFx0Ly8gTWFyayBhcyBDVUJJQ1NQTElORS4gYHRyYWNrLmdldEludGVycG9sYXRpb24oKWAgZG9lc24ndCBzdXBwb3J0IGN1c3RvbSBpbnRlcnBvbGFudHMuXG5cdFx0dHJhY2suY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUgPSB0cnVlO1xuXG5cdH1cblxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG4gKiBAcGFyYW0ge0dMVEYuUHJpbWl0aXZlfSBwcmltaXRpdmVEZWZcbiAqIEBwYXJhbSB7R0xURlBhcnNlcn0gcGFyc2VyXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZHMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlciApIHtcblxuXHRjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG5cblx0Y29uc3QgYm94ID0gbmV3IEJveDMoKTtcblxuXHRpZiAoIGF0dHJpYnV0ZXMuUE9TSVRJT04gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzWyBhdHRyaWJ1dGVzLlBPU0lUSU9OIF07XG5cblx0XHRjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG5cdFx0Y29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuXG5cdFx0Ly8gZ2xURiByZXF1aXJlcyAnbWluJyBhbmQgJ21heCcsIGJ1dCBWUk0gKHdoaWNoIGV4dGVuZHMgZ2xURikgY3VycmVudGx5IGlnbm9yZXMgdGhhdCByZXF1aXJlbWVudC5cblxuXHRcdGlmICggbWluICE9PSB1bmRlZmluZWQgJiYgbWF4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJveC5zZXQoXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCBtaW5bIDAgXSwgbWluWyAxIF0sIG1pblsgMiBdICksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCBtYXhbIDAgXSwgbWF4WyAxIF0sIG1heFsgMiBdIClcblx0XHRcdCk7XG5cblx0XHRcdGlmICggYWNjZXNzb3Iubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRjb25zdCBib3hTY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSggV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3Nvci5jb21wb25lbnRUeXBlIF0gKTtcblx0XHRcdFx0Ym94Lm1pbi5tdWx0aXBseVNjYWxhciggYm94U2NhbGUgKTtcblx0XHRcdFx0Ym94Lm1heC5tdWx0aXBseVNjYWxhciggYm94U2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLicgKTtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm47XG5cblx0fVxuXG5cdGNvbnN0IHRhcmdldHMgPSBwcmltaXRpdmVEZWYudGFyZ2V0cztcblxuXHRpZiAoIHRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGNvbnN0IG1heERpc3BsYWNlbWVudCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB0YXJnZXQgPSB0YXJnZXRzWyBpIF07XG5cblx0XHRcdGlmICggdGFyZ2V0LlBPU0lUSU9OICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbIHRhcmdldC5QT1NJVElPTiBdO1xuXHRcdFx0XHRjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG5cdFx0XHRcdGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcblxuXHRcdFx0XHQvLyBnbFRGIHJlcXVpcmVzICdtaW4nIGFuZCAnbWF4JywgYnV0IFZSTSAod2hpY2ggZXh0ZW5kcyBnbFRGKSBjdXJyZW50bHkgaWdub3JlcyB0aGF0IHJlcXVpcmVtZW50LlxuXG5cdFx0XHRcdGlmICggbWluICE9PSB1bmRlZmluZWQgJiYgbWF4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGdldCBtYXggb2YgYWJzb2x1dGUgY29tcG9uZW50cyBiZWNhdXNlIHRhcmdldCB3ZWlnaHQgaXMgWy0xLDFdXG5cdFx0XHRcdFx0dmVjdG9yLnNldFgoIE1hdGgubWF4KCBNYXRoLmFicyggbWluWyAwIF0gKSwgTWF0aC5hYnMoIG1heFsgMCBdICkgKSApO1xuXHRcdFx0XHRcdHZlY3Rvci5zZXRZKCBNYXRoLm1heCggTWF0aC5hYnMoIG1pblsgMSBdICksIE1hdGguYWJzKCBtYXhbIDEgXSApICkgKTtcblx0XHRcdFx0XHR2ZWN0b3Iuc2V0WiggTWF0aC5tYXgoIE1hdGguYWJzKCBtaW5bIDIgXSApLCBNYXRoLmFicyggbWF4WyAyIF0gKSApICk7XG5cblxuXHRcdFx0XHRcdGlmICggYWNjZXNzb3Iubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoIFdFQkdMX0NPTVBPTkVOVF9UWVBFU1sgYWNjZXNzb3IuY29tcG9uZW50VHlwZSBdICk7XG5cdFx0XHRcdFx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIGJveFNjYWxlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOb3RlOiB0aGlzIGFzc3VtZXMgdGhhdCB0aGUgc3VtIG9mIGFsbCB3ZWlnaHRzIGlzIGF0IG1vc3QgMS4gVGhpcyBpc24ndCBxdWl0ZSBjb3JyZWN0IC0gaXQncyBtb3JlIGNvbnNlcnZhdGl2ZVxuXHRcdFx0XHRcdC8vIHRvIGFzc3VtZSB0aGF0IGVhY2ggdGFyZ2V0IGNhbiBoYXZlIGEgbWF4IHdlaWdodCBvZiAxLiBIb3dldmVyLCBmb3Igc29tZSB1c2UgY2FzZXMgLSBub3RhYmx5LCB3aGVuIG1vcnBoIHRhcmdldHNcblx0XHRcdFx0XHQvLyBhcmUgdXNlZCB0byBpbXBsZW1lbnQga2V5LWZyYW1lIGFuaW1hdGlvbnMgYW5kIGFzIHN1Y2ggb25seSB0d28gYXJlIGFjdGl2ZSBhdCBhIHRpbWUgLSB0aGlzIHJlc3VsdHMgaW4gdmVyeSBsYXJnZVxuXHRcdFx0XHRcdC8vIGJveGVzLiBTbyBmb3Igbm93IHdlIG1ha2UgYSBib3ggdGhhdCdzIHNvbWV0aW1lcyBhIHRvdWNoIHRvbyBzbWFsbCBidXQgaXMgaG9wZWZ1bGx5IG1vc3RseSBvZiByZWFzb25hYmxlIHNpemUuXG5cdFx0XHRcdFx0bWF4RGlzcGxhY2VtZW50Lm1heCggdmVjdG9yICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBBcyBwZXIgY29tbWVudCBhYm92ZSB0aGlzIGJveCBpc24ndCBjb25zZXJ2YXRpdmUsIGJ1dCBoYXMgYSByZWFzb25hYmxlIHNpemUgZm9yIGEgdmVyeSBsYXJnZSBudW1iZXIgb2YgbW9ycGggdGFyZ2V0cy5cblx0XHRib3guZXhwYW5kQnlWZWN0b3IoIG1heERpc3BsYWNlbWVudCApO1xuXG5cdH1cblxuXHRnZW9tZXRyeS5ib3VuZGluZ0JveCA9IGJveDtcblxuXHRjb25zdCBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cblx0Ym94LmdldENlbnRlciggc3BoZXJlLmNlbnRlciApO1xuXHRzcGhlcmUucmFkaXVzID0gYm94Lm1pbi5kaXN0YW5jZVRvKCBib3gubWF4ICkgLyAyO1xuXG5cdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gc3BoZXJlO1xuXG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnlcbiAqIEBwYXJhbSB7R0xURi5QcmltaXRpdmV9IHByaW1pdGl2ZURlZlxuICogQHBhcmFtIHtHTFRGUGFyc2VyfSBwYXJzZXJcbiAqIEByZXR1cm4ge1Byb21pc2U8QnVmZmVyR2VvbWV0cnk+fVxuICovXG5mdW5jdGlvbiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKCBnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIgKSB7XG5cblx0Y29uc3QgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuXG5cdGNvbnN0IHBlbmRpbmcgPSBbXTtcblxuXHRmdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvciggYWNjZXNzb3JJbmRleCwgYXR0cmlidXRlTmFtZSApIHtcblxuXHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgYWNjZXNzb3JJbmRleCApXG5cdFx0XHQudGhlbiggZnVuY3Rpb24gKCBhY2Nlc3NvciApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUsIGFjY2Vzc29yICk7XG5cblx0XHRcdH0gKTtcblxuXHR9XG5cblx0Zm9yICggY29uc3QgZ2x0ZkF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbIGdsdGZBdHRyaWJ1dGVOYW1lIF0gfHwgZ2x0ZkF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdC8vIFNraXAgYXR0cmlidXRlcyBhbHJlYWR5IHByb3ZpZGVkIGJ5IGUuZy4gRHJhY28gZXh0ZW5zaW9uLlxuXHRcdGlmICggdGhyZWVBdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSBjb250aW51ZTtcblxuXHRcdHBlbmRpbmcucHVzaCggYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoIGF0dHJpYnV0ZXNbIGdsdGZBdHRyaWJ1dGVOYW1lIF0sIHRocmVlQXR0cmlidXRlTmFtZSApICk7XG5cblx0fVxuXG5cdGlmICggcHJpbWl0aXZlRGVmLmluZGljZXMgIT09IHVuZGVmaW5lZCAmJiAhIGdlb21ldHJ5LmluZGV4ICkge1xuXG5cdFx0Y29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgcHJpbWl0aXZlRGVmLmluZGljZXMgKS50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29yICkge1xuXG5cdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggYWNjZXNzb3IgKTtcblxuXHRcdH0gKTtcblxuXHRcdHBlbmRpbmcucHVzaCggYWNjZXNzb3IgKTtcblxuXHR9XG5cblx0aWYgKCBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2UgIT09IExpbmVhclNSR0JDb2xvclNwYWNlICYmICdDT0xPUl8wJyBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCBgVEhSRUUuR0xURkxvYWRlcjogQ29udmVydGluZyB2ZXJ0ZXggY29sb3JzIGZyb20gXCJzcmdiLWxpbmVhclwiIHRvIFwiJHtDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2V9XCIgbm90IHN1cHBvcnRlZC5gICk7XG5cblx0fVxuXG5cdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYgKTtcblxuXHRjb21wdXRlQm91bmRzKCBnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIgKTtcblxuXHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gcHJpbWl0aXZlRGVmLnRhcmdldHMgIT09IHVuZGVmaW5lZFxuXHRcdFx0PyBhZGRNb3JwaFRhcmdldHMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYudGFyZ2V0cywgcGFyc2VyIClcblx0XHRcdDogZ2VvbWV0cnk7XG5cblx0fSApO1xuXG59XG5cbmV4cG9ydCB7IEdMVEZMb2FkZXIgfTtcbiJdLCJuYW1lcyI6WyJBbmltYXRpb25DbGlwIiwiQm9uZSIsIkJveDMiLCJCdWZmZXJBdHRyaWJ1dGUiLCJCdWZmZXJHZW9tZXRyeSIsIkNsYW1wVG9FZGdlV3JhcHBpbmciLCJDb2xvciIsIkNvbG9yTWFuYWdlbWVudCIsIkRpcmVjdGlvbmFsTGlnaHQiLCJEb3VibGVTaWRlIiwiRmlsZUxvYWRlciIsIkZyb250U2lkZSIsIkdyb3VwIiwiSW1hZ2VCaXRtYXBMb2FkZXIiLCJJbnN0YW5jZWRNZXNoIiwiSW50ZXJsZWF2ZWRCdWZmZXIiLCJJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSIsIkludGVycG9sYW50IiwiSW50ZXJwb2xhdGVEaXNjcmV0ZSIsIkludGVycG9sYXRlTGluZWFyIiwiTGluZSIsIkxpbmVCYXNpY01hdGVyaWFsIiwiTGluZUxvb3AiLCJMaW5lU2VnbWVudHMiLCJMaW5lYXJGaWx0ZXIiLCJMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIiLCJMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyIiwiTGluZWFyU1JHQkNvbG9yU3BhY2UiLCJMb2FkZXIiLCJMb2FkZXJVdGlscyIsIk1hdGVyaWFsIiwiTWF0aFV0aWxzIiwiTWF0cml4NCIsIk1lc2giLCJNZXNoQmFzaWNNYXRlcmlhbCIsIk1lc2hQaHlzaWNhbE1hdGVyaWFsIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJNaXJyb3JlZFJlcGVhdFdyYXBwaW5nIiwiTmVhcmVzdEZpbHRlciIsIk5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIiLCJOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciIsIk51bWJlcktleWZyYW1lVHJhY2siLCJPYmplY3QzRCIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiUG9pbnRMaWdodCIsIlBvaW50cyIsIlBvaW50c01hdGVyaWFsIiwiUHJvcGVydHlCaW5kaW5nIiwiUXVhdGVybmlvbiIsIlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrIiwiUmVwZWF0V3JhcHBpbmciLCJTa2VsZXRvbiIsIlNraW5uZWRNZXNoIiwiU3BoZXJlIiwiU3BvdExpZ2h0IiwiVGV4dHVyZSIsIlRleHR1cmVMb2FkZXIiLCJUcmlhbmdsZUZhbkRyYXdNb2RlIiwiVHJpYW5nbGVTdHJpcERyYXdNb2RlIiwiVmVjdG9yMiIsIlZlY3RvcjMiLCJWZWN0b3JLZXlmcmFtZVRyYWNrIiwiU1JHQkNvbG9yU3BhY2UiLCJJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUiLCJ0b1RyaWFuZ2xlc0RyYXdNb2RlIiwiR0xURkxvYWRlciIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsInNjb3BlIiwicmVzb3VyY2VQYXRoIiwicGF0aCIsInJlbGF0aXZlVXJsIiwiZXh0cmFjdFVybEJhc2UiLCJyZXNvbHZlVVJMIiwibWFuYWdlciIsIml0ZW1TdGFydCIsIl9vbkVycm9yIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsIml0ZW1FcnJvciIsIml0ZW1FbmQiLCJsb2FkZXIiLCJzZXRQYXRoIiwic2V0UmVzcG9uc2VUeXBlIiwic2V0UmVxdWVzdEhlYWRlciIsInJlcXVlc3RIZWFkZXIiLCJzZXRXaXRoQ3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJkYXRhIiwicGFyc2UiLCJnbHRmIiwic2V0RFJBQ09Mb2FkZXIiLCJkcmFjb0xvYWRlciIsInNldEREU0xvYWRlciIsIkVycm9yIiwic2V0S1RYMkxvYWRlciIsImt0eDJMb2FkZXIiLCJzZXRNZXNob3B0RGVjb2RlciIsIm1lc2hvcHREZWNvZGVyIiwicmVnaXN0ZXIiLCJjYWxsYmFjayIsInBsdWdpbkNhbGxiYWNrcyIsImluZGV4T2YiLCJwdXNoIiwidW5yZWdpc3RlciIsInNwbGljZSIsImpzb24iLCJleHRlbnNpb25zIiwicGx1Z2lucyIsInRleHREZWNvZGVyIiwiVGV4dERlY29kZXIiLCJKU09OIiwiQXJyYXlCdWZmZXIiLCJtYWdpYyIsImRlY29kZSIsIlVpbnQ4QXJyYXkiLCJCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyIsIkVYVEVOU0lPTlMiLCJLSFJfQklOQVJZX0dMVEYiLCJHTFRGQmluYXJ5RXh0ZW5zaW9uIiwiY29udGVudCIsImFzc2V0IiwidW5kZWZpbmVkIiwidmVyc2lvbiIsInBhcnNlciIsIkdMVEZQYXJzZXIiLCJjcm9zc09yaWdpbiIsImZpbGVMb2FkZXIiLCJpIiwibGVuZ3RoIiwicGx1Z2luIiwibmFtZSIsImV4dGVuc2lvbnNVc2VkIiwiZXh0ZW5zaW9uTmFtZSIsImV4dGVuc2lvbnNSZXF1aXJlZCIsIktIUl9NQVRFUklBTFNfVU5MSVQiLCJHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24iLCJLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiIsIkdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbiIsIktIUl9URVhUVVJFX1RSQU5TRk9STSIsIkdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uIiwiS0hSX01FU0hfUVVBTlRJWkFUSU9OIiwiR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24iLCJ3YXJuIiwic2V0RXh0ZW5zaW9ucyIsInNldFBsdWdpbnMiLCJwYXJzZUFzeW5jIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjb25zdHJ1Y3RvciIsIkdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24iLCJHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiIsIkdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiIsIkdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzVm9sdW1lRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0lyaWRlc2NlbmNlRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzQnVtcEV4dGVuc2lvbiIsIkdMVEZMaWdodHNFeHRlbnNpb24iLCJHTFRGTWVzaG9wdENvbXByZXNzaW9uIiwiR0xURk1lc2hHcHVJbnN0YW5jaW5nIiwiR0xURlJlZ2lzdHJ5Iiwib2JqZWN0cyIsImdldCIsImtleSIsImFkZCIsIm9iamVjdCIsInJlbW92ZSIsInJlbW92ZUFsbCIsIktIUl9MSUdIVFNfUFVOQ1RVQUwiLCJLSFJfTUFURVJJQUxTX0NMRUFSQ09BVCIsIktIUl9NQVRFUklBTFNfSU9SIiwiS0hSX01BVEVSSUFMU19TSEVFTiIsIktIUl9NQVRFUklBTFNfU1BFQ1VMQVIiLCJLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTiIsIktIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0UiLCJLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFkiLCJLSFJfTUFURVJJQUxTX1ZPTFVNRSIsIktIUl9URVhUVVJFX0JBU0lTVSIsIktIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEgiLCJFWFRfTUFURVJJQUxTX0JVTVAiLCJFWFRfVEVYVFVSRV9XRUJQIiwiRVhUX1RFWFRVUkVfQVZJRiIsIkVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OIiwiRVhUX01FU0hfR1BVX0lOU1RBTkNJTkciLCJfbWFya0RlZnMiLCJub2RlRGVmcyIsIm5vZGVzIiwibm9kZUluZGV4Iiwibm9kZUxlbmd0aCIsIm5vZGVEZWYiLCJsaWdodCIsIl9hZGROb2RlUmVmIiwiY2FjaGUiLCJfbG9hZExpZ2h0IiwibGlnaHRJbmRleCIsImNhY2hlS2V5IiwiZGVwZW5kZW5jeSIsImxpZ2h0RGVmcyIsImxpZ2h0cyIsImxpZ2h0RGVmIiwibGlnaHROb2RlIiwiY29sb3IiLCJzZXRSR0IiLCJyYW5nZSIsInR5cGUiLCJ0YXJnZXQiLCJwb3NpdGlvbiIsInNldCIsImRpc3RhbmNlIiwic3BvdCIsImlubmVyQ29uZUFuZ2xlIiwib3V0ZXJDb25lQW5nbGUiLCJNYXRoIiwiUEkiLCJhbmdsZSIsInBlbnVtYnJhIiwiZGVjYXkiLCJhc3NpZ25FeHRyYXNUb1VzZXJEYXRhIiwiaW50ZW5zaXR5IiwiY3JlYXRlVW5pcXVlTmFtZSIsImdldERlcGVuZGVuY3kiLCJpbmRleCIsImNyZWF0ZU5vZGVBdHRhY2htZW50Iiwic2VsZiIsInRoZW4iLCJfZ2V0Tm9kZVJlZiIsInJlZnMiLCJ1c2VzIiwiZ2V0TWF0ZXJpYWxUeXBlIiwiZXh0ZW5kUGFyYW1zIiwibWF0ZXJpYWxQYXJhbXMiLCJtYXRlcmlhbERlZiIsInBlbmRpbmciLCJvcGFjaXR5IiwibWV0YWxsaWNSb3VnaG5lc3MiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyIsIkFycmF5IiwiaXNBcnJheSIsImJhc2VDb2xvckZhY3RvciIsImFycmF5IiwiYmFzZUNvbG9yVGV4dHVyZSIsImFzc2lnblRleHR1cmUiLCJhbGwiLCJleHRlbmRNYXRlcmlhbFBhcmFtcyIsIm1hdGVyaWFsSW5kZXgiLCJtYXRlcmlhbHMiLCJlbWlzc2l2ZVN0cmVuZ3RoIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJleHRlbnNpb24iLCJjbGVhcmNvYXRGYWN0b3IiLCJjbGVhcmNvYXQiLCJjbGVhcmNvYXRUZXh0dXJlIiwiY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yIiwiY2xlYXJjb2F0Um91Z2huZXNzIiwiY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSIsImNsZWFyY29hdE5vcm1hbFRleHR1cmUiLCJzY2FsZSIsImNsZWFyY29hdE5vcm1hbFNjYWxlIiwiaXJpZGVzY2VuY2VGYWN0b3IiLCJpcmlkZXNjZW5jZSIsImlyaWRlc2NlbmNlVGV4dHVyZSIsImlyaWRlc2NlbmNlSW9yIiwiaXJpZGVzY2VuY2VJT1IiLCJpcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlIiwiaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtIiwiaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtIiwiaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlIiwic2hlZW5Db2xvciIsInNoZWVuUm91Z2huZXNzIiwic2hlZW4iLCJzaGVlbkNvbG9yRmFjdG9yIiwiY29sb3JGYWN0b3IiLCJzaGVlblJvdWdobmVzc0ZhY3RvciIsInNoZWVuQ29sb3JUZXh0dXJlIiwic2hlZW5Sb3VnaG5lc3NUZXh0dXJlIiwidHJhbnNtaXNzaW9uRmFjdG9yIiwidHJhbnNtaXNzaW9uIiwidHJhbnNtaXNzaW9uVGV4dHVyZSIsInRoaWNrbmVzcyIsInRoaWNrbmVzc0ZhY3RvciIsInRoaWNrbmVzc1RleHR1cmUiLCJhdHRlbnVhdGlvbkRpc3RhbmNlIiwiSW5maW5pdHkiLCJjb2xvckFycmF5IiwiYXR0ZW51YXRpb25Db2xvciIsImlvciIsInNwZWN1bGFySW50ZW5zaXR5Iiwic3BlY3VsYXJGYWN0b3IiLCJzcGVjdWxhclRleHR1cmUiLCJzcGVjdWxhckNvbG9yRmFjdG9yIiwic3BlY3VsYXJDb2xvciIsInNwZWN1bGFyQ29sb3JUZXh0dXJlIiwiYnVtcFNjYWxlIiwiYnVtcEZhY3RvciIsImJ1bXBUZXh0dXJlIiwiYW5pc290cm9weVN0cmVuZ3RoIiwiYW5pc290cm9weSIsImFuaXNvdHJvcHlSb3RhdGlvbiIsImFuaXNvdHJvcHlUZXh0dXJlIiwibG9hZFRleHR1cmUiLCJ0ZXh0dXJlSW5kZXgiLCJ0ZXh0dXJlRGVmIiwidGV4dHVyZXMiLCJvcHRpb25zIiwibG9hZFRleHR1cmVJbWFnZSIsInNvdXJjZSIsImltYWdlcyIsInRleHR1cmVMb2FkZXIiLCJ1cmkiLCJoYW5kbGVyIiwiZ2V0SGFuZGxlciIsImRldGVjdFN1cHBvcnQiLCJpc1N1cHBvcnRlZCIsImltYWdlIiwiSW1hZ2UiLCJzcmMiLCJvbmxvYWQiLCJvbmVycm9yIiwiaGVpZ2h0IiwibG9hZEJ1ZmZlclZpZXciLCJidWZmZXJWaWV3IiwiYnVmZmVyVmlld3MiLCJleHRlbnNpb25EZWYiLCJidWZmZXIiLCJkZWNvZGVyIiwic3VwcG9ydGVkIiwicmVzIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJjb3VudCIsInN0cmlkZSIsImJ5dGVTdHJpZGUiLCJkZWNvZGVHbHRmQnVmZmVyQXN5bmMiLCJtb2RlIiwiZmlsdGVyIiwicmVhZHkiLCJyZXN1bHQiLCJkZWNvZGVHbHRmQnVmZmVyIiwiY3JlYXRlTm9kZU1lc2giLCJtZXNoIiwibWVzaERlZiIsIm1lc2hlcyIsInByaW1pdGl2ZSIsInByaW1pdGl2ZXMiLCJXRUJHTF9DT05TVEFOVFMiLCJUUklBTkdMRVMiLCJUUklBTkdMRV9TVFJJUCIsIlRSSUFOR0xFX0ZBTiIsImF0dHJpYnV0ZXNEZWYiLCJhdHRyaWJ1dGVzIiwiYWNjZXNzb3IiLCJyZXN1bHRzIiwibm9kZU9iamVjdCIsInBvcCIsImlzR3JvdXAiLCJjaGlsZHJlbiIsImluc3RhbmNlZE1lc2hlcyIsIm0iLCJwIiwicSIsInMiLCJpbnN0YW5jZWRNZXNoIiwiZ2VvbWV0cnkiLCJtYXRlcmlhbCIsIlRSQU5TTEFUSU9OIiwiZnJvbUJ1ZmZlckF0dHJpYnV0ZSIsIlJPVEFUSU9OIiwiU0NBTEUiLCJzZXRNYXRyaXhBdCIsImNvbXBvc2UiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0ciIsImluc3RhbmNlQ29sb3IiLCJpdGVtU2l6ZSIsIm5vcm1hbGl6ZWQiLCJzZXRBdHRyaWJ1dGUiLCJwcm90b3R5cGUiLCJjb3B5IiwiY2FsbCIsImFzc2lnbkZpbmFsTWF0ZXJpYWwiLCJjbGVhciIsIkJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCIsIkJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMiLCJCSU4iLCJib2R5IiwiaGVhZGVyVmlldyIsIkRhdGFWaWV3IiwiaGVhZGVyIiwic2xpY2UiLCJnZXRVaW50MzIiLCJjaHVua0NvbnRlbnRzTGVuZ3RoIiwiY2h1bmtWaWV3IiwiY2h1bmtJbmRleCIsImNodW5rTGVuZ3RoIiwiY2h1bmtUeXBlIiwiY29udGVudEFycmF5IiwiZGVjb2RlUHJpbWl0aXZlIiwiYnVmZmVyVmlld0luZGV4IiwiZ2x0ZkF0dHJpYnV0ZU1hcCIsInRocmVlQXR0cmlidXRlTWFwIiwiYXR0cmlidXRlTm9ybWFsaXplZE1hcCIsImF0dHJpYnV0ZVR5cGVNYXAiLCJ0aHJlZUF0dHJpYnV0ZU5hbWUiLCJBVFRSSUJVVEVTIiwidG9Mb3dlckNhc2UiLCJhY2Nlc3NvckRlZiIsImFjY2Vzc29ycyIsImNvbXBvbmVudFR5cGUiLCJXRUJHTF9DT01QT05FTlRfVFlQRVMiLCJkZWNvZGVEcmFjb0ZpbGUiLCJhdHRyaWJ1dGUiLCJwcmVsb2FkIiwiZXh0ZW5kVGV4dHVyZSIsInRleHR1cmUiLCJ0cmFuc2Zvcm0iLCJ0ZXhDb29yZCIsImNoYW5uZWwiLCJvZmZzZXQiLCJyb3RhdGlvbiIsImNsb25lIiwiZnJvbUFycmF5IiwicmVwZWF0IiwibmVlZHNVcGRhdGUiLCJHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCIsImNvcHlTYW1wbGVWYWx1ZV8iLCJyZXN1bHRCdWZmZXIiLCJ2YWx1ZXMiLCJzYW1wbGVWYWx1ZXMiLCJ2YWx1ZVNpemUiLCJpbnRlcnBvbGF0ZV8iLCJpMSIsInQwIiwidCIsInQxIiwic3RyaWRlMiIsInN0cmlkZTMiLCJ0ZCIsInBwIiwicHBwIiwib2Zmc2V0MSIsIm9mZnNldDAiLCJzMiIsInMzIiwiczAiLCJzMSIsInAwIiwibTAiLCJwMSIsIm0xIiwicGFyYW1ldGVyUG9zaXRpb25zIiwic2FtcGxlU2l6ZSIsIl9xIiwiR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50Iiwibm9ybWFsaXplIiwidG9BcnJheSIsIkZMT0FUIiwiRkxPQVRfTUFUMyIsIkZMT0FUX01BVDQiLCJGTE9BVF9WRUMyIiwiRkxPQVRfVkVDMyIsIkZMT0FUX1ZFQzQiLCJMSU5FQVIiLCJSRVBFQVQiLCJTQU1QTEVSXzJEIiwiUE9JTlRTIiwiTElORVMiLCJMSU5FX0xPT1AiLCJMSU5FX1NUUklQIiwiVU5TSUdORURfQllURSIsIlVOU0lHTkVEX1NIT1JUIiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJXRUJHTF9GSUxURVJTIiwiV0VCR0xfV1JBUFBJTkdTIiwiV0VCR0xfVFlQRV9TSVpFUyIsIlBPU0lUSU9OIiwiTk9STUFMIiwiVEFOR0VOVCIsIlRFWENPT1JEXzAiLCJURVhDT09SRF8xIiwiVEVYQ09PUkRfMiIsIlRFWENPT1JEXzMiLCJDT0xPUl8wIiwiV0VJR0hUU18wIiwiSk9JTlRTXzAiLCJQQVRIX1BST1BFUlRJRVMiLCJ0cmFuc2xhdGlvbiIsIndlaWdodHMiLCJJTlRFUlBPTEFUSU9OIiwiQ1VCSUNTUExJTkUiLCJTVEVQIiwiQUxQSEFfTU9ERVMiLCJPUEFRVUUiLCJNQVNLIiwiQkxFTkQiLCJjcmVhdGVEZWZhdWx0TWF0ZXJpYWwiLCJlbWlzc2l2ZSIsIm1ldGFsbmVzcyIsInJvdWdobmVzcyIsInRyYW5zcGFyZW50IiwiZGVwdGhUZXN0Iiwic2lkZSIsImFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSIsImtub3duRXh0ZW5zaW9ucyIsIm9iamVjdERlZiIsInVzZXJEYXRhIiwiZ2x0ZkV4dGVuc2lvbnMiLCJnbHRmRGVmIiwiZXh0cmFzIiwiT2JqZWN0IiwiYXNzaWduIiwiYWRkTW9ycGhUYXJnZXRzIiwidGFyZ2V0cyIsImhhc01vcnBoUG9zaXRpb24iLCJoYXNNb3JwaE5vcm1hbCIsImhhc01vcnBoQ29sb3IiLCJpbCIsInBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyIsInBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMiLCJwZW5kaW5nQ29sb3JBY2Nlc3NvcnMiLCJwZW5kaW5nQWNjZXNzb3IiLCJub3JtYWwiLCJtb3JwaFBvc2l0aW9ucyIsIm1vcnBoTm9ybWFscyIsIm1vcnBoQ29sb3JzIiwibW9ycGhBdHRyaWJ1dGVzIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUiLCJ1cGRhdGVNb3JwaFRhcmdldHMiLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLCJ0YXJnZXROYW1lcyIsIm1vcnBoVGFyZ2V0RGljdGlvbmFyeSIsImNyZWF0ZVByaW1pdGl2ZUtleSIsInByaW1pdGl2ZURlZiIsImdlb21ldHJ5S2V5IiwiZHJhY29FeHRlbnNpb24iLCJpbmRpY2VzIiwiY3JlYXRlQXR0cmlidXRlc0tleSIsImF0dHJpYnV0ZXNLZXkiLCJrZXlzIiwic29ydCIsImdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSIsImdldEltYWdlVVJJTWltZVR5cGUiLCJzZWFyY2giLCJfaWRlbnRpdHlNYXRyaXgiLCJub2RlQ2FjaGUiLCJfaW52b2tlQWxsIiwiZXh0IiwiYmVmb3JlUm9vdCIsImdldERlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsInNjZW5lIiwic2NlbmVzIiwiYW5pbWF0aW9ucyIsImNhbWVyYXMiLCJhZnRlclJvb3QiLCJjYXRjaCIsInNraW5EZWZzIiwic2tpbnMiLCJtZXNoRGVmcyIsInNraW5JbmRleCIsInNraW5MZW5ndGgiLCJqb2ludHMiLCJpc0JvbmUiLCJtZXNoQ2FjaGUiLCJza2luIiwiaXNTa2lubmVkTWVzaCIsImNhbWVyYSIsImNhbWVyYUNhY2hlIiwicmVmIiwidXBkYXRlTWFwcGluZ3MiLCJvcmlnaW5hbCIsIm1hcHBpbmdzIiwiYXNzb2NpYXRpb25zIiwiY2hpbGQiLCJlbnRyaWVzIiwiX2ludm9rZU9uZSIsImZ1bmMiLCJ1bnNoaWZ0IiwibG9hZFNjZW5lIiwibG9hZE5vZGUiLCJsb2FkTWVzaCIsImxvYWRBY2Nlc3NvciIsImxvYWRCdWZmZXIiLCJsb2FkTWF0ZXJpYWwiLCJsb2FkU2tpbiIsImxvYWRBbmltYXRpb24iLCJsb2FkQ2FtZXJhIiwiZGVmcyIsIm1hcCIsImRlZiIsImJ1ZmZlckluZGV4IiwiYnVmZmVyRGVmIiwiYnVmZmVycyIsImJ1ZmZlclZpZXdEZWYiLCJhY2Nlc3NvckluZGV4Iiwic3BhcnNlIiwiVHlwZWRBcnJheSIsInBlbmRpbmdCdWZmZXJWaWV3cyIsImVsZW1lbnRCeXRlcyIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiaXRlbUJ5dGVzIiwiYnVmZmVyQXR0cmlidXRlIiwiaWJTbGljZSIsImZsb29yIiwiaWJDYWNoZUtleSIsImliIiwiaXRlbVNpemVJbmRpY2VzIiwiU0NBTEFSIiwiVHlwZWRBcnJheUluZGljZXMiLCJieXRlT2Zmc2V0SW5kaWNlcyIsImJ5dGVPZmZzZXRWYWx1ZXMiLCJzcGFyc2VJbmRpY2VzIiwic3BhcnNlVmFsdWVzIiwic2V0WCIsInNldFkiLCJzZXRaIiwic2V0VyIsInNvdXJjZUluZGV4Iiwic291cmNlRGVmIiwic2FtcGxlciIsInRleHR1cmVDYWNoZSIsInByb21pc2UiLCJsb2FkSW1hZ2VTb3VyY2UiLCJmbGlwWSIsInN0YXJ0c1dpdGgiLCJzYW1wbGVycyIsIm1hZ0ZpbHRlciIsIm1pbkZpbHRlciIsIndyYXBTIiwid3JhcFQiLCJzb3VyY2VDYWNoZSIsIlVSTCIsIndlYmtpdFVSTCIsInNvdXJjZVVSSSIsImlzT2JqZWN0VVJMIiwiYmxvYiIsIkJsb2IiLCJtaW1lVHlwZSIsImNyZWF0ZU9iamVjdFVSTCIsImlzSW1hZ2VCaXRtYXBMb2FkZXIiLCJpbWFnZUJpdG1hcCIsInJldm9rZU9iamVjdFVSTCIsIm1hcE5hbWUiLCJtYXBEZWYiLCJjb2xvclNwYWNlIiwiZ2x0ZlJlZmVyZW5jZSIsInVzZURlcml2YXRpdmVUYW5nZW50cyIsInRhbmdlbnQiLCJ1c2VWZXJ0ZXhDb2xvcnMiLCJ1c2VGbGF0U2hhZGluZyIsImlzUG9pbnRzIiwidXVpZCIsInBvaW50c01hdGVyaWFsIiwic2l6ZUF0dGVudWF0aW9uIiwiaXNMaW5lIiwibGluZU1hdGVyaWFsIiwiY2FjaGVkTWF0ZXJpYWwiLCJ2ZXJ0ZXhDb2xvcnMiLCJmbGF0U2hhZGluZyIsIm5vcm1hbFNjYWxlIiwieSIsIm1hdGVyaWFsVHlwZSIsIm1hdGVyaWFsRXh0ZW5zaW9ucyIsImttdUV4dGVuc2lvbiIsIm1ldGFsbGljRmFjdG9yIiwicm91Z2huZXNzRmFjdG9yIiwibWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlIiwiZG91YmxlU2lkZWQiLCJhbHBoYU1vZGUiLCJkZXB0aFdyaXRlIiwiYWxwaGFUZXN0IiwiYWxwaGFDdXRvZmYiLCJub3JtYWxUZXh0dXJlIiwib2NjbHVzaW9uVGV4dHVyZSIsInN0cmVuZ3RoIiwiYW9NYXBJbnRlbnNpdHkiLCJlbWlzc2l2ZUZhY3RvciIsImVtaXNzaXZlVGV4dHVyZSIsIm9yaWdpbmFsTmFtZSIsInNhbml0aXplZE5hbWUiLCJzYW5pdGl6ZU5vZGVOYW1lIiwibm9kZU5hbWVzVXNlZCIsImxvYWRHZW9tZXRyaWVzIiwicHJpbWl0aXZlQ2FjaGUiLCJjcmVhdGVEcmFjb1ByaW1pdGl2ZSIsImFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMiLCJjYWNoZWQiLCJnZW9tZXRyeVByb21pc2UiLCJtZXNoSW5kZXgiLCJnZW9tZXRyaWVzIiwibm9ybWFsaXplU2tpbldlaWdodHMiLCJncm91cCIsImNhbWVyYUluZGV4IiwiY2FtZXJhRGVmIiwicGFyYW1zIiwicmFkVG9EZWciLCJ5Zm92IiwiYXNwZWN0UmF0aW8iLCJ6bmVhciIsInpmYXIiLCJ4bWFnIiwieW1hZyIsInNraW5EZWYiLCJfbG9hZE5vZGVTaGFsbG93IiwiaW52ZXJzZUJpbmRNYXRyaWNlcyIsImpvaW50Tm9kZXMiLCJib25lcyIsImJvbmVJbnZlcnNlcyIsImpvaW50Tm9kZSIsIm1hdCIsImFuaW1hdGlvbkluZGV4IiwiYW5pbWF0aW9uRGVmIiwiYW5pbWF0aW9uTmFtZSIsInBlbmRpbmdOb2RlcyIsInBlbmRpbmdJbnB1dEFjY2Vzc29ycyIsInBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMiLCJwZW5kaW5nU2FtcGxlcnMiLCJwZW5kaW5nVGFyZ2V0cyIsImNoYW5uZWxzIiwibm9kZSIsImlucHV0IiwicGFyYW1ldGVycyIsIm91dHB1dCIsImlucHV0QWNjZXNzb3JzIiwib3V0cHV0QWNjZXNzb3JzIiwidHJhY2tzIiwiaW5wdXRBY2Nlc3NvciIsIm91dHB1dEFjY2Vzc29yIiwidXBkYXRlTWF0cml4IiwiY3JlYXRlZFRyYWNrcyIsIl9jcmVhdGVBbmltYXRpb25UcmFja3MiLCJrIiwidHJhdmVyc2UiLCJvIiwiaXNNZXNoIiwibm9kZVBlbmRpbmciLCJjaGlsZFBlbmRpbmciLCJjaGlsZHJlbkRlZiIsInNrZWxldG9uUGVuZGluZyIsInNrZWxldG9uIiwiYmluZCIsIm5vZGVOYW1lIiwibWVzaFByb21pc2UiLCJmb3JFYWNoIiwibWF0cml4IiwiYXBwbHlNYXRyaXg0IiwicXVhdGVybmlvbiIsImhhcyIsInNjZW5lSW5kZXgiLCJzY2VuZURlZiIsIm5vZGVJZHMiLCJyZWR1Y2VBc3NvY2lhdGlvbnMiLCJyZWR1Y2VkQXNzb2NpYXRpb25zIiwiTWFwIiwidmFsdWUiLCJ0YXJnZXROYW1lIiwiVHlwZWRLZXlmcmFtZVRyYWNrIiwiaW50ZXJwb2xhdGlvbiIsIm91dHB1dEFycmF5IiwiX2dldEFycmF5RnJvbUFjY2Vzc29yIiwiaiIsImpsIiwidHJhY2siLCJfY3JlYXRlQ3ViaWNTcGxpbmVUcmFja0ludGVycG9sYW50Iiwic2NhbGVkIiwiY3JlYXRlSW50ZXJwb2xhbnQiLCJJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUiLCJpbnRlcnBvbGFudFR5cGUiLCJ0aW1lcyIsImdldFZhbHVlU2l6ZSIsImlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lIiwibGlnaHRDYWNoZSIsImlzU2FmYXJpIiwiaXNGaXJlZm94IiwiZmlyZWZveFZlcnNpb24iLCJuYXZpZ2F0b3IiLCJ0ZXN0IiwidXNlckFnZW50IiwibWF0Y2giLCJjcmVhdGVJbWFnZUJpdG1hcCIsInNldENyb3NzT3JpZ2luIiwiY29tcHV0ZUJvdW5kcyIsImJveCIsIm1pbiIsIm1heCIsImJveFNjYWxlIiwibXVsdGlwbHlTY2FsYXIiLCJtYXhEaXNwbGFjZW1lbnQiLCJ2ZWN0b3IiLCJhYnMiLCJleHBhbmRCeVZlY3RvciIsImJvdW5kaW5nQm94Iiwic3BoZXJlIiwiZ2V0Q2VudGVyIiwiY2VudGVyIiwicmFkaXVzIiwiZGlzdGFuY2VUbyIsImJvdW5kaW5nU3BoZXJlIiwiYXNzaWduQXR0cmlidXRlQWNjZXNzb3IiLCJnbHRmQXR0cmlidXRlTmFtZSIsInNldEluZGV4Iiwid29ya2luZ0NvbG9yU3BhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three/examples/jsm/loaders/GLTFLoader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMikkTSpaceTangents: function() { return /* binding */ computeMikkTSpaceTangents; },\n/* harmony export */   computeMorphedAttributes: function() { return /* binding */ computeMorphedAttributes; },\n/* harmony export */   deepCloneAttribute: function() { return /* binding */ deepCloneAttribute; },\n/* harmony export */   deinterleaveAttribute: function() { return /* binding */ deinterleaveAttribute; },\n/* harmony export */   deinterleaveGeometry: function() { return /* binding */ deinterleaveGeometry; },\n/* harmony export */   estimateBytesUsed: function() { return /* binding */ estimateBytesUsed; },\n/* harmony export */   interleaveAttributes: function() { return /* binding */ interleaveAttributes; },\n/* harmony export */   mergeAttributes: function() { return /* binding */ mergeAttributes; },\n/* harmony export */   mergeGeometries: function() { return /* binding */ mergeGeometries; },\n/* harmony export */   mergeGroups: function() { return /* binding */ mergeGroups; },\n/* harmony export */   mergeVertices: function() { return /* binding */ mergeVertices; },\n/* harmony export */   toCreasedNormals: function() { return /* binding */ toCreasedNormals; },\n/* harmony export */   toTrianglesDrawMode: function() { return /* binding */ toTrianglesDrawMode; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nfunction computeMikkTSpaceTangents(geometry, MikkTSpace) {\n    let negateSign = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    if (!MikkTSpace || !MikkTSpace.isReady) {\n        throw new Error(\"BufferGeometryUtils: Initialized MikkTSpace library required.\");\n    }\n    if (!geometry.hasAttribute(\"position\") || !geometry.hasAttribute(\"normal\") || !geometry.hasAttribute(\"uv\")) {\n        throw new Error('BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.');\n    }\n    function getAttributeArray(attribute) {\n        if (attribute.normalized || attribute.isInterleavedBufferAttribute) {\n            const dstArray = new Float32Array(attribute.count * attribute.itemSize);\n            for(let i = 0, j = 0; i < attribute.count; i++){\n                dstArray[j++] = attribute.getX(i);\n                dstArray[j++] = attribute.getY(i);\n                if (attribute.itemSize > 2) {\n                    dstArray[j++] = attribute.getZ(i);\n                }\n            }\n            return dstArray;\n        }\n        if (attribute.array instanceof Float32Array) {\n            return attribute.array;\n        }\n        return new Float32Array(attribute.array);\n    }\n    // MikkTSpace algorithm requires non-indexed input.\n    const _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    // Compute vertex tangents.\n    const tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv));\n    // Texture coordinate convention of glTF differs from the apparent\n    // default of the MikkTSpace library; .w component must be flipped.\n    if (negateSign) {\n        for(let i = 3; i < tangents.length; i += 4){\n            tangents[i] *= -1;\n        }\n    }\n    //\n    _geometry.setAttribute(\"tangent\", new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(tangents, 4));\n    if (geometry !== _geometry) {\n        geometry.copy(_geometry);\n    }\n    return geometry;\n}\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */ function mergeGeometries(geometries) {\n    let useGroups = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const isIndexed = geometries[0].index !== null;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    const attributes = {};\n    const morphAttributes = {};\n    const morphTargetsRelative = geometries[0].morphTargetsRelative;\n    const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    let offset = 0;\n    for(let i = 0; i < geometries.length; ++i){\n        const geometry = geometries[i];\n        let attributesCount = 0;\n        // ensure that all geometries are indexed, or none\n        if (isIndexed !== (geometry.index !== null)) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n            return null;\n        }\n        // gather attributes, exit early if they're different\n        for(const name in geometry.attributes){\n            if (!attributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n                return null;\n            }\n            if (attributes[name] === undefined) attributes[name] = [];\n            attributes[name].push(geometry.attributes[name]);\n            attributesCount++;\n        }\n        // ensure geometries have the same number of attributes\n        if (attributesCount !== attributesUsed.size) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n            return null;\n        }\n        // gather morph attributes, exit early if they're different\n        if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n            return null;\n        }\n        for(const name in geometry.morphAttributes){\n            if (!morphAttributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n                return null;\n            }\n            if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n            morphAttributes[name].push(geometry.morphAttributes[name]);\n        }\n        if (useGroups) {\n            let count;\n            if (isIndexed) {\n                count = geometry.index.count;\n            } else if (geometry.attributes.position !== undefined) {\n                count = geometry.attributes.position.count;\n            } else {\n                console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n                return null;\n            }\n            mergedGeometry.addGroup(offset, count, i);\n            offset += count;\n        }\n    }\n    // merge indices\n    if (isIndexed) {\n        let indexOffset = 0;\n        const mergedIndex = [];\n        for(let i = 0; i < geometries.length; ++i){\n            const index = geometries[i].index;\n            for(let j = 0; j < index.count; ++j){\n                mergedIndex.push(index.getX(j) + indexOffset);\n            }\n            indexOffset += geometries[i].attributes.position.count;\n        }\n        mergedGeometry.setIndex(mergedIndex);\n    }\n    // merge attributes\n    for(const name in attributes){\n        const mergedAttribute = mergeAttributes(attributes[name]);\n        if (!mergedAttribute) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the \" + name + \" attribute.\");\n            return null;\n        }\n        mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n    // merge morph attributes\n    for(const name in morphAttributes){\n        const numMorphTargets = morphAttributes[name][0].length;\n        if (numMorphTargets === 0) break;\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[name] = [];\n        for(let i = 0; i < numMorphTargets; ++i){\n            const morphAttributesToMerge = [];\n            for(let j = 0; j < morphAttributes[name].length; ++j){\n                morphAttributesToMerge.push(morphAttributes[name][j][i]);\n            }\n            const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);\n            if (!mergedMorphAttribute) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n                return null;\n            }\n            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n        }\n    }\n    return mergedGeometry;\n}\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */ function mergeAttributes(attributes) {\n    let TypedArray;\n    let itemSize;\n    let normalized;\n    let gpuType = -1;\n    let arrayLength = 0;\n    for(let i = 0; i < attributes.length; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n            return null;\n        }\n        if (itemSize === undefined) itemSize = attribute.itemSize;\n        if (itemSize !== attribute.itemSize) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n            return null;\n        }\n        if (normalized === undefined) normalized = attribute.normalized;\n        if (normalized !== attribute.normalized) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n            return null;\n        }\n        if (gpuType === -1) gpuType = attribute.gpuType;\n        if (gpuType !== attribute.gpuType) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.\");\n            return null;\n        }\n        arrayLength += attribute.count * itemSize;\n    }\n    const array = new TypedArray(arrayLength);\n    const result = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n    let offset = 0;\n    for(let i = 0; i < attributes.length; ++i){\n        const attribute = attributes[i];\n        if (attribute.isInterleavedBufferAttribute) {\n            const tupleOffset = offset / itemSize;\n            for(let j = 0, l = attribute.count; j < l; j++){\n                for(let c = 0; c < itemSize; c++){\n                    const value = attribute.getComponent(j, c);\n                    result.setComponent(j + tupleOffset, c, value);\n                }\n            }\n        } else {\n            array.set(attribute.array, offset);\n        }\n        offset += attribute.count * itemSize;\n    }\n    if (gpuType !== undefined) {\n        result.gpuType = gpuType;\n    }\n    return result;\n}\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */ function deepCloneAttribute(attribute) {\n    if (attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute) {\n        return deinterleaveAttribute(attribute);\n    }\n    if (attribute.isInstancedBufferAttribute) {\n        return new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute().copy(attribute);\n    }\n    return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute().copy(attribute);\n}\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */ function interleaveAttributes(attributes) {\n    // Interleaves the provided attributes into an InterleavedBuffer and returns\n    // a set of InterleavedBufferAttributes for each attribute\n    let TypedArray;\n    let arrayLength = 0;\n    let stride = 0;\n    // calculate the length and type of the interleavedBuffer\n    for(let i = 0, l = attributes.length; i < l; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"AttributeBuffers of different types cannot be interleaved\");\n            return null;\n        }\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n    }\n    // Create the set of buffer attributes\n    const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n    let offset = 0;\n    const res = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    for(let j = 0, l = attributes.length; j < l; j++){\n        const attribute = attributes[j];\n        const itemSize = attribute.itemSize;\n        const count = attribute.count;\n        const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n        res.push(iba);\n        offset += itemSize;\n        // Move the data for each attribute into the new interleavedBuffer\n        // at the appropriate offset\n        for(let c = 0; c < count; c++){\n            for(let k = 0; k < itemSize; k++){\n                iba[setters[k]](c, attribute[getters[k]](c));\n            }\n        }\n    }\n    return res;\n}\n// returns a new, non-interleaved version of the provided attribute\nfunction deinterleaveAttribute(attribute) {\n    const cons = attribute.data.array.constructor;\n    const count = attribute.count;\n    const itemSize = attribute.itemSize;\n    const normalized = attribute.normalized;\n    const array = new cons(count * itemSize);\n    let newAttribute;\n    if (attribute.isInstancedInterleavedBufferAttribute) {\n        newAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(array, itemSize, normalized, attribute.meshPerAttribute);\n    } else {\n        newAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n    }\n    for(let i = 0; i < count; i++){\n        newAttribute.setX(i, attribute.getX(i));\n        if (itemSize >= 2) {\n            newAttribute.setY(i, attribute.getY(i));\n        }\n        if (itemSize >= 3) {\n            newAttribute.setZ(i, attribute.getZ(i));\n        }\n        if (itemSize >= 4) {\n            newAttribute.setW(i, attribute.getW(i));\n        }\n    }\n    return newAttribute;\n}\n// deinterleaves all attributes on the geometry\nfunction deinterleaveGeometry(geometry) {\n    const attributes = geometry.attributes;\n    const morphTargets = geometry.morphTargets;\n    const attrMap = new Map();\n    for(const key in attributes){\n        const attr = attributes[key];\n        if (attr.isInterleavedBufferAttribute) {\n            if (!attrMap.has(attr)) {\n                attrMap.set(attr, deinterleaveAttribute(attr));\n            }\n            attributes[key] = attrMap.get(attr);\n        }\n    }\n    for(const key in morphTargets){\n        const attr = morphTargets[key];\n        if (attr.isInterleavedBufferAttribute) {\n            if (!attrMap.has(attr)) {\n                attrMap.set(attr, deinterleaveAttribute(attr));\n            }\n            morphTargets[key] = attrMap.get(attr);\n        }\n    }\n}\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */ function estimateBytesUsed(geometry) {\n    // Return the estimated memory used by this geometry in bytes\n    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n    // for InterleavedBufferAttributes.\n    let mem = 0;\n    for(const name in geometry.attributes){\n        const attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    const indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */ function mergeVertices(geometry) {\n    let tolerance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e-4;\n    tolerance = Math.max(tolerance, Number.EPSILON);\n    // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n    const hashToIndex = {};\n    const indices = geometry.getIndex();\n    const positions = geometry.getAttribute(\"position\");\n    const vertexCount = indices ? indices.count : positions.count;\n    // next value for triangle indices\n    let nextIndex = 0;\n    // attributes and new attribute arrays\n    const attributeNames = Object.keys(geometry.attributes);\n    const tmpAttributes = {};\n    const tmpMorphAttributes = {};\n    const newIndices = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    // Initialize the arrays, allocating space conservatively. Extra\n    // space will be trimmed in the last step.\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        const attr = geometry.attributes[name];\n        tmpAttributes[name] = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new attr.array.constructor(attr.count * attr.itemSize), attr.itemSize, attr.normalized);\n        const morphAttr = geometry.morphAttributes[name];\n        if (morphAttr) {\n            tmpMorphAttributes[name] = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize), morphAttr.itemSize, morphAttr.normalized);\n        }\n    }\n    // convert the error tolerance to an amount of decimal places to truncate to\n    const halfTolerance = tolerance * 0.5;\n    const exponent = Math.log10(1 / tolerance);\n    const hashMultiplier = Math.pow(10, exponent);\n    const hashAdditive = halfTolerance * hashMultiplier;\n    for(let i = 0; i < vertexCount; i++){\n        const index = indices ? indices.getX(i) : i;\n        // Generate a hash for the vertex attributes at the current index 'i'\n        let hash = \"\";\n        for(let j = 0, l = attributeNames.length; j < l; j++){\n            const name = attributeNames[j];\n            const attribute = geometry.getAttribute(name);\n            const itemSize = attribute.itemSize;\n            for(let k = 0; k < itemSize; k++){\n                // double tilde truncates the decimal value\n                hash += \"\".concat(~~(attribute[getters[k]](index) * hashMultiplier + hashAdditive), \",\");\n            }\n        }\n        // Add another reference to the vertex if it's already\n        // used by another index\n        if (hash in hashToIndex) {\n            newIndices.push(hashToIndex[hash]);\n        } else {\n            // copy data to the new index in the temporary attributes\n            for(let j = 0, l = attributeNames.length; j < l; j++){\n                const name = attributeNames[j];\n                const attribute = geometry.getAttribute(name);\n                const morphAttr = geometry.morphAttributes[name];\n                const itemSize = attribute.itemSize;\n                const newarray = tmpAttributes[name];\n                const newMorphArrays = tmpMorphAttributes[name];\n                for(let k = 0; k < itemSize; k++){\n                    const getterFunc = getters[k];\n                    const setterFunc = setters[k];\n                    newarray[setterFunc](nextIndex, attribute[getterFunc](index));\n                    if (morphAttr) {\n                        for(let m = 0, ml = morphAttr.length; m < ml; m++){\n                            newMorphArrays[m][setterFunc](nextIndex, morphAttr[m][getterFunc](index));\n                        }\n                    }\n                }\n            }\n            hashToIndex[hash] = nextIndex;\n            newIndices.push(nextIndex);\n            nextIndex++;\n        }\n    }\n    // generate result BufferGeometry\n    const result = geometry.clone();\n    for(const name in geometry.attributes){\n        const tmpAttribute = tmpAttributes[name];\n        result.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize), tmpAttribute.itemSize, tmpAttribute.normalized));\n        if (!(name in tmpMorphAttributes)) continue;\n        for(let j = 0; j < tmpMorphAttributes[name].length; j++){\n            const tmpMorphAttribute = tmpMorphAttributes[name][j];\n            result.morphAttributes[name][j] = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize), tmpMorphAttribute.itemSize, tmpMorphAttribute.normalized);\n        }\n    }\n    // indices\n    result.setIndex(newIndices);\n    return result;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */ function toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n        console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n        return geometry;\n    }\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n        let index = geometry.getIndex();\n        // generate index if not present\n        if (index === null) {\n            const indices = [];\n            const position = geometry.getAttribute(\"position\");\n            if (position !== undefined) {\n                for(let i = 0; i < position.count; i++){\n                    indices.push(i);\n                }\n                geometry.setIndex(indices);\n                index = geometry.getIndex();\n            } else {\n                console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n                return geometry;\n            }\n        }\n        //\n        const numberOfTriangles = index.count - 2;\n        const newIndices = [];\n        if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n            // gl.TRIANGLE_FAN\n            for(let i = 1; i <= numberOfTriangles; i++){\n                newIndices.push(index.getX(0));\n                newIndices.push(index.getX(i));\n                newIndices.push(index.getX(i + 1));\n            }\n        } else {\n            // gl.TRIANGLE_STRIP\n            for(let i = 0; i < numberOfTriangles; i++){\n                if (i % 2 === 0) {\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                    newIndices.push(index.getX(i + 2));\n                } else {\n                    newIndices.push(index.getX(i + 2));\n                    newIndices.push(index.getX(i + 1));\n                    newIndices.push(index.getX(i));\n                }\n            }\n        }\n        if (newIndices.length / 3 !== numberOfTriangles) {\n            console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n        }\n        // build final geometry\n        const newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n        return newGeometry;\n    } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n        return geometry;\n    }\n}\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */ function computeMorphedAttributes(object) {\n    const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function _calculateMorphedAttributeData(object, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n        _vA.fromBufferAttribute(attribute, a);\n        _vB.fromBufferAttribute(attribute, b);\n        _vC.fromBufferAttribute(attribute, c);\n        const morphInfluences = object.morphTargetInfluences;\n        if (morphAttribute && morphInfluences) {\n            _morphA.set(0, 0, 0);\n            _morphB.set(0, 0, 0);\n            _morphC.set(0, 0, 0);\n            for(let i = 0, il = morphAttribute.length; i < il; i++){\n                const influence = morphInfluences[i];\n                const morph = morphAttribute[i];\n                if (influence === 0) continue;\n                _tempA.fromBufferAttribute(morph, a);\n                _tempB.fromBufferAttribute(morph, b);\n                _tempC.fromBufferAttribute(morph, c);\n                if (morphTargetsRelative) {\n                    _morphA.addScaledVector(_tempA, influence);\n                    _morphB.addScaledVector(_tempB, influence);\n                    _morphC.addScaledVector(_tempC, influence);\n                } else {\n                    _morphA.addScaledVector(_tempA.sub(_vA), influence);\n                    _morphB.addScaledVector(_tempB.sub(_vB), influence);\n                    _morphC.addScaledVector(_tempC.sub(_vC), influence);\n                }\n            }\n            _vA.add(_morphA);\n            _vB.add(_morphB);\n            _vC.add(_morphC);\n        }\n        if (object.isSkinnedMesh) {\n            object.applyBoneTransform(a, _vA);\n            object.applyBoneTransform(b, _vB);\n            object.applyBoneTransform(c, _vC);\n        }\n        modifiedAttributeArray[a * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c * 3 + 2] = _vC.z;\n    }\n    const geometry = object.geometry;\n    const material = object.material;\n    let a, b, c;\n    const index = geometry.index;\n    const positionAttribute = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const normalAttribute = geometry.attributes.normal;\n    const morphNormal = geometry.morphAttributes.position;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    let i, j, il, jl;\n    let group;\n    let start, end;\n    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n    if (index !== null) {\n        // indexed buffer geometry\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = index.getX(j);\n                    b = index.getX(j + 1);\n                    c = index.getX(j + 2);\n                    _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(index.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = index.getX(i);\n                b = index.getX(i + 1);\n                c = index.getX(i + 2);\n                _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    } else {\n        // non-indexed buffer geometry\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = j;\n                    b = j + 1;\n                    c = j + 2;\n                    _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = i;\n                b = i + 1;\n                c = i + 2;\n                _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    }\n    const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n    const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n    return {\n        positionAttribute: positionAttribute,\n        normalAttribute: normalAttribute,\n        morphedPositionAttribute: morphedPositionAttribute,\n        morphedNormalAttribute: morphedNormalAttribute\n    };\n}\nfunction mergeGroups(geometry) {\n    if (geometry.groups.length === 0) {\n        console.warn(\"THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.\");\n        return geometry;\n    }\n    let groups = geometry.groups;\n    // sort groups by material index\n    groups = groups.sort((a, b)=>{\n        if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;\n        return a.start - b.start;\n    });\n    // create index for non-indexed geometries\n    if (geometry.getIndex() === null) {\n        const positionAttribute = geometry.getAttribute(\"position\");\n        const indices = [];\n        for(let i = 0; i < positionAttribute.count; i += 3){\n            indices.push(i, i + 1, i + 2);\n        }\n        geometry.setIndex(indices);\n    }\n    // sort index\n    const index = geometry.getIndex();\n    const newIndices = [];\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        const groupStart = group.start;\n        const groupLength = groupStart + group.count;\n        for(let j = groupStart; j < groupLength; j++){\n            newIndices.push(index.getX(j));\n        }\n    }\n    geometry.dispose(); // Required to force buffer recreation\n    geometry.setIndex(newIndices);\n    // update groups indices\n    let start = 0;\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        group.start = start;\n        start += group.count;\n    }\n    // merge groups\n    let currentGroup = groups[0];\n    geometry.groups = [\n        currentGroup\n    ];\n    for(let i = 1; i < groups.length; i++){\n        const group = groups[i];\n        if (currentGroup.materialIndex === group.materialIndex) {\n            currentGroup.count += group.count;\n        } else {\n            currentGroup = group;\n            geometry.groups.push(currentGroup);\n        }\n    }\n    return geometry;\n}\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */ function toCreasedNormals(geometry) {\n    let creaseAngle = arguments.length > 1 && arguments[1] !== void 0 /* 60 degrees */  ? arguments[1] : Math.PI / 3;\n    const creaseDot = Math.cos(creaseAngle);\n    const hashMultiplier = (1 + 1e-10) * 1e2;\n    // reusable vectors\n    const verts = [\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n    ];\n    const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    // hashes a vector\n    function hashVertex(v) {\n        const x = ~~(v.x * hashMultiplier);\n        const y = ~~(v.y * hashMultiplier);\n        const z = ~~(v.z * hashMultiplier);\n        return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n    }\n    // BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n    // and returns the original geometry\n    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    const posAttr = resultGeometry.attributes.position;\n    const vertexMap = {};\n    // find all the normals shared by commonly located vertices\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        // add the normal to the map for all vertices\n        const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            if (!(hash in vertexMap)) {\n                vertexMap[hash] = [];\n            }\n            vertexMap[hash].push(normal);\n        }\n    }\n    // average normals from all vertices that share a common location if they are within the\n    // provided crease threshold\n    const normalArray = new Float32Array(posAttr.count * 3);\n    const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        // get the face normal for this vertex\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n        // average all normals that meet the threshold and set the normal value\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            const otherNormals = vertexMap[hash];\n            tempNorm2.set(0, 0, 0);\n            for(let k = 0, lk = otherNormals.length; k < lk; k++){\n                const otherNorm = otherNormals[k];\n                if (tempNorm.dot(otherNorm) > creaseDot) {\n                    tempNorm2.add(otherNorm);\n                }\n            }\n            tempNorm2.normalize();\n            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n        }\n    }\n    resultGeometry.setAttribute(\"normal\", normAttr);\n    return resultGeometry;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQVdlO0FBRWYsU0FBU1UsMEJBQTJCQyxRQUFRLEVBQUVDLFVBQVU7UUFBRUMsYUFBQUEsaUVBQWE7SUFFdEUsSUFBSyxDQUFFRCxjQUFjLENBQUVBLFdBQVdFLE9BQU8sRUFBRztRQUUzQyxNQUFNLElBQUlDLE1BQU87SUFFbEI7SUFFQSxJQUFLLENBQUVKLFNBQVNLLFlBQVksQ0FBRSxlQUFnQixDQUFFTCxTQUFTSyxZQUFZLENBQUUsYUFBYyxDQUFFTCxTQUFTSyxZQUFZLENBQUUsT0FBUztRQUV0SCxNQUFNLElBQUlELE1BQU87SUFFbEI7SUFFQSxTQUFTRSxrQkFBbUJDLFNBQVM7UUFFcEMsSUFBS0EsVUFBVUMsVUFBVSxJQUFJRCxVQUFVRSw0QkFBNEIsRUFBRztZQUVyRSxNQUFNQyxXQUFXLElBQUlDLGFBQWNKLFVBQVVLLEtBQUssR0FBR0wsVUFBVU0sUUFBUTtZQUV2RSxJQUFNLElBQUlDLElBQUksR0FBR0MsSUFBSSxHQUFHRCxJQUFJUCxVQUFVSyxLQUFLLEVBQUVFLElBQU87Z0JBRW5ESixRQUFRLENBQUVLLElBQU0sR0FBR1IsVUFBVVMsSUFBSSxDQUFFRjtnQkFDbkNKLFFBQVEsQ0FBRUssSUFBTSxHQUFHUixVQUFVVSxJQUFJLENBQUVIO2dCQUVuQyxJQUFLUCxVQUFVTSxRQUFRLEdBQUcsR0FBSTtvQkFFN0JILFFBQVEsQ0FBRUssSUFBTSxHQUFHUixVQUFVVyxJQUFJLENBQUVKO2dCQUVwQztZQUVEO1lBRUEsT0FBT0o7UUFFUjtRQUVBLElBQUtILFVBQVVZLEtBQUssWUFBWVIsY0FBZTtZQUU5QyxPQUFPSixVQUFVWSxLQUFLO1FBRXZCO1FBRUEsT0FBTyxJQUFJUixhQUFjSixVQUFVWSxLQUFLO0lBRXpDO0lBRUEsbURBQW1EO0lBRW5E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S0ksR0FBR1YsVUFBVXJDLENBQUMsRUFBRXFDLFVBQVVwQyxDQUFDLEVBQUVvQyxVQUFVbkMsQ0FBQztRQUUvRDtJQUVEO0lBRUFzQyxlQUFldkwsWUFBWSxDQUFFLFVBQVVpTTtJQUN2QyxPQUFPVjtBQUVSO0FBYUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS91dGlscy9CdWZmZXJHZW9tZXRyeVV0aWxzLmpzPzdjYzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QnVmZmVyQXR0cmlidXRlLFxuXHRCdWZmZXJHZW9tZXRyeSxcblx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0SW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLFxuXHRJbnRlcmxlYXZlZEJ1ZmZlcixcblx0SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsXG5cdFRyaWFuZ2xlRmFuRHJhd01vZGUsXG5cdFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSxcblx0VHJpYW5nbGVzRHJhd01vZGUsXG5cdFZlY3RvcjMsXG59IGZyb20gJ3RocmVlJztcblxuZnVuY3Rpb24gY29tcHV0ZU1pa2tUU3BhY2VUYW5nZW50cyggZ2VvbWV0cnksIE1pa2tUU3BhY2UsIG5lZ2F0ZVNpZ24gPSB0cnVlICkge1xuXG5cdGlmICggISBNaWtrVFNwYWNlIHx8ICEgTWlra1RTcGFjZS5pc1JlYWR5ICkge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnQnVmZmVyR2VvbWV0cnlVdGlsczogSW5pdGlhbGl6ZWQgTWlra1RTcGFjZSBsaWJyYXJ5IHJlcXVpcmVkLicgKTtcblxuXHR9XG5cblx0aWYgKCAhIGdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApIHx8ICEgZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCAnbm9ybWFsJyApIHx8ICEgZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCAndXYnICkgKSB7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoICdCdWZmZXJHZW9tZXRyeVV0aWxzOiBUYW5nZW50cyByZXF1aXJlIFwicG9zaXRpb25cIiwgXCJub3JtYWxcIiwgYW5kIFwidXZcIiBhdHRyaWJ1dGVzLicgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlQXJyYXkoIGF0dHJpYnV0ZSApIHtcblxuXHRcdGlmICggYXR0cmlidXRlLm5vcm1hbGl6ZWQgfHwgYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnN0IGRzdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggYXR0cmlidXRlLmNvdW50ICogYXR0cmlidXRlLml0ZW1TaXplICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaiA9IDA7IGkgPCBhdHRyaWJ1dGUuY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0ZHN0QXJyYXlbIGogKysgXSA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XG5cdFx0XHRcdGRzdEFycmF5WyBqICsrIF0gPSBhdHRyaWJ1dGUuZ2V0WSggaSApO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlLml0ZW1TaXplID4gMiApIHtcblxuXHRcdFx0XHRcdGRzdEFycmF5WyBqICsrIF0gPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZHN0QXJyYXk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGF0dHJpYnV0ZS5hcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSApIHtcblxuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZS5hcnJheTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KCBhdHRyaWJ1dGUuYXJyYXkgKTtcblxuXHR9XG5cblx0Ly8gTWlra1RTcGFjZSBhbGdvcml0aG0gcmVxdWlyZXMgbm9uLWluZGV4ZWQgaW5wdXQuXG5cblx0Y29uc3QgX2dlb21ldHJ5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS50b05vbkluZGV4ZWQoKSA6IGdlb21ldHJ5O1xuXG5cdC8vIENvbXB1dGUgdmVydGV4IHRhbmdlbnRzLlxuXG5cdGNvbnN0IHRhbmdlbnRzID0gTWlra1RTcGFjZS5nZW5lcmF0ZVRhbmdlbnRzKFxuXG5cdFx0Z2V0QXR0cmlidXRlQXJyYXkoIF9nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uICksXG5cdFx0Z2V0QXR0cmlidXRlQXJyYXkoIF9nZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCApLFxuXHRcdGdldEF0dHJpYnV0ZUFycmF5KCBfZ2VvbWV0cnkuYXR0cmlidXRlcy51diApXG5cblx0KTtcblxuXHQvLyBUZXh0dXJlIGNvb3JkaW5hdGUgY29udmVudGlvbiBvZiBnbFRGIGRpZmZlcnMgZnJvbSB0aGUgYXBwYXJlbnRcblx0Ly8gZGVmYXVsdCBvZiB0aGUgTWlra1RTcGFjZSBsaWJyYXJ5OyAudyBjb21wb25lbnQgbXVzdCBiZSBmbGlwcGVkLlxuXG5cdGlmICggbmVnYXRlU2lnbiApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMzsgaSA8IHRhbmdlbnRzLmxlbmd0aDsgaSArPSA0ICkge1xuXG5cdFx0XHR0YW5nZW50c1sgaSBdICo9IC0gMTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly9cblxuXHRfZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndGFuZ2VudCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHRhbmdlbnRzLCA0ICkgKTtcblxuXHRpZiAoIGdlb21ldHJ5ICE9PSBfZ2VvbWV0cnkgKSB7XG5cblx0XHRnZW9tZXRyeS5jb3B5KCBfZ2VvbWV0cnkgKTtcblxuXHR9XG5cblx0cmV0dXJuIGdlb21ldHJ5O1xuXG59XG5cbi8qKlxuICogQHBhcmFtICB7QXJyYXk8QnVmZmVyR2VvbWV0cnk+fSBnZW9tZXRyaWVzXG4gKiBAcGFyYW0gIHtCb29sZWFufSB1c2VHcm91cHNcbiAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fVxuICovXG5mdW5jdGlvbiBtZXJnZUdlb21ldHJpZXMoIGdlb21ldHJpZXMsIHVzZUdyb3VwcyA9IGZhbHNlICkge1xuXG5cdGNvbnN0IGlzSW5kZXhlZCA9IGdlb21ldHJpZXNbIDAgXS5pbmRleCAhPT0gbnVsbDtcblxuXHRjb25zdCBhdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoIE9iamVjdC5rZXlzKCBnZW9tZXRyaWVzWyAwIF0uYXR0cmlidXRlcyApICk7XG5cdGNvbnN0IG1vcnBoQXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KCBPYmplY3Qua2V5cyggZ2VvbWV0cmllc1sgMCBdLm1vcnBoQXR0cmlidXRlcyApICk7XG5cblx0Y29uc3QgYXR0cmlidXRlcyA9IHt9O1xuXHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblxuXHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJpZXNbIDAgXS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRjb25zdCBtZXJnZWRHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdGxldCBvZmZzZXQgPSAwO1xuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBpIF07XG5cdFx0bGV0IGF0dHJpYnV0ZXNDb3VudCA9IDA7XG5cblx0XHQvLyBlbnN1cmUgdGhhdCBhbGwgZ2VvbWV0cmllcyBhcmUgaW5kZXhlZCwgb3Igbm9uZVxuXG5cdFx0aWYgKCBpc0luZGV4ZWQgIT09ICggZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCAnICsgaSArICcuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBpbmRleCBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJyApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBnYXRoZXIgYXR0cmlidXRlcywgZXhpdCBlYXJseSBpZiB0aGV5J3JlIGRpZmZlcmVudFxuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRpZiAoICEgYXR0cmlidXRlc1VzZWQuaGFzKCBuYW1lICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCAnICsgaSArICcuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBcIicgKyBuYW1lICsgJ1wiIGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS4nICk7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXR0cmlidXRlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSBhdHRyaWJ1dGVzWyBuYW1lIF0gPSBbXTtcblxuXHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdLnB1c2goIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXSApO1xuXG5cdFx0XHRhdHRyaWJ1dGVzQ291bnQgKys7XG5cblx0XHR9XG5cblx0XHQvLyBlbnN1cmUgZ2VvbWV0cmllcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzXG5cblx0XHRpZiAoIGF0dHJpYnV0ZXNDb3VudCAhPT0gYXR0cmlidXRlc1VzZWQuc2l6ZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCAnICsgaSArICcuIE1ha2Ugc3VyZSBhbGwgZ2VvbWV0cmllcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzLicgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZ2F0aGVyIG1vcnBoIGF0dHJpYnV0ZXMsIGV4aXQgZWFybHkgaWYgdGhleSdyZSBkaWZmZXJlbnRcblxuXHRcdGlmICggbW9ycGhUYXJnZXRzUmVsYXRpdmUgIT09IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4ICcgKyBpICsgJy4gLm1vcnBoVGFyZ2V0c1JlbGF0aXZlIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLicgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggISBtb3JwaEF0dHJpYnV0ZXNVc2VkLmhhcyggbmFtZSApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggJyArIGkgKyAnLiAgLm1vcnBoQXR0cmlidXRlcyBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy4nICk7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gW107XG5cblx0XHRcdG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdLnB1c2goIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHVzZUdyb3VwcyApIHtcblxuXHRcdFx0bGV0IGNvdW50O1xuXG5cdFx0XHRpZiAoIGlzSW5kZXhlZCApIHtcblxuXHRcdFx0XHRjb3VudCA9IGdlb21ldHJ5LmluZGV4LmNvdW50O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y291bnQgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggJyArIGkgKyAnLiBUaGUgZ2VvbWV0cnkgbXVzdCBoYXZlIGVpdGhlciBhbiBpbmRleCBvciBhIHBvc2l0aW9uIGF0dHJpYnV0ZScgKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0bWVyZ2VkR2VvbWV0cnkuYWRkR3JvdXAoIG9mZnNldCwgY291bnQsIGkgKTtcblxuXHRcdFx0b2Zmc2V0ICs9IGNvdW50O1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBtZXJnZSBpbmRpY2VzXG5cblx0aWYgKCBpc0luZGV4ZWQgKSB7XG5cblx0XHRsZXQgaW5kZXhPZmZzZXQgPSAwO1xuXHRcdGNvbnN0IG1lcmdlZEluZGV4ID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyaWVzWyBpIF0uaW5kZXg7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGluZGV4LmNvdW50OyArKyBqICkge1xuXG5cdFx0XHRcdG1lcmdlZEluZGV4LnB1c2goIGluZGV4LmdldFgoIGogKSArIGluZGV4T2Zmc2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aW5kZXhPZmZzZXQgKz0gZ2VvbWV0cmllc1sgaSBdLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG5cblx0XHR9XG5cblx0XHRtZXJnZWRHZW9tZXRyeS5zZXRJbmRleCggbWVyZ2VkSW5kZXggKTtcblxuXHR9XG5cblx0Ly8gbWVyZ2UgYXR0cmlidXRlc1xuXG5cdGZvciAoIGNvbnN0IG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdGNvbnN0IG1lcmdlZEF0dHJpYnV0ZSA9IG1lcmdlQXR0cmlidXRlcyggYXR0cmlidXRlc1sgbmFtZSBdICk7XG5cblx0XHRpZiAoICEgbWVyZ2VkQXR0cmlidXRlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlR2VvbWV0cmllcygpIGZhaWxlZCB3aGlsZSB0cnlpbmcgdG8gbWVyZ2UgdGhlICcgKyBuYW1lICsgJyBhdHRyaWJ1dGUuJyApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRtZXJnZWRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG1lcmdlZEF0dHJpYnV0ZSApO1xuXG5cdH1cblxuXHQvLyBtZXJnZSBtb3JwaCBhdHRyaWJ1dGVzXG5cblx0Zm9yICggY29uc3QgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRjb25zdCBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXVsgMCBdLmxlbmd0aDtcblxuXHRcdGlmICggbnVtTW9ycGhUYXJnZXRzID09PSAwICkgYnJlYWs7XG5cblx0XHRtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgPSBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgfHwge307XG5cdFx0bWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXS5sZW5ndGg7ICsrIGogKSB7XG5cblx0XHRcdFx0bW9ycGhBdHRyaWJ1dGVzVG9NZXJnZS5wdXNoKCBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXVsgaiBdWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtZXJnZWRNb3JwaEF0dHJpYnV0ZSA9IG1lcmdlQXR0cmlidXRlcyggbW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSApO1xuXG5cdFx0XHRpZiAoICEgbWVyZ2VkTW9ycGhBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUdlb21ldHJpZXMoKSBmYWlsZWQgd2hpbGUgdHJ5aW5nIHRvIG1lcmdlIHRoZSAnICsgbmFtZSArICcgbW9ycGhBdHRyaWJ1dGUuJyApO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHRtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXS5wdXNoKCBtZXJnZWRNb3JwaEF0dHJpYnV0ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gbWVyZ2VkR2VvbWV0cnk7XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEJ1ZmZlckF0dHJpYnV0ZT59IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge0J1ZmZlckF0dHJpYnV0ZX1cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzICkge1xuXG5cdGxldCBUeXBlZEFycmF5O1xuXHRsZXQgaXRlbVNpemU7XG5cdGxldCBub3JtYWxpemVkO1xuXHRsZXQgZ3B1VHlwZSA9IC0gMTtcblx0bGV0IGFycmF5TGVuZ3RoID0gMDtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGkgXTtcblxuXHRcdGlmICggVHlwZWRBcnJheSA9PT0gdW5kZWZpbmVkICkgVHlwZWRBcnJheSA9IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRpZiAoIFR5cGVkQXJyYXkgIT09IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvciApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5hcnJheSBtdXN0IGJlIG9mIGNvbnNpc3RlbnQgYXJyYXkgdHlwZXMgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuJyApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRpZiAoIGl0ZW1TaXplID09PSB1bmRlZmluZWQgKSBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRpZiAoIGl0ZW1TaXplICE9PSBhdHRyaWJ1dGUuaXRlbVNpemUgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUgbXVzdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLicgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBub3JtYWxpemVkID09PSB1bmRlZmluZWQgKSBub3JtYWxpemVkID0gYXR0cmlidXRlLm5vcm1hbGl6ZWQ7XG5cdFx0aWYgKCBub3JtYWxpemVkICE9PSBhdHRyaWJ1dGUubm9ybWFsaXplZCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5ub3JtYWxpemVkIG11c3QgYmUgY29uc2lzdGVudCBhY3Jvc3MgbWF0Y2hpbmcgYXR0cmlidXRlcy4nICk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGlmICggZ3B1VHlwZSA9PT0gLSAxICkgZ3B1VHlwZSA9IGF0dHJpYnV0ZS5ncHVUeXBlO1xuXHRcdGlmICggZ3B1VHlwZSAhPT0gYXR0cmlidXRlLmdwdVR5cGUgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUuZ3B1VHlwZSBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuJyApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRhcnJheUxlbmd0aCArPSBhdHRyaWJ1dGUuY291bnQgKiBpdGVtU2l6ZTtcblxuXHR9XG5cblx0Y29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheSggYXJyYXlMZW5ndGggKTtcblx0Y29uc3QgcmVzdWx0ID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cdGxldCBvZmZzZXQgPSAwO1xuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgaSBdO1xuXHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnN0IHR1cGxlT2Zmc2V0ID0gb2Zmc2V0IC8gaXRlbVNpemU7XG5cdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGogPCBsOyBqICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBjID0gMDsgYyA8IGl0ZW1TaXplOyBjICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBhdHRyaWJ1dGUuZ2V0Q29tcG9uZW50KCBqLCBjICk7XG5cdFx0XHRcdFx0cmVzdWx0LnNldENvbXBvbmVudCggaiArIHR1cGxlT2Zmc2V0LCBjLCB2YWx1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YXJyYXkuc2V0KCBhdHRyaWJ1dGUuYXJyYXksIG9mZnNldCApO1xuXG5cdFx0fVxuXG5cdFx0b2Zmc2V0ICs9IGF0dHJpYnV0ZS5jb3VudCAqIGl0ZW1TaXplO1xuXG5cdH1cblxuXHRpZiAoIGdwdVR5cGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHJlc3VsdC5ncHVUeXBlID0gZ3B1VHlwZTtcblxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyQXR0cmlidXRlfVxuICogQHJldHVybiB7QnVmZmVyQXR0cmlidXRlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcENsb25lQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0aWYgKCBhdHRyaWJ1dGUuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSB8fCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdHJldHVybiBkZWludGVybGVhdmVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xuXG5cdH1cblxuXHRpZiAoIGF0dHJpYnV0ZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdHJldHVybiBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKCkuY29weSggYXR0cmlidXRlICk7XG5cblx0fVxuXG5cdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCkuY29weSggYXR0cmlidXRlICk7XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEJ1ZmZlckF0dHJpYnV0ZT59IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge0FycmF5PEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlPn1cbiAqL1xuZnVuY3Rpb24gaW50ZXJsZWF2ZUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXMgKSB7XG5cblx0Ly8gSW50ZXJsZWF2ZXMgdGhlIHByb3ZpZGVkIGF0dHJpYnV0ZXMgaW50byBhbiBJbnRlcmxlYXZlZEJ1ZmZlciBhbmQgcmV0dXJuc1xuXHQvLyBhIHNldCBvZiBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZXMgZm9yIGVhY2ggYXR0cmlidXRlXG5cdGxldCBUeXBlZEFycmF5O1xuXHRsZXQgYXJyYXlMZW5ndGggPSAwO1xuXHRsZXQgc3RyaWRlID0gMDtcblxuXHQvLyBjYWxjdWxhdGUgdGhlIGxlbmd0aCBhbmQgdHlwZSBvZiB0aGUgaW50ZXJsZWF2ZWRCdWZmZXJcblx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyArKyBpICkge1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgaSBdO1xuXG5cdFx0aWYgKCBUeXBlZEFycmF5ID09PSB1bmRlZmluZWQgKSBUeXBlZEFycmF5ID0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yO1xuXHRcdGlmICggVHlwZWRBcnJheSAhPT0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnQXR0cmlidXRlQnVmZmVycyBvZiBkaWZmZXJlbnQgdHlwZXMgY2Fubm90IGJlIGludGVybGVhdmVkJyApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRhcnJheUxlbmd0aCArPSBhdHRyaWJ1dGUuYXJyYXkubGVuZ3RoO1xuXHRcdHN0cmlkZSArPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0fVxuXG5cdC8vIENyZWF0ZSB0aGUgc2V0IG9mIGJ1ZmZlciBhdHRyaWJ1dGVzXG5cdGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKCBuZXcgVHlwZWRBcnJheSggYXJyYXlMZW5ndGggKSwgc3RyaWRlICk7XG5cdGxldCBvZmZzZXQgPSAwO1xuXHRjb25zdCByZXMgPSBbXTtcblx0Y29uc3QgZ2V0dGVycyA9IFsgJ2dldFgnLCAnZ2V0WScsICdnZXRaJywgJ2dldFcnIF07XG5cdGNvbnN0IHNldHRlcnMgPSBbICdzZXRYJywgJ3NldFknLCAnc2V0WicsICdzZXRXJyBdO1xuXG5cdGZvciAoIGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgbDsgaiArKyApIHtcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGogXTtcblx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRjb25zdCBjb3VudCA9IGF0dHJpYnV0ZS5jb3VudDtcblx0XHRjb25zdCBpYmEgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBhdHRyaWJ1dGUubm9ybWFsaXplZCApO1xuXHRcdHJlcy5wdXNoKCBpYmEgKTtcblxuXHRcdG9mZnNldCArPSBpdGVtU2l6ZTtcblxuXHRcdC8vIE1vdmUgdGhlIGRhdGEgZm9yIGVhY2ggYXR0cmlidXRlIGludG8gdGhlIG5ldyBpbnRlcmxlYXZlZEJ1ZmZlclxuXHRcdC8vIGF0IHRoZSBhcHByb3ByaWF0ZSBvZmZzZXRcblx0XHRmb3IgKCBsZXQgYyA9IDA7IGMgPCBjb3VudDsgYyArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsgKysgKSB7XG5cblx0XHRcdFx0aWJhWyBzZXR0ZXJzWyBrIF0gXSggYywgYXR0cmlidXRlWyBnZXR0ZXJzWyBrIF0gXSggYyApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHJlcztcblxufVxuXG4vLyByZXR1cm5zIGEgbmV3LCBub24taW50ZXJsZWF2ZWQgdmVyc2lvbiBvZiB0aGUgcHJvdmlkZWQgYXR0cmlidXRlXG5leHBvcnQgZnVuY3Rpb24gZGVpbnRlcmxlYXZlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0Y29uc3QgY29ucyA9IGF0dHJpYnV0ZS5kYXRhLmFycmF5LmNvbnN0cnVjdG9yO1xuXHRjb25zdCBjb3VudCA9IGF0dHJpYnV0ZS5jb3VudDtcblx0Y29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGUubm9ybWFsaXplZDtcblxuXHRjb25zdCBhcnJheSA9IG5ldyBjb25zKCBjb3VudCAqIGl0ZW1TaXplICk7XG5cdGxldCBuZXdBdHRyaWJ1dGU7XG5cdGlmICggYXR0cmlidXRlLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRuZXdBdHRyaWJ1dGUgPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQsIGF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdG5ld0F0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcblxuXHRcdG5ld0F0dHJpYnV0ZS5zZXRYKCBpLCBhdHRyaWJ1dGUuZ2V0WCggaSApICk7XG5cblx0XHRpZiAoIGl0ZW1TaXplID49IDIgKSB7XG5cblx0XHRcdG5ld0F0dHJpYnV0ZS5zZXRZKCBpLCBhdHRyaWJ1dGUuZ2V0WSggaSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGl0ZW1TaXplID49IDMgKSB7XG5cblx0XHRcdG5ld0F0dHJpYnV0ZS5zZXRaKCBpLCBhdHRyaWJ1dGUuZ2V0WiggaSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGl0ZW1TaXplID49IDQgKSB7XG5cblx0XHRcdG5ld0F0dHJpYnV0ZS5zZXRXKCBpLCBhdHRyaWJ1dGUuZ2V0VyggaSApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBuZXdBdHRyaWJ1dGU7XG5cbn1cblxuLy8gZGVpbnRlcmxlYXZlcyBhbGwgYXR0cmlidXRlcyBvbiB0aGUgZ2VvbWV0cnlcbmV4cG9ydCBmdW5jdGlvbiBkZWludGVybGVhdmVHZW9tZXRyeSggZ2VvbWV0cnkgKSB7XG5cblx0Y29uc3QgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdGNvbnN0IG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcblx0Y29uc3QgYXR0ck1hcCA9IG5ldyBNYXAoKTtcblxuXHRmb3IgKCBjb25zdCBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblx0XHRpZiAoIGF0dHIuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0aWYgKCAhIGF0dHJNYXAuaGFzKCBhdHRyICkgKSB7XG5cblx0XHRcdFx0YXR0ck1hcC5zZXQoIGF0dHIsIGRlaW50ZXJsZWF2ZUF0dHJpYnV0ZSggYXR0ciApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YXR0cmlidXRlc1sga2V5IF0gPSBhdHRyTWFwLmdldCggYXR0ciApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmb3IgKCBjb25zdCBrZXkgaW4gbW9ycGhUYXJnZXRzICkge1xuXG5cdFx0Y29uc3QgYXR0ciA9IG1vcnBoVGFyZ2V0c1sga2V5IF07XG5cdFx0aWYgKCBhdHRyLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGlmICggISBhdHRyTWFwLmhhcyggYXR0ciApICkge1xuXG5cdFx0XHRcdGF0dHJNYXAuc2V0KCBhdHRyLCBkZWludGVybGVhdmVBdHRyaWJ1dGUoIGF0dHIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1vcnBoVGFyZ2V0c1sga2V5IF0gPSBhdHRyTWFwLmdldCggYXR0ciApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGVzdGltYXRlQnl0ZXNVc2VkKCBnZW9tZXRyeSApIHtcblxuXHQvLyBSZXR1cm4gdGhlIGVzdGltYXRlZCBtZW1vcnkgdXNlZCBieSB0aGlzIGdlb21ldHJ5IGluIGJ5dGVzXG5cdC8vIENhbGN1bGF0ZSB1c2luZyBpdGVtU2l6ZSwgY291bnQsIGFuZCBCWVRFU19QRVJfRUxFTUVOVCB0byBhY2NvdW50XG5cdC8vIGZvciBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZXMuXG5cdGxldCBtZW0gPSAwO1xuXHRmb3IgKCBjb25zdCBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRjb25zdCBhdHRyID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cdFx0bWVtICs9IGF0dHIuY291bnQgKiBhdHRyLml0ZW1TaXplICogYXR0ci5hcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHR9XG5cblx0Y29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdG1lbSArPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCAqIGluZGljZXMuaXRlbVNpemUgKiBpbmRpY2VzLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UIDogMDtcblx0cmV0dXJuIG1lbTtcblxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlXG4gKiBAcmV0dXJuIHtCdWZmZXJHZW9tZXRyeX1cbiAqL1xuZnVuY3Rpb24gbWVyZ2VWZXJ0aWNlcyggZ2VvbWV0cnksIHRvbGVyYW5jZSA9IDFlLTQgKSB7XG5cblx0dG9sZXJhbmNlID0gTWF0aC5tYXgoIHRvbGVyYW5jZSwgTnVtYmVyLkVQU0lMT04gKTtcblxuXHQvLyBHZW5lcmF0ZSBhbiBpbmRleCBidWZmZXIgaWYgdGhlIGdlb21ldHJ5IGRvZXNuJ3QgaGF2ZSBvbmUsIG9yIG9wdGltaXplIGl0XG5cdC8vIGlmIGl0J3MgYWxyZWFkeSBhdmFpbGFibGUuXG5cdGNvbnN0IGhhc2hUb0luZGV4ID0ge307XG5cdGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0Y29uc3QgdmVydGV4Q291bnQgPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCA6IHBvc2l0aW9ucy5jb3VudDtcblxuXHQvLyBuZXh0IHZhbHVlIGZvciB0cmlhbmdsZSBpbmRpY2VzXG5cdGxldCBuZXh0SW5kZXggPSAwO1xuXG5cdC8vIGF0dHJpYnV0ZXMgYW5kIG5ldyBhdHRyaWJ1dGUgYXJyYXlzXG5cdGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKTtcblx0Y29uc3QgdG1wQXR0cmlidXRlcyA9IHt9O1xuXHRjb25zdCB0bXBNb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0Y29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuXHRjb25zdCBnZXR0ZXJzID0gWyAnZ2V0WCcsICdnZXRZJywgJ2dldFonLCAnZ2V0VycgXTtcblx0Y29uc3Qgc2V0dGVycyA9IFsgJ3NldFgnLCAnc2V0WScsICdzZXRaJywgJ3NldFcnIF07XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgYXJyYXlzLCBhbGxvY2F0aW5nIHNwYWNlIGNvbnNlcnZhdGl2ZWx5LiBFeHRyYVxuXHQvLyBzcGFjZSB3aWxsIGJlIHRyaW1tZWQgaW4gdGhlIGxhc3Qgc3RlcC5cblx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1sgaSBdO1xuXHRcdGNvbnN0IGF0dHIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHR0bXBBdHRyaWJ1dGVzWyBuYW1lIF0gPSBuZXcgQnVmZmVyQXR0cmlidXRlKFxuXHRcdFx0bmV3IGF0dHIuYXJyYXkuY29uc3RydWN0b3IoIGF0dHIuY291bnQgKiBhdHRyLml0ZW1TaXplICksXG5cdFx0XHRhdHRyLml0ZW1TaXplLFxuXHRcdFx0YXR0ci5ub3JtYWxpemVkXG5cdFx0KTtcblxuXHRcdGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xuXHRcdGlmICggbW9ycGhBdHRyICkge1xuXG5cdFx0XHR0bXBNb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoXG5cdFx0XHRcdG5ldyBtb3JwaEF0dHIuYXJyYXkuY29uc3RydWN0b3IoIG1vcnBoQXR0ci5jb3VudCAqIG1vcnBoQXR0ci5pdGVtU2l6ZSApLFxuXHRcdFx0XHRtb3JwaEF0dHIuaXRlbVNpemUsXG5cdFx0XHRcdG1vcnBoQXR0ci5ub3JtYWxpemVkXG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBjb252ZXJ0IHRoZSBlcnJvciB0b2xlcmFuY2UgdG8gYW4gYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIHRvIHRydW5jYXRlIHRvXG5cdGNvbnN0IGhhbGZUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiAwLjU7XG5cdGNvbnN0IGV4cG9uZW50ID0gTWF0aC5sb2cxMCggMSAvIHRvbGVyYW5jZSApO1xuXHRjb25zdCBoYXNoTXVsdGlwbGllciA9IE1hdGgucG93KCAxMCwgZXhwb25lbnQgKTtcblx0Y29uc3QgaGFzaEFkZGl0aXZlID0gaGFsZlRvbGVyYW5jZSAqIGhhc2hNdWx0aXBsaWVyO1xuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSArKyApIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gaW5kaWNlcyA/IGluZGljZXMuZ2V0WCggaSApIDogaTtcblxuXHRcdC8vIEdlbmVyYXRlIGEgaGFzaCBmb3IgdGhlIHZlcnRleCBhdHRyaWJ1dGVzIGF0IHRoZSBjdXJyZW50IGluZGV4ICdpJ1xuXHRcdGxldCBoYXNoID0gJyc7XG5cdFx0Zm9yICggbGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaiArKyApIHtcblxuXHRcdFx0Y29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzWyBqIF07XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG5cdFx0XHRmb3IgKCBsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgayArKyApIHtcblxuXHRcdFx0XHQvLyBkb3VibGUgdGlsZGUgdHJ1bmNhdGVzIHRoZSBkZWNpbWFsIHZhbHVlXG5cdFx0XHRcdGhhc2ggKz0gYCR7IH4gfiAoIGF0dHJpYnV0ZVsgZ2V0dGVyc1sgayBdIF0oIGluZGV4ICkgKiBoYXNoTXVsdGlwbGllciArIGhhc2hBZGRpdGl2ZSApIH0sYDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGFub3RoZXIgcmVmZXJlbmNlIHRvIHRoZSB2ZXJ0ZXggaWYgaXQncyBhbHJlYWR5XG5cdFx0Ly8gdXNlZCBieSBhbm90aGVyIGluZGV4XG5cdFx0aWYgKCBoYXNoIGluIGhhc2hUb0luZGV4ICkge1xuXG5cdFx0XHRuZXdJbmRpY2VzLnB1c2goIGhhc2hUb0luZGV4WyBoYXNoIF0gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGNvcHkgZGF0YSB0byB0aGUgbmV3IGluZGV4IGluIHRoZSB0ZW1wb3JhcnkgYXR0cmlidXRlc1xuXHRcdFx0Zm9yICggbGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbIGogXTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHRcdGNvbnN0IG1vcnBoQXR0ciA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xuXHRcdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdFx0Y29uc3QgbmV3YXJyYXkgPSB0bXBBdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHRcdGNvbnN0IG5ld01vcnBoQXJyYXlzID0gdG1wTW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdFx0Zm9yICggbGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBnZXR0ZXJGdW5jID0gZ2V0dGVyc1sgayBdO1xuXHRcdFx0XHRcdGNvbnN0IHNldHRlckZ1bmMgPSBzZXR0ZXJzWyBrIF07XG5cdFx0XHRcdFx0bmV3YXJyYXlbIHNldHRlckZ1bmMgXSggbmV4dEluZGV4LCBhdHRyaWJ1dGVbIGdldHRlckZ1bmMgXSggaW5kZXggKSApO1xuXG5cdFx0XHRcdFx0aWYgKCBtb3JwaEF0dHIgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHIubGVuZ3RoOyBtIDwgbWw7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0bmV3TW9ycGhBcnJheXNbIG0gXVsgc2V0dGVyRnVuYyBdKCBuZXh0SW5kZXgsIG1vcnBoQXR0clsgbSBdWyBnZXR0ZXJGdW5jIF0oIGluZGV4ICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRoYXNoVG9JbmRleFsgaGFzaCBdID0gbmV4dEluZGV4O1xuXHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBuZXh0SW5kZXggKTtcblx0XHRcdG5leHRJbmRleCArKztcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZ2VuZXJhdGUgcmVzdWx0IEJ1ZmZlckdlb21ldHJ5XG5cdGNvbnN0IHJlc3VsdCA9IGdlb21ldHJ5LmNsb25lKCk7XG5cdGZvciAoIGNvbnN0IG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcyApIHtcblxuXHRcdGNvbnN0IHRtcEF0dHJpYnV0ZSA9IHRtcEF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdHJlc3VsdC5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoXG5cdFx0XHR0bXBBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoIDAsIG5leHRJbmRleCAqIHRtcEF0dHJpYnV0ZS5pdGVtU2l6ZSApLFxuXHRcdFx0dG1wQXR0cmlidXRlLml0ZW1TaXplLFxuXHRcdFx0dG1wQXR0cmlidXRlLm5vcm1hbGl6ZWQsXG5cdFx0KSApO1xuXG5cdFx0aWYgKCAhICggbmFtZSBpbiB0bXBNb3JwaEF0dHJpYnV0ZXMgKSApIGNvbnRpbnVlO1xuXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgdG1wTW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0ubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRjb25zdCB0bXBNb3JwaEF0dHJpYnV0ZSA9IHRtcE1vcnBoQXR0cmlidXRlc1sgbmFtZSBdWyBqIF07XG5cblx0XHRcdHJlc3VsdC5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXVsgaiBdID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShcblx0XHRcdFx0dG1wTW9ycGhBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoIDAsIG5leHRJbmRleCAqIHRtcE1vcnBoQXR0cmlidXRlLml0ZW1TaXplICksXG5cdFx0XHRcdHRtcE1vcnBoQXR0cmlidXRlLml0ZW1TaXplLFxuXHRcdFx0XHR0bXBNb3JwaEF0dHJpYnV0ZS5ub3JtYWxpemVkLFxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gaW5kaWNlc1xuXG5cdHJlc3VsdC5zZXRJbmRleCggbmV3SW5kaWNlcyApO1xuXG5cdHJldHVybiByZXN1bHQ7XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuICogQHBhcmFtIHtudW1iZXJ9IGRyYXdNb2RlXG4gKiBAcmV0dXJuIHtCdWZmZXJHZW9tZXRyeX1cbiAqL1xuZnVuY3Rpb24gdG9UcmlhbmdsZXNEcmF3TW9kZSggZ2VvbWV0cnksIGRyYXdNb2RlICkge1xuXG5cdGlmICggZHJhd01vZGUgPT09IFRyaWFuZ2xlc0RyYXdNb2RlICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IEdlb21ldHJ5IGFscmVhZHkgZGVmaW5lZCBhcyB0cmlhbmdsZXMuJyApO1xuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9XG5cblx0aWYgKCBkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSB8fCBkcmF3TW9kZSA9PT0gVHJpYW5nbGVTdHJpcERyYXdNb2RlICkge1xuXG5cdFx0bGV0IGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblxuXHRcdC8vIGdlbmVyYXRlIGluZGV4IGlmIG5vdCBwcmVzZW50XG5cblx0XHRpZiAoIGluZGV4ID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbi5jb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggaSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdFx0XHRpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmRlZmluZWQgcG9zaXRpb24gYXR0cmlidXRlLiBQcm9jZXNzaW5nIG5vdCBwb3NzaWJsZS4nICk7XG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGNvbnN0IG51bWJlck9mVHJpYW5nbGVzID0gaW5kZXguY291bnQgLSAyO1xuXHRcdGNvbnN0IG5ld0luZGljZXMgPSBbXTtcblxuXHRcdGlmICggZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUgKSB7XG5cblx0XHRcdC8vIGdsLlRSSUFOR0xFX0ZBTlxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gbnVtYmVyT2ZUcmlhbmdsZXM7IGkgKysgKSB7XG5cblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCAwICkgKTtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICkgKTtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICsgMSApICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGdsLlRSSUFOR0xFX1NUUklQXG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG51bWJlck9mVHJpYW5nbGVzOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggaSAlIDIgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKSApO1xuXHRcdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDEgKSApO1xuXHRcdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDIgKSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKyAyICkgKTtcblx0XHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKyAxICkgKTtcblx0XHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCAoIG5ld0luZGljZXMubGVuZ3RoIC8gMyApICE9PSBudW1iZXJPZlRyaWFuZ2xlcyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmFibGUgdG8gZ2VuZXJhdGUgY29ycmVjdCBhbW91bnQgb2YgdHJpYW5nbGVzLicgKTtcblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGZpbmFsIGdlb21ldHJ5XG5cblx0XHRjb25zdCBuZXdHZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCk7XG5cdFx0bmV3R2VvbWV0cnkuc2V0SW5kZXgoIG5ld0luZGljZXMgKTtcblx0XHRuZXdHZW9tZXRyeS5jbGVhckdyb3VwcygpO1xuXG5cdFx0cmV0dXJuIG5ld0dlb21ldHJ5O1xuXG5cdH0gZWxzZSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVua25vd24gZHJhdyBtb2RlOicsIGRyYXdNb2RlICk7XG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH1cblxufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG1vcnBoZWQgYXR0cmlidXRlcyBvZiBhIG1vcnBoZWQvc2tpbm5lZCBCdWZmZXJHZW9tZXRyeS5cbiAqIEhlbHBmdWwgZm9yIFJheXRyYWNpbmcgb3IgRGVjYWxzLlxuICogQHBhcmFtIHtNZXNoIHwgTGluZSB8IFBvaW50c30gb2JqZWN0IEFuIGluc3RhbmNlIG9mIE1lc2gsIExpbmUgb3IgUG9pbnRzLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBPYmplY3Qgd2l0aCBvcmlnaW5hbCBwb3NpdGlvbi9ub3JtYWwgYXR0cmlidXRlcyBhbmQgbW9ycGhlZCBvbmVzLlxuICovXG5mdW5jdGlvbiBjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMoIG9iamVjdCApIHtcblxuXHRjb25zdCBfdkEgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBfdkIgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBfdkMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdGNvbnN0IF90ZW1wQSA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IF90ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IF90ZW1wQyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0Y29uc3QgX21vcnBoQSA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IF9tb3JwaEIgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBfbW9ycGhDID0gbmV3IFZlY3RvcjMoKTtcblxuXHRmdW5jdGlvbiBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG5cdFx0b2JqZWN0LFxuXHRcdGF0dHJpYnV0ZSxcblx0XHRtb3JwaEF0dHJpYnV0ZSxcblx0XHRtb3JwaFRhcmdldHNSZWxhdGl2ZSxcblx0XHRhLFxuXHRcdGIsXG5cdFx0Yyxcblx0XHRtb2RpZmllZEF0dHJpYnV0ZUFycmF5XG5cdCkge1xuXG5cdFx0X3ZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgYSApO1xuXHRcdF92Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGIgKTtcblx0XHRfdkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBjICk7XG5cblx0XHRjb25zdCBtb3JwaEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG5cdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZSAmJiBtb3JwaEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdF9tb3JwaEEuc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRfbW9ycGhCLnNldCggMCwgMCwgMCApO1xuXHRcdFx0X21vcnBoQy5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBtb3JwaCA9IG1vcnBoQXR0cmlidXRlWyBpIF07XG5cblx0XHRcdFx0aWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRfdGVtcEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGgsIGEgKTtcblx0XHRcdFx0X3RlbXBCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoLCBiICk7XG5cdFx0XHRcdF90ZW1wQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaCwgYyApO1xuXG5cdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRfbW9ycGhBLmFkZFNjYWxlZFZlY3RvciggX3RlbXBBLCBpbmZsdWVuY2UgKTtcblx0XHRcdFx0XHRfbW9ycGhCLmFkZFNjYWxlZFZlY3RvciggX3RlbXBCLCBpbmZsdWVuY2UgKTtcblx0XHRcdFx0XHRfbW9ycGhDLmFkZFNjYWxlZFZlY3RvciggX3RlbXBDLCBpbmZsdWVuY2UgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0X21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoIF90ZW1wQS5zdWIoIF92QSApLCBpbmZsdWVuY2UgKTtcblx0XHRcdFx0XHRfbW9ycGhCLmFkZFNjYWxlZFZlY3RvciggX3RlbXBCLnN1YiggX3ZCICksIGluZmx1ZW5jZSApO1xuXHRcdFx0XHRcdF9tb3JwaEMuYWRkU2NhbGVkVmVjdG9yKCBfdGVtcEMuc3ViKCBfdkMgKSwgaW5mbHVlbmNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF92QS5hZGQoIF9tb3JwaEEgKTtcblx0XHRcdF92Qi5hZGQoIF9tb3JwaEIgKTtcblx0XHRcdF92Qy5hZGQoIF9tb3JwaEMgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0LmlzU2tpbm5lZE1lc2ggKSB7XG5cblx0XHRcdG9iamVjdC5hcHBseUJvbmVUcmFuc2Zvcm0oIGEsIF92QSApO1xuXHRcdFx0b2JqZWN0LmFwcGx5Qm9uZVRyYW5zZm9ybSggYiwgX3ZCICk7XG5cdFx0XHRvYmplY3QuYXBwbHlCb25lVHJhbnNmb3JtKCBjLCBfdkMgKTtcblxuXHRcdH1cblxuXHRcdG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbIGEgKiAzICsgMCBdID0gX3ZBLng7XG5cdFx0bW9kaWZpZWRBdHRyaWJ1dGVBcnJheVsgYSAqIDMgKyAxIF0gPSBfdkEueTtcblx0XHRtb2RpZmllZEF0dHJpYnV0ZUFycmF5WyBhICogMyArIDIgXSA9IF92QS56O1xuXHRcdG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbIGIgKiAzICsgMCBdID0gX3ZCLng7XG5cdFx0bW9kaWZpZWRBdHRyaWJ1dGVBcnJheVsgYiAqIDMgKyAxIF0gPSBfdkIueTtcblx0XHRtb2RpZmllZEF0dHJpYnV0ZUFycmF5WyBiICogMyArIDIgXSA9IF92Qi56O1xuXHRcdG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbIGMgKiAzICsgMCBdID0gX3ZDLng7XG5cdFx0bW9kaWZpZWRBdHRyaWJ1dGVBcnJheVsgYyAqIDMgKyAxIF0gPSBfdkMueTtcblx0XHRtb2RpZmllZEF0dHJpYnV0ZUFycmF5WyBjICogMyArIDIgXSA9IF92Qy56O1xuXG5cdH1cblxuXHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0Y29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0bGV0IGEsIGIsIGM7XG5cdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0Y29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblx0Y29uc3Qgbm9ybWFsQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG5cdGNvbnN0IG1vcnBoTm9ybWFsID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0Y29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuXHRsZXQgaSwgaiwgaWwsIGpsO1xuXHRsZXQgZ3JvdXA7XG5cdGxldCBzdGFydCwgZW5kO1xuXG5cdGNvbnN0IG1vZGlmaWVkUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAqIHBvc2l0aW9uQXR0cmlidXRlLml0ZW1TaXplICk7XG5cdGNvbnN0IG1vZGlmaWVkTm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheSggbm9ybWFsQXR0cmlidXRlLmNvdW50ICogbm9ybWFsQXR0cmlidXRlLml0ZW1TaXplICk7XG5cblx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdC8vIGluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG5cdFx0XHRcdHN0YXJ0ID0gTWF0aC5tYXgoIGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdFx0ZW5kID0gTWF0aC5taW4oICggZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCApLCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XG5cblx0XHRcdFx0Zm9yICggaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0XHRhID0gaW5kZXguZ2V0WCggaiApO1xuXHRcdFx0XHRcdGIgPSBpbmRleC5nZXRYKCBqICsgMSApO1xuXHRcdFx0XHRcdGMgPSBpbmRleC5nZXRYKCBqICsgMiApO1xuXG5cdFx0XHRcdFx0X2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuXHRcdFx0XHRcdFx0b2JqZWN0LFxuXHRcdFx0XHRcdFx0cG9zaXRpb25BdHRyaWJ1dGUsXG5cdFx0XHRcdFx0XHRtb3JwaFBvc2l0aW9uLFxuXHRcdFx0XHRcdFx0bW9ycGhUYXJnZXRzUmVsYXRpdmUsXG5cdFx0XHRcdFx0XHRhLCBiLCBjLFxuXHRcdFx0XHRcdFx0bW9kaWZpZWRQb3NpdGlvblxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG5cdFx0XHRcdFx0XHRvYmplY3QsXG5cdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUsXG5cdFx0XHRcdFx0XHRtb3JwaE5vcm1hbCxcblx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuXHRcdFx0XHRcdFx0YSwgYiwgYyxcblx0XHRcdFx0XHRcdG1vZGlmaWVkTm9ybWFsXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHN0YXJ0ID0gTWF0aC5tYXgoIDAsIGRyYXdSYW5nZS5zdGFydCApO1xuXHRcdFx0ZW5kID0gTWF0aC5taW4oIGluZGV4LmNvdW50LCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XG5cblx0XHRcdGZvciAoIGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGEgPSBpbmRleC5nZXRYKCBpICk7XG5cdFx0XHRcdGIgPSBpbmRleC5nZXRYKCBpICsgMSApO1xuXHRcdFx0XHRjID0gaW5kZXguZ2V0WCggaSArIDIgKTtcblxuXHRcdFx0XHRfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG5cdFx0XHRcdFx0b2JqZWN0LFxuXHRcdFx0XHRcdHBvc2l0aW9uQXR0cmlidXRlLFxuXHRcdFx0XHRcdG1vcnBoUG9zaXRpb24sXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXRzUmVsYXRpdmUsXG5cdFx0XHRcdFx0YSwgYiwgYyxcblx0XHRcdFx0XHRtb2RpZmllZFBvc2l0aW9uXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0X2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuXHRcdFx0XHRcdG9iamVjdCxcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUsXG5cdFx0XHRcdFx0bW9ycGhOb3JtYWwsXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXRzUmVsYXRpdmUsXG5cdFx0XHRcdFx0YSwgYiwgYyxcblx0XHRcdFx0XHRtb2RpZmllZE5vcm1hbFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIG5vbi1pbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Z3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdFx0XHRzdGFydCA9IE1hdGgubWF4KCBncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0ICk7XG5cdFx0XHRcdGVuZCA9IE1hdGgubWluKCAoIGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQgKSwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRcdGZvciAoIGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzICkge1xuXG5cdFx0XHRcdFx0YSA9IGo7XG5cdFx0XHRcdFx0YiA9IGogKyAxO1xuXHRcdFx0XHRcdGMgPSBqICsgMjtcblxuXHRcdFx0XHRcdF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcblx0XHRcdFx0XHRcdG9iamVjdCxcblx0XHRcdFx0XHRcdHBvc2l0aW9uQXR0cmlidXRlLFxuXHRcdFx0XHRcdFx0bW9ycGhQb3NpdGlvbixcblx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuXHRcdFx0XHRcdFx0YSwgYiwgYyxcblx0XHRcdFx0XHRcdG1vZGlmaWVkUG9zaXRpb25cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0X2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuXHRcdFx0XHRcdFx0b2JqZWN0LFxuXHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLFxuXHRcdFx0XHRcdFx0bW9ycGhOb3JtYWwsXG5cdFx0XHRcdFx0XHRtb3JwaFRhcmdldHNSZWxhdGl2ZSxcblx0XHRcdFx0XHRcdGEsIGIsIGMsXG5cdFx0XHRcdFx0XHRtb2RpZmllZE5vcm1hbFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcblx0XHRcdGVuZCA9IE1hdGgubWluKCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xuXG5cdFx0XHRmb3IgKCBpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRhID0gaTtcblx0XHRcdFx0YiA9IGkgKyAxO1xuXHRcdFx0XHRjID0gaSArIDI7XG5cblx0XHRcdFx0X2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuXHRcdFx0XHRcdG9iamVjdCxcblx0XHRcdFx0XHRwb3NpdGlvbkF0dHJpYnV0ZSxcblx0XHRcdFx0XHRtb3JwaFBvc2l0aW9uLFxuXHRcdFx0XHRcdG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuXHRcdFx0XHRcdGEsIGIsIGMsXG5cdFx0XHRcdFx0bW9kaWZpZWRQb3NpdGlvblxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcblx0XHRcdFx0XHRvYmplY3QsXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLFxuXHRcdFx0XHRcdG1vcnBoTm9ybWFsLFxuXHRcdFx0XHRcdG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuXHRcdFx0XHRcdGEsIGIsIGMsXG5cdFx0XHRcdFx0bW9kaWZpZWROb3JtYWxcblx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbW9kaWZpZWRQb3NpdGlvbiwgMyApO1xuXHRjb25zdCBtb3JwaGVkTm9ybWFsQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG1vZGlmaWVkTm9ybWFsLCAzICk7XG5cblx0cmV0dXJuIHtcblxuXHRcdHBvc2l0aW9uQXR0cmlidXRlOiBwb3NpdGlvbkF0dHJpYnV0ZSxcblx0XHRub3JtYWxBdHRyaWJ1dGU6IG5vcm1hbEF0dHJpYnV0ZSxcblx0XHRtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGU6IG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSxcblx0XHRtb3JwaGVkTm9ybWFsQXR0cmlidXRlOiBtb3JwaGVkTm9ybWFsQXR0cmlidXRlXG5cblx0fTtcblxufVxuXG5mdW5jdGlvbiBtZXJnZUdyb3VwcyggZ2VvbWV0cnkgKSB7XG5cblx0aWYgKCBnZW9tZXRyeS5ncm91cHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy5tZXJnZUdyb3VwcygpOiBObyBncm91cHMgYXJlIGRlZmluZWQuIE5vdGhpbmcgdG8gbWVyZ2UuJyApO1xuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9XG5cblx0bGV0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHQvLyBzb3J0IGdyb3VwcyBieSBtYXRlcmlhbCBpbmRleFxuXG5cdGdyb3VwcyA9IGdyb3Vwcy5zb3J0KCAoIGEsIGIgKSA9PiB7XG5cblx0XHRpZiAoIGEubWF0ZXJpYWxJbmRleCAhPT0gYi5tYXRlcmlhbEluZGV4ICkgcmV0dXJuIGEubWF0ZXJpYWxJbmRleCAtIGIubWF0ZXJpYWxJbmRleDtcblxuXHRcdHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydDtcblxuXHR9ICk7XG5cblx0Ly8gY3JlYXRlIGluZGV4IGZvciBub24taW5kZXhlZCBnZW9tZXRyaWVzXG5cblx0aWYgKCBnZW9tZXRyeS5nZXRJbmRleCgpID09PSBudWxsICkge1xuXG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSArPSAzICkge1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCBpICsgMiApO1xuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIGluZGljZXMgKTtcblxuXHR9XG5cblx0Ly8gc29ydCBpbmRleFxuXG5cdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblxuXHRjb25zdCBuZXdJbmRpY2VzID0gW107XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRjb25zdCBncm91cFN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0Y29uc3QgZ3JvdXBMZW5ndGggPSBncm91cFN0YXJ0ICsgZ3JvdXAuY291bnQ7XG5cblx0XHRmb3IgKCBsZXQgaiA9IGdyb3VwU3RhcnQ7IGogPCBncm91cExlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBqICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2VvbWV0cnkuZGlzcG9zZSgpOyAvLyBSZXF1aXJlZCB0byBmb3JjZSBidWZmZXIgcmVjcmVhdGlvblxuXHRnZW9tZXRyeS5zZXRJbmRleCggbmV3SW5kaWNlcyApO1xuXG5cdC8vIHVwZGF0ZSBncm91cHMgaW5kaWNlc1xuXG5cdGxldCBzdGFydCA9IDA7XG5cblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRncm91cC5zdGFydCA9IHN0YXJ0O1xuXHRcdHN0YXJ0ICs9IGdyb3VwLmNvdW50O1xuXG5cdH1cblxuXHQvLyBtZXJnZSBncm91cHNcblxuXHRsZXQgY3VycmVudEdyb3VwID0gZ3JvdXBzWyAwIF07XG5cblx0Z2VvbWV0cnkuZ3JvdXBzID0gWyBjdXJyZW50R3JvdXAgXTtcblxuXHRmb3IgKCBsZXQgaSA9IDE7IGkgPCBncm91cHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdGlmICggY3VycmVudEdyb3VwLm1hdGVyaWFsSW5kZXggPT09IGdyb3VwLm1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRcdGN1cnJlbnRHcm91cC5jb3VudCArPSBncm91cC5jb3VudDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGN1cnJlbnRHcm91cCA9IGdyb3VwO1xuXHRcdFx0Z2VvbWV0cnkuZ3JvdXBzLnB1c2goIGN1cnJlbnRHcm91cCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZ2VvbWV0cnk7XG5cbn1cblxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBzdXBwbGllZCBnZW9tZXRyeSBpZiBpdCBpcyBub24taW5kZXhlZCwgb3RoZXJ3aXNlIGNyZWF0ZXMgYSBuZXcsXG4gKiBub24taW5kZXhlZCBnZW9tZXRyeS4gUmV0dXJucyB0aGUgZ2VvbWV0cnkgd2l0aCBzbW9vdGggbm9ybWFscyBldmVyeXdoZXJlIGV4Y2VwdFxuICogZmFjZXMgdGhhdCBtZWV0IGF0IGFuIGFuZ2xlIGdyZWF0ZXIgdGhhbiB0aGUgY3JlYXNlIGFuZ2xlLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG4gKiBAcGFyYW0ge251bWJlcn0gW2NyZWFzZUFuZ2xlXVxuICogQHJldHVybiB7QnVmZmVyR2VvbWV0cnl9XG4gKi9cbmZ1bmN0aW9uIHRvQ3JlYXNlZE5vcm1hbHMoIGdlb21ldHJ5LCBjcmVhc2VBbmdsZSA9IE1hdGguUEkgLyAzIC8qIDYwIGRlZ3JlZXMgKi8gKSB7XG5cblx0Y29uc3QgY3JlYXNlRG90ID0gTWF0aC5jb3MoIGNyZWFzZUFuZ2xlICk7XG5cdGNvbnN0IGhhc2hNdWx0aXBsaWVyID0gKCAxICsgMWUtMTAgKSAqIDFlMjtcblxuXHQvLyByZXVzYWJsZSB2ZWN0b3JzXG5cdGNvbnN0IHZlcnRzID0gWyBuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpLCBuZXcgVmVjdG9yMygpIF07XG5cdGNvbnN0IHRlbXBWZWMxID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcFZlYzIgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wTm9ybSA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXBOb3JtMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0Ly8gaGFzaGVzIGEgdmVjdG9yXG5cdGZ1bmN0aW9uIGhhc2hWZXJ0ZXgoIHYgKSB7XG5cblx0XHRjb25zdCB4ID0gfiB+ICggdi54ICogaGFzaE11bHRpcGxpZXIgKTtcblx0XHRjb25zdCB5ID0gfiB+ICggdi55ICogaGFzaE11bHRpcGxpZXIgKTtcblx0XHRjb25zdCB6ID0gfiB+ICggdi56ICogaGFzaE11bHRpcGxpZXIgKTtcblx0XHRyZXR1cm4gYCR7eH0sJHt5fSwke3p9YDtcblxuXHR9XG5cblx0Ly8gQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCkgd2FybnMgaWYgdGhlIGdlb21ldHJ5IGlzIG5vbi1pbmRleGVkXG5cdC8vIGFuZCByZXR1cm5zIHRoZSBvcmlnaW5hbCBnZW9tZXRyeVxuXHRjb25zdCByZXN1bHRHZW9tZXRyeSA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkudG9Ob25JbmRleGVkKCkgOiBnZW9tZXRyeTtcblx0Y29uc3QgcG9zQXR0ciA9IHJlc3VsdEdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuXG5cdC8vIGZpbmQgYWxsIHRoZSBub3JtYWxzIHNoYXJlZCBieSBjb21tb25seSBsb2NhdGVkIHZlcnRpY2VzXG5cdGZvciAoIGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGNvbnN0IGkzID0gMyAqIGk7XG5cdFx0Y29uc3QgYSA9IHZlcnRzWyAwIF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zQXR0ciwgaTMgKyAwICk7XG5cdFx0Y29uc3QgYiA9IHZlcnRzWyAxIF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zQXR0ciwgaTMgKyAxICk7XG5cdFx0Y29uc3QgYyA9IHZlcnRzWyAyIF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zQXR0ciwgaTMgKyAyICk7XG5cblx0XHR0ZW1wVmVjMS5zdWJWZWN0b3JzKCBjLCBiICk7XG5cdFx0dGVtcFZlYzIuc3ViVmVjdG9ycyggYSwgYiApO1xuXG5cdFx0Ly8gYWRkIHRoZSBub3JtYWwgdG8gdGhlIG1hcCBmb3IgYWxsIHZlcnRpY2VzXG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMoIHRlbXBWZWMxLCB0ZW1wVmVjMiApLm5vcm1hbGl6ZSgpO1xuXHRcdGZvciAoIGxldCBuID0gMDsgbiA8IDM7IG4gKysgKSB7XG5cblx0XHRcdGNvbnN0IHZlcnQgPSB2ZXJ0c1sgbiBdO1xuXHRcdFx0Y29uc3QgaGFzaCA9IGhhc2hWZXJ0ZXgoIHZlcnQgKTtcblx0XHRcdGlmICggISAoIGhhc2ggaW4gdmVydGV4TWFwICkgKSB7XG5cblx0XHRcdFx0dmVydGV4TWFwWyBoYXNoIF0gPSBbXTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2ZXJ0ZXhNYXBbIGhhc2ggXS5wdXNoKCBub3JtYWwgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gYXZlcmFnZSBub3JtYWxzIGZyb20gYWxsIHZlcnRpY2VzIHRoYXQgc2hhcmUgYSBjb21tb24gbG9jYXRpb24gaWYgdGhleSBhcmUgd2l0aGluIHRoZVxuXHQvLyBwcm92aWRlZCBjcmVhc2UgdGhyZXNob2xkXG5cdGNvbnN0IG5vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggcG9zQXR0ci5jb3VudCAqIDMgKTtcblx0Y29uc3Qgbm9ybUF0dHIgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBub3JtYWxBcnJheSwgMywgZmFsc2UgKTtcblx0Zm9yICggbGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0Ly8gZ2V0IHRoZSBmYWNlIG5vcm1hbCBmb3IgdGhpcyB2ZXJ0ZXhcblx0XHRjb25zdCBpMyA9IDMgKiBpO1xuXHRcdGNvbnN0IGEgPSB2ZXJ0c1sgMCBdLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc0F0dHIsIGkzICsgMCApO1xuXHRcdGNvbnN0IGIgPSB2ZXJ0c1sgMSBdLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc0F0dHIsIGkzICsgMSApO1xuXHRcdGNvbnN0IGMgPSB2ZXJ0c1sgMiBdLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc0F0dHIsIGkzICsgMiApO1xuXG5cdFx0dGVtcFZlYzEuc3ViVmVjdG9ycyggYywgYiApO1xuXHRcdHRlbXBWZWMyLnN1YlZlY3RvcnMoIGEsIGIgKTtcblxuXHRcdHRlbXBOb3JtLmNyb3NzVmVjdG9ycyggdGVtcFZlYzEsIHRlbXBWZWMyICkubm9ybWFsaXplKCk7XG5cblx0XHQvLyBhdmVyYWdlIGFsbCBub3JtYWxzIHRoYXQgbWVldCB0aGUgdGhyZXNob2xkIGFuZCBzZXQgdGhlIG5vcm1hbCB2YWx1ZVxuXHRcdGZvciAoIGxldCBuID0gMDsgbiA8IDM7IG4gKysgKSB7XG5cblx0XHRcdGNvbnN0IHZlcnQgPSB2ZXJ0c1sgbiBdO1xuXHRcdFx0Y29uc3QgaGFzaCA9IGhhc2hWZXJ0ZXgoIHZlcnQgKTtcblx0XHRcdGNvbnN0IG90aGVyTm9ybWFscyA9IHZlcnRleE1hcFsgaGFzaCBdO1xuXHRcdFx0dGVtcE5vcm0yLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRmb3IgKCBsZXQgayA9IDAsIGxrID0gb3RoZXJOb3JtYWxzLmxlbmd0aDsgayA8IGxrOyBrICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG90aGVyTm9ybSA9IG90aGVyTm9ybWFsc1sgayBdO1xuXHRcdFx0XHRpZiAoIHRlbXBOb3JtLmRvdCggb3RoZXJOb3JtICkgPiBjcmVhc2VEb3QgKSB7XG5cblx0XHRcdFx0XHR0ZW1wTm9ybTIuYWRkKCBvdGhlck5vcm0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGVtcE5vcm0yLm5vcm1hbGl6ZSgpO1xuXHRcdFx0bm9ybUF0dHIuc2V0WFlaKCBpMyArIG4sIHRlbXBOb3JtMi54LCB0ZW1wTm9ybTIueSwgdGVtcE5vcm0yLnogKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmVzdWx0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybUF0dHIgKTtcblx0cmV0dXJuIHJlc3VsdEdlb21ldHJ5O1xuXG59XG5cbmV4cG9ydCB7XG5cdGNvbXB1dGVNaWtrVFNwYWNlVGFuZ2VudHMsXG5cdG1lcmdlR2VvbWV0cmllcyxcblx0bWVyZ2VBdHRyaWJ1dGVzLFxuXHRpbnRlcmxlYXZlQXR0cmlidXRlcyxcblx0ZXN0aW1hdGVCeXRlc1VzZWQsXG5cdG1lcmdlVmVydGljZXMsXG5cdHRvVHJpYW5nbGVzRHJhd01vZGUsXG5cdGNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyxcblx0bWVyZ2VHcm91cHMsXG5cdHRvQ3JlYXNlZE5vcm1hbHNcbn07XG4iXSwibmFtZXMiOlsiQnVmZmVyQXR0cmlidXRlIiwiQnVmZmVyR2VvbWV0cnkiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwiSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIiwiSW50ZXJsZWF2ZWRCdWZmZXIiLCJJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSIsIlRyaWFuZ2xlRmFuRHJhd01vZGUiLCJUcmlhbmdsZVN0cmlwRHJhd01vZGUiLCJUcmlhbmdsZXNEcmF3TW9kZSIsIlZlY3RvcjMiLCJjb21wdXRlTWlra1RTcGFjZVRhbmdlbnRzIiwiZ2VvbWV0cnkiLCJNaWtrVFNwYWNlIiwibmVnYXRlU2lnbiIsImlzUmVhZHkiLCJFcnJvciIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZUFycmF5IiwiYXR0cmlidXRlIiwibm9ybWFsaXplZCIsImlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUiLCJkc3RBcnJheSIsIkZsb2F0MzJBcnJheSIsImNvdW50IiwiaXRlbVNpemUiLCJpIiwiaiIsImdldFgiLCJnZXRZIiwiZ2V0WiIsImFycmF5IiwiX2dlb21ldHJ5IiwiaW5kZXgiLCJ0b05vbkluZGV4ZWQiLCJ0YW5nZW50cyIsImdlbmVyYXRlVGFuZ2VudHMiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJub3JtYWwiLCJ1diIsImxlbmd0aCIsInNldEF0dHJpYnV0ZSIsImNvcHkiLCJtZXJnZUdlb21ldHJpZXMiLCJnZW9tZXRyaWVzIiwidXNlR3JvdXBzIiwiaXNJbmRleGVkIiwiYXR0cmlidXRlc1VzZWQiLCJTZXQiLCJPYmplY3QiLCJrZXlzIiwibW9ycGhBdHRyaWJ1dGVzVXNlZCIsIm1vcnBoQXR0cmlidXRlcyIsIm1vcnBoVGFyZ2V0c1JlbGF0aXZlIiwibWVyZ2VkR2VvbWV0cnkiLCJvZmZzZXQiLCJhdHRyaWJ1dGVzQ291bnQiLCJjb25zb2xlIiwiZXJyb3IiLCJuYW1lIiwiaGFzIiwidW5kZWZpbmVkIiwicHVzaCIsInNpemUiLCJhZGRHcm91cCIsImluZGV4T2Zmc2V0IiwibWVyZ2VkSW5kZXgiLCJzZXRJbmRleCIsIm1lcmdlZEF0dHJpYnV0ZSIsIm1lcmdlQXR0cmlidXRlcyIsIm51bU1vcnBoVGFyZ2V0cyIsIm1vcnBoQXR0cmlidXRlc1RvTWVyZ2UiLCJtZXJnZWRNb3JwaEF0dHJpYnV0ZSIsIlR5cGVkQXJyYXkiLCJncHVUeXBlIiwiYXJyYXlMZW5ndGgiLCJjb25zdHJ1Y3RvciIsInJlc3VsdCIsInR1cGxlT2Zmc2V0IiwibCIsImMiLCJ2YWx1ZSIsImdldENvbXBvbmVudCIsInNldENvbXBvbmVudCIsInNldCIsImRlZXBDbG9uZUF0dHJpYnV0ZSIsImlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUiLCJkZWludGVybGVhdmVBdHRyaWJ1dGUiLCJpc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSIsImludGVybGVhdmVBdHRyaWJ1dGVzIiwic3RyaWRlIiwiaW50ZXJsZWF2ZWRCdWZmZXIiLCJyZXMiLCJnZXR0ZXJzIiwic2V0dGVycyIsImliYSIsImsiLCJjb25zIiwiZGF0YSIsIm5ld0F0dHJpYnV0ZSIsIm1lc2hQZXJBdHRyaWJ1dGUiLCJzZXRYIiwic2V0WSIsInNldFoiLCJzZXRXIiwiZ2V0VyIsImRlaW50ZXJsZWF2ZUdlb21ldHJ5IiwibW9ycGhUYXJnZXRzIiwiYXR0ck1hcCIsIk1hcCIsImtleSIsImF0dHIiLCJnZXQiLCJlc3RpbWF0ZUJ5dGVzVXNlZCIsIm1lbSIsImdldEF0dHJpYnV0ZSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiaW5kaWNlcyIsImdldEluZGV4IiwibWVyZ2VWZXJ0aWNlcyIsInRvbGVyYW5jZSIsIk1hdGgiLCJtYXgiLCJOdW1iZXIiLCJFUFNJTE9OIiwiaGFzaFRvSW5kZXgiLCJwb3NpdGlvbnMiLCJ2ZXJ0ZXhDb3VudCIsIm5leHRJbmRleCIsImF0dHJpYnV0ZU5hbWVzIiwidG1wQXR0cmlidXRlcyIsInRtcE1vcnBoQXR0cmlidXRlcyIsIm5ld0luZGljZXMiLCJtb3JwaEF0dHIiLCJoYWxmVG9sZXJhbmNlIiwiZXhwb25lbnQiLCJsb2cxMCIsImhhc2hNdWx0aXBsaWVyIiwicG93IiwiaGFzaEFkZGl0aXZlIiwiaGFzaCIsIm5ld2FycmF5IiwibmV3TW9ycGhBcnJheXMiLCJnZXR0ZXJGdW5jIiwic2V0dGVyRnVuYyIsIm0iLCJtbCIsImNsb25lIiwidG1wQXR0cmlidXRlIiwic2xpY2UiLCJ0bXBNb3JwaEF0dHJpYnV0ZSIsInRvVHJpYW5nbGVzRHJhd01vZGUiLCJkcmF3TW9kZSIsIndhcm4iLCJudW1iZXJPZlRyaWFuZ2xlcyIsIm5ld0dlb21ldHJ5IiwiY2xlYXJHcm91cHMiLCJjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMiLCJvYmplY3QiLCJfdkEiLCJfdkIiLCJfdkMiLCJfdGVtcEEiLCJfdGVtcEIiLCJfdGVtcEMiLCJfbW9ycGhBIiwiX21vcnBoQiIsIl9tb3JwaEMiLCJfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEiLCJtb3JwaEF0dHJpYnV0ZSIsImEiLCJiIiwibW9kaWZpZWRBdHRyaWJ1dGVBcnJheSIsImZyb21CdWZmZXJBdHRyaWJ1dGUiLCJtb3JwaEluZmx1ZW5jZXMiLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLCJpbCIsImluZmx1ZW5jZSIsIm1vcnBoIiwiYWRkU2NhbGVkVmVjdG9yIiwic3ViIiwiYWRkIiwiaXNTa2lubmVkTWVzaCIsImFwcGx5Qm9uZVRyYW5zZm9ybSIsIngiLCJ5IiwieiIsIm1hdGVyaWFsIiwicG9zaXRpb25BdHRyaWJ1dGUiLCJtb3JwaFBvc2l0aW9uIiwibm9ybWFsQXR0cmlidXRlIiwibW9ycGhOb3JtYWwiLCJncm91cHMiLCJkcmF3UmFuZ2UiLCJqbCIsImdyb3VwIiwic3RhcnQiLCJlbmQiLCJtb2RpZmllZFBvc2l0aW9uIiwibW9kaWZpZWROb3JtYWwiLCJBcnJheSIsImlzQXJyYXkiLCJtaW4iLCJtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUiLCJtb3JwaGVkTm9ybWFsQXR0cmlidXRlIiwibWVyZ2VHcm91cHMiLCJzb3J0IiwibWF0ZXJpYWxJbmRleCIsImdyb3VwU3RhcnQiLCJncm91cExlbmd0aCIsImRpc3Bvc2UiLCJjdXJyZW50R3JvdXAiLCJ0b0NyZWFzZWROb3JtYWxzIiwiY3JlYXNlQW5nbGUiLCJQSSIsImNyZWFzZURvdCIsImNvcyIsInZlcnRzIiwidGVtcFZlYzEiLCJ0ZW1wVmVjMiIsInRlbXBOb3JtIiwidGVtcE5vcm0yIiwiaGFzaFZlcnRleCIsInYiLCJyZXN1bHRHZW9tZXRyeSIsInBvc0F0dHIiLCJ2ZXJ0ZXhNYXAiLCJpMyIsInN1YlZlY3RvcnMiLCJjcm9zc1ZlY3RvcnMiLCJub3JtYWxpemUiLCJuIiwidmVydCIsIm5vcm1hbEFycmF5Iiwibm9ybUF0dHIiLCJvdGhlck5vcm1hbHMiLCJsayIsIm90aGVyTm9ybSIsImRvdCIsInNldFhZWiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js\n"));

/***/ })

}]);